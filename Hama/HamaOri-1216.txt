ID 1=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.AbstractMessageManager#loopBackBundle(BSPMessageBundle<M>)
Rmethod: org.apache.hama.bsp.message.AbstractMessageManager#notifyReceivedMessage(M)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
AbstractMessageManager
@Override public void loopBackBundle(BSPMessageBundle<M> bundle) throws IOException {
  peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_MESSAGES_RECEIVED,bundle.size());
  this.localQueueForNextIteration.addBundle(bundle);
  notifyReceivedMessage(bundle);
}

ID 2=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.AbstractMessageManager#loopBackMessage(Writable)
Rmethod: org.apache.hama.bsp.message.AbstractMessageManager#notifyReceivedMessage(M)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
AbstractMessageManager
@SuppressWarnings("unchecked") @Override public void loopBackMessage(Writable message) throws IOException {
  this.localQueueForNextIteration.add((M)message);
  notifyReceivedMessage((M)message);
}

ID 3=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#init(java.lang.String[])
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable t) {
  LOG.fatal("Error running ApplicationMaster",t);
  LogManager.shutdown();
  ExitUtil.terminate(1,t);
}

block: 
ApplicationMaster
public static void main(String[] args) throws IOException {
  boolean result=false;
  ApplicationMaster appMaster=new ApplicationMaster();
  try {
    LOG.info("Initializing ApplicationMaster");
    boolean doRun=appMaster.init(args);
    if (!doRun) {
      System.exit(0);
    }
    appMaster.run();
    result=appMaster.finish();
  }
 catch (  Throwable t) {
    LOG.fatal("Error running ApplicationMaster",t);
    LogManager.shutdown();
    ExitUtil.terminate(1,t);
  }
 finally {
    LOG.info("Stop SyncServer and RPCServer.");
    appMaster.close();
  }
  if (result) {
    LOG.info("Application Master completed successfully. exiting");
    System.exit(0);
  }
 else {
    LOG.info("Application Master failed. exiting");
    System.exit(2);
  }
}

ID 4=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#run()
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.YarnException
exception comment: null
method comment: null
catch: 
null
block: 
ApplicationMaster
public static void main(String[] args) throws IOException {
  boolean result=false;
  ApplicationMaster appMaster=new ApplicationMaster();
  try {
    LOG.info("Initializing ApplicationMaster");
    boolean doRun=appMaster.init(args);
    if (!doRun) {
      System.exit(0);
    }
    appMaster.run();
    result=appMaster.finish();
  }
 catch (  Throwable t) {
    LOG.fatal("Error running ApplicationMaster",t);
    LogManager.shutdown();
    ExitUtil.terminate(1,t);
  }
 finally {
    LOG.info("Stop SyncServer and RPCServer.");
    appMaster.close();
  }
  if (result) {
    LOG.info("Application Master completed successfully. exiting");
    System.exit(0);
  }
 else {
    LOG.info("Application Master failed. exiting");
    System.exit(2);
  }
}

ID 5=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#run()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable t) {
  LOG.fatal("Error running ApplicationMaster",t);
  LogManager.shutdown();
  ExitUtil.terminate(1,t);
}

block: 
ApplicationMaster
public static void main(String[] args) throws IOException {
  boolean result=false;
  ApplicationMaster appMaster=new ApplicationMaster();
  try {
    LOG.info("Initializing ApplicationMaster");
    boolean doRun=appMaster.init(args);
    if (!doRun) {
      System.exit(0);
    }
    appMaster.run();
    result=appMaster.finish();
  }
 catch (  Throwable t) {
    LOG.fatal("Error running ApplicationMaster",t);
    LogManager.shutdown();
    ExitUtil.terminate(1,t);
  }
 finally {
    LOG.info("Stop SyncServer and RPCServer.");
    appMaster.close();
  }
  if (result) {
    LOG.info("Application Master completed successfully. exiting");
    System.exit(0);
  }
 else {
    LOG.info("Application Master failed. exiting");
    System.exit(2);
  }
}

ID 6=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#run()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable t) {
  LOG.fatal("Error running ApplicationMaster",t);
  LogManager.shutdown();
  ExitUtil.terminate(1,t);
}

block: 
ApplicationMaster
public static void main(String[] args) throws IOException {
  boolean result=false;
  ApplicationMaster appMaster=new ApplicationMaster();
  try {
    LOG.info("Initializing ApplicationMaster");
    boolean doRun=appMaster.init(args);
    if (!doRun) {
      System.exit(0);
    }
    appMaster.run();
    result=appMaster.finish();
  }
 catch (  Throwable t) {
    LOG.fatal("Error running ApplicationMaster",t);
    LogManager.shutdown();
    ExitUtil.terminate(1,t);
  }
 finally {
    LOG.info("Stop SyncServer and RPCServer.");
    appMaster.close();
  }
  if (result) {
    LOG.info("Application Master completed successfully. exiting");
    System.exit(0);
  }
 else {
    LOG.info("Application Master failed. exiting");
    System.exit(2);
  }
}

ID 7=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable t) {
  LOG.fatal("Error running ApplicationMaster",t);
  LogManager.shutdown();
  ExitUtil.terminate(1,t);
}

block: 
ApplicationMaster
public static void main(String[] args) throws IOException {
  boolean result=false;
  ApplicationMaster appMaster=new ApplicationMaster();
  try {
    LOG.info("Initializing ApplicationMaster");
    boolean doRun=appMaster.init(args);
    if (!doRun) {
      System.exit(0);
    }
    appMaster.run();
    result=appMaster.finish();
  }
 catch (  Throwable t) {
    LOG.fatal("Error running ApplicationMaster",t);
    LogManager.shutdown();
    ExitUtil.terminate(1,t);
  }
 finally {
    LOG.info("Stop SyncServer and RPCServer.");
    appMaster.close();
  }
  if (result) {
    LOG.info("Application Master completed successfully. exiting");
    System.exit(0);
  }
 else {
    LOG.info("Application Master failed. exiting");
    System.exit(2);
  }
}

ID 8=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#init(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#getSubmitConfiguration(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ApplicationMaster
public boolean init(String[] args) throws Exception {
  if (args.length != 1) {
    throw new IllegalArgumentException();
  }
  this.jobFile=args[0];
  this.jobConf=getSubmitConfiguration(jobFile);
  localConf.addResource(localConf);
  fs=FileSystem.get(jobConf);
  this.applicationName=jobConf.get("bsp.job.name","<no bsp job name defined>");
  if (applicationName.isEmpty()) {
    this.applicationName="<no bsp job name defined>";
  }
  appAttemptID=getApplicationAttemptId();
  this.jobId=new BSPJobID(appAttemptID.toString(),0);
  this.appMasterHostname=BSPNetUtils.getCanonicalHostname();
  this.appMasterTrackingUrl="http://localhost:8088";
  this.numTotalContainers=this.jobConf.getInt("bsp.peers.num",1);
  this.containerMemory=getMemoryRequirements(jobConf);
  this.hostname=BSPNetUtils.getCanonicalHostname();
  this.clientPort=BSPNetUtils.getFreePort(12000);
  this.jobConf.set(Constants.ZOOKEEPER_QUORUM,appMasterHostname);
  startSyncServer();
  startRPCServers();
  rewriteSubmitConfiguration(jobFile,jobConf);
  String jobSplit=jobConf.get("bsp.job.split.file");
  splits=null;
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(jobSplit));
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
  }
  return true;
}

ID 9=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#init(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#getApplicationAttemptId()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ApplicationMaster
public boolean init(String[] args) throws Exception {
  if (args.length != 1) {
    throw new IllegalArgumentException();
  }
  this.jobFile=args[0];
  this.jobConf=getSubmitConfiguration(jobFile);
  localConf.addResource(localConf);
  fs=FileSystem.get(jobConf);
  this.applicationName=jobConf.get("bsp.job.name","<no bsp job name defined>");
  if (applicationName.isEmpty()) {
    this.applicationName="<no bsp job name defined>";
  }
  appAttemptID=getApplicationAttemptId();
  this.jobId=new BSPJobID(appAttemptID.toString(),0);
  this.appMasterHostname=BSPNetUtils.getCanonicalHostname();
  this.appMasterTrackingUrl="http://localhost:8088";
  this.numTotalContainers=this.jobConf.getInt("bsp.peers.num",1);
  this.containerMemory=getMemoryRequirements(jobConf);
  this.hostname=BSPNetUtils.getCanonicalHostname();
  this.clientPort=BSPNetUtils.getFreePort(12000);
  this.jobConf.set(Constants.ZOOKEEPER_QUORUM,appMasterHostname);
  startSyncServer();
  startRPCServers();
  rewriteSubmitConfiguration(jobFile,jobConf);
  String jobSplit=jobConf.get("bsp.job.split.file");
  splits=null;
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(jobSplit));
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
  }
  return true;
}

ID 10=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#init(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#startSyncServer()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ApplicationMaster
public boolean init(String[] args) throws Exception {
  if (args.length != 1) {
    throw new IllegalArgumentException();
  }
  this.jobFile=args[0];
  this.jobConf=getSubmitConfiguration(jobFile);
  localConf.addResource(localConf);
  fs=FileSystem.get(jobConf);
  this.applicationName=jobConf.get("bsp.job.name","<no bsp job name defined>");
  if (applicationName.isEmpty()) {
    this.applicationName="<no bsp job name defined>";
  }
  appAttemptID=getApplicationAttemptId();
  this.jobId=new BSPJobID(appAttemptID.toString(),0);
  this.appMasterHostname=BSPNetUtils.getCanonicalHostname();
  this.appMasterTrackingUrl="http://localhost:8088";
  this.numTotalContainers=this.jobConf.getInt("bsp.peers.num",1);
  this.containerMemory=getMemoryRequirements(jobConf);
  this.hostname=BSPNetUtils.getCanonicalHostname();
  this.clientPort=BSPNetUtils.getFreePort(12000);
  this.jobConf.set(Constants.ZOOKEEPER_QUORUM,appMasterHostname);
  startSyncServer();
  startRPCServers();
  rewriteSubmitConfiguration(jobFile,jobConf);
  String jobSplit=jobConf.get("bsp.job.split.file");
  splits=null;
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(jobSplit));
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
  }
  return true;
}

ID 11=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#init(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#startRPCServers()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ApplicationMaster
public boolean init(String[] args) throws Exception {
  if (args.length != 1) {
    throw new IllegalArgumentException();
  }
  this.jobFile=args[0];
  this.jobConf=getSubmitConfiguration(jobFile);
  localConf.addResource(localConf);
  fs=FileSystem.get(jobConf);
  this.applicationName=jobConf.get("bsp.job.name","<no bsp job name defined>");
  if (applicationName.isEmpty()) {
    this.applicationName="<no bsp job name defined>";
  }
  appAttemptID=getApplicationAttemptId();
  this.jobId=new BSPJobID(appAttemptID.toString(),0);
  this.appMasterHostname=BSPNetUtils.getCanonicalHostname();
  this.appMasterTrackingUrl="http://localhost:8088";
  this.numTotalContainers=this.jobConf.getInt("bsp.peers.num",1);
  this.containerMemory=getMemoryRequirements(jobConf);
  this.hostname=BSPNetUtils.getCanonicalHostname();
  this.clientPort=BSPNetUtils.getFreePort(12000);
  this.jobConf.set(Constants.ZOOKEEPER_QUORUM,appMasterHostname);
  startSyncServer();
  startRPCServers();
  rewriteSubmitConfiguration(jobFile,jobConf);
  String jobSplit=jobConf.get("bsp.job.split.file");
  splits=null;
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(jobSplit));
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
  }
  return true;
}

ID 12=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#init(java.lang.String[])
Rmethod: org.apache.hama.bsp.ApplicationMaster#rewriteSubmitConfiguration(java.lang.String, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ApplicationMaster
public boolean init(String[] args) throws Exception {
  if (args.length != 1) {
    throw new IllegalArgumentException();
  }
  this.jobFile=args[0];
  this.jobConf=getSubmitConfiguration(jobFile);
  localConf.addResource(localConf);
  fs=FileSystem.get(jobConf);
  this.applicationName=jobConf.get("bsp.job.name","<no bsp job name defined>");
  if (applicationName.isEmpty()) {
    this.applicationName="<no bsp job name defined>";
  }
  appAttemptID=getApplicationAttemptId();
  this.jobId=new BSPJobID(appAttemptID.toString(),0);
  this.appMasterHostname=BSPNetUtils.getCanonicalHostname();
  this.appMasterTrackingUrl="http://localhost:8088";
  this.numTotalContainers=this.jobConf.getInt("bsp.peers.num",1);
  this.containerMemory=getMemoryRequirements(jobConf);
  this.hostname=BSPNetUtils.getCanonicalHostname();
  this.clientPort=BSPNetUtils.getFreePort(12000);
  this.jobConf.set(Constants.ZOOKEEPER_QUORUM,appMasterHostname);
  startSyncServer();
  startRPCServers();
  rewriteSubmitConfiguration(jobFile,jobConf);
  String jobSplit=jobConf.get("bsp.job.split.file");
  splits=null;
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(jobSplit));
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
  }
  return true;
}

ID 13=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#init(java.lang.String[])
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ApplicationMaster
public boolean init(String[] args) throws Exception {
  if (args.length != 1) {
    throw new IllegalArgumentException();
  }
  this.jobFile=args[0];
  this.jobConf=getSubmitConfiguration(jobFile);
  localConf.addResource(localConf);
  fs=FileSystem.get(jobConf);
  this.applicationName=jobConf.get("bsp.job.name","<no bsp job name defined>");
  if (applicationName.isEmpty()) {
    this.applicationName="<no bsp job name defined>";
  }
  appAttemptID=getApplicationAttemptId();
  this.jobId=new BSPJobID(appAttemptID.toString(),0);
  this.appMasterHostname=BSPNetUtils.getCanonicalHostname();
  this.appMasterTrackingUrl="http://localhost:8088";
  this.numTotalContainers=this.jobConf.getInt("bsp.peers.num",1);
  this.containerMemory=getMemoryRequirements(jobConf);
  this.hostname=BSPNetUtils.getCanonicalHostname();
  this.clientPort=BSPNetUtils.getFreePort(12000);
  this.jobConf.set(Constants.ZOOKEEPER_QUORUM,appMasterHostname);
  startSyncServer();
  startRPCServers();
  rewriteSubmitConfiguration(jobFile,jobConf);
  String jobSplit=jobConf.get("bsp.job.split.file");
  splits=null;
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(jobSplit));
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
  }
  return true;
}

ID 14=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LaunchContainerRunnable#run()
Rmethod: java.lang.Long#parseLong(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Connects to CM, sets up container launch context for shell command and eventually dispatches the container start request to the CM.
 */

catch: 
null
block: 
LaunchContainerRunnable
/** 
 * Connects to CM, sets up container launch context for shell command and eventually dispatches the container start request to the CM.
 */
@Override public void run(){
  LOG.info("Setting up container launch container for containerid=" + container.getId());
  ContainerLaunchContext ctx=Records.newRecord(ContainerLaunchContext.class);
  Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
  LocalResource packageResource=Records.newRecord(LocalResource.class);
  FileSystem fs=null;
  try {
    fs=FileSystem.get(conf);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  Path packageFile=new Path(System.getenv(YARNBSPConstants.HAMA_YARN_LOCATION));
  URL packageUrl=null;
  try {
    packageUrl=ConverterUtils.getYarnUrlFromPath(packageFile.makeQualified(fs.getUri(),fs.getWorkingDirectory()));
    LOG.info("PackageURL has been composed to " + packageUrl.toString());
    LOG.info("Reverting packageURL to path: " + ConverterUtils.getPathFromYarnURL(packageUrl));
  }
 catch (  URISyntaxException e) {
    LOG.fatal("If you see this error the workarround does not work",e);
    numCompletedContainers.incrementAndGet();
    numFailedContainers.incrementAndGet();
    return;
  }
  packageResource.setResource(packageUrl);
  packageResource.setSize(Long.parseLong(System.getenv(YARNBSPConstants.HAMA_YARN_SIZE)));
  packageResource.setTimestamp(Long.parseLong(System.getenv(YARNBSPConstants.HAMA_YARN_TIMESTAMP)));
  packageResource.setType(LocalResourceType.FILE);
  packageResource.setVisibility(LocalResourceVisibility.APPLICATION);
  localResources.put(YARNBSPConstants.APP_MASTER_JAR_PATH,packageResource);
  Path hamaReleaseFile=new Path(System.getenv(YARNBSPConstants.HAMA_LOCATION));
  URL hamaReleaseUrl=ConverterUtils.getYarnUrlFromPath(hamaReleaseFile.makeQualified(fs.getUri(),fs.getWorkingDirectory()));
  LOG.info("Hama release URL has been composed to " + hamaReleaseUrl.toString());
  RemoteIterator<LocatedFileStatus> fileStatusListIterator=null;
  try {
    fileStatusListIterator=fs.listFiles(hamaReleaseFile,true);
    while (fileStatusListIterator.hasNext()) {
      LocatedFileStatus lfs=fileStatusListIterator.next();
      LocalResource localRsrc=LocalResource.newInstance(ConverterUtils.getYarnUrlFromPath(lfs.getPath()),LocalResourceType.FILE,LocalResourceVisibility.APPLICATION,lfs.getLen(),lfs.getModificationTime());
      localResources.put(lfs.getPath().getName(),localRsrc);
    }
  }
 catch (  IOException e) {
    LOG.fatal("The error has occured to RemoteIterator  " + e);
  }
  ctx.setLocalResources(localResources);
  StringBuilder classPathEnv=new StringBuilder(ApplicationConstants.Environment.CLASSPATH.$()).append(File.pathSeparatorChar).append("./*");
  for (  String c : conf.getStrings(YarnConfiguration.YARN_APPLICATION_CLASSPATH,YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH)) {
    classPathEnv.append(File.pathSeparatorChar);
    classPathEnv.append(c.trim());
  }
  Vector<CharSequence> vargs=new Vector<CharSequence>();
  vargs.add("${JAVA_HOME}/bin/java");
  vargs.add("-cp " + classPathEnv + "");
  vargs.add(BSPRunner.class.getCanonicalName());
  vargs.add(jobId.getJtIdentifier());
  vargs.add(Integer.toString(ai.incrementAndGet()));
  vargs.add(new Path(jobFile).makeQualified(fs.getUri(),fs.getWorkingDirectory()).toString());
  vargs.add("1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-worker.stdout");
  vargs.add("2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-worker.stderr");
  StringBuilder command=new StringBuilder();
  for (  CharSequence str : vargs) {
    command.append(str).append(" ");
  }
  List<String> commands=new ArrayList<String>();
  commands.add(command.toString());
  ctx.setCommands(commands);
  ctx.setTokens(allTokens.duplicate());
  LOG.info("Starting commands: " + commands);
  containerListener.addContainer(container.getId(),container);
  nmClientAsync.startContainerAsync(container,ctx);
}

ID 15=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ApplicationMaster#getMemoryFromOptString(java.lang.String)
Rmethod: java.lang.Integer#valueOf(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ApplicationMaster
private static int getMemoryFromOptString(String opts){
  final int DEFAULT_MEMORY_MB=256;
  if (opts == null) {
    return DEFAULT_MEMORY_MB;
  }
  if (!opts.contains("-Xmx")) {
    LOG.info("No \"-Xmx\" option found in child opts, using default amount of memory!");
    return DEFAULT_MEMORY_MB;
  }
 else {
    int startIndex=opts.indexOf("-Xmx") + 4;
    String xmxString=opts.substring(startIndex);
    char qualifier=xmxString.charAt(xmxString.length() - 1);
    int memory=Integer.valueOf(xmxString.substring(0,xmxString.length() - 1));
    if (qualifier == 'm') {
      return memory;
    }
 else     if (qualifier == 'g') {
      return memory * 1024;
    }
 else {
      throw new IllegalArgumentException("Memory Limit in child opts was not set! \"bsp.child.java.opts\" String was: " + opts);
    }
  }
}

ID 16=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupIOstreams()
Rmethod: org.apache.hama.ipc.Connection#setupConnection()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server.
 */

catch: 
catch (Throwable t) {
  if (t instanceof IOException) {
    markClosed((IOException)t);
  }
 else {
    markClosed(new IOException("Couldn't set up IO streams",t));
  }
  close();
}

block: 
Connection
/** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server.
 */
private void setupIOstreams() throws InterruptedException {
  if (channel != null && channel.isActive()) {
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Connecting to " + serverAddress);
    }
    setupConnection();
    writeHeader();
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      markClosed((IOException)t);
    }
 else {
      markClosed(new IOException("Couldn't set up IO streams",t));
    }
    close();
  }
}

ID 17=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: org.apache.hama.ipc.Connection#updateAddress()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Configure the client and connect to server
 */

catch: 
catch (Exception ie) {
  if (updateAddress()) {
    ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
/** 
 * Configure the client and connect to server
 */
private void setupConnection() throws Exception {
  while (true) {
    short ioFailures=0;
    try {
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      group=new EpollEventLoopGroup();
      bootstrap=new Bootstrap();
      bootstrap.group(group).channel(EpollSocketChannel.class).option(ChannelOption.TCP_NODELAY,this.tcpNoDelay).option(ChannelOption.SO_KEEPALIVE,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,pingInterval).option(ChannelOption.SO_SNDBUF,30 * 1024 * 1024).handler(new LoggingHandler(LogLevel.INFO)).handler(new ChannelInitializer<SocketChannel>(){
        @Override public void initChannel(        SocketChannel ch) throws Exception {
          ChannelPipeline p=ch.pipeline();
          p.addLast(new IdleStateHandler(0,0,maxIdleTime));
          p.addLast(new NioClientInboundHandler());
        }
      }
);
      ChannelFuture channelFuture=bootstrap.connect(serverAddress.getAddress(),serverAddress.getPort()).sync();
      channel=channelFuture.channel();
      LOG.info("AsyncClient startup");
      break;
    }
 catch (    Exception ie) {
      if (updateAddress()) {
        ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 18=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: org.apache.hama.ipc.Connection#handleConnectionFailure(int, java.lang.Exception)
hasForStatement: true
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * Configure the client and connect to server
 */

catch: 
catch (Exception ie) {
  if (updateAddress()) {
    ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
/** 
 * Configure the client and connect to server
 */
private void setupConnection() throws Exception {
  while (true) {
    short ioFailures=0;
    try {
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      group=new EpollEventLoopGroup();
      bootstrap=new Bootstrap();
      bootstrap.group(group).channel(EpollSocketChannel.class).option(ChannelOption.TCP_NODELAY,this.tcpNoDelay).option(ChannelOption.SO_KEEPALIVE,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,pingInterval).option(ChannelOption.SO_SNDBUF,30 * 1024 * 1024).handler(new LoggingHandler(LogLevel.INFO)).handler(new ChannelInitializer<SocketChannel>(){
        @Override public void initChannel(        SocketChannel ch) throws Exception {
          ChannelPipeline p=ch.pipeline();
          p.addLast(new IdleStateHandler(0,0,maxIdleTime));
          p.addLast(new NioClientInboundHandler());
        }
      }
);
      ChannelFuture channelFuture=bootstrap.connect(serverAddress.getAddress(),serverAddress.getPort()).sync();
      channel=channelFuture.channel();
      LOG.info("AsyncClient startup");
      break;
    }
 catch (    Exception ie) {
      if (updateAddress()) {
        ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 19=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioClientInboundHandler#channelRead(ChannelHandlerContext, java.lang.Object)
Rmethod: java.io.FilterInputStream#available()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Receive a response. This method is called with the received response message, whenever new data is received from a server.
 * @param ctx
 * @param cause
 */

catch: 
catch (IOException e) {
  markClosed(e);
}

block: 
NioClientInboundHandler
/** 
 * Receive a response. This method is called with the received response message, whenever new data is received from a server.
 * @param ctx
 * @param cause
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  ByteBuf byteBuf=(ByteBuf)msg;
  ByteBufInputStream byteBufInputStream=new ByteBufInputStream(byteBuf);
  DataInputStream in=new DataInputStream(byteBufInputStream);
  while (true) {
    try {
      if (in.available() <= 0)       break;
      int id=in.readInt();
      if (LOG.isDebugEnabled())       LOG.debug(serverAddress.getHostName() + " got value #" + id);
      Call call=calls.get(id);
      int state=in.readInt();
      if (state == Status.SUCCESS.state) {
        Writable value=ReflectionUtils.newInstance(valueClass,conf);
        value.readFields(in);
        call.setValue(value);
        calls.remove(id);
      }
 else       if (state == Status.ERROR.state) {
        String className=WritableUtils.readString(in);
        byte[] errorBytes=new byte[in.available()];
        in.readFully(errorBytes);
        call.setException(new RemoteException(className,new String(errorBytes)));
        calls.remove(id);
      }
 else       if (state == Status.FATAL.state) {
        markClosed(new RemoteException(WritableUtils.readString(in),WritableUtils.readString(in)));
      }
 else {
        byte[] garbageBytes=new byte[in.available()];
        in.readFully(garbageBytes);
      }
    }
 catch (    IOException e) {
      markClosed(e);
    }
  }
  IOUtils.closeStream(in);
  IOUtils.closeStream(byteBufInputStream);
  ReferenceCountUtil.release(msg);
}

ID 20=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioClientInboundHandler#channelRead(ChannelHandlerContext, java.lang.Object)
Rmethod: java.io.DataInputStream#readInt()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Receive a response. This method is called with the received response message, whenever new data is received from a server.
 * @param ctx
 * @param cause
 */

catch: 
catch (IOException e) {
  markClosed(e);
}

block: 
NioClientInboundHandler
/** 
 * Receive a response. This method is called with the received response message, whenever new data is received from a server.
 * @param ctx
 * @param cause
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  ByteBuf byteBuf=(ByteBuf)msg;
  ByteBufInputStream byteBufInputStream=new ByteBufInputStream(byteBuf);
  DataInputStream in=new DataInputStream(byteBufInputStream);
  while (true) {
    try {
      if (in.available() <= 0)       break;
      int id=in.readInt();
      if (LOG.isDebugEnabled())       LOG.debug(serverAddress.getHostName() + " got value #" + id);
      Call call=calls.get(id);
      int state=in.readInt();
      if (state == Status.SUCCESS.state) {
        Writable value=ReflectionUtils.newInstance(valueClass,conf);
        value.readFields(in);
        call.setValue(value);
        calls.remove(id);
      }
 else       if (state == Status.ERROR.state) {
        String className=WritableUtils.readString(in);
        byte[] errorBytes=new byte[in.available()];
        in.readFully(errorBytes);
        call.setException(new RemoteException(className,new String(errorBytes)));
        calls.remove(id);
      }
 else       if (state == Status.FATAL.state) {
        markClosed(new RemoteException(WritableUtils.readString(in),WritableUtils.readString(in)));
      }
 else {
        byte[] garbageBytes=new byte[in.available()];
        in.readFully(garbageBytes);
      }
    }
 catch (    IOException e) {
      markClosed(e);
    }
  }
  IOUtils.closeStream(in);
  IOUtils.closeStream(byteBufInputStream);
  ReferenceCountUtil.release(msg);
}

ID 21=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioClientInboundHandler#channelRead(ChannelHandlerContext, java.lang.Object)
Rmethod: java.io.DataInputStream#readFully(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Receive a response. This method is called with the received response message, whenever new data is received from a server.
 * @param ctx
 * @param cause
 */

catch: 
catch (IOException e) {
  markClosed(e);
}

block: 
NioClientInboundHandler
/** 
 * Receive a response. This method is called with the received response message, whenever new data is received from a server.
 * @param ctx
 * @param cause
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  ByteBuf byteBuf=(ByteBuf)msg;
  ByteBufInputStream byteBufInputStream=new ByteBufInputStream(byteBuf);
  DataInputStream in=new DataInputStream(byteBufInputStream);
  while (true) {
    try {
      if (in.available() <= 0)       break;
      int id=in.readInt();
      if (LOG.isDebugEnabled())       LOG.debug(serverAddress.getHostName() + " got value #" + id);
      Call call=calls.get(id);
      int state=in.readInt();
      if (state == Status.SUCCESS.state) {
        Writable value=ReflectionUtils.newInstance(valueClass,conf);
        value.readFields(in);
        call.setValue(value);
        calls.remove(id);
      }
 else       if (state == Status.ERROR.state) {
        String className=WritableUtils.readString(in);
        byte[] errorBytes=new byte[in.available()];
        in.readFully(errorBytes);
        call.setException(new RemoteException(className,new String(errorBytes)));
        calls.remove(id);
      }
 else       if (state == Status.FATAL.state) {
        markClosed(new RemoteException(WritableUtils.readString(in),WritableUtils.readString(in)));
      }
 else {
        byte[] garbageBytes=new byte[in.available()];
        in.readFully(garbageBytes);
      }
    }
 catch (    IOException e) {
      markClosed(e);
    }
  }
  IOUtils.closeStream(in);
  IOUtils.closeStream(byteBufInputStream);
  ReferenceCountUtil.release(msg);
}

ID 22=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#handleConnectionFailure(int, int, java.io.IOException)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Handle connection failures If the current number of retries is equal to the max number of retries, stop retrying and throw the exception; Otherwise backoff 1 second and try connecting again. This Method is only called from inside setupIOstreams(), which is synchronized. Hence the sleep is synchronized; the locks will be retained.
 * @param curRetries current number of retries
 * @param maxRetries max number of retries allowed
 * @param ioe failure reason
 * @throws IOException if max number of retries is reached
 */

catch: 
catch (InterruptedException ignored) {
}

block: 
Connection
/** 
 * Handle connection failures If the current number of retries is equal to the max number of retries, stop retrying and throw the exception; Otherwise backoff 1 second and try connecting again. This Method is only called from inside setupIOstreams(), which is synchronized. Hence the sleep is synchronized; the locks will be retained.
 * @param curRetries current number of retries
 * @param maxRetries max number of retries allowed
 * @param ioe failure reason
 * @throws IOException if max number of retries is reached
 */
@SuppressWarnings("unused") private void handleConnectionFailure(int curRetries,int maxRetries,IOException ioe) throws IOException {
  closeConnection();
  if (curRetries >= maxRetries) {
    throw ioe;
  }
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException ignored) {
  }
  LOG.info("Retrying connect to server: " + serverAddress + ". Already tried "+ curRetries+ " time(s); maxRetries="+ maxRetries);
}

ID 23=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param addr
 * @param protocol
 * @param ticket
 * @param rpcTimeout
 * @param conf
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param addr
 * @param protocol
 * @param ticket
 * @param rpcTimeout
 * @param conf
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */
public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,Configuration conf) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 24=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
Rmethod: org.apache.hama.ipc.AsyncClient#call(Writable, org.apache.hama.ipc.AsyncClient.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param addr
 * @param protocol
 * @param ticket
 * @param rpcTimeout
 * @param conf
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param addr
 * @param protocol
 * @param ticket
 * @param rpcTimeout
 * @param conf
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */
public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,Configuration conf) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 25=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
Rmethod: org.apache.hama.ipc.AsyncClient#call(Writable, org.apache.hama.ipc.AsyncClient.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param addr
 * @param protocol
 * @param ticket
 * @param rpcTimeout
 * @param conf
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param addr
 * @param protocol
 * @param ticket
 * @param rpcTimeout
 * @param conf
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */
public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,Configuration conf) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 26=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable, org.apache.hama.ipc.AsyncClient.ConnectionId)
Rmethod: org.apache.hama.ipc.AsyncClient#getConnection(org.apache.hama.ipc.AsyncClient.ConnectionId, org.apache.hama.ipc.AsyncClient.Call)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param remoteId
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param remoteId
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */
public Writable call(Writable param,ConnectionId remoteId) throws InterruptedException, IOException {
  Call call=new Call(param);
  Connection connection=getConnection(remoteId,call);
  connection.sendParam(call);
  boolean interrupted=false;
synchronized (call) {
    int callFailCount=0;
    while (!call.done) {
      try {
        call.wait(1000);
        if (callFailCount++ == IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT)         break;
      }
 catch (      InterruptedException ie) {
        interrupted=true;
      }
    }
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
    if (call.error != null) {
      if (call.error instanceof RemoteException) {
        call.error.fillInStackTrace();
        throw call.error;
      }
 else {
        throw wrapException(connection.getRemoteAddress(),call.error);
      }
    }
 else {
      return call.value;
    }
  }
}

ID 27=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable, org.apache.hama.ipc.AsyncClient.ConnectionId)
Rmethod: org.apache.hama.ipc.AsyncClient#getConnection(org.apache.hama.ipc.AsyncClient.ConnectionId, org.apache.hama.ipc.AsyncClient.Call)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param remoteId
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param remoteId
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */
public Writable call(Writable param,ConnectionId remoteId) throws InterruptedException, IOException {
  Call call=new Call(param);
  Connection connection=getConnection(remoteId,call);
  connection.sendParam(call);
  boolean interrupted=false;
synchronized (call) {
    int callFailCount=0;
    while (!call.done) {
      try {
        call.wait(1000);
        if (callFailCount++ == IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT)         break;
      }
 catch (      InterruptedException ie) {
        interrupted=true;
      }
    }
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
    if (call.error != null) {
      if (call.error instanceof RemoteException) {
        call.error.fillInStackTrace();
        throw call.error;
      }
 else {
        throw wrapException(connection.getRemoteAddress(),call.error);
      }
    }
 else {
      return call.value;
    }
  }
}

ID 28=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable, org.apache.hama.ipc.AsyncClient.ConnectionId)
Rmethod: java.lang.Object#wait(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param remoteId
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
catch (InterruptedException ie) {
  interrupted=true;
}

block: 
AsyncClient
/** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @param param
 * @param remoteId
 * @return Response Writable value
 * @throws InterruptedException
 * @throws IOException
 */
public Writable call(Writable param,ConnectionId remoteId) throws InterruptedException, IOException {
  Call call=new Call(param);
  Connection connection=getConnection(remoteId,call);
  connection.sendParam(call);
  boolean interrupted=false;
synchronized (call) {
    int callFailCount=0;
    while (!call.done) {
      try {
        call.wait(1000);
        if (callFailCount++ == IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT)         break;
      }
 catch (      InterruptedException ie) {
        interrupted=true;
      }
    }
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
    if (call.error != null) {
      if (call.error instanceof RemoteException) {
        call.error.fillInStackTrace();
        throw call.error;
      }
 else {
        throw wrapException(connection.getRemoteAddress(),call.error);
      }
    }
 else {
      return call.value;
    }
  }
}

ID 29=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
catch (IOException e) {
  LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
  results.size--;
}

block: 
AsyncClient
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
  ConnectionId remoteId[]=new ConnectionId[addresses.length];
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        remoteId[i]=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId[i],call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 30=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: org.apache.hama.ipc.AsyncClient#getConnection(org.apache.hama.ipc.AsyncClient.ConnectionId, org.apache.hama.ipc.AsyncClient.Call)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
catch (IOException e) {
  LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
  results.size--;
}

block: 
AsyncClient
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
  ConnectionId remoteId[]=new ConnectionId[addresses.length];
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        remoteId[i]=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId[i],call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 31=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: org.apache.hama.ipc.AsyncClient#getConnection(org.apache.hama.ipc.AsyncClient.ConnectionId, org.apache.hama.ipc.AsyncClient.Call)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
  ConnectionId remoteId[]=new ConnectionId[addresses.length];
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        remoteId[i]=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId[i],call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 32=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
catch (InterruptedException e) {
}

block: 
AsyncClient
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 * @param params
 * @param addresses
 * @param protocol
 * @param ticket
 * @param conf
 * @return Response Writable value array
 * @throws IOException
 * @throws InterruptedException
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
  ConnectionId remoteId[]=new ConnectionId[addresses.length];
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        remoteId[i]=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId[i],call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 33=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#getConnection(org.apache.hama.ipc.AsyncClient.ConnectionId, org.apache.hama.ipc.AsyncClient.Call)
Rmethod: org.apache.hama.ipc.Connection#Connection(org.apache.hama.ipc.AsyncClient.ConnectionId)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 * @param remoteId
 * @param call
 * @return connection
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 * @param remoteId
 * @param call
 * @return connection
 * @throws IOException
 * @throws InterruptedException
 */
private synchronized Connection getConnection(ConnectionId remoteId,Call call) throws IOException, InterruptedException {
  if (!running.get()) {
    throw new IOException("The client is stopped");
  }
  Connection connection;
  do {
    connection=connections.get(remoteId);
    if (connection == null) {
      connection=new Connection(remoteId);
      connections.put(remoteId,connection);
    }
 else     if (!connection.channel.isWritable() || !connection.channel.isActive()) {
      connection=new Connection(remoteId);
      connections.remove(remoteId);
      connections.put(remoteId,connection);
    }
  }
 while (!connection.addCall(call));
  connection.setupIOstreams();
  return connection;
}

ID 34=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncClient#getConnection(org.apache.hama.ipc.AsyncClient.ConnectionId, org.apache.hama.ipc.AsyncClient.Call)
Rmethod: org.apache.hama.ipc.Connection#setupIOstreams()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 * @param remoteId
 * @param call
 * @return connection
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
AsyncClient
/** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 * @param remoteId
 * @param call
 * @return connection
 * @throws IOException
 * @throws InterruptedException
 */
private synchronized Connection getConnection(ConnectionId remoteId,Call call) throws IOException, InterruptedException {
  if (!running.get()) {
    throw new IOException("The client is stopped");
  }
  Connection connection;
  do {
    connection=connections.get(remoteId);
    if (connection == null) {
      connection=new Connection(remoteId);
      connections.put(remoteId,connection);
    }
 else     if (!connection.channel.isWritable() || !connection.channel.isActive()) {
      connection=new Connection(remoteId);
      connections.remove(remoteId);
      connections.put(remoteId,connection);
    }
  }
 while (!connection.addCall(call));
  connection.setupIOstreams();
  return connection;
}

ID 35=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, Configuration)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ConnectionId
static ConnectionId getConnectionId(InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException {
  return getConnectionId(addr,protocol,ticket,0,conf);
}

ID 36=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, RetryPolicy, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ConnectionId
static ConnectionId getConnectionId(InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,Configuration conf) throws IOException {
  return getConnectionId(addr,protocol,ticket,rpcTimeout,null,conf);
}

ID 37=========================================================================type: only_throws
package: org.apache.hama.bsp.ft
Method:org.apache.hama.bsp.ft.CheckpointMasterService#recoverTasks(JobInProgress, Map<java.lang.String,GroomServerStatus>, TaskInProgress[], TaskInProgress[], Map<GroomServerStatus,java.lang.Integer>, Map<GroomServerStatus,List<GroomServerAction>>)
Rmethod: org.apache.hama.bsp.ft.CheckpointMasterService#restartJob(long, Map<java.lang.String,GroomServerStatus>, Map<TaskID,TaskInProgress>, TaskInProgress[], Map<GroomServerStatus,java.lang.Integer>, Map<GroomServerStatus,List<GroomServerAction>>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CheckpointMasterService
@Override public void recoverTasks(JobInProgress jip,Map<String,GroomServerStatus> groomStatuses,TaskInProgress[] failedTasksInProgress,TaskInProgress[] allTasksInProgress,Map<GroomServerStatus,Integer> taskCountInGroomMap,Map<GroomServerStatus,List<GroomServerAction>> actionMap) throws IOException {
  Map<TaskID,TaskInProgress> recoverySet=new HashMap<TaskID,TaskInProgress>(2 * failedTasksInProgress.length);
  for (  TaskInProgress failedTasksInProgres : failedTasksInProgress) {
    recoverySet.put(failedTasksInProgres.getTaskId(),failedTasksInProgres);
  }
  long lowestSuperstepNumber=Long.MAX_VALUE;
  String[] taskProgress=this.masterSyncClient.getChildKeySet(this.masterSyncClient.constructKey(jobId,"checkpoint"),null);
  if (LOG.isDebugEnabled()) {
    StringBuffer list=new StringBuffer(25 * taskProgress.length);
    list.append("got child key set").append(taskProgress.length).append("/").append(tasks.length).append(" ");
    for (    String entry : taskProgress) {
      list.append(entry).append(",");
    }
    LOG.debug(list);
  }
  if (taskProgress.length == this.tasks.length) {
    for (    String taskProgres : taskProgress) {
      ArrayWritable progressInformation=new ArrayWritable(LongWritable.class);
      boolean result=this.masterSyncClient.getInformation(this.masterSyncClient.constructKey(jobId,"checkpoint",taskProgres),progressInformation);
      if (!result) {
        lowestSuperstepNumber=-1L;
        break;
      }
      Writable[] progressArr=progressInformation.get();
      LongWritable superstepProgress=(LongWritable)progressArr[0];
      if (superstepProgress != null) {
        if (superstepProgress.get() < lowestSuperstepNumber) {
          lowestSuperstepNumber=superstepProgress.get();
          if (LOG.isDebugEnabled()) {
            LOG.debug("Got superstep number " + lowestSuperstepNumber + " from "+ taskProgres);
          }
        }
      }
    }
    clearClientForSuperstep(lowestSuperstepNumber);
    restartJob(lowestSuperstepNumber,groomStatuses,recoverySet,allTasksInProgress,taskCountInGroomMap,actionMap);
  }
 else {
    restartJob(-1,groomStatuses,recoverySet,allTasksInProgress,taskCountInGroomMap,actionMap);
  }
  ++currentAttemptId;
}

ID 38=========================================================================type: only_throws
package: org.apache.hama.bsp.ft
Method:org.apache.hama.bsp.ft.AsyncRcvdMsgCheckpointImpl#constructPeerFaultTolerance(BSPJob, BSPPeer, PeerSyncClient, java.net.InetSocketAddress, TaskAttemptID, long, Configuration, MessageManager<M>)
Rmethod: org.apache.hama.bsp.ft.CheckpointPeerService#initialize(BSPJob, BSPPeer, PeerSyncClient, java.net.InetSocketAddress, TaskAttemptID, long, Configuration, MessageManager<M>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
AsyncRcvdMsgCheckpointImpl
@Override public FaultTolerantPeerService<M> constructPeerFaultTolerance(BSPJob job,@SuppressWarnings("rawtypes") BSPPeer bspPeer,PeerSyncClient syncClient,InetSocketAddress peerAddress,TaskAttemptID taskAttemptId,long superstep,Configuration conf,MessageManager<M> messenger) throws Exception {
  CheckpointPeerService<M> service=new CheckpointPeerService<M>();
  service.initialize(job,bspPeer,syncClient,peerAddress,taskAttemptId,superstep,conf,messenger);
  return service;
}

ID 39=========================================================================type: only_throws
package: org.apache.hama.bsp.ft
Method:org.apache.hama.bsp.ft.CheckpointPeerService#onPeerInitialized(TaskStatus.State)
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: true
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CheckpointPeerService
@Override public TaskStatus.State onPeerInitialized(TaskStatus.State state) throws Exception {
  if (this.superstep >= 0 && state.equals(TaskStatus.State.RECOVERING)) {
    ArrayWritable progressArr=new ArrayWritable(LongWritable.class);
    boolean result=this.syncClient.getInformation(this.syncClient.constructKey(job.getJobID(),"checkpoint",String.valueOf(peer.getPeerIndex())),progressArr);
    if (!result) {
      throw new IOException("No data found to restore peer state.");
    }
    Writable[] progressInfo=progressArr.get();
    long superstepProgress=((LongWritable)progressInfo[0]).get();
    long numMessages=((LongWritable)progressInfo[1]).get();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Got sstep =" + superstepProgress + " numMessages = "+ numMessages+ " this.superstep = "+ this.superstep);
    }
    if (numMessages > 0) {
      Path path=new Path(checkpointPath(superstepProgress));
      FSDataInputStream in=this.fs.open(path);
      BSPMessageBundle<M> bundle=new BSPMessageBundle<M>();
      try {
        for (int i=0; i < numMessages; ++i) {
          String className=in.readUTF();
          if (className.equals(BSPMessageBundle.class.getCanonicalName())) {
            BSPMessageBundle<M> tmp=new BSPMessageBundle<M>();
            tmp.readFields(in);
            messenger.loopBackBundle(tmp);
          }
 else {
            @SuppressWarnings("unchecked") M message=(M)ReflectionUtils.newInstance(Class.forName(className),conf);
            message.readFields(in);
            bundle.addMessage(message);
          }
        }
        if (bundle.size() > 0) {
          messenger.loopBackBundle(bundle);
        }
      }
 catch (      EOFException e) {
        LOG.error("Error recovering from checkpointing",e);
        throw new IOException(e);
      }
 finally {
        this.fs.close();
      }
    }
  }
  this.messenger.registerListener(this);
  return TaskStatus.State.RUNNING;
}

ID 40=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Invocation#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * @param in
 */

catch: 
null
block: 
Invocation
/** 
 * @param in
 */
public void readFields(DataInput in) throws IOException {
  methodName=Text.readString(in);
  parameters=new Object[in.readInt()];
  parameterClasses=new Class[parameters.length];
  ObjectWritable objectWritable=new ObjectWritable();
  for (int i=0; i < parameters.length; i++) {
    parameters[i]=ObjectWritable.readObject(in,objectWritable,this.conf);
    parameterClasses[i]=objectWritable.getDeclaredClass();
  }
}

ID 41=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Invocation#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * @param out
 */

catch: 
null
block: 
Invocation
/** 
 * @param out
 */
public void write(DataOutput out) throws IOException {
  Text.writeString(out,methodName);
  out.writeInt(parameterClasses.length);
  for (int i=0; i < parameterClasses.length; i++) {
    ObjectWritable.writeObject(out,parameters[i],parameterClasses[i],conf);
  }
}

ID 42=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration)
Rmethod: org.apache.hama.ipc.AsyncRPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get a proxy connection to a remote server
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Get a proxy connection to a remote server
 */
public static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf) throws IOException {
  return waitForProxy(protocol,clientVersion,addr,conf,0,Long.MAX_VALUE);
}

ID 43=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, long)
Rmethod: org.apache.hama.ipc.AsyncRPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */
static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,long connTimeout) throws IOException {
  return waitForProxy(protocol,clientVersion,addr,conf,0,connTimeout);
}

ID 44=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
Rmethod: org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param rpcTimeout rpc timeout
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param rpcTimeout rpc timeout
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */
static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,int rpcTimeout,long connTimeout) throws IOException {
  long startTime=System.currentTimeMillis();
  IOException ioe;
  while (true) {
    try {
      return getProxy(protocol,clientVersion,addr,conf,rpcTimeout);
    }
 catch (    ConnectException se) {
      LOG.info("Server at " + addr + " not available yet, Zzzzz...");
      ioe=se;
    }
catch (    SocketTimeoutException te) {
      LOG.info("Problem connecting to server: " + addr);
      ioe=te;
    }
    if (System.currentTimeMillis() - connTimeout >= startTime) {
      throw ioe;
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ie) {
    }
  }
}

ID 45=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param rpcTimeout rpc timeout
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */

catch: 
catch (InterruptedException ie) {
}

block: 
AsyncRPC
/** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param rpcTimeout rpc timeout
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */
static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,int rpcTimeout,long connTimeout) throws IOException {
  long startTime=System.currentTimeMillis();
  IOException ioe;
  while (true) {
    try {
      return getProxy(protocol,clientVersion,addr,conf,rpcTimeout);
    }
 catch (    ConnectException se) {
      LOG.info("Server at " + addr + " not available yet, Zzzzz...");
      ioe=se;
    }
catch (    SocketTimeoutException te) {
      LOG.info("Problem connecting to server: " + addr);
      ioe=te;
    }
    if (System.currentTimeMillis() - connTimeout >= startTime) {
      throw ioe;
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ie) {
    }
  }
}

ID 46=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory)
Rmethod: org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @param factory
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @param factory
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,SocketFactory factory) throws IOException {
  UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
  return getProxy(protocol,clientVersion,addr,ugi,conf,factory,0);
}

ID 47=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory, int)
Rmethod: org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,SocketFactory factory,int rpcTimeout) throws IOException {
  return getProxy(protocol,clientVersion,addr,null,conf,factory,rpcTimeout);
}

ID 48=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory)
Rmethod: org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory) throws IOException {
  return getProxy(protocol,clientVersion,addr,ticket,conf,factory,0);
}

ID 49=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
Rmethod: org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout) throws IOException {
  return getProxy(protocol,clientVersion,addr,ticket,conf,factory,rpcTimeout,null,true);
}

ID 50=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
Rmethod: org.apache.hama.ipc.Invoker#Invoker(Class<? extends VersionedProtocol>, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @param connectionRetryPolicy
 * @param checkVersion
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @param connectionRetryPolicy
 * @param checkVersion
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout,RetryPolicy connectionRetryPolicy,boolean checkVersion) throws IOException {
  final Invoker invoker=new Invoker(protocol,addr,ticket,conf,factory,rpcTimeout,connectionRetryPolicy);
  VersionedProtocol proxy=(VersionedProtocol)Proxy.newProxyInstance(protocol.getClassLoader(),new Class[]{protocol},invoker);
  if (checkVersion) {
    checkVersion(protocol,clientVersion,proxy);
  }
  return proxy;
}

ID 51=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
Rmethod: java.lang.reflect.Proxy#newProxyInstance(java.lang.ClassLoader, Class<?>[], java.lang.reflect.InvocationHandler)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @param connectionRetryPolicy
 * @param checkVersion
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @param connectionRetryPolicy
 * @param checkVersion
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout,RetryPolicy connectionRetryPolicy,boolean checkVersion) throws IOException {
  final Invoker invoker=new Invoker(protocol,addr,ticket,conf,factory,rpcTimeout,connectionRetryPolicy);
  VersionedProtocol proxy=(VersionedProtocol)Proxy.newProxyInstance(protocol.getClassLoader(),new Class[]{protocol},invoker);
  if (checkVersion) {
    checkVersion(protocol,clientVersion,proxy);
  }
  return proxy;
}

ID 52=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
Rmethod: org.apache.hama.ipc.AsyncRPC#checkVersion(Class<? extends VersionedProtocol>, long, VersionedProtocol)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @param connectionRetryPolicy
 * @param checkVersion
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param ticket
 * @param conf
 * @param factory
 * @param rpcTimeout
 * @param connectionRetryPolicy
 * @param checkVersion
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout,RetryPolicy connectionRetryPolicy,boolean checkVersion) throws IOException {
  final Invoker invoker=new Invoker(protocol,addr,ticket,conf,factory,rpcTimeout,connectionRetryPolicy);
  VersionedProtocol proxy=(VersionedProtocol)Proxy.newProxyInstance(protocol.getClassLoader(),new Class[]{protocol},invoker);
  if (checkVersion) {
    checkVersion(protocol,clientVersion,proxy);
  }
  return proxy;
}

ID 53=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration)
Rmethod: org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object with the default SocketFactory
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @return a proxy instance
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a client-side proxy object with the default SocketFactory
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @return a proxy instance
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf) throws IOException {
  return getProxy(protocol,clientVersion,addr,conf,BSPNetUtils.getDefaultSocketFactory(conf),0);
}

ID 54=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int)
Rmethod: org.apache.hama.ipc.AsyncRPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get VersionedProtocol
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @param rpcTimeout
 * @return the proxy
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Get VersionedProtocol
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @param rpcTimeout
 * @return the proxy
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,int rpcTimeout) throws IOException {
  return getProxy(protocol,clientVersion,addr,conf,BSPNetUtils.getDefaultSocketFactory(conf),rpcTimeout);
}

ID 55=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], UserGroupInformation, Configuration)
Rmethod: java.lang.reflect.Array#newInstance(Class<?>, int[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @param method
 * @param params
 * @param addrs
 * @param ticket
 * @param conf
 * @return response object array
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @param method
 * @param params
 * @param addrs
 * @param ticket
 * @param conf
 * @return response object array
 * @throws IOException
 * @throws InterruptedException
 */
public static Object[] call(Method method,Object[][] params,InetSocketAddress[] addrs,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  Invocation[] invocations=new Invocation[params.length];
  for (int i=0; i < params.length; i++)   invocations[i]=new Invocation(method,params[i]);
  AsyncClient client=CLIENTS.getClient(conf);
  try {
    Writable[] wrappedValues=client.call(invocations,addrs,method.getDeclaringClass(),ticket,conf);
    if (method.getReturnType() == Void.TYPE) {
      return null;
    }
    Object[] values=(Object[])Array.newInstance(method.getReturnType(),wrappedValues.length);
    for (int i=0; i < values.length; i++)     if (wrappedValues[i] != null)     values[i]=((ObjectWritable)wrappedValues[i]).get();
    return values;
  }
  finally {
    CLIENTS.stopClient(client);
  }
}

ID 56=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], UserGroupInformation, Configuration)
Rmethod: java.lang.reflect.Array#newInstance(Class<?>, int[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.NegativeArraySizeException
exception comment: /** 
 * Thrown if an application tries to create an array with negative size.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @param method
 * @param params
 * @param addrs
 * @param ticket
 * @param conf
 * @return response object array
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @param method
 * @param params
 * @param addrs
 * @param ticket
 * @param conf
 * @return response object array
 * @throws IOException
 * @throws InterruptedException
 */
public static Object[] call(Method method,Object[][] params,InetSocketAddress[] addrs,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  Invocation[] invocations=new Invocation[params.length];
  for (int i=0; i < params.length; i++)   invocations[i]=new Invocation(method,params[i]);
  AsyncClient client=CLIENTS.getClient(conf);
  try {
    Writable[] wrappedValues=client.call(invocations,addrs,method.getDeclaringClass(),ticket,conf);
    if (method.getReturnType() == Void.TYPE) {
      return null;
    }
    Object[] values=(Object[])Array.newInstance(method.getReturnType(),wrappedValues.length);
    for (int i=0; i < values.length; i++)     if (wrappedValues[i] != null)     values[i]=((ObjectWritable)wrappedValues[i]).get();
    return values;
  }
  finally {
    CLIENTS.stopClient(client);
  }
}

ID 57=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getServer(java.lang.Object, java.lang.String, int, Configuration)
Rmethod: org.apache.hama.ipc.AsyncRPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 * @param instance
 * @param bindAddress
 * @param port
 * @param conf
 * @return server
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 * @param instance
 * @param bindAddress
 * @param port
 * @param conf
 * @return server
 * @throws IOException
 */
public static NioServer getServer(final Object instance,final String bindAddress,final int port,Configuration conf) throws IOException {
  return getServer(instance,bindAddress,port,1,false,conf);
}

ID 58=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration)
Rmethod: org.apache.hama.ipc.AsyncRPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration, SecretManager<? extends TokenIdentifier>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 * @param instance
 * @param bindAddress
 * @param port
 * @param numHandlers
 * @param verbose
 * @param conf
 * @return server
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 * @param instance
 * @param bindAddress
 * @param port
 * @param numHandlers
 * @param verbose
 * @param conf
 * @return server
 * @throws IOException
 */
public static NioServer getServer(final Object instance,final String bindAddress,final int port,final int numHandlers,final boolean verbose,Configuration conf) throws IOException {
  return getServer(instance,bindAddress,port,numHandlers,verbose,conf,null);
}

ID 59=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncRPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration, SecretManager<? extends TokenIdentifier>)
Rmethod: org.apache.hama.ipc.NioServer#NioServer(java.lang.Object, Configuration, java.lang.String, int, int, boolean, SecretManager<? extends TokenIdentifier>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a server for a protocol implementation instance listening on a port and address, with a secret manager.
 * @param instance
 * @param bindAddress
 * @param port
 * @param numHandlers
 * @param verbose
 * @param conf
 * @param secretManager
 * @return server
 * @throws IOException
 */

catch: 
null
block: 
AsyncRPC
/** 
 * Construct a server for a protocol implementation instance listening on a port and address, with a secret manager.
 * @param instance
 * @param bindAddress
 * @param port
 * @param numHandlers
 * @param verbose
 * @param conf
 * @param secretManager
 * @return server
 * @throws IOException
 */
public static NioServer getServer(final Object instance,final String bindAddress,final int port,final int numHandlers,final boolean verbose,Configuration conf,SecretManager<? extends TokenIdentifier> secretManager) throws IOException {
  return new NioServer(instance,conf,bindAddress,port,numHandlers,verbose,secretManager);
}

ID 60=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServer#call(Class<?>, Writable, long)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
NioServer
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 61=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServer#call(Class<?>, Writable, long)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
NioServer
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 62=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServer#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
NioServer
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 63=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServer#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
NioServer
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 64=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServer#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
NioServer
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 65=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServer#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
NioServer
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 66=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServerInboundHandler#channelRead(ChannelHandlerContext, java.lang.Object)
Rmethod: org.apache.hama.ipc.NioServerInboundHandler#processOneRpc(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Process a recieved message from client. This method is called with the received message, whenever new data is received from a client.
 * @param ctx
 * @param cause
 */

catch: 
catch (Exception e) {
  LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
  errorClass=e.getClass().getName();
  error=StringUtils.stringifyException(e);
}

block: 
NioServerInboundHandler
/** 
 * Process a recieved message from client. This method is called with the received message, whenever new data is received from a client.
 * @param ctx
 * @param cause
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  ByteBuffer dataLengthBuffer=ByteBuffer.allocate(4);
  ByteBuf byteBuf=(ByteBuf)msg;
  ByteBuffer data=null;
  ByteBuffer rpcHeaderBuffer=null;
  try {
    while (true) {
      Call call=null;
      errorClass=null;
      error=null;
      try {
        if (dataLengthBuffer.remaining() > 0 && byteBuf.isReadable()) {
          byteBuf.readBytes(dataLengthBuffer);
          if (dataLengthBuffer.remaining() > 0 && byteBuf.isReadable()) {
            return;
          }
        }
 else {
          return;
        }
        if (!rpcHeaderRead) {
          if (rpcHeaderBuffer == null) {
            dataLengthBuffer=null;
            dataLengthBuffer=ByteBuffer.allocate(4);
            byteBuf.readBytes(dataLengthBuffer);
            rpcHeaderBuffer=ByteBuffer.allocate(2);
          }
          byteBuf.readBytes(rpcHeaderBuffer);
          if (!rpcHeaderBuffer.hasArray() || rpcHeaderBuffer.remaining() > 0) {
            return;
          }
          int version=rpcHeaderBuffer.get(0);
          byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
          try {
            authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
            dataLengthBuffer.flip();
          }
 catch (          IOException ioe) {
            errorClass=ioe.getClass().getName();
            error=StringUtils.stringifyException(ioe);
          }
          if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
            LOG.warn("Incorrect header or version mismatch from " + address.getHostName() + ":"+ address.getPort()+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
            return;
          }
          dataLengthBuffer.clear();
          if (authMethod == null) {
            throw new RuntimeException("Unable to read authentication method");
          }
          rpcHeaderBuffer=null;
          rpcHeaderRead=true;
          continue;
        }
        if (data == null) {
          dataLengthBuffer.flip();
          int dataLength=dataLengthBuffer.getInt();
          if (dataLength < 0) {
            LOG.warn("Unexpected data length " + dataLength + "!! from "+ address.getHostName());
          }
          data=ByteBuffer.allocate(dataLength);
        }
        byteBuf.readBytes(data);
        if (data.remaining() == 0) {
          dataLengthBuffer.clear();
          data.flip();
          boolean isHeaderRead=headerRead;
          call=processOneRpc(data.array());
          data=null;
          if (!isHeaderRead) {
            continue;
          }
        }
      }
 catch (      OutOfMemoryError oome) {
        LOG.warn("Out of Memory in server select",oome);
        try {
          Thread.sleep(60000);
          errorClass=oome.getClass().getName();
          error=StringUtils.stringifyException(oome);
        }
 catch (        Exception ie) {
        }
      }
catch (      Exception e) {
        LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
      }
      sendResponse(ctx,call);
    }
  }
  finally {
    ReferenceCountUtil.release(msg);
  }
}

ID 67=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServerInboundHandler#channelRead(ChannelHandlerContext, java.lang.Object)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Process a recieved message from client. This method is called with the received message, whenever new data is received from a client.
 * @param ctx
 * @param cause
 */

catch: 
catch (Exception ie) {
}

block: 
NioServerInboundHandler
/** 
 * Process a recieved message from client. This method is called with the received message, whenever new data is received from a client.
 * @param ctx
 * @param cause
 */
@Override public void channelRead(ChannelHandlerContext ctx,Object msg){
  ByteBuffer dataLengthBuffer=ByteBuffer.allocate(4);
  ByteBuf byteBuf=(ByteBuf)msg;
  ByteBuffer data=null;
  ByteBuffer rpcHeaderBuffer=null;
  try {
    while (true) {
      Call call=null;
      errorClass=null;
      error=null;
      try {
        if (dataLengthBuffer.remaining() > 0 && byteBuf.isReadable()) {
          byteBuf.readBytes(dataLengthBuffer);
          if (dataLengthBuffer.remaining() > 0 && byteBuf.isReadable()) {
            return;
          }
        }
 else {
          return;
        }
        if (!rpcHeaderRead) {
          if (rpcHeaderBuffer == null) {
            dataLengthBuffer=null;
            dataLengthBuffer=ByteBuffer.allocate(4);
            byteBuf.readBytes(dataLengthBuffer);
            rpcHeaderBuffer=ByteBuffer.allocate(2);
          }
          byteBuf.readBytes(rpcHeaderBuffer);
          if (!rpcHeaderBuffer.hasArray() || rpcHeaderBuffer.remaining() > 0) {
            return;
          }
          int version=rpcHeaderBuffer.get(0);
          byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
          try {
            authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
            dataLengthBuffer.flip();
          }
 catch (          IOException ioe) {
            errorClass=ioe.getClass().getName();
            error=StringUtils.stringifyException(ioe);
          }
          if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
            LOG.warn("Incorrect header or version mismatch from " + address.getHostName() + ":"+ address.getPort()+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
            return;
          }
          dataLengthBuffer.clear();
          if (authMethod == null) {
            throw new RuntimeException("Unable to read authentication method");
          }
          rpcHeaderBuffer=null;
          rpcHeaderRead=true;
          continue;
        }
        if (data == null) {
          dataLengthBuffer.flip();
          int dataLength=dataLengthBuffer.getInt();
          if (dataLength < 0) {
            LOG.warn("Unexpected data length " + dataLength + "!! from "+ address.getHostName());
          }
          data=ByteBuffer.allocate(dataLength);
        }
        byteBuf.readBytes(data);
        if (data.remaining() == 0) {
          dataLengthBuffer.clear();
          data.flip();
          boolean isHeaderRead=headerRead;
          call=processOneRpc(data.array());
          data=null;
          if (!isHeaderRead) {
            continue;
          }
        }
      }
 catch (      OutOfMemoryError oome) {
        LOG.warn("Out of Memory in server select",oome);
        try {
          Thread.sleep(60000);
          errorClass=oome.getClass().getName();
          error=StringUtils.stringifyException(oome);
        }
 catch (        Exception ie) {
        }
      }
catch (      Exception e) {
        LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
      }
      sendResponse(ctx,call);
    }
  }
  finally {
    ReferenceCountUtil.release(msg);
  }
}

ID 68=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServerInboundHandler#sendResponse(ChannelHandlerContext, org.apache.hama.ipc.AsyncServer.Call)
Rmethod: org.apache.hama.ipc.AsyncServer#call(Class<?>, Writable, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Send response data to client
 * @param ctx
 * @param call
 */

catch: 
catch (Throwable e) {
  String logMsg=this.getClass().getName() + ", call " + call+ ": error: "+ e;
  if (e instanceof RuntimeException || e instanceof Error) {
    LOG.warn(logMsg,e);
  }
 else   if (exceptionsHandler.isTerse(e.getClass())) {
    LOG.info(logMsg);
  }
 else {
    LOG.info(logMsg,e);
  }
  errorClass=e.getClass().getName();
  error=StringUtils.stringifyException(e);
}

block: 
NioServerInboundHandler
/** 
 * Send response data to client
 * @param ctx
 * @param call
 */
private void sendResponse(ChannelHandlerContext ctx,Call call){
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  Writable value=null;
  try {
    value=call(protocol,call.param,call.timestamp);
  }
 catch (  Throwable e) {
    String logMsg=this.getClass().getName() + ", call " + call+ ": error: "+ e;
    if (e instanceof RuntimeException || e instanceof Error) {
      LOG.warn(logMsg,e);
    }
 else     if (exceptionsHandler.isTerse(e.getClass())) {
      LOG.info(logMsg);
    }
 else {
      LOG.info(logMsg,e);
    }
    errorClass=e.getClass().getName();
    error=StringUtils.stringifyException(e);
  }
  try {
    setupResponse(buf,call,(error == null) ? Status.SUCCESS : Status.ERROR,value,errorClass,error);
    if (buf.size() > maxRespSize) {
      LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
      buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
    }
    channelWrite(ctx,call.response);
  }
 catch (  Exception e) {
    LOG.info(this.getClass().getName() + " caught: " + StringUtils.stringifyException(e));
    error=null;
  }
 finally {
    IOUtils.closeStream(buf);
  }
}

ID 69=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServerInboundHandler#sendResponse(ChannelHandlerContext, org.apache.hama.ipc.AsyncServer.Call)
Rmethod: org.apache.hama.ipc.AsyncServer#setupResponse(java.io.ByteArrayOutputStream, org.apache.hama.ipc.AsyncServer.Call, Status, Writable, java.lang.String, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Send response data to client
 * @param ctx
 * @param call
 */

catch: 
catch (Exception e) {
  LOG.info(this.getClass().getName() + " caught: " + StringUtils.stringifyException(e));
  error=null;
}

block: 
NioServerInboundHandler
/** 
 * Send response data to client
 * @param ctx
 * @param call
 */
private void sendResponse(ChannelHandlerContext ctx,Call call){
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  Writable value=null;
  try {
    value=call(protocol,call.param,call.timestamp);
  }
 catch (  Throwable e) {
    String logMsg=this.getClass().getName() + ", call " + call+ ": error: "+ e;
    if (e instanceof RuntimeException || e instanceof Error) {
      LOG.warn(logMsg,e);
    }
 else     if (exceptionsHandler.isTerse(e.getClass())) {
      LOG.info(logMsg);
    }
 else {
      LOG.info(logMsg,e);
    }
    errorClass=e.getClass().getName();
    error=StringUtils.stringifyException(e);
  }
  try {
    setupResponse(buf,call,(error == null) ? Status.SUCCESS : Status.ERROR,value,errorClass,error);
    if (buf.size() > maxRespSize) {
      LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
      buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
    }
    channelWrite(ctx,call.response);
  }
 catch (  Exception e) {
    LOG.info(this.getClass().getName() + " caught: " + StringUtils.stringifyException(e));
    error=null;
  }
 finally {
    IOUtils.closeStream(buf);
  }
}

ID 70=========================================================================type: Rethrow
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServerInboundHandler#processHeader(byte[])
Rmethod: org.apache.hama.ipc.AsyncServer#getProtocolClass(java.lang.String, Configuration)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * Reads the connection header following version
 * @param buf buffer
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
NioServerInboundHandler
/** 
 * Reads the connection header following version
 * @param buf buffer
 */
private void processHeader(byte[] buf){
  DataInputStream in=new DataInputStream(new ByteArrayInputStream(buf));
  try {
    header.readFields(in);
    String protocolClassName=header.getProtocol();
    if (protocolClassName != null) {
      protocol=getProtocolClass(header.getProtocol(),conf);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
 finally {
    IOUtils.closeStream(in);
  }
  UserGroupInformation protocolUser=header.getUgi();
  user=protocolUser;
}

ID 71=========================================================================type: Rethrow
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.NioServerInboundHandler#processData(byte[])
Rmethod: java.io.DataInputStream#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Reads the received data, create call object;
 * @param buf buffer to serialize the response into
 * @return the IPC Call
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
NioServerInboundHandler
/** 
 * Reads the received data, create call object;
 * @param buf buffer to serialize the response into
 * @return the IPC Call
 */
private Call processData(byte[] buf){
  DataInputStream dis=new DataInputStream(new ByteArrayInputStream(buf));
  try {
    int id=dis.readInt();
    if (LOG.isDebugEnabled())     LOG.debug(" got #" + id);
    Writable param=ReflectionUtils.newInstance(paramClass,conf);
    param.readFields(dis);
    Call call=new Call(id,param,this);
    return call;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
 finally {
    IOUtils.closeStream(dis);
  }
}

ID 72=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.AsyncServer#setupResponse(java.io.ByteArrayOutputStream, org.apache.hama.ipc.AsyncServer.Call, Status, Writable, java.lang.String, java.lang.String)
Rmethod: java.io.DataOutputStream#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Setup response for the IPC Call.
 * @param response buffer to serialize the response into
 * @param call {@link Call} to which we are setting up the response
 * @param status {@link Status} of the IPC call
 * @param rv return value for the IPC Call, if the call was successful
 * @param errorClass error class, if the the call failed
 * @param error error message, if the call failed
 * @throws IOException
 */

catch: 
null
block: 
AsyncServer
/** 
 * Setup response for the IPC Call.
 * @param response buffer to serialize the response into
 * @param call {@link Call} to which we are setting up the response
 * @param status {@link Status} of the IPC call
 * @param rv return value for the IPC Call, if the call was successful
 * @param errorClass error class, if the the call failed
 * @param error error message, if the call failed
 * @throws IOException
 */
private void setupResponse(ByteArrayOutputStream response,Call call,Status status,Writable rv,String errorClass,String error) throws IOException {
  response.reset();
  DataOutputStream out=new DataOutputStream(response);
  out.writeInt(call.id);
  out.writeInt(status.state);
  if (status == Status.SUCCESS) {
    rv.write(out);
  }
 else {
    WritableUtils.writeString(out,errorClass);
    WritableUtils.writeString(out,error);
  }
  call.setResponse(ByteBuffer.wrap(response.toByteArray()));
  IOUtils.closeStream(out);
}

ID 73=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.AvroMessageManagerImpl#transfer(java.net.InetSocketAddress, BSPMessageBundle<M>)
Rmethod: org.apache.hama.bsp.message.AvroMessageManagerImpl#serializeMessage(BSPMessageBundle<M>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
AvroMessageManagerImpl
@Override public void transfer(InetSocketAddress addr,BSPMessageBundle<M> bundle) throws IOException {
  AvroBSPMessageBundle<M> msg=new AvroBSPMessageBundle<M>();
  msg.setData(serializeMessage(bundle));
  Sender<M> sender=getSender(addr);
  sender.transfer(msg);
}

ID 74=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.AvroMessageManagerImpl#transfer(java.net.InetSocketAddress, BSPMessageBundle<M>)
Rmethod: org.apache.hama.bsp.message.AvroMessageManagerImpl#getSender(java.net.InetSocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
AvroMessageManagerImpl
@Override public void transfer(InetSocketAddress addr,BSPMessageBundle<M> bundle) throws IOException {
  AvroBSPMessageBundle<M> msg=new AvroBSPMessageBundle<M>();
  msg.setData(serializeMessage(bundle));
  Sender<M> sender=getSender(addr);
  sender.transfer(msg);
}

ID 75=========================================================================type: Recover
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.AvroMessageManagerImpl#transfer(AvroBSPMessageBundle<M>)
Rmethod: org.apache.hama.bsp.message.AvroMessageManagerImpl#deserializeMessage(java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
AvroMessageManagerImpl
@Override public Void transfer(AvroBSPMessageBundle<M> messagebundle) throws AvroRemoteException {
  try {
    BSPMessageBundle<M> deserializeMessage=deserializeMessage(messagebundle.getData());
    this.put(deserializeMessage);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}

ID 76=========================================================================type: Recover
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.AvroMessageManagerImpl#transfer(AvroBSPMessageBundle<M>)
Rmethod: org.apache.hama.bsp.message.AvroMessageManagerImpl#put(BSPMessageBundle<M>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
AvroMessageManagerImpl
@Override public Void transfer(AvroBSPMessageBundle<M> messagebundle) throws AvroRemoteException {
  try {
    BSPMessageBundle<M> deserializeMessage=deserializeMessage(messagebundle.getData());
    this.put(deserializeMessage);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}

ID 77=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.AvroMessageManagerImpl#serializeMessage(BSPMessageBundle<M>)
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
AvroMessageManagerImpl
private final ByteBuffer serializeMessage(BSPMessageBundle<M> msg) throws IOException {
  if (compressor == null) {
    ByteArrayOutputStream outArray=new ByteArrayOutputStream();
    DataOutputStream out=new DataOutputStream(outArray);
    msg.write(out);
    out.close();
    byte[] byteArray=outArray.toByteArray();
    peer.incrementCounter(BSPPeerImpl.PeerCounter.MESSAGE_BYTES_TRANSFERED,byteArray.length);
    return ByteBuffer.wrap(byteArray);
  }
 else {
    BSPCompressedBundle compMsgBundle=compressor.compressBundle(msg);
    byte[] data=compMsgBundle.getData();
    peer.incrementCounter(BSPPeerImpl.PeerCounter.COMPRESSED_BYTES_SENT,data.length);
    return ByteBuffer.wrap(data);
  }
}

ID 78=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#BinaryProtocol(Configuration, java.io.OutputStream, java.io.InputStream)
Rmethod: org.apache.hama.pipes.protocol.TeeOutputStream#TeeOutputStream(java.lang.String, java.io.OutputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a proxy object that will speak the binary protocol on a socket. Upward messages are passed on the specified handler and downward downward messages are public methods on this object.
 * @param conf The job's configuration
 * @param out The output stream to communicate on.
 * @param in The input stream to communicate on.
 * @throws IOException
 */

catch: 
null
block: 
BinaryProtocol
/** 
 * Create a proxy object that will speak the binary protocol on a socket. Upward messages are passed on the specified handler and downward downward messages are public methods on this object.
 * @param conf The job's configuration
 * @param out The output stream to communicate on.
 * @param in The input stream to communicate on.
 * @throws IOException
 */
public BinaryProtocol(Configuration conf,OutputStream out,InputStream in) throws IOException {
  this.conf=conf;
  this.peer=null;
  if (Submitter.getKeepCommandFile(conf)) {
    out=new TeeOutputStream("downlink.data",out);
  }
  this.outStream=new DataOutputStream(new BufferedOutputStream(out,BUFFER_SIZE));
  this.uplink=new UplinkReader<K1,V1,K2,V2,M>(this,conf,in);
  this.uplink.setName("pipe-uplink-handler");
  this.uplink.start();
}

ID 79=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#BinaryProtocol(BSPPeer<K1,V1,K2,V2,M>, java.io.OutputStream, java.io.InputStream)
Rmethod: org.apache.hama.pipes.protocol.TeeOutputStream#TeeOutputStream(java.lang.String, java.io.OutputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a proxy object that will speak the binary protocol on a socket. Upward messages are passed on the specified handler and downward downward messages are public methods on this object.
 * @param peer the current peer including the task's configuration
 * @param out The output stream to communicate on.
 * @param in The input stream to communicate on.
 * @throws IOException
 */

catch: 
null
block: 
BinaryProtocol
/** 
 * Create a proxy object that will speak the binary protocol on a socket. Upward messages are passed on the specified handler and downward downward messages are public methods on this object.
 * @param peer the current peer including the task's configuration
 * @param out The output stream to communicate on.
 * @param in The input stream to communicate on.
 * @throws IOException
 */
public BinaryProtocol(BSPPeer<K1,V1,K2,V2,M> peer,OutputStream out,InputStream in) throws IOException {
  this.peer=peer;
  this.conf=peer.getConfiguration();
  if (Submitter.getKeepCommandFile(conf)) {
    out=new TeeOutputStream("downlink.data",out);
  }
  this.outStream=new DataOutputStream(new BufferedOutputStream(out,BUFFER_SIZE));
  this.uplink=getUplinkReader(peer,in);
  this.uplink.setName("pipe-uplink-handler");
  this.uplink.start();
}

ID 80=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#BinaryProtocol(BSPPeer<K1,V1,K2,V2,M>, java.io.OutputStream, java.io.InputStream)
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#getUplinkReader(BSPPeer<K1,V1,K2,V2,M>, java.io.InputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a proxy object that will speak the binary protocol on a socket. Upward messages are passed on the specified handler and downward downward messages are public methods on this object.
 * @param peer the current peer including the task's configuration
 * @param out The output stream to communicate on.
 * @param in The input stream to communicate on.
 * @throws IOException
 */

catch: 
null
block: 
BinaryProtocol
/** 
 * Create a proxy object that will speak the binary protocol on a socket. Upward messages are passed on the specified handler and downward downward messages are public methods on this object.
 * @param peer the current peer including the task's configuration
 * @param out The output stream to communicate on.
 * @param in The input stream to communicate on.
 * @throws IOException
 */
public BinaryProtocol(BSPPeer<K1,V1,K2,V2,M> peer,OutputStream out,InputStream in) throws IOException {
  this.peer=peer;
  this.conf=peer.getConfiguration();
  if (Submitter.getKeepCommandFile(conf)) {
    out=new TeeOutputStream("downlink.data",out);
  }
  this.outStream=new DataOutputStream(new BufferedOutputStream(out,BUFFER_SIZE));
  this.uplink=getUplinkReader(peer,in);
  this.uplink.setName("pipe-uplink-handler");
  this.uplink.start();
}

ID 81=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.TeeOutputStream#TeeOutputStream(java.lang.String, java.io.OutputStream)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TeeOutputStream
TeeOutputStream(String filename,OutputStream base) throws IOException {
  super(base);
  file=new FileOutputStream(filename);
}

ID 82=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.TeeOutputStream#write(byte[], int, int)
Rmethod: java.io.OutputStream#write(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TeeOutputStream
@Override public void write(byte b[],int off,int len) throws IOException {
  file.write(b,off,len);
  out.write(b,off,len);
}

ID 83=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.TeeOutputStream#write(int)
Rmethod: java.io.OutputStream#write(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TeeOutputStream
@Override public void write(int b) throws IOException {
  file.write(b);
  out.write(b);
}

ID 84=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.TeeOutputStream#flush()
Rmethod: java.io.OutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TeeOutputStream
@Override public void flush() throws IOException {
  file.flush();
  out.flush();
}

ID 85=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.TeeOutputStream#close()
Rmethod: org.apache.hama.pipes.protocol.TeeOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TeeOutputStream
@Override public void close() throws IOException {
  flush();
  file.close();
  out.close();
}

ID 86=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.TeeOutputStream#close()
Rmethod: java.io.OutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TeeOutputStream
@Override public void close() throws IOException {
  flush();
  file.close();
  out.close();
}

ID 87=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#start()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void start() throws IOException {
  LOG.debug("starting downlink");
  WritableUtils.writeVInt(this.outStream,MessageType.START.code);
  WritableUtils.writeVInt(this.outStream,CURRENT_PROTOCOL_VERSION);
  flush();
  LOG.debug("Sent MessageType.START");
  setBSPJobConf(conf);
}

ID 88=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#start()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#setBSPJobConf(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void start() throws IOException {
  LOG.debug("starting downlink");
  WritableUtils.writeVInt(this.outStream,MessageType.START.code);
  WritableUtils.writeVInt(this.outStream,CURRENT_PROTOCOL_VERSION);
  flush();
  LOG.debug("Sent MessageType.START");
  setBSPJobConf(conf);
}

ID 89=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#setBSPJobConf(Configuration)
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void setBSPJobConf(Configuration conf) throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.SET_BSPJOB_CONF.code);
  List<Entry<String,String>> list=new ArrayList<Entry<String,String>>();
  for (  Entry<String,String> entry : conf) {
    list.add(entry);
  }
  WritableUtils.writeVInt(this.outStream,list.size());
  for (  Entry<String,String> entry : list) {
    Text.writeString(this.outStream,entry.getKey());
    Text.writeString(this.outStream,entry.getValue());
  }
  flush();
  LOG.debug("Sent MessageType.SET_BSPJOB_CONF including " + list.size() + " entries.");
}

ID 90=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#setInputTypes(java.lang.String, java.lang.String)
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void setInputTypes(String keyType,String valueType) throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.SET_INPUT_TYPES.code);
  Text.writeString(this.outStream,keyType);
  Text.writeString(this.outStream,valueType);
  flush();
  LOG.debug("Sent MessageType.SET_INPUT_TYPES");
}

ID 91=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#runSetup()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void runSetup() throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.RUN_SETUP.code);
  flush();
  setHasTask(true);
  LOG.debug("Sent MessageType.RUN_SETUP");
}

ID 92=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#runBsp()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void runBsp() throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.RUN_BSP.code);
  flush();
  setHasTask(true);
  LOG.debug("Sent MessageType.RUN_BSP");
}

ID 93=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#runCleanup()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void runCleanup() throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.RUN_CLEANUP.code);
  flush();
  setHasTask(true);
  LOG.debug("Sent MessageType.RUN_CLEANUP");
}

ID 94=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#getPartition(K1, V1, int)
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#writeObject(Writable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public int getPartition(K1 key,V1 value,int numTasks) throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.PARTITION_REQUEST.code);
  writeObject((Writable)key);
  writeObject((Writable)value);
  WritableUtils.writeVInt(this.outStream,numTasks);
  flush();
  LOG.debug("Sent MessageType.PARTITION_REQUEST - key: " + ((key.toString().length() < 10) ? key.toString() : key.toString().substring(0,9) + "...") + " value: "+ ((value.toString().length() < 10) ? value.toString() : value.toString().substring(0,9) + "...")+ " numTasks: "+ numTasks);
  int resultVal=0;
synchronized (this.resultLock) {
    try {
      while (resultInt == null) {
        this.resultLock.wait();
      }
      resultVal=resultInt;
      resultInt=null;
    }
 catch (    InterruptedException e) {
      LOG.error(e);
    }
  }
  return resultVal;
}

ID 95=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#getPartition(K1, V1, int)
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public int getPartition(K1 key,V1 value,int numTasks) throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.PARTITION_REQUEST.code);
  writeObject((Writable)key);
  writeObject((Writable)value);
  WritableUtils.writeVInt(this.outStream,numTasks);
  flush();
  LOG.debug("Sent MessageType.PARTITION_REQUEST - key: " + ((key.toString().length() < 10) ? key.toString() : key.toString().substring(0,9) + "...") + " value: "+ ((value.toString().length() < 10) ? value.toString() : value.toString().substring(0,9) + "...")+ " numTasks: "+ numTasks);
  int resultVal=0;
synchronized (this.resultLock) {
    try {
      while (resultInt == null) {
        this.resultLock.wait();
      }
      resultVal=resultInt;
      resultInt=null;
    }
 catch (    InterruptedException e) {
      LOG.error(e);
    }
  }
  return resultVal;
}

ID 96=========================================================================type: Ignore_Log
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#getPartition(K1, V1, int)
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.error(e);
}

block: 
BinaryProtocol
@Override public int getPartition(K1 key,V1 value,int numTasks) throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.PARTITION_REQUEST.code);
  writeObject((Writable)key);
  writeObject((Writable)value);
  WritableUtils.writeVInt(this.outStream,numTasks);
  flush();
  LOG.debug("Sent MessageType.PARTITION_REQUEST - key: " + ((key.toString().length() < 10) ? key.toString() : key.toString().substring(0,9) + "...") + " value: "+ ((value.toString().length() < 10) ? value.toString() : value.toString().substring(0,9) + "...")+ " numTasks: "+ numTasks);
  int resultVal=0;
synchronized (this.resultLock) {
    try {
      while (resultInt == null) {
        this.resultLock.wait();
      }
      resultVal=resultInt;
      resultInt=null;
    }
 catch (    InterruptedException e) {
      LOG.error(e);
    }
  }
  return resultVal;
}

ID 97=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#abort()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void abort() throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.ABORT.code);
  flush();
  LOG.debug("Sent MessageType.ABORT");
}

ID 98=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#flush()
Rmethod: java.io.DataOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public void flush() throws IOException {
  this.outStream.flush();
}

ID 99=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#close()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#endOfInput()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Close the connection and shutdown the handler thread.
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BinaryProtocol
/** 
 * Close the connection and shutdown the handler thread.
 * @throws IOException
 * @throws InterruptedException
 */
@Override public void close() throws IOException, InterruptedException {
  LOG.debug("closing connection");
  boolean streamingEnabled=conf.getBoolean("hama.streaming.enabled",false);
  if (!streamingEnabled) {
    endOfInput();
  }
  this.uplink.interrupt();
  this.uplink.join();
  this.uplink.closeConnection();
  this.outStream.close();
}

ID 100=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#close()
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Close the connection and shutdown the handler thread.
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BinaryProtocol
/** 
 * Close the connection and shutdown the handler thread.
 * @throws IOException
 * @throws InterruptedException
 */
@Override public void close() throws IOException, InterruptedException {
  LOG.debug("closing connection");
  boolean streamingEnabled=conf.getBoolean("hama.streaming.enabled",false);
  if (!streamingEnabled) {
    endOfInput();
  }
  this.uplink.interrupt();
  this.uplink.join();
  this.uplink.closeConnection();
  this.outStream.close();
}

ID 101=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#waitForFinish()
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
@Override public boolean waitForFinish() throws IOException, InterruptedException {
synchronized (this.hasTaskLock) {
    while (this.hasTask) {
      this.hasTaskLock.wait();
    }
    if (uplinkException != null) {
      throw new InterruptedException(StringUtils.stringifyException(uplinkException));
    }
  }
  return hasTask;
}

ID 102=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#endOfInput()
Rmethod: org.apache.hama.pipes.protocol.BinaryProtocol#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BinaryProtocol
public void endOfInput() throws IOException {
  WritableUtils.writeVInt(this.outStream,MessageType.CLOSE.code);
  flush();
  LOG.debug("Sent close command");
  LOG.debug("Sent MessageType.CLOSE");
}

ID 103=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.BinaryProtocol#writeObject(Writable)
Rmethod: java.io.DataOutputStream#write(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write the given object to the stream. If it is a IntWritable, LongWritable, FloatWritable, DoubleWritable, Text or BytesWritable, write it directly. Otherwise, write it to a buffer and then write the length and data to the stream.
 * @param obj the object to write
 * @throws IOException
 */

catch: 
null
block: 
BinaryProtocol
/** 
 * Write the given object to the stream. If it is a IntWritable, LongWritable, FloatWritable, DoubleWritable, Text or BytesWritable, write it directly. Otherwise, write it to a buffer and then write the length and data to the stream.
 * @param obj the object to write
 * @throws IOException
 */
protected void writeObject(Writable obj) throws IOException {
  if (obj instanceof Text) {
    Text t=(Text)obj;
    int len=t.getLength();
    WritableUtils.writeVInt(this.outStream,len);
    this.outStream.write(t.getBytes(),0,len);
  }
 else   if (obj instanceof BytesWritable) {
    BytesWritable b=(BytesWritable)obj;
    int len=b.getLength();
    WritableUtils.writeVInt(this.outStream,len);
    this.outStream.write(b.getBytes(),0,len);
  }
 else   if (obj instanceof IntWritable) {
    WritableUtils.writeVInt(this.outStream,((IntWritable)obj).get());
  }
 else   if (obj instanceof LongWritable) {
    WritableUtils.writeVLong(this.outStream,((LongWritable)obj).get());
  }
 else {
    obj.write(this.outStream);
  }
}

ID 104=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.BipartiteMatching#createJob(java.lang.String[], HamaConfiguration)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BipartiteMatching
public static GraphJob createJob(String[] args,HamaConfiguration conf) throws IOException {
  GraphJob job=new GraphJob(conf,BipartiteMatching.class);
  job.setMaxIteration(30);
  job.setNumBspTask(2);
  if (args.length >= 4)   job.setNumBspTask(Integer.parseInt(args[3]));
  if (args.length >= 3)   job.setMaxIteration(Integer.parseInt(args[2]));
  job.setJobName("BipartiteMatching");
  job.setInputPath(new Path(args[0]));
  job.setOutputPath(new Path(args[1]));
  job.setVertexClass(BipartiteMatchingVertex.class);
  job.setVertexIDClass(Text.class);
  job.setVertexValueClass(TextPair.class);
  job.setEdgeValueClass(NullWritable.class);
  job.setInputFormat(TextInputFormat.class);
  job.setInputKeyClass(LongWritable.class);
  job.setInputValueClass(Text.class);
  job.setVertexInputReaderClass(BipartiteMatchingVertexReader.class);
  job.setPartitioner(HashPartitioner.class);
  job.setOutputFormat(TextOutputFormat.class);
  job.setOutputKeyClass(Text.class);
  job.setOutputValueClass(TextPair.class);
  return job;
}

ID 105=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.BipartiteMatching#main(java.lang.String[])
Rmethod: org.apache.hama.examples.BipartiteMatching#createJob(java.lang.String[], HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BipartiteMatching
public static void main(String... args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length < 2) {
    printUsage();
  }
  HamaConfiguration conf=new HamaConfiguration(new Configuration());
  GraphJob job=createJob(args,conf);
  long startTime=System.currentTimeMillis();
  if (job.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 106=========================================================================type: Recover
package: org.apache.hama.examples
Method:org.apache.hama.examples.BipartiteMatchingTest#generateTestData()
Rmethod: java.io.FileWriter#FileWriter(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
BipartiteMatchingTest
private void generateTestData(){
  FileWriter fout=null;
  BufferedWriter bout=null;
  PrintWriter pout=null;
  try {
    fout=new FileWriter(INPUT);
    bout=new BufferedWriter(fout);
    pout=new PrintWriter(bout);
    for (    String line : input) {
      pout.println(line);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (pout != null) {
        pout.close();
      }
      if (bout != null) {
        bout.close();
      }
      if (fout != null) {
        fout.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}

ID 107=========================================================================type: Recover
package: org.apache.hama.examples
Method:org.apache.hama.examples.BipartiteMatchingTest#generateTestData()
Rmethod: java.io.BufferedWriter#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
BipartiteMatchingTest
private void generateTestData(){
  FileWriter fout=null;
  BufferedWriter bout=null;
  PrintWriter pout=null;
  try {
    fout=new FileWriter(INPUT);
    bout=new BufferedWriter(fout);
    pout=new PrintWriter(bout);
    for (    String line : input) {
      pout.println(line);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (pout != null) {
        pout.close();
      }
      if (bout != null) {
        bout.close();
      }
      if (fout != null) {
        fout.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}

ID 108=========================================================================type: Recover
package: org.apache.hama.examples
Method:org.apache.hama.examples.BipartiteMatchingTest#generateTestData()
Rmethod: java.io.OutputStreamWriter#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
BipartiteMatchingTest
private void generateTestData(){
  FileWriter fout=null;
  BufferedWriter bout=null;
  PrintWriter pout=null;
  try {
    fout=new FileWriter(INPUT);
    bout=new BufferedWriter(fout);
    pout=new PrintWriter(bout);
    for (    String line : input) {
      pout.println(line);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (pout != null) {
        pout.close();
      }
      if (bout != null) {
        bout.close();
      }
      if (fout != null) {
        fout.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}

ID 109=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.BipartiteMatchingTest#verifyResult()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BipartiteMatchingTest
private void verifyResult() throws IOException {
  FileStatus[] files=fs.globStatus(new Path(OUTPUT + "/part-*"));
  assertTrue("Not enough files found: " + files.length,files.length == 1);
  for (  FileStatus file : files) {
    if (file.getLen() > 0) {
      FSDataInputStream in=fs.open(file.getPath());
      BufferedReader bin=new BufferedReader(new InputStreamReader(in));
      String s=null;
      while ((s=bin.readLine()) != null) {
        String[] lineA=s.split(DELIMETER);
        String expValue=output1.get(lineA[0]);
        assertNotNull(expValue);
        System.out.println(lineA[0] + " -> " + lineA[1]+ " expvalue = "+ expValue);
        assertEquals(expValue,lineA[1]);
      }
      in.close();
    }
  }
}

ID 110=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#BSPJob(HamaConfiguration, java.lang.String)
Rmethod: org.apache.hama.bsp.BSPJob#setJobName(java.lang.String)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public BSPJob(HamaConfiguration conf,String jobName) throws IOException {
  this(conf);
  setJobName(jobName);
}

ID 111=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#setBspClass(Class<? extends BSP>)
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: /** 
 * Set the BSP algorithm class for the job.
 * @param cls the class implementing the BSP job
 * @throws IllegalStateException
 */

catch: 
null
block: 
BSPJob
/** 
 * Set the BSP algorithm class for the job.
 * @param cls the class implementing the BSP job
 * @throws IllegalStateException
 */
@SuppressWarnings("rawtypes") public void setBspClass(Class<? extends BSP> cls) throws IllegalStateException {
  ensureState(JobState.DEFINE);
  conf.setClass(WORK_CLASS_ATTR,cls,BSP.class);
}

ID 112=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#findContainingJar(Class<?>)
Rmethod: java.lang.ClassLoader#getResources(java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  throw new RuntimeException(e);
}

block: 
BSPJob
private static String findContainingJar(Class<?> my_class){
  ClassLoader loader=my_class.getClassLoader();
  String class_file=my_class.getName().replaceAll("\\.","/") + ".class";
  try {
    for (Enumeration<URL> itr=loader.getResources(class_file); itr.hasMoreElements(); ) {
      URL url=itr.nextElement();
      if ("jar".equals(url.getProtocol())) {
        String toReturn=url.getPath();
        if (toReturn.startsWith("file:")) {
          toReturn=toReturn.substring("file:".length());
        }
        toReturn=URLDecoder.decode(toReturn,"UTF-8");
        return toReturn.replaceAll("!.*$","");
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return null;
}

ID 113=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#findContainingJar(Class<?>)
Rmethod: java.net.URLDecoder#decode(java.lang.String, java.lang.String)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.io.UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

method comment: null
catch: 
catch (IOException e) {
  throw new RuntimeException(e);
}

block: 
BSPJob
private static String findContainingJar(Class<?> my_class){
  ClassLoader loader=my_class.getClassLoader();
  String class_file=my_class.getName().replaceAll("\\.","/") + ".class";
  try {
    for (Enumeration<URL> itr=loader.getResources(class_file); itr.hasMoreElements(); ) {
      URL url=itr.nextElement();
      if ("jar".equals(url.getProtocol())) {
        String toReturn=url.getPath();
        if (toReturn.startsWith("file:")) {
          toReturn=toReturn.substring("file:".length());
        }
        toReturn=URLDecoder.decode(toReturn,"UTF-8");
        return toReturn.replaceAll("!.*$","");
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return null;
}

ID 114=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#setJobName(java.lang.String)
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public void setJobName(String name) throws IllegalStateException {
  ensureState(JobState.DEFINE);
  conf.set("bsp.job.name",name);
}

ID 115=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#progress()
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public long progress() throws IOException {
  ensureState(JobState.RUNNING);
  return info.progress();
}

ID 116=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#getCounters()
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public Counters getCounters() throws IOException {
  ensureState(JobState.RUNNING);
  return info.getCounters();
}

ID 117=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#isComplete()
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public boolean isComplete() throws IOException {
  ensureState(JobState.RUNNING);
  return info.isComplete();
}

ID 118=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#isSuccessful()
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public boolean isSuccessful() throws IOException {
  ensureState(JobState.RUNNING);
  return info.isSuccessful();
}

ID 119=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#killJob()
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public void killJob() throws IOException {
  ensureState(JobState.RUNNING);
  info.killJob();
}

ID 120=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#killTask(TaskAttemptID)
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public void killTask(TaskAttemptID taskId) throws IOException {
  ensureState(JobState.RUNNING);
  info.killTask(taskId,false);
}

ID 121=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#failTask(TaskAttemptID)
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public void failTask(TaskAttemptID taskId) throws IOException {
  ensureState(JobState.RUNNING);
  info.killTask(taskId,true);
}

ID 122=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#submit()
Rmethod: org.apache.hama.bsp.BSPJob#ensureState(org.apache.hama.bsp.BSPJob.JobState)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
BSPJob
public void submit() throws IOException, InterruptedException {
  ensureState(JobState.DEFINE);
  info=jobClient.submitJob(this);
  state=JobState.RUNNING;
}

ID 123=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#waitForCompletion(boolean)
Rmethod: org.apache.hama.bsp.BSPJob#submit()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJob
public boolean waitForCompletion(boolean verbose) throws IOException, InterruptedException, ClassNotFoundException {
  if (state == JobState.DEFINE) {
    submit();
  }
  if (verbose) {
    jobClient.monitorAndPrintJob(this,info);
  }
 else {
    info.waitForCompletion();
  }
  return isSuccessful();
}

ID 124=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#waitForCompletion(boolean)
Rmethod: org.apache.hama.bsp.BSPJob#submit()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJob
public boolean waitForCompletion(boolean verbose) throws IOException, InterruptedException, ClassNotFoundException {
  if (state == JobState.DEFINE) {
    submit();
  }
  if (verbose) {
    jobClient.monitorAndPrintJob(this,info);
  }
 else {
    info.waitForCompletion();
  }
  return isSuccessful();
}

ID 125=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJob#waitForCompletion(boolean)
Rmethod: org.apache.hama.bsp.BSPJob#isSuccessful()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJob
public boolean waitForCompletion(boolean verbose) throws IOException, InterruptedException, ClassNotFoundException {
  if (state == JobState.DEFINE) {
    submit();
  }
  if (verbose) {
    jobClient.monitorAndPrintJob(this,info);
  }
 else {
    info.waitForCompletion();
  }
  return isSuccessful();
}

ID 126=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#ensureFreshStatus()
Rmethod: org.apache.hama.bsp.NetworkedJob#updateStatus()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Some methods rely on having a recent job profile object. Refresh it, if necessary
 */

catch: 
null
block: 
NetworkedJob
/** 
 * Some methods rely on having a recent job profile object. Refresh it, if necessary
 */
synchronized void ensureFreshStatus() throws IOException {
  if (System.currentTimeMillis() - statustime > MAX_JOBPROFILE_AGE) {
    updateStatus();
  }
}

ID 127=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#progress()
Rmethod: org.apache.hama.bsp.NetworkedJob#ensureFreshStatus()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
NetworkedJob
@Override public long progress() throws IOException {
  ensureFreshStatus();
  return status.progress();
}

ID 128=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#isComplete()
Rmethod: org.apache.hama.bsp.NetworkedJob#updateStatus()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Returns immediately whether the whole job is done yet or not.
 */

catch: 
null
block: 
NetworkedJob
/** 
 * Returns immediately whether the whole job is done yet or not.
 */
@Override public synchronized boolean isComplete() throws IOException {
  updateStatus();
  return (status.getRunState() == JobStatus.SUCCEEDED || status.getRunState() == JobStatus.FAILED || status.getRunState() == JobStatus.KILLED);
}

ID 129=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#isSuccessful()
Rmethod: org.apache.hama.bsp.NetworkedJob#updateStatus()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * True if job completed successfully.
 */

catch: 
null
block: 
NetworkedJob
/** 
 * True if job completed successfully.
 */
@Override public synchronized boolean isSuccessful() throws IOException {
  updateStatus();
  return status.getRunState() == JobStatus.SUCCEEDED;
}

ID 130=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#getSuperstepCount()
Rmethod: org.apache.hama.bsp.NetworkedJob#ensureFreshStatus()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
NetworkedJob
@Override public synchronized long getSuperstepCount() throws IOException {
  ensureFreshStatus();
  return status.getSuperstepCount();
}

ID 131=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#waitForCompletion()
Rmethod: org.apache.hama.bsp.NetworkedJob#isComplete()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Blocks until the job is finished
 */

catch: 
null
block: 
NetworkedJob
/** 
 * Blocks until the job is finished
 */
@Override public void waitForCompletion() throws IOException {
  while (!isComplete()) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException ie) {
    }
  }
}

ID 132=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#waitForCompletion()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Blocks until the job is finished
 */

catch: 
catch (InterruptedException ie) {
}

block: 
NetworkedJob
/** 
 * Blocks until the job is finished
 */
@Override public void waitForCompletion() throws IOException {
  while (!isComplete()) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException ie) {
    }
  }
}

ID 133=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.NetworkedJob#getJobState()
Rmethod: org.apache.hama.bsp.NetworkedJob#updateStatus()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Tells the service to get the state of the current job.
 */

catch: 
null
block: 
NetworkedJob
/** 
 * Tells the service to get the state of the current job.
 */
@Override public synchronized int getJobState() throws IOException {
  updateStatus();
  return status.getRunState();
}

ID 134=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#BSPJobClient(Configuration)
Rmethod: org.apache.hama.bsp.BSPJobClient#init(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public BSPJobClient(Configuration conf) throws IOException {
  setConf(conf);
  init(conf);
}

ID 135=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJob(BSPJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Submit a job to the BSP system. This returns a handle to the {@link RunningJob} which can be used to track the running-job.
 * @param job the job configuration.
 * @return a handle to the {@link RunningJob} which can be used to track therunning-job.
 * @throws FileNotFoundException
 * @throws IOException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Submit a job to the BSP system. This returns a handle to the {@link RunningJob} which can be used to track the running-job.
 * @param job the job configuration.
 * @return a handle to the {@link RunningJob} which can be used to track therunning-job.
 * @throws FileNotFoundException
 * @throws IOException
 */
public RunningJob submitJob(BSPJob job) throws FileNotFoundException, IOException {
  return submitJobInternal(job,jobSubmitClient.getNewJobId());
}

ID 136=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
Rmethod: org.apache.hama.bsp.BSPJobClient#getClusterStatus(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public RunningJob submitJobInternal(BSPJob pJob,BSPJobID jobId) throws IOException {
  BSPJob job=pJob;
  job.setJobID(jobId);
  int maxTasks;
  int configured=job.getConfiguration().getInt(Constants.MAX_TASKS_PER_JOB,job.getNumBspTask());
  ClusterStatus clusterStatus=getClusterStatus(true);
  if (clusterStatus != null) {
    maxTasks=clusterStatus.getMaxTasks() - clusterStatus.getTasks();
    if (configured > maxTasks) {
      LOG.warn("The configured number of tasks has exceeded the maximum allowed. Job will run with " + (maxTasks) + " tasks.");
      job.setNumBspTask(maxTasks);
    }
  }
 else {
    maxTasks=configured;
  }
  Path submitJobDir=new Path(getSystemDir(),"submit_" + Integer.toString(Math.abs(r.nextInt()),36));
  Path submitSplitFile=new Path(submitJobDir,"job.split");
  Path submitJarFile=new Path(submitJobDir,"job.jar");
  Path submitJobFile=new Path(submitJobDir,"job.xml");
  LOG.debug("BSPJobClient.submitJobDir: " + submitJobDir);
  FileSystem fs=getFs();
  fs.delete(submitJobDir,true);
  submitJobDir=fs.makeQualified(submitJobDir);
  submitJobDir=new Path(submitJobDir.toUri().getPath());
  FsPermission bspSysPerms=new FsPermission(JOB_DIR_PERMISSION);
  FileSystem.mkdirs(fs,submitJobDir,bspSysPerms);
  fs.mkdirs(submitJobDir);
  short replication=(short)job.getInt("bsp.submit.replication",10);
  if ((job.get(Constants.JOB_INPUT_DIR) != null) || (job.get("bsp.join.expr") != null)) {
    LOG.debug("Creating splits at " + fs.makeQualified(submitSplitFile));
    InputSplit[] splits=job.getInputFormat().getSplits(job,(maxTasks > configured) ? configured : maxTasks);
    if (job.getConfiguration().getBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false)) {
      LOG.info("Run pre-partitioning job");
      job=partition(job,splits,maxTasks);
      maxTasks=job.getInt("hama.partition.count",maxTasks);
    }
    if (job.getBoolean("input.has.partitioned",false)) {
      splits=job.getInputFormat().getSplits(job,maxTasks);
    }
    int additionalTasks=job.getConfiguration().getInt(Constants.ADDITIONAL_BSP_TASKS,0);
    if (maxTasks < splits.length + additionalTasks) {
      throw new IOException("Job failed! The number of splits has exceeded the number of max tasks. The number of splits: " + splits.length + ", The number of additional tasks: "+ +additionalTasks+ ", The number of max tasks: "+ maxTasks);
    }
    int numOfSplits=writeSplits(job,splits,submitSplitFile,maxTasks);
    if (numOfSplits > configured || !job.getConfiguration().getBoolean(Constants.FORCE_SET_BSP_TASKS,false)) {
      job.setNumBspTask(numOfSplits + additionalTasks);
    }
    job.set("bsp.job.split.file",submitSplitFile.toString());
  }
  String originalJarPath=job.getJar();
  if (originalJarPath != null) {
    if ("".equals(job.getJobName())) {
      job.setJobName(new Path(originalJarPath).getName());
    }
    job.setJar(submitJarFile.toString());
    fs.copyFromLocalFile(new Path(originalJarPath),submitJarFile);
    fs.setReplication(submitJarFile,replication);
    fs.setPermission(submitJarFile,new FsPermission(JOB_FILE_PERMISSION));
  }
 else {
    LOG.warn("No job jar file set.  User classes may not be found. " + "See BSPJob#setJar(String) or check Your jar file.");
  }
  job.setUser(getUnixUserName());
  job.set("group.name",getUnixUserGroupName(job.getUser()));
  if (job.getWorkingDirectory() == null) {
    job.setWorkingDirectory(fs.getWorkingDirectory());
  }
  FSDataOutputStream out=FileSystem.create(fs,submitJobFile,new FsPermission(JOB_FILE_PERMISSION));
  try {
    job.writeXml(out);
  }
  finally {
    out.close();
  }
  return launchJob(jobId,job,submitJobFile,fs);
}

ID 137=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
Rmethod: org.apache.hama.bsp.BSPJobClient#getFs()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public RunningJob submitJobInternal(BSPJob pJob,BSPJobID jobId) throws IOException {
  BSPJob job=pJob;
  job.setJobID(jobId);
  int maxTasks;
  int configured=job.getConfiguration().getInt(Constants.MAX_TASKS_PER_JOB,job.getNumBspTask());
  ClusterStatus clusterStatus=getClusterStatus(true);
  if (clusterStatus != null) {
    maxTasks=clusterStatus.getMaxTasks() - clusterStatus.getTasks();
    if (configured > maxTasks) {
      LOG.warn("The configured number of tasks has exceeded the maximum allowed. Job will run with " + (maxTasks) + " tasks.");
      job.setNumBspTask(maxTasks);
    }
  }
 else {
    maxTasks=configured;
  }
  Path submitJobDir=new Path(getSystemDir(),"submit_" + Integer.toString(Math.abs(r.nextInt()),36));
  Path submitSplitFile=new Path(submitJobDir,"job.split");
  Path submitJarFile=new Path(submitJobDir,"job.jar");
  Path submitJobFile=new Path(submitJobDir,"job.xml");
  LOG.debug("BSPJobClient.submitJobDir: " + submitJobDir);
  FileSystem fs=getFs();
  fs.delete(submitJobDir,true);
  submitJobDir=fs.makeQualified(submitJobDir);
  submitJobDir=new Path(submitJobDir.toUri().getPath());
  FsPermission bspSysPerms=new FsPermission(JOB_DIR_PERMISSION);
  FileSystem.mkdirs(fs,submitJobDir,bspSysPerms);
  fs.mkdirs(submitJobDir);
  short replication=(short)job.getInt("bsp.submit.replication",10);
  if ((job.get(Constants.JOB_INPUT_DIR) != null) || (job.get("bsp.join.expr") != null)) {
    LOG.debug("Creating splits at " + fs.makeQualified(submitSplitFile));
    InputSplit[] splits=job.getInputFormat().getSplits(job,(maxTasks > configured) ? configured : maxTasks);
    if (job.getConfiguration().getBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false)) {
      LOG.info("Run pre-partitioning job");
      job=partition(job,splits,maxTasks);
      maxTasks=job.getInt("hama.partition.count",maxTasks);
    }
    if (job.getBoolean("input.has.partitioned",false)) {
      splits=job.getInputFormat().getSplits(job,maxTasks);
    }
    int additionalTasks=job.getConfiguration().getInt(Constants.ADDITIONAL_BSP_TASKS,0);
    if (maxTasks < splits.length + additionalTasks) {
      throw new IOException("Job failed! The number of splits has exceeded the number of max tasks. The number of splits: " + splits.length + ", The number of additional tasks: "+ +additionalTasks+ ", The number of max tasks: "+ maxTasks);
    }
    int numOfSplits=writeSplits(job,splits,submitSplitFile,maxTasks);
    if (numOfSplits > configured || !job.getConfiguration().getBoolean(Constants.FORCE_SET_BSP_TASKS,false)) {
      job.setNumBspTask(numOfSplits + additionalTasks);
    }
    job.set("bsp.job.split.file",submitSplitFile.toString());
  }
  String originalJarPath=job.getJar();
  if (originalJarPath != null) {
    if ("".equals(job.getJobName())) {
      job.setJobName(new Path(originalJarPath).getName());
    }
    job.setJar(submitJarFile.toString());
    fs.copyFromLocalFile(new Path(originalJarPath),submitJarFile);
    fs.setReplication(submitJarFile,replication);
    fs.setPermission(submitJarFile,new FsPermission(JOB_FILE_PERMISSION));
  }
 else {
    LOG.warn("No job jar file set.  User classes may not be found. " + "See BSPJob#setJar(String) or check Your jar file.");
  }
  job.setUser(getUnixUserName());
  job.set("group.name",getUnixUserGroupName(job.getUser()));
  if (job.getWorkingDirectory() == null) {
    job.setWorkingDirectory(fs.getWorkingDirectory());
  }
  FSDataOutputStream out=FileSystem.create(fs,submitJobFile,new FsPermission(JOB_FILE_PERMISSION));
  try {
    job.writeXml(out);
  }
  finally {
    out.close();
  }
  return launchJob(jobId,job,submitJobFile,fs);
}

ID 138=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
Rmethod: org.apache.hama.bsp.BSPJobClient#partition(BSPJob, InputSplit[], int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public RunningJob submitJobInternal(BSPJob pJob,BSPJobID jobId) throws IOException {
  BSPJob job=pJob;
  job.setJobID(jobId);
  int maxTasks;
  int configured=job.getConfiguration().getInt(Constants.MAX_TASKS_PER_JOB,job.getNumBspTask());
  ClusterStatus clusterStatus=getClusterStatus(true);
  if (clusterStatus != null) {
    maxTasks=clusterStatus.getMaxTasks() - clusterStatus.getTasks();
    if (configured > maxTasks) {
      LOG.warn("The configured number of tasks has exceeded the maximum allowed. Job will run with " + (maxTasks) + " tasks.");
      job.setNumBspTask(maxTasks);
    }
  }
 else {
    maxTasks=configured;
  }
  Path submitJobDir=new Path(getSystemDir(),"submit_" + Integer.toString(Math.abs(r.nextInt()),36));
  Path submitSplitFile=new Path(submitJobDir,"job.split");
  Path submitJarFile=new Path(submitJobDir,"job.jar");
  Path submitJobFile=new Path(submitJobDir,"job.xml");
  LOG.debug("BSPJobClient.submitJobDir: " + submitJobDir);
  FileSystem fs=getFs();
  fs.delete(submitJobDir,true);
  submitJobDir=fs.makeQualified(submitJobDir);
  submitJobDir=new Path(submitJobDir.toUri().getPath());
  FsPermission bspSysPerms=new FsPermission(JOB_DIR_PERMISSION);
  FileSystem.mkdirs(fs,submitJobDir,bspSysPerms);
  fs.mkdirs(submitJobDir);
  short replication=(short)job.getInt("bsp.submit.replication",10);
  if ((job.get(Constants.JOB_INPUT_DIR) != null) || (job.get("bsp.join.expr") != null)) {
    LOG.debug("Creating splits at " + fs.makeQualified(submitSplitFile));
    InputSplit[] splits=job.getInputFormat().getSplits(job,(maxTasks > configured) ? configured : maxTasks);
    if (job.getConfiguration().getBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false)) {
      LOG.info("Run pre-partitioning job");
      job=partition(job,splits,maxTasks);
      maxTasks=job.getInt("hama.partition.count",maxTasks);
    }
    if (job.getBoolean("input.has.partitioned",false)) {
      splits=job.getInputFormat().getSplits(job,maxTasks);
    }
    int additionalTasks=job.getConfiguration().getInt(Constants.ADDITIONAL_BSP_TASKS,0);
    if (maxTasks < splits.length + additionalTasks) {
      throw new IOException("Job failed! The number of splits has exceeded the number of max tasks. The number of splits: " + splits.length + ", The number of additional tasks: "+ +additionalTasks+ ", The number of max tasks: "+ maxTasks);
    }
    int numOfSplits=writeSplits(job,splits,submitSplitFile,maxTasks);
    if (numOfSplits > configured || !job.getConfiguration().getBoolean(Constants.FORCE_SET_BSP_TASKS,false)) {
      job.setNumBspTask(numOfSplits + additionalTasks);
    }
    job.set("bsp.job.split.file",submitSplitFile.toString());
  }
  String originalJarPath=job.getJar();
  if (originalJarPath != null) {
    if ("".equals(job.getJobName())) {
      job.setJobName(new Path(originalJarPath).getName());
    }
    job.setJar(submitJarFile.toString());
    fs.copyFromLocalFile(new Path(originalJarPath),submitJarFile);
    fs.setReplication(submitJarFile,replication);
    fs.setPermission(submitJarFile,new FsPermission(JOB_FILE_PERMISSION));
  }
 else {
    LOG.warn("No job jar file set.  User classes may not be found. " + "See BSPJob#setJar(String) or check Your jar file.");
  }
  job.setUser(getUnixUserName());
  job.set("group.name",getUnixUserGroupName(job.getUser()));
  if (job.getWorkingDirectory() == null) {
    job.setWorkingDirectory(fs.getWorkingDirectory());
  }
  FSDataOutputStream out=FileSystem.create(fs,submitJobFile,new FsPermission(JOB_FILE_PERMISSION));
  try {
    job.writeXml(out);
  }
  finally {
    out.close();
  }
  return launchJob(jobId,job,submitJobFile,fs);
}

ID 139=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
Rmethod: org.apache.hama.bsp.BSPJobClient#writeSplits(BSPJob, InputSplit[], Path, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public RunningJob submitJobInternal(BSPJob pJob,BSPJobID jobId) throws IOException {
  BSPJob job=pJob;
  job.setJobID(jobId);
  int maxTasks;
  int configured=job.getConfiguration().getInt(Constants.MAX_TASKS_PER_JOB,job.getNumBspTask());
  ClusterStatus clusterStatus=getClusterStatus(true);
  if (clusterStatus != null) {
    maxTasks=clusterStatus.getMaxTasks() - clusterStatus.getTasks();
    if (configured > maxTasks) {
      LOG.warn("The configured number of tasks has exceeded the maximum allowed. Job will run with " + (maxTasks) + " tasks.");
      job.setNumBspTask(maxTasks);
    }
  }
 else {
    maxTasks=configured;
  }
  Path submitJobDir=new Path(getSystemDir(),"submit_" + Integer.toString(Math.abs(r.nextInt()),36));
  Path submitSplitFile=new Path(submitJobDir,"job.split");
  Path submitJarFile=new Path(submitJobDir,"job.jar");
  Path submitJobFile=new Path(submitJobDir,"job.xml");
  LOG.debug("BSPJobClient.submitJobDir: " + submitJobDir);
  FileSystem fs=getFs();
  fs.delete(submitJobDir,true);
  submitJobDir=fs.makeQualified(submitJobDir);
  submitJobDir=new Path(submitJobDir.toUri().getPath());
  FsPermission bspSysPerms=new FsPermission(JOB_DIR_PERMISSION);
  FileSystem.mkdirs(fs,submitJobDir,bspSysPerms);
  fs.mkdirs(submitJobDir);
  short replication=(short)job.getInt("bsp.submit.replication",10);
  if ((job.get(Constants.JOB_INPUT_DIR) != null) || (job.get("bsp.join.expr") != null)) {
    LOG.debug("Creating splits at " + fs.makeQualified(submitSplitFile));
    InputSplit[] splits=job.getInputFormat().getSplits(job,(maxTasks > configured) ? configured : maxTasks);
    if (job.getConfiguration().getBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false)) {
      LOG.info("Run pre-partitioning job");
      job=partition(job,splits,maxTasks);
      maxTasks=job.getInt("hama.partition.count",maxTasks);
    }
    if (job.getBoolean("input.has.partitioned",false)) {
      splits=job.getInputFormat().getSplits(job,maxTasks);
    }
    int additionalTasks=job.getConfiguration().getInt(Constants.ADDITIONAL_BSP_TASKS,0);
    if (maxTasks < splits.length + additionalTasks) {
      throw new IOException("Job failed! The number of splits has exceeded the number of max tasks. The number of splits: " + splits.length + ", The number of additional tasks: "+ +additionalTasks+ ", The number of max tasks: "+ maxTasks);
    }
    int numOfSplits=writeSplits(job,splits,submitSplitFile,maxTasks);
    if (numOfSplits > configured || !job.getConfiguration().getBoolean(Constants.FORCE_SET_BSP_TASKS,false)) {
      job.setNumBspTask(numOfSplits + additionalTasks);
    }
    job.set("bsp.job.split.file",submitSplitFile.toString());
  }
  String originalJarPath=job.getJar();
  if (originalJarPath != null) {
    if ("".equals(job.getJobName())) {
      job.setJobName(new Path(originalJarPath).getName());
    }
    job.setJar(submitJarFile.toString());
    fs.copyFromLocalFile(new Path(originalJarPath),submitJarFile);
    fs.setReplication(submitJarFile,replication);
    fs.setPermission(submitJarFile,new FsPermission(JOB_FILE_PERMISSION));
  }
 else {
    LOG.warn("No job jar file set.  User classes may not be found. " + "See BSPJob#setJar(String) or check Your jar file.");
  }
  job.setUser(getUnixUserName());
  job.set("group.name",getUnixUserGroupName(job.getUser()));
  if (job.getWorkingDirectory() == null) {
    job.setWorkingDirectory(fs.getWorkingDirectory());
  }
  FSDataOutputStream out=FileSystem.create(fs,submitJobFile,new FsPermission(JOB_FILE_PERMISSION));
  try {
    job.writeXml(out);
  }
  finally {
    out.close();
  }
  return launchJob(jobId,job,submitJobFile,fs);
}

ID 140=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
Rmethod: org.apache.hama.bsp.BSPJobClient#getUnixUserName()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public RunningJob submitJobInternal(BSPJob pJob,BSPJobID jobId) throws IOException {
  BSPJob job=pJob;
  job.setJobID(jobId);
  int maxTasks;
  int configured=job.getConfiguration().getInt(Constants.MAX_TASKS_PER_JOB,job.getNumBspTask());
  ClusterStatus clusterStatus=getClusterStatus(true);
  if (clusterStatus != null) {
    maxTasks=clusterStatus.getMaxTasks() - clusterStatus.getTasks();
    if (configured > maxTasks) {
      LOG.warn("The configured number of tasks has exceeded the maximum allowed. Job will run with " + (maxTasks) + " tasks.");
      job.setNumBspTask(maxTasks);
    }
  }
 else {
    maxTasks=configured;
  }
  Path submitJobDir=new Path(getSystemDir(),"submit_" + Integer.toString(Math.abs(r.nextInt()),36));
  Path submitSplitFile=new Path(submitJobDir,"job.split");
  Path submitJarFile=new Path(submitJobDir,"job.jar");
  Path submitJobFile=new Path(submitJobDir,"job.xml");
  LOG.debug("BSPJobClient.submitJobDir: " + submitJobDir);
  FileSystem fs=getFs();
  fs.delete(submitJobDir,true);
  submitJobDir=fs.makeQualified(submitJobDir);
  submitJobDir=new Path(submitJobDir.toUri().getPath());
  FsPermission bspSysPerms=new FsPermission(JOB_DIR_PERMISSION);
  FileSystem.mkdirs(fs,submitJobDir,bspSysPerms);
  fs.mkdirs(submitJobDir);
  short replication=(short)job.getInt("bsp.submit.replication",10);
  if ((job.get(Constants.JOB_INPUT_DIR) != null) || (job.get("bsp.join.expr") != null)) {
    LOG.debug("Creating splits at " + fs.makeQualified(submitSplitFile));
    InputSplit[] splits=job.getInputFormat().getSplits(job,(maxTasks > configured) ? configured : maxTasks);
    if (job.getConfiguration().getBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false)) {
      LOG.info("Run pre-partitioning job");
      job=partition(job,splits,maxTasks);
      maxTasks=job.getInt("hama.partition.count",maxTasks);
    }
    if (job.getBoolean("input.has.partitioned",false)) {
      splits=job.getInputFormat().getSplits(job,maxTasks);
    }
    int additionalTasks=job.getConfiguration().getInt(Constants.ADDITIONAL_BSP_TASKS,0);
    if (maxTasks < splits.length + additionalTasks) {
      throw new IOException("Job failed! The number of splits has exceeded the number of max tasks. The number of splits: " + splits.length + ", The number of additional tasks: "+ +additionalTasks+ ", The number of max tasks: "+ maxTasks);
    }
    int numOfSplits=writeSplits(job,splits,submitSplitFile,maxTasks);
    if (numOfSplits > configured || !job.getConfiguration().getBoolean(Constants.FORCE_SET_BSP_TASKS,false)) {
      job.setNumBspTask(numOfSplits + additionalTasks);
    }
    job.set("bsp.job.split.file",submitSplitFile.toString());
  }
  String originalJarPath=job.getJar();
  if (originalJarPath != null) {
    if ("".equals(job.getJobName())) {
      job.setJobName(new Path(originalJarPath).getName());
    }
    job.setJar(submitJarFile.toString());
    fs.copyFromLocalFile(new Path(originalJarPath),submitJarFile);
    fs.setReplication(submitJarFile,replication);
    fs.setPermission(submitJarFile,new FsPermission(JOB_FILE_PERMISSION));
  }
 else {
    LOG.warn("No job jar file set.  User classes may not be found. " + "See BSPJob#setJar(String) or check Your jar file.");
  }
  job.setUser(getUnixUserName());
  job.set("group.name",getUnixUserGroupName(job.getUser()));
  if (job.getWorkingDirectory() == null) {
    job.setWorkingDirectory(fs.getWorkingDirectory());
  }
  FSDataOutputStream out=FileSystem.create(fs,submitJobFile,new FsPermission(JOB_FILE_PERMISSION));
  try {
    job.writeXml(out);
  }
  finally {
    out.close();
  }
  return launchJob(jobId,job,submitJobFile,fs);
}

ID 141=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
Rmethod: org.apache.hama.bsp.BSPJobClient#getUnixUserGroupName(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public RunningJob submitJobInternal(BSPJob pJob,BSPJobID jobId) throws IOException {
  BSPJob job=pJob;
  job.setJobID(jobId);
  int maxTasks;
  int configured=job.getConfiguration().getInt(Constants.MAX_TASKS_PER_JOB,job.getNumBspTask());
  ClusterStatus clusterStatus=getClusterStatus(true);
  if (clusterStatus != null) {
    maxTasks=clusterStatus.getMaxTasks() - clusterStatus.getTasks();
    if (configured > maxTasks) {
      LOG.warn("The configured number of tasks has exceeded the maximum allowed. Job will run with " + (maxTasks) + " tasks.");
      job.setNumBspTask(maxTasks);
    }
  }
 else {
    maxTasks=configured;
  }
  Path submitJobDir=new Path(getSystemDir(),"submit_" + Integer.toString(Math.abs(r.nextInt()),36));
  Path submitSplitFile=new Path(submitJobDir,"job.split");
  Path submitJarFile=new Path(submitJobDir,"job.jar");
  Path submitJobFile=new Path(submitJobDir,"job.xml");
  LOG.debug("BSPJobClient.submitJobDir: " + submitJobDir);
  FileSystem fs=getFs();
  fs.delete(submitJobDir,true);
  submitJobDir=fs.makeQualified(submitJobDir);
  submitJobDir=new Path(submitJobDir.toUri().getPath());
  FsPermission bspSysPerms=new FsPermission(JOB_DIR_PERMISSION);
  FileSystem.mkdirs(fs,submitJobDir,bspSysPerms);
  fs.mkdirs(submitJobDir);
  short replication=(short)job.getInt("bsp.submit.replication",10);
  if ((job.get(Constants.JOB_INPUT_DIR) != null) || (job.get("bsp.join.expr") != null)) {
    LOG.debug("Creating splits at " + fs.makeQualified(submitSplitFile));
    InputSplit[] splits=job.getInputFormat().getSplits(job,(maxTasks > configured) ? configured : maxTasks);
    if (job.getConfiguration().getBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false)) {
      LOG.info("Run pre-partitioning job");
      job=partition(job,splits,maxTasks);
      maxTasks=job.getInt("hama.partition.count",maxTasks);
    }
    if (job.getBoolean("input.has.partitioned",false)) {
      splits=job.getInputFormat().getSplits(job,maxTasks);
    }
    int additionalTasks=job.getConfiguration().getInt(Constants.ADDITIONAL_BSP_TASKS,0);
    if (maxTasks < splits.length + additionalTasks) {
      throw new IOException("Job failed! The number of splits has exceeded the number of max tasks. The number of splits: " + splits.length + ", The number of additional tasks: "+ +additionalTasks+ ", The number of max tasks: "+ maxTasks);
    }
    int numOfSplits=writeSplits(job,splits,submitSplitFile,maxTasks);
    if (numOfSplits > configured || !job.getConfiguration().getBoolean(Constants.FORCE_SET_BSP_TASKS,false)) {
      job.setNumBspTask(numOfSplits + additionalTasks);
    }
    job.set("bsp.job.split.file",submitSplitFile.toString());
  }
  String originalJarPath=job.getJar();
  if (originalJarPath != null) {
    if ("".equals(job.getJobName())) {
      job.setJobName(new Path(originalJarPath).getName());
    }
    job.setJar(submitJarFile.toString());
    fs.copyFromLocalFile(new Path(originalJarPath),submitJarFile);
    fs.setReplication(submitJarFile,replication);
    fs.setPermission(submitJarFile,new FsPermission(JOB_FILE_PERMISSION));
  }
 else {
    LOG.warn("No job jar file set.  User classes may not be found. " + "See BSPJob#setJar(String) or check Your jar file.");
  }
  job.setUser(getUnixUserName());
  job.set("group.name",getUnixUserGroupName(job.getUser()));
  if (job.getWorkingDirectory() == null) {
    job.setWorkingDirectory(fs.getWorkingDirectory());
  }
  FSDataOutputStream out=FileSystem.create(fs,submitJobFile,new FsPermission(JOB_FILE_PERMISSION));
  try {
    job.writeXml(out);
  }
  finally {
    out.close();
  }
  return launchJob(jobId,job,submitJobFile,fs);
}

ID 142=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#submitJobInternal(BSPJob, BSPJobID)
Rmethod: org.apache.hama.bsp.BSPJobClient#launchJob(BSPJobID, BSPJob, Path, FileSystem)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public RunningJob submitJobInternal(BSPJob pJob,BSPJobID jobId) throws IOException {
  BSPJob job=pJob;
  job.setJobID(jobId);
  int maxTasks;
  int configured=job.getConfiguration().getInt(Constants.MAX_TASKS_PER_JOB,job.getNumBspTask());
  ClusterStatus clusterStatus=getClusterStatus(true);
  if (clusterStatus != null) {
    maxTasks=clusterStatus.getMaxTasks() - clusterStatus.getTasks();
    if (configured > maxTasks) {
      LOG.warn("The configured number of tasks has exceeded the maximum allowed. Job will run with " + (maxTasks) + " tasks.");
      job.setNumBspTask(maxTasks);
    }
  }
 else {
    maxTasks=configured;
  }
  Path submitJobDir=new Path(getSystemDir(),"submit_" + Integer.toString(Math.abs(r.nextInt()),36));
  Path submitSplitFile=new Path(submitJobDir,"job.split");
  Path submitJarFile=new Path(submitJobDir,"job.jar");
  Path submitJobFile=new Path(submitJobDir,"job.xml");
  LOG.debug("BSPJobClient.submitJobDir: " + submitJobDir);
  FileSystem fs=getFs();
  fs.delete(submitJobDir,true);
  submitJobDir=fs.makeQualified(submitJobDir);
  submitJobDir=new Path(submitJobDir.toUri().getPath());
  FsPermission bspSysPerms=new FsPermission(JOB_DIR_PERMISSION);
  FileSystem.mkdirs(fs,submitJobDir,bspSysPerms);
  fs.mkdirs(submitJobDir);
  short replication=(short)job.getInt("bsp.submit.replication",10);
  if ((job.get(Constants.JOB_INPUT_DIR) != null) || (job.get("bsp.join.expr") != null)) {
    LOG.debug("Creating splits at " + fs.makeQualified(submitSplitFile));
    InputSplit[] splits=job.getInputFormat().getSplits(job,(maxTasks > configured) ? configured : maxTasks);
    if (job.getConfiguration().getBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false)) {
      LOG.info("Run pre-partitioning job");
      job=partition(job,splits,maxTasks);
      maxTasks=job.getInt("hama.partition.count",maxTasks);
    }
    if (job.getBoolean("input.has.partitioned",false)) {
      splits=job.getInputFormat().getSplits(job,maxTasks);
    }
    int additionalTasks=job.getConfiguration().getInt(Constants.ADDITIONAL_BSP_TASKS,0);
    if (maxTasks < splits.length + additionalTasks) {
      throw new IOException("Job failed! The number of splits has exceeded the number of max tasks. The number of splits: " + splits.length + ", The number of additional tasks: "+ +additionalTasks+ ", The number of max tasks: "+ maxTasks);
    }
    int numOfSplits=writeSplits(job,splits,submitSplitFile,maxTasks);
    if (numOfSplits > configured || !job.getConfiguration().getBoolean(Constants.FORCE_SET_BSP_TASKS,false)) {
      job.setNumBspTask(numOfSplits + additionalTasks);
    }
    job.set("bsp.job.split.file",submitSplitFile.toString());
  }
  String originalJarPath=job.getJar();
  if (originalJarPath != null) {
    if ("".equals(job.getJobName())) {
      job.setJobName(new Path(originalJarPath).getName());
    }
    job.setJar(submitJarFile.toString());
    fs.copyFromLocalFile(new Path(originalJarPath),submitJarFile);
    fs.setReplication(submitJarFile,replication);
    fs.setPermission(submitJarFile,new FsPermission(JOB_FILE_PERMISSION));
  }
 else {
    LOG.warn("No job jar file set.  User classes may not be found. " + "See BSPJob#setJar(String) or check Your jar file.");
  }
  job.setUser(getUnixUserName());
  job.set("group.name",getUnixUserGroupName(job.getUser()));
  if (job.getWorkingDirectory() == null) {
    job.setWorkingDirectory(fs.getWorkingDirectory());
  }
  FSDataOutputStream out=FileSystem.create(fs,submitJobFile,new FsPermission(JOB_FILE_PERMISSION));
  try {
    job.writeXml(out);
  }
  finally {
    out.close();
  }
  return launchJob(jobId,job,submitJobFile,fs);
}

ID 143=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#launchJob(BSPJobID, BSPJob, Path, FileSystem)
Rmethod: org.apache.hama.bsp.NetworkedJob#NetworkedJob(JobStatus)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
protected RunningJob launchJob(BSPJobID jobId,BSPJob job,Path submitJobFile,FileSystem fs) throws IOException {
  JobStatus status=jobSubmitClient.submitJob(jobId,submitJobFile.makeQualified(fs).toString());
  if (status != null) {
    return new NetworkedJob(status);
  }
 else {
    throw new IOException("Could not launch job");
  }
}

ID 144=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#writeSplits(BSPJob, InputSplit[], Path, int)
Rmethod: org.apache.hama.bsp.BSPJobClient#writeSplitsFileHeader(Configuration, Path, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static int writeSplits(BSPJob job,InputSplit[] splits,Path submitSplitFile,int maxTasks) throws IOException {
  final DataOutputStream out=writeSplitsFileHeader(job.getConfiguration(),submitSplitFile,splits.length);
  try {
    DataOutputBuffer buffer=new DataOutputBuffer();
    RawSplit rawSplit=new RawSplit();
    for (    InputSplit split : splits) {
      if (split.getClass().getName().equals(FileSplit.class.getName()) && job.getBoolean("input.has.partitioned",false)) {
        String[] extractPartitionID=((FileSplit)split).getPath().getName().split("[-]");
        if (extractPartitionID.length > 1)         rawSplit.setPartitionID(Integer.parseInt(extractPartitionID[1]));
      }
      rawSplit.setClassName(split.getClass().getName());
      buffer.reset();
      split.write(buffer);
      rawSplit.setDataLength(split.getLength());
      rawSplit.setBytes(buffer.getData(),0,buffer.getLength());
      rawSplit.setLocations(split.getLocations());
      rawSplit.write(out);
    }
  }
  finally {
    out.close();
  }
  return splits.length;
}

ID 145=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#writeSplits(BSPJob, InputSplit[], Path, int)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static int writeSplits(BSPJob job,InputSplit[] splits,Path submitSplitFile,int maxTasks) throws IOException {
  final DataOutputStream out=writeSplitsFileHeader(job.getConfiguration(),submitSplitFile,splits.length);
  try {
    DataOutputBuffer buffer=new DataOutputBuffer();
    RawSplit rawSplit=new RawSplit();
    for (    InputSplit split : splits) {
      if (split.getClass().getName().equals(FileSplit.class.getName()) && job.getBoolean("input.has.partitioned",false)) {
        String[] extractPartitionID=((FileSplit)split).getPath().getName().split("[-]");
        if (extractPartitionID.length > 1)         rawSplit.setPartitionID(Integer.parseInt(extractPartitionID[1]));
      }
      rawSplit.setClassName(split.getClass().getName());
      buffer.reset();
      split.write(buffer);
      rawSplit.setDataLength(split.getLength());
      rawSplit.setBytes(buffer.getData(),0,buffer.getLength());
      rawSplit.setLocations(split.getLocations());
      rawSplit.write(out);
    }
  }
  finally {
    out.close();
  }
  return splits.length;
}

ID 146=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#writeSplits(BSPJob, InputSplit[], Path, int)
Rmethod: org.apache.hama.bsp.RawSplit#write(java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static int writeSplits(BSPJob job,InputSplit[] splits,Path submitSplitFile,int maxTasks) throws IOException {
  final DataOutputStream out=writeSplitsFileHeader(job.getConfiguration(),submitSplitFile,splits.length);
  try {
    DataOutputBuffer buffer=new DataOutputBuffer();
    RawSplit rawSplit=new RawSplit();
    for (    InputSplit split : splits) {
      if (split.getClass().getName().equals(FileSplit.class.getName()) && job.getBoolean("input.has.partitioned",false)) {
        String[] extractPartitionID=((FileSplit)split).getPath().getName().split("[-]");
        if (extractPartitionID.length > 1)         rawSplit.setPartitionID(Integer.parseInt(extractPartitionID[1]));
      }
      rawSplit.setClassName(split.getClass().getName());
      buffer.reset();
      split.write(buffer);
      rawSplit.setDataLength(split.getLength());
      rawSplit.setBytes(buffer.getData(),0,buffer.getLength());
      rawSplit.setLocations(split.getLocations());
      rawSplit.write(out);
    }
  }
  finally {
    out.close();
  }
  return splits.length;
}

ID 147=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#writeSplits(BSPJob, InputSplit[], Path, int)
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static int writeSplits(BSPJob job,InputSplit[] splits,Path submitSplitFile,int maxTasks) throws IOException {
  final DataOutputStream out=writeSplitsFileHeader(job.getConfiguration(),submitSplitFile,splits.length);
  try {
    DataOutputBuffer buffer=new DataOutputBuffer();
    RawSplit rawSplit=new RawSplit();
    for (    InputSplit split : splits) {
      if (split.getClass().getName().equals(FileSplit.class.getName()) && job.getBoolean("input.has.partitioned",false)) {
        String[] extractPartitionID=((FileSplit)split).getPath().getName().split("[-]");
        if (extractPartitionID.length > 1)         rawSplit.setPartitionID(Integer.parseInt(extractPartitionID[1]));
      }
      rawSplit.setClassName(split.getClass().getName());
      buffer.reset();
      split.write(buffer);
      rawSplit.setDataLength(split.getLength());
      rawSplit.setBytes(buffer.getData(),0,buffer.getLength());
      rawSplit.setLocations(split.getLocations());
      rawSplit.write(out);
    }
  }
  finally {
    out.close();
  }
  return splits.length;
}

ID 148=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#readSplitFile(java.io.DataInput)
Rmethod: java.io.DataInput#readFully(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read a splits file into a list of raw splits
 * @param in the stream to read from
 * @return the complete list of splits
 * @throws IOException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Read a splits file into a list of raw splits
 * @param in the stream to read from
 * @return the complete list of splits
 * @throws IOException
 */
static RawSplit[] readSplitFile(DataInput in) throws IOException {
  byte[] header=new byte[SPLIT_FILE_HEADER.length];
  in.readFully(header);
  if (!Arrays.equals(SPLIT_FILE_HEADER,header)) {
    throw new IOException("Invalid header on split file");
  }
  int vers=WritableUtils.readVInt(in);
  if (vers != CURRENT_SPLIT_FILE_VERSION) {
    throw new IOException("Unsupported split version " + vers);
  }
  int len=WritableUtils.readVInt(in);
  RawSplit[] result=new RawSplit[len];
  for (int i=0; i < len; ++i) {
    RawSplit split=new RawSplit();
    split.readFields(in);
    if (split.getPartitionID() != Integer.MIN_VALUE)     result[split.getPartitionID()]=split;
 else     result[i]=split;
  }
  return result;
}

ID 149=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#readSplitFile(java.io.DataInput)
Rmethod: org.apache.hama.bsp.RawSplit#readFields(java.io.DataInput)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read a splits file into a list of raw splits
 * @param in the stream to read from
 * @return the complete list of splits
 * @throws IOException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Read a splits file into a list of raw splits
 * @param in the stream to read from
 * @return the complete list of splits
 * @throws IOException
 */
static RawSplit[] readSplitFile(DataInput in) throws IOException {
  byte[] header=new byte[SPLIT_FILE_HEADER.length];
  in.readFully(header);
  if (!Arrays.equals(SPLIT_FILE_HEADER,header)) {
    throw new IOException("Invalid header on split file");
  }
  int vers=WritableUtils.readVInt(in);
  if (vers != CURRENT_SPLIT_FILE_VERSION) {
    throw new IOException("Unsupported split version " + vers);
  }
  int len=WritableUtils.readVInt(in);
  RawSplit[] result=new RawSplit[len];
  for (int i=0; i < len; ++i) {
    RawSplit split=new RawSplit();
    split.readFields(in);
    if (split.getPartitionID() != Integer.MIN_VALUE)     result[split.getPartitionID()]=split;
 else     result[i]=split;
  }
  return result;
}

ID 150=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#monitorAndPrintJob(BSPJob, RunningJob)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Monitor a job and print status in real-time as progress is made and tasks fail.
 * @param job
 * @param info
 * @return true, if job is successful
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Monitor a job and print status in real-time as progress is made and tasks fail.
 * @param job
 * @param info
 * @return true, if job is successful
 * @throws IOException
 * @throws InterruptedException
 */
public boolean monitorAndPrintJob(BSPJob job,RunningJob info) throws IOException, InterruptedException {
  String lastReport=null;
  LOG.info("Running job: " + info.getID());
  int eventCounter=0;
  while (!job.isComplete()) {
    Thread.sleep(3000);
    long step=job.progress();
    String report="";
    report="Current supersteps number: " + step;
    if (!report.equals(lastReport)) {
      LOG.info(report);
      lastReport=report;
    }
    TaskCompletionEvent[] events=info.getTaskCompletionEvents(eventCounter);
    eventCounter+=events.length;
    for (    TaskCompletionEvent event : events) {
      if (event.getTaskStatus() == TaskCompletionEvent.Status.FAILED) {
        displayTaskLogs(event.getTaskAttemptId(),event.getGroomServerInfo());
      }
    }
  }
  if (job.isSuccessful()) {
    LOG.info("The total number of supersteps: " + info.getSuperstepCount());
    info.getStatus().getCounter().incrCounter(JobInProgress.JobCounter.SUPERSTEPS,info.getSuperstepCount());
    info.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  return job.isSuccessful();
}

ID 151=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#monitorAndPrintJob(BSPJob, RunningJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#displayTaskLogs(TaskAttemptID, java.lang.String)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.net.MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

method comment: /** 
 * Monitor a job and print status in real-time as progress is made and tasks fail.
 * @param job
 * @param info
 * @return true, if job is successful
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Monitor a job and print status in real-time as progress is made and tasks fail.
 * @param job
 * @param info
 * @return true, if job is successful
 * @throws IOException
 * @throws InterruptedException
 */
public boolean monitorAndPrintJob(BSPJob job,RunningJob info) throws IOException, InterruptedException {
  String lastReport=null;
  LOG.info("Running job: " + info.getID());
  int eventCounter=0;
  while (!job.isComplete()) {
    Thread.sleep(3000);
    long step=job.progress();
    String report="";
    report="Current supersteps number: " + step;
    if (!report.equals(lastReport)) {
      LOG.info(report);
      lastReport=report;
    }
    TaskCompletionEvent[] events=info.getTaskCompletionEvents(eventCounter);
    eventCounter+=events.length;
    for (    TaskCompletionEvent event : events) {
      if (event.getTaskStatus() == TaskCompletionEvent.Status.FAILED) {
        displayTaskLogs(event.getTaskAttemptId(),event.getGroomServerInfo());
      }
    }
  }
  if (job.isSuccessful()) {
    LOG.info("The total number of supersteps: " + info.getSuperstepCount());
    info.getStatus().getCounter().incrCounter(JobInProgress.JobCounter.SUPERSTEPS,info.getSuperstepCount());
    info.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  return job.isSuccessful();
}

ID 152=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#displayTaskLogs(TaskAttemptID, java.lang.String)
Rmethod: java.net.URL#URL(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static void displayTaskLogs(TaskAttemptID taskId,String baseUrl) throws MalformedURLException {
  if (baseUrl != null) {
    String taskLogUrl=getTaskLogURL(taskId,baseUrl);
    getTaskLogs(taskId,new URL(taskLogUrl + "&filter=stdout"),System.out);
  }
}

ID 153=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getTaskLogs(TaskAttemptID, java.net.URL, java.io.OutputStream)
Rmethod: java.net.URL#openConnection()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Error reading task output" + ioe.getMessage());
}

block: 
BSPJobClient
private static void getTaskLogs(TaskAttemptID taskId,URL taskLogUrl,OutputStream out){
  try {
    URLConnection connection=taskLogUrl.openConnection();
    BufferedReader input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    BufferedWriter output=new BufferedWriter(new OutputStreamWriter(out));
    try {
      String logData=null;
      while ((logData=input.readLine()) != null) {
        if (logData.length() > 0) {
          output.write(taskId + ": " + logData+ "\n");
          output.flush();
        }
      }
    }
  finally {
      input.close();
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Error reading task output" + ioe.getMessage());
  }
}

ID 154=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getTaskLogs(TaskAttemptID, java.net.URL, java.io.OutputStream)
Rmethod: java.net.URLConnection#getInputStream()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Error reading task output" + ioe.getMessage());
}

block: 
BSPJobClient
private static void getTaskLogs(TaskAttemptID taskId,URL taskLogUrl,OutputStream out){
  try {
    URLConnection connection=taskLogUrl.openConnection();
    BufferedReader input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    BufferedWriter output=new BufferedWriter(new OutputStreamWriter(out));
    try {
      String logData=null;
      while ((logData=input.readLine()) != null) {
        if (logData.length() > 0) {
          output.write(taskId + ": " + logData+ "\n");
          output.flush();
        }
      }
    }
  finally {
      input.close();
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Error reading task output" + ioe.getMessage());
  }
}

ID 155=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getTaskLogs(TaskAttemptID, java.net.URL, java.io.OutputStream)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static void getTaskLogs(TaskAttemptID taskId,URL taskLogUrl,OutputStream out){
  try {
    URLConnection connection=taskLogUrl.openConnection();
    BufferedReader input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    BufferedWriter output=new BufferedWriter(new OutputStreamWriter(out));
    try {
      String logData=null;
      while ((logData=input.readLine()) != null) {
        if (logData.length() > 0) {
          output.write(taskId + ": " + logData+ "\n");
          output.flush();
        }
      }
    }
  finally {
      input.close();
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Error reading task output" + ioe.getMessage());
  }
}

ID 156=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getTaskLogs(TaskAttemptID, java.net.URL, java.io.OutputStream)
Rmethod: java.io.Writer#write(char[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static void getTaskLogs(TaskAttemptID taskId,URL taskLogUrl,OutputStream out){
  try {
    URLConnection connection=taskLogUrl.openConnection();
    BufferedReader input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    BufferedWriter output=new BufferedWriter(new OutputStreamWriter(out));
    try {
      String logData=null;
      while ((logData=input.readLine()) != null) {
        if (logData.length() > 0) {
          output.write(taskId + ": " + logData+ "\n");
          output.flush();
        }
      }
    }
  finally {
      input.close();
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Error reading task output" + ioe.getMessage());
  }
}

ID 157=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getTaskLogs(TaskAttemptID, java.net.URL, java.io.OutputStream)
Rmethod: java.io.BufferedWriter#flush()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static void getTaskLogs(TaskAttemptID taskId,URL taskLogUrl,OutputStream out){
  try {
    URLConnection connection=taskLogUrl.openConnection();
    BufferedReader input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    BufferedWriter output=new BufferedWriter(new OutputStreamWriter(out));
    try {
      String logData=null;
      while ((logData=input.readLine()) != null) {
        if (logData.length() > 0) {
          output.write(taskId + ": " + logData+ "\n");
          output.flush();
        }
      }
    }
  finally {
      input.close();
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Error reading task output" + ioe.getMessage());
  }
}

ID 158=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getTaskLogs(TaskAttemptID, java.net.URL, java.io.OutputStream)
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
private static void getTaskLogs(TaskAttemptID taskId,URL taskLogUrl,OutputStream out){
  try {
    URLConnection connection=taskLogUrl.openConnection();
    BufferedReader input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    BufferedWriter output=new BufferedWriter(new OutputStreamWriter(out));
    try {
      String logData=null;
      while ((logData=input.readLine()) != null) {
        if (logData.length() > 0) {
          output.write(taskId + ": " + logData+ "\n");
          output.flush();
        }
      }
    }
  finally {
      input.close();
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Error reading task output" + ioe.getMessage());
  }
}

ID 159=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#runJob(BSPJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#BSPJobClient(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public static void runJob(BSPJob job) throws FileNotFoundException, IOException {
  BSPJobClient jc=new BSPJobClient(job.getConfiguration());
  if (job.getNumBspTask() == 0 || job.getNumBspTask() > jc.getClusterStatus(false).getMaxTasks()) {
    job.setNumBspTask(jc.getClusterStatus(false).getMaxTasks());
  }
  RunningJob running=jc.submitJob(job);
  BSPJobID jobId=running.getID();
  LOG.info("Running job: " + jobId.toString());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    if (running.isComplete()) {
      break;
    }
    running=jc.getJob(jobId);
  }
  if (running.isSuccessful()) {
    LOG.info("Job complete: " + jobId);
    LOG.info("The total number of supersteps: " + running.getSuperstepCount());
    running.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  jc.close();
}

ID 160=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#runJob(BSPJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#getClusterStatus(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public static void runJob(BSPJob job) throws FileNotFoundException, IOException {
  BSPJobClient jc=new BSPJobClient(job.getConfiguration());
  if (job.getNumBspTask() == 0 || job.getNumBspTask() > jc.getClusterStatus(false).getMaxTasks()) {
    job.setNumBspTask(jc.getClusterStatus(false).getMaxTasks());
  }
  RunningJob running=jc.submitJob(job);
  BSPJobID jobId=running.getID();
  LOG.info("Running job: " + jobId.toString());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    if (running.isComplete()) {
      break;
    }
    running=jc.getJob(jobId);
  }
  if (running.isSuccessful()) {
    LOG.info("Job complete: " + jobId);
    LOG.info("The total number of supersteps: " + running.getSuperstepCount());
    running.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  jc.close();
}

ID 161=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#runJob(BSPJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#submitJob(BSPJob)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public static void runJob(BSPJob job) throws FileNotFoundException, IOException {
  BSPJobClient jc=new BSPJobClient(job.getConfiguration());
  if (job.getNumBspTask() == 0 || job.getNumBspTask() > jc.getClusterStatus(false).getMaxTasks()) {
    job.setNumBspTask(jc.getClusterStatus(false).getMaxTasks());
  }
  RunningJob running=jc.submitJob(job);
  BSPJobID jobId=running.getID();
  LOG.info("Running job: " + jobId.toString());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    if (running.isComplete()) {
      break;
    }
    running=jc.getJob(jobId);
  }
  if (running.isSuccessful()) {
    LOG.info("Job complete: " + jobId);
    LOG.info("The total number of supersteps: " + running.getSuperstepCount());
    running.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  jc.close();
}

ID 162=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#runJob(BSPJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#submitJob(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public static void runJob(BSPJob job) throws FileNotFoundException, IOException {
  BSPJobClient jc=new BSPJobClient(job.getConfiguration());
  if (job.getNumBspTask() == 0 || job.getNumBspTask() > jc.getClusterStatus(false).getMaxTasks()) {
    job.setNumBspTask(jc.getClusterStatus(false).getMaxTasks());
  }
  RunningJob running=jc.submitJob(job);
  BSPJobID jobId=running.getID();
  LOG.info("Running job: " + jobId.toString());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    if (running.isComplete()) {
      break;
    }
    running=jc.getJob(jobId);
  }
  if (running.isSuccessful()) {
    LOG.info("Job complete: " + jobId);
    LOG.info("The total number of supersteps: " + running.getSuperstepCount());
    running.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  jc.close();
}

ID 163=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#runJob(BSPJob)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
}

block: 
BSPJobClient
public static void runJob(BSPJob job) throws FileNotFoundException, IOException {
  BSPJobClient jc=new BSPJobClient(job.getConfiguration());
  if (job.getNumBspTask() == 0 || job.getNumBspTask() > jc.getClusterStatus(false).getMaxTasks()) {
    job.setNumBspTask(jc.getClusterStatus(false).getMaxTasks());
  }
  RunningJob running=jc.submitJob(job);
  BSPJobID jobId=running.getID();
  LOG.info("Running job: " + jobId.toString());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    if (running.isComplete()) {
      break;
    }
    running=jc.getJob(jobId);
  }
  if (running.isSuccessful()) {
    LOG.info("Job complete: " + jobId);
    LOG.info("The total number of supersteps: " + running.getSuperstepCount());
    running.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  jc.close();
}

ID 164=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#runJob(BSPJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#getJob(BSPJobID)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public static void runJob(BSPJob job) throws FileNotFoundException, IOException {
  BSPJobClient jc=new BSPJobClient(job.getConfiguration());
  if (job.getNumBspTask() == 0 || job.getNumBspTask() > jc.getClusterStatus(false).getMaxTasks()) {
    job.setNumBspTask(jc.getClusterStatus(false).getMaxTasks());
  }
  RunningJob running=jc.submitJob(job);
  BSPJobID jobId=running.getID();
  LOG.info("Running job: " + jobId.toString());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    if (running.isComplete()) {
      break;
    }
    running=jc.getJob(jobId);
  }
  if (running.isSuccessful()) {
    LOG.info("Job complete: " + jobId);
    LOG.info("The total number of supersteps: " + running.getSuperstepCount());
    running.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  jc.close();
}

ID 165=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#runJob(BSPJob)
Rmethod: org.apache.hama.bsp.BSPJobClient#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
public static void runJob(BSPJob job) throws FileNotFoundException, IOException {
  BSPJobClient jc=new BSPJobClient(job.getConfiguration());
  if (job.getNumBspTask() == 0 || job.getNumBspTask() > jc.getClusterStatus(false).getMaxTasks()) {
    job.setNumBspTask(jc.getClusterStatus(false).getMaxTasks());
  }
  RunningJob running=jc.submitJob(job);
  BSPJobID jobId=running.getID();
  LOG.info("Running job: " + jobId.toString());
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    if (running.isComplete()) {
      break;
    }
    running=jc.getJob(jobId);
  }
  if (running.isSuccessful()) {
    LOG.info("Job complete: " + jobId);
    LOG.info("The total number of supersteps: " + running.getSuperstepCount());
    running.getStatus().getCounter().log(LOG);
  }
 else {
    LOG.info("Job failed.");
  }
  jc.close();
}

ID 166=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getJob(BSPJobID)
Rmethod: org.apache.hama.bsp.NetworkedJob#NetworkedJob(JobStatus)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get an RunningJob object to track an ongoing job. Returns null if the id does not correspond to any known job.
 * @throws IOException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Get an RunningJob object to track an ongoing job. Returns null if the id does not correspond to any known job.
 * @throws IOException
 */
private RunningJob getJob(BSPJobID jobId) throws IOException {
  JobStatus status=jobSubmitClient.getJobStatus(jobId);
  if (status != null) {
    return new NetworkedJob(status);
  }
 else {
    return null;
  }
}

ID 167=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#init(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 168=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#BSPJobClient(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 169=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#listJobs()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 170=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#listAllJobs()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 171=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#listActiveGrooms()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 172=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#submitJob(BSPJob)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 173=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#submitJob(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 174=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#run(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPJobClient#getJob(BSPJobID)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
@Override public int run(String[] args) throws Exception {
  int exitCode=-1;
  if (args.length < 1) {
    displayUsage("");
    return exitCode;
  }
  String cmd=args[0];
  boolean listJobs=false;
  boolean listAllJobs=false;
  boolean listActiveGrooms=false;
  boolean killJob=false;
  boolean submitJob=false;
  boolean getStatus=false;
  String submitJobFile=null;
  String jobid=null;
  HamaConfiguration conf=new HamaConfiguration(getConf());
  init(conf);
  if ("-list".equals(cmd)) {
    if (args.length != 1 && !(args.length == 2 && "all".equals(args[1]))) {
      displayUsage(cmd);
      return exitCode;
    }
    if (args.length == 2 && "all".equals(args[1])) {
      listAllJobs=true;
    }
 else {
      listJobs=true;
    }
  }
 else   if ("-list-active-grooms".equals(cmd)) {
    if (args.length != 1) {
      displayUsage(cmd);
      return exitCode;
    }
    listActiveGrooms=true;
  }
 else   if ("-submit".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    submitJob=true;
    submitJobFile=args[1];
  }
 else   if ("-kill".equals(cmd)) {
    if (args.length == 1) {
      displayUsage(cmd);
      return exitCode;
    }
    killJob=true;
    jobid=args[1];
  }
 else   if ("-status".equals(cmd)) {
    if (args.length != 2) {
      displayUsage(cmd);
      return exitCode;
    }
    jobid=args[1];
    getStatus=true;
  }
 else   if ("-list-attempt-ids".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-kill-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
 else   if ("-fail-task".equals(cmd)) {
    System.out.println("This function is not implemented yet.");
    return exitCode;
  }
  BSPJobClient jc=new BSPJobClient(new HamaConfiguration());
  if (listJobs) {
    listJobs();
    exitCode=0;
  }
 else   if (listAllJobs) {
    listAllJobs();
    exitCode=0;
  }
 else   if (listActiveGrooms) {
    listActiveGrooms();
    exitCode=0;
  }
 else   if (submitJob) {
    HamaConfiguration tConf=new HamaConfiguration(new Path(submitJobFile));
    RunningJob job=jc.submitJob(new BSPJob(tConf));
    System.out.println("Created job " + job.getID().toString());
  }
 else   if (killJob) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      job.killJob();
      System.out.println("Killed job " + jobid);
    }
    exitCode=0;
  }
 else   if (getStatus) {
    RunningJob job=jc.getJob(BSPJobID.forName(jobid));
    if (job == null) {
      System.out.println("Could not find job " + jobid);
    }
 else {
      JobStatus jobStatus=jobSubmitClient.getJobStatus(job.getID());
      System.out.println("Job name: " + job.getJobName());
      System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
      System.out.printf("%s\t%d\t%d\t%s\n",jobStatus.getJobID(),jobStatus.getRunState(),jobStatus.getStartTime(),jobStatus.getUsername());
      exitCode=0;
    }
  }
  return 0;
}

ID 175=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#listJobs()
Rmethod: org.apache.hama.bsp.BSPJobClient#jobsToComplete()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Dump a list of currently running jobs
 * @throws IOException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Dump a list of currently running jobs
 * @throws IOException
 */
private void listJobs() throws IOException {
  JobStatus[] jobs=jobsToComplete();
  if (jobs == null)   jobs=new JobStatus[0];
  System.out.printf("%d jobs currently running\n",jobs.length);
  displayJobList(jobs);
}

ID 176=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#listAllJobs()
Rmethod: org.apache.hama.bsp.BSPJobClient#getAllJobs()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Dump a list of all jobs submitted.
 * @throws IOException
 */

catch: 
null
block: 
BSPJobClient
/** 
 * Dump a list of all jobs submitted.
 * @throws IOException
 */
private void listAllJobs() throws IOException {
  JobStatus[] jobs=getAllJobs();
  if (jobs == null)   jobs=new JobStatus[0];
  System.out.printf("%d jobs submitted\n",jobs.length);
  System.out.printf("States are:\n\tRunning : 1\tSucceded : 2" + "\tFailed : 3\tPrep : 4\n");
  displayJobList(jobs);
}

ID 177=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getUnixUserName()
Rmethod: org.apache.hama.bsp.BSPJobClient#executeShellCommand(java.lang.String[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
protected static String getUnixUserName() throws IOException {
  String[] result=executeShellCommand(new String[]{Shell.USER_NAME_COMMAND});
  if (result.length != 1) {
    throw new IOException("Expect one token as the result of " + Shell.USER_NAME_COMMAND + ": "+ toString(result));
  }
  String fixResult=fixCygwinName(result[0]);
  return fixResult;
}

ID 178=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobClient#getUnixUserGroupName(java.lang.String)
Rmethod: org.apache.hama.bsp.BSPJobClient#executeShellCommand(java.lang.String[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPJobClient
static String getUnixUserGroupName(String user) throws IOException {
  String[] result=executeShellCommand(new String[]{"bash","-c","id -Gn " + user});
  if (result.length < 1) {
    throw new IOException("Expect one token as the result of " + "bash -c id -Gn " + user + ": "+ toString(result));
  }
  return result[0];
}

ID 179=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.RawSplit#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RawSplit
@Override public void readFields(DataInput in) throws IOException {
  splitClass=Text.readString(in);
  dataLength=in.readLong();
  bytes.readFields(in);
  partitionID=in.readInt();
  int len=WritableUtils.readVInt(in);
  locations=new String[len];
  for (int i=0; i < len; ++i) {
    locations[i]=Text.readString(in);
  }
}

ID 180=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.RawSplit#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RawSplit
@Override public void readFields(DataInput in) throws IOException {
  splitClass=Text.readString(in);
  dataLength=in.readLong();
  bytes.readFields(in);
  partitionID=in.readInt();
  int len=WritableUtils.readVInt(in);
  locations=new String[len];
  for (int i=0; i < len; ++i) {
    locations[i]=Text.readString(in);
  }
}

ID 181=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.RawSplit#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RawSplit
@Override public void write(DataOutput out) throws IOException {
  Text.writeString(out,splitClass);
  out.writeLong(dataLength);
  bytes.write(out);
  out.writeInt(partitionID);
  WritableUtils.writeVInt(out,locations.length);
  for (  String location : locations) {
    Text.writeString(out,location);
  }
}

ID 182=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.RawSplit#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RawSplit
@Override public void write(DataOutput out) throws IOException {
  Text.writeString(out,splitClass);
  out.writeLong(dataLength);
  bytes.write(out);
  out.writeInt(partitionID);
  WritableUtils.writeVInt(out,locations.length);
  for (  String location : locations) {
    Text.writeString(out,location);
  }
}

ID 183=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPJobID#forName(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception ex) {
}

block: 
BSPJobID
public static BSPJobID forName(String str) throws IllegalArgumentException {
  if (str == null)   return null;
  try {
    String[] parts=str.split("_");
    if (parts.length == 3) {
      if (parts[0].equals(JOB)) {
        return new BSPJobID(parts[1],Integer.parseInt(parts[2]));
      }
    }
  }
 catch (  Exception ex) {
  }
  throw new IllegalArgumentException("JobId string : " + str + " is not properly formed");
}

ID 184=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#BSPMaster(HamaConfiguration, java.lang.String)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMaster
BSPMaster(HamaConfiguration conf,String identifier) throws IOException, InterruptedException {
  this.conf=conf;
  this.masterIdentifier=identifier;
  Class<? extends TaskScheduler> schedulerClass=conf.getClass("bsp.master.taskscheduler",SimpleTaskScheduler.class,TaskScheduler.class);
  this.taskScheduler=ReflectionUtils.newInstance(schedulerClass,conf);
  InetSocketAddress inetSocketAddress=getAddress(conf);
  if (inetSocketAddress != null) {
    host=inetSocketAddress.getHostName();
    port=inetSocketAddress.getPort();
    LOG.info("RPC BSPMaster: host " + host + " port "+ port);
    startTime=System.currentTimeMillis();
    this.masterServer=RPC.getServer(this,host,port,conf);
    infoPort=conf.getInt("bsp.http.infoserver.port",40013);
    infoServer=new HttpServer("bspmaster",host,infoPort,true,conf);
    infoServer.setAttribute("bsp.master",this);
    infoServer.start();
    if (conf.getBoolean("bsp.monitor.fd.enabled",false)) {
      this.supervisor.set(FDProvider.createSupervisor(conf.getClass("bsp.monitor.fd.supervisor.class",UDPSupervisor.class,Supervisor.class),conf));
    }
    while (!Thread.currentThread().isInterrupted()) {
      try {
        if (fs == null) {
          fs=FileSystem.get(conf);
        }
      }
 catch (      IOException e) {
        LOG.error("Can't get connection to Hadoop Namenode!",e);
      }
      try {
        if (systemDir == null) {
          systemDir=new Path(getSystemDir());
        }
        LOG.info("Cleaning up the system directory");
        LOG.info(systemDir);
        fs.delete(systemDir,true);
        if (FileSystem.mkdirs(fs,systemDir,new FsPermission(SYSTEM_DIR_PERMISSION))) {
          break;
        }
        LOG.error("Mkdirs failed to create " + systemDir);
        LOG.info(SUBDIR);
      }
 catch (      AccessControlException ace) {
        LOG.warn("Failed to operate on bsp.system.dir (" + systemDir + ") because of permissions.");
        LOG.warn("Manually delete the bsp.system.dir (" + systemDir + ") and then start the BSPMaster.");
        LOG.warn("Bailing out ... ");
        throw ace;
      }
catch (      IOException ie) {
        LOG.info("problem cleaning system directory: " + systemDir,ie);
      }
      Thread.sleep(FS_ACCESS_RETRY_PERIOD);
    }
    if (Thread.currentThread().isInterrupted()) {
      throw new InterruptedException();
    }
    deleteLocalFiles(SUBDIR);
  }
 else {
    System.out.println(localModeMessage);
    LOG.info(localModeMessage);
  }
}

ID 185=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#BSPMaster(HamaConfiguration, java.lang.String)
Rmethod: org.apache.hama.bsp.BSPMaster#deleteLocalFiles(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMaster
BSPMaster(HamaConfiguration conf,String identifier) throws IOException, InterruptedException {
  this.conf=conf;
  this.masterIdentifier=identifier;
  Class<? extends TaskScheduler> schedulerClass=conf.getClass("bsp.master.taskscheduler",SimpleTaskScheduler.class,TaskScheduler.class);
  this.taskScheduler=ReflectionUtils.newInstance(schedulerClass,conf);
  InetSocketAddress inetSocketAddress=getAddress(conf);
  if (inetSocketAddress != null) {
    host=inetSocketAddress.getHostName();
    port=inetSocketAddress.getPort();
    LOG.info("RPC BSPMaster: host " + host + " port "+ port);
    startTime=System.currentTimeMillis();
    this.masterServer=RPC.getServer(this,host,port,conf);
    infoPort=conf.getInt("bsp.http.infoserver.port",40013);
    infoServer=new HttpServer("bspmaster",host,infoPort,true,conf);
    infoServer.setAttribute("bsp.master",this);
    infoServer.start();
    if (conf.getBoolean("bsp.monitor.fd.enabled",false)) {
      this.supervisor.set(FDProvider.createSupervisor(conf.getClass("bsp.monitor.fd.supervisor.class",UDPSupervisor.class,Supervisor.class),conf));
    }
    while (!Thread.currentThread().isInterrupted()) {
      try {
        if (fs == null) {
          fs=FileSystem.get(conf);
        }
      }
 catch (      IOException e) {
        LOG.error("Can't get connection to Hadoop Namenode!",e);
      }
      try {
        if (systemDir == null) {
          systemDir=new Path(getSystemDir());
        }
        LOG.info("Cleaning up the system directory");
        LOG.info(systemDir);
        fs.delete(systemDir,true);
        if (FileSystem.mkdirs(fs,systemDir,new FsPermission(SYSTEM_DIR_PERMISSION))) {
          break;
        }
        LOG.error("Mkdirs failed to create " + systemDir);
        LOG.info(SUBDIR);
      }
 catch (      AccessControlException ace) {
        LOG.warn("Failed to operate on bsp.system.dir (" + systemDir + ") because of permissions.");
        LOG.warn("Manually delete the bsp.system.dir (" + systemDir + ") and then start the BSPMaster.");
        LOG.warn("Bailing out ... ");
        throw ace;
      }
catch (      IOException ie) {
        LOG.info("problem cleaning system directory: " + systemDir,ie);
      }
      Thread.sleep(FS_ACCESS_RETRY_PERIOD);
    }
    if (Thread.currentThread().isInterrupted()) {
      throw new InterruptedException();
    }
    deleteLocalFiles(SUBDIR);
  }
 else {
    System.out.println(localModeMessage);
    LOG.info(localModeMessage);
  }
}

ID 186=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#deleteLocalFiles()
Rmethod: org.apache.hama.bsp.BSPMaster#getLocalDirs()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMaster
void deleteLocalFiles() throws IOException {
  String[] localDirs=getLocalDirs();
  for (  String localDir : localDirs) {
    FileSystem.getLocal(conf).delete(new Path(localDir),true);
  }
}

ID 187=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#deleteLocalFiles(java.lang.String)
Rmethod: org.apache.hama.bsp.BSPMaster#getLocalDirs()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMaster
void deleteLocalFiles(String subdir) throws IOException {
  try {
    String[] localDirs=getLocalDirs();
    for (    String localDir : localDirs) {
      FileSystem.getLocal(conf).delete(new Path(localDir,subdir),true);
    }
  }
 catch (  NullPointerException e) {
    LOG.info(e);
  }
}

ID 188=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#startMaster(HamaConfiguration)
Rmethod: org.apache.hama.bsp.BSPMaster#startMaster(HamaConfiguration, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Starts the BSP Master process.
 * @param conf The Hama configuration.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BSPMaster
/** 
 * Starts the BSP Master process.
 * @param conf The Hama configuration.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */
public static BSPMaster startMaster(HamaConfiguration conf) throws IOException, InterruptedException {
  return startMaster(conf,generateNewIdentifier());
}

ID 189=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#startMaster(HamaConfiguration)
Rmethod: org.apache.hama.bsp.BSPMaster#startMaster(HamaConfiguration, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Starts the BSP Master process.
 * @param conf The Hama configuration.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BSPMaster
/** 
 * Starts the BSP Master process.
 * @param conf The Hama configuration.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */
public static BSPMaster startMaster(HamaConfiguration conf) throws IOException, InterruptedException {
  return startMaster(conf,generateNewIdentifier());
}

ID 190=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#startMaster(HamaConfiguration, java.lang.String)
Rmethod: org.apache.hama.bsp.BSPMaster#BSPMaster(HamaConfiguration, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Starts the BSP Master process
 * @param conf The Hama configuration
 * @param identifier Identifier for the job.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BSPMaster
/** 
 * Starts the BSP Master process
 * @param conf The Hama configuration
 * @param identifier Identifier for the job.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */
public static BSPMaster startMaster(HamaConfiguration conf,String identifier) throws IOException, InterruptedException {
  BSPMaster result=new BSPMaster(conf,identifier);
  result.initZK(conf);
  result.taskScheduler.setGroomServerManager(result);
  result.taskScheduler.setMonitorManager(result);
  if (conf.getBoolean("bsp.monitor.fd.enabled",false)) {
    result.supervisor.get().start();
  }
  result.taskScheduler.start();
  return result;
}

ID 191=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#startMaster(HamaConfiguration, java.lang.String)
Rmethod: org.apache.hama.bsp.BSPMaster#BSPMaster(HamaConfiguration, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Starts the BSP Master process
 * @param conf The Hama configuration
 * @param identifier Identifier for the job.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
BSPMaster
/** 
 * Starts the BSP Master process
 * @param conf The Hama configuration
 * @param identifier Identifier for the job.
 * @return an instance of BSPMaster
 * @throws IOException
 * @throws InterruptedException
 */
public static BSPMaster startMaster(HamaConfiguration conf,String identifier) throws IOException, InterruptedException {
  BSPMaster result=new BSPMaster(conf,identifier);
  result.initZK(conf);
  result.taskScheduler.setGroomServerManager(result);
  result.taskScheduler.setMonitorManager(result);
  if (conf.getBoolean("bsp.monitor.fd.enabled",false)) {
    result.supervisor.get().start();
  }
  result.taskScheduler.start();
  return result;
}

ID 192=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#killJob(BSPJobID)
Rmethod: org.apache.hama.bsp.BSPMaster#killJob(BSPJobID)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMaster
@Override public void killJob(BSPJobID jobid) throws IOException {
  JobInProgress job=jobs.get(jobid);
  if (null == job) {
    LOG.info("killJob(): JobId " + jobid.toString() + " is not a valid job");
    return;
  }
  killJob(job);
}

ID 193=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#constructMaster(Class<? extends org.apache.hama.bsp.BSPMaster>, Configuration)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
}

block: 
BSPMaster
public static BSPMaster constructMaster(Class<? extends BSPMaster> masterClass,final Configuration conf){
  try {
    Constructor<? extends BSPMaster> c=masterClass.getConstructor(Configuration.class);
    return c.newInstance(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
  }
}

ID 194=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#constructMaster(Class<? extends org.apache.hama.bsp.BSPMaster>, Configuration)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
}

block: 
BSPMaster
public static BSPMaster constructMaster(Class<? extends BSPMaster> masterClass,final Configuration conf){
  try {
    Constructor<? extends BSPMaster> c=masterClass.getConstructor(Configuration.class);
    return c.newInstance(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
  }
}

ID 195=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#constructMaster(Class<? extends org.apache.hama.bsp.BSPMaster>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
}

block: 
BSPMaster
public static BSPMaster constructMaster(Class<? extends BSPMaster> masterClass,final Configuration conf){
  try {
    Constructor<? extends BSPMaster> c=masterClass.getConstructor(Configuration.class);
    return c.newInstance(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
  }
}

ID 196=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#constructMaster(Class<? extends org.apache.hama.bsp.BSPMaster>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
}

block: 
BSPMaster
public static BSPMaster constructMaster(Class<? extends BSPMaster> masterClass,final Configuration conf){
  try {
    Constructor<? extends BSPMaster> c=masterClass.getConstructor(Configuration.class);
    return c.newInstance(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
  }
}

ID 197=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#constructMaster(Class<? extends org.apache.hama.bsp.BSPMaster>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
}

block: 
BSPMaster
public static BSPMaster constructMaster(Class<? extends BSPMaster> masterClass,final Configuration conf){
  try {
    Constructor<? extends BSPMaster> c=masterClass.getConstructor(Configuration.class);
    return c.newInstance(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
  }
}

ID 198=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMaster#constructMaster(Class<? extends org.apache.hama.bsp.BSPMaster>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
}

block: 
BSPMaster
public static BSPMaster constructMaster(Class<? extends BSPMaster> masterClass,final Configuration conf){
  try {
    Constructor<? extends BSPMaster> c=masterClass.getConstructor(Configuration.class);
    return c.newInstance(conf);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + masterClass.toString() + ((e.getCause() != null) ? e.getCause().getMessage() : ""),e);
  }
}

ID 199=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMessageBundle#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMessageBundle
@SuppressWarnings("unchecked") @Override public void write(DataOutput out) throws IOException {
  out.writeInt(messages.size());
  if (messages.size() > 0) {
    Class<M> clazz=(Class<M>)messages.get(0).getClass();
    out.writeUTF(clazz.getName());
    for (    M m : messages) {
      m.write(out);
    }
  }
}

ID 200=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMessageBundle#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMessageBundle
@SuppressWarnings("unchecked") @Override public void write(DataOutput out) throws IOException {
  out.writeInt(messages.size());
  if (messages.size() > 0) {
    Class<M> clazz=(Class<M>)messages.get(0).getClass();
    out.writeUTF(clazz.getName());
    for (    M m : messages) {
      m.write(out);
    }
  }
}

ID 201=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMessageBundle#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMessageBundle
@SuppressWarnings("unchecked") @Override public void readFields(DataInput in) throws IOException {
  int num=in.readInt();
  if (num > 0) {
    Class<M> clazz=null;
    try {
      clazz=(Class<M>)Class.forName(in.readUTF());
    }
 catch (    ClassNotFoundException e) {
      LOG.error("Class was not found.",e);
    }
    for (int i=0; i < num; i++) {
      M msg=ReflectionUtils.newInstance(clazz);
      msg.readFields(in);
      messages.add(msg);
    }
  }
}

ID 202=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMessageBundle#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPMessageBundle
@SuppressWarnings("unchecked") @Override public void readFields(DataInput in) throws IOException {
  int num=in.readInt();
  if (num > 0) {
    Class<M> clazz=null;
    try {
      clazz=(Class<M>)Class.forName(in.readUTF());
    }
 catch (    ClassNotFoundException e) {
      LOG.error("Class was not found.",e);
    }
    for (int i=0; i < num; i++) {
      M msg=ReflectionUtils.newInstance(clazz);
      msg.readFields(in);
      messages.add(msg);
    }
  }
}

ID 203=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPMessageBundle#readFields(java.io.DataInput)
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (ClassNotFoundException e) {
  LOG.error("Class was not found.",e);
}

block: 
BSPMessageBundle
@SuppressWarnings("unchecked") @Override public void readFields(DataInput in) throws IOException {
  int num=in.readInt();
  if (num > 0) {
    Class<M> clazz=null;
    try {
      clazz=(Class<M>)Class.forName(in.readUTF());
    }
 catch (    ClassNotFoundException e) {
      LOG.error("Class was not found.",e);
    }
    for (int i=0; i < num; i++) {
      M msg=ReflectionUtils.newInstance(clazz);
      msg.readFields(in);
      messages.add(msg);
    }
  }
}

ID 204=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getCanonicalHostname()
Rmethod: java.net.InetAddress#getLocalHost()
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

method comment: /** 
 * Gets the canonical hostname of this machine.
 * @return String representing host canonical host name
 * @throws UnknownHostException
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Gets the canonical hostname of this machine.
 * @return String representing host canonical host name
 * @throws UnknownHostException
 */
public static String getCanonicalHostname() throws UnknownHostException {
  return InetAddress.getLocalHost().getCanonicalHostName();
}

ID 205=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getAddress(java.lang.String)
Rmethod: java.lang.Integer#valueOf(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Gets a new InetSocketAddress from the given peerName. peerName must contain a colon to distinct between host and port.
 * @param peerName the name as a String of the BSP peer to get the addressfrom
 * @return the InetSocketAddress of the given BSP peer
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Gets a new InetSocketAddress from the given peerName. peerName must contain a colon to distinct between host and port.
 * @param peerName the name as a String of the BSP peer to get the addressfrom
 * @return the InetSocketAddress of the given BSP peer
 */
public static InetSocketAddress getAddress(String peerName){
  int index=peerName.lastIndexOf(':');
  if (index <= 0 || index == peerName.length() - 1) {
    throw new ArrayIndexOutOfBoundsException("Invalid host and port information. " + "Peername must consist of atleast ONE \":\"! " + "Given peername was: "+ peerName);
  }
  return new InetSocketAddress(peerName.substring(0,index),Integer.valueOf(peerName.substring(index + 1)));
}

ID 206=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#available(int)
Rmethod: java.net.ServerSocket#ServerSocket(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */

catch: 
catch (IOException e) {
}

block: 
BSPNetUtils
/** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */
public static boolean available(int port){
  if (port < 1000 || port > MAX_PORT_NUMBER) {
    throw new IllegalArgumentException("Invalid start port: " + port);
  }
  ServerSocket ss=null;
  DatagramSocket ds=null;
  try {
    ss=new ServerSocket(port);
    ss.setReuseAddress(true);
    ds=new DatagramSocket(port);
    ds.setReuseAddress(true);
    return true;
  }
 catch (  IOException e) {
  }
 finally {
    if (ds != null) {
      ds.close();
    }
    if (ss != null) {
      try {
        ss.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return false;
}

ID 207=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#available(int)
Rmethod: java.net.ServerSocket#setReuseAddress(boolean)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */

catch: 
catch (IOException e) {
}

block: 
BSPNetUtils
/** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */
public static boolean available(int port){
  if (port < 1000 || port > MAX_PORT_NUMBER) {
    throw new IllegalArgumentException("Invalid start port: " + port);
  }
  ServerSocket ss=null;
  DatagramSocket ds=null;
  try {
    ss=new ServerSocket(port);
    ss.setReuseAddress(true);
    ds=new DatagramSocket(port);
    ds.setReuseAddress(true);
    return true;
  }
 catch (  IOException e) {
  }
 finally {
    if (ds != null) {
      ds.close();
    }
    if (ss != null) {
      try {
        ss.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return false;
}

ID 208=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#available(int)
Rmethod: java.net.DatagramSocket#DatagramSocket(int)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */

catch: 
catch (IOException e) {
}

block: 
BSPNetUtils
/** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */
public static boolean available(int port){
  if (port < 1000 || port > MAX_PORT_NUMBER) {
    throw new IllegalArgumentException("Invalid start port: " + port);
  }
  ServerSocket ss=null;
  DatagramSocket ds=null;
  try {
    ss=new ServerSocket(port);
    ss.setReuseAddress(true);
    ds=new DatagramSocket(port);
    ds.setReuseAddress(true);
    return true;
  }
 catch (  IOException e) {
  }
 finally {
    if (ds != null) {
      ds.close();
    }
    if (ss != null) {
      try {
        ss.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return false;
}

ID 209=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#available(int)
Rmethod: java.net.DatagramSocket#setReuseAddress(boolean)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */

catch: 
catch (IOException e) {
}

block: 
BSPNetUtils
/** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */
public static boolean available(int port){
  if (port < 1000 || port > MAX_PORT_NUMBER) {
    throw new IllegalArgumentException("Invalid start port: " + port);
  }
  ServerSocket ss=null;
  DatagramSocket ds=null;
  try {
    ss=new ServerSocket(port);
    ss.setReuseAddress(true);
    ds=new DatagramSocket(port);
    ds.setReuseAddress(true);
    return true;
  }
 catch (  IOException e) {
  }
 finally {
    if (ds != null) {
      ds.close();
    }
    if (ss != null) {
      try {
        ss.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return false;
}

ID 210=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#available(int)
Rmethod: java.net.ServerSocket#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */

catch: 
catch (IOException e) {
}

block: 
BSPNetUtils
/** 
 * Checks to see if a specific port is available.
 * @param port the port to check for availability
 */
public static boolean available(int port){
  if (port < 1000 || port > MAX_PORT_NUMBER) {
    throw new IllegalArgumentException("Invalid start port: " + port);
  }
  ServerSocket ss=null;
  DatagramSocket ds=null;
  try {
    ss=new ServerSocket(port);
    ss.setReuseAddress(true);
    ds=new DatagramSocket(port);
    ds.setReuseAddress(true);
    return true;
  }
 catch (  IOException e) {
  }
 finally {
    if (ds != null) {
      ds.close();
    }
    if (ss != null) {
      try {
        ss.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return false;
}

ID 211=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#makeSocketAddr(java.lang.String, int)
Rmethod: java.net.InetAddress#getByAddress(java.lang.String, byte[])
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

method comment: /** 
 * Create a socket address with the given host and port. The hostname might be replaced with another host that was set via {@link NetUtils#addStaticResolution(String,String)}. The value of hadoop.security.token.service.use_ip will determine whether the standard java host resolver is used, or if the fully qualified resolver is used.
 * @param host the hostname or IP use to instantiate the object
 * @param port the port number
 * @return InetSocketAddress
 */

catch: 
catch (UnknownHostException e) {
  addr=InetSocketAddress.createUnresolved(host,port);
}

block: 
BSPNetUtils
/** 
 * Create a socket address with the given host and port. The hostname might be replaced with another host that was set via {@link NetUtils#addStaticResolution(String,String)}. The value of hadoop.security.token.service.use_ip will determine whether the standard java host resolver is used, or if the fully qualified resolver is used.
 * @param host the hostname or IP use to instantiate the object
 * @param port the port number
 * @return InetSocketAddress
 */
public static InetSocketAddress makeSocketAddr(String host,int port){
  String staticHost=getStaticResolution(host);
  String resolveHost=(staticHost != null) ? staticHost : host;
  InetSocketAddress addr;
  try {
    InetAddress iaddr=SecurityUtil.getByName(resolveHost);
    if (staticHost != null) {
      iaddr=InetAddress.getByAddress(host,iaddr.getAddress());
    }
    addr=new InetSocketAddress(iaddr,port);
  }
 catch (  UnknownHostException e) {
    addr=InetSocketAddress.createUnresolved(host,port);
  }
  return addr;
}

ID 212=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getLocalInetAddress(java.lang.String)
Rmethod: java.net.InetAddress#getByName(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

method comment: /** 
 * Checks if  {@code host} is a local host name and return {@link InetAddress}corresponding to that address.
 * @param host the specified host
 * @return a valid local {@link InetAddress} or null
 * @throws SocketException if an I/O error occurs
 */

catch: 
catch (UnknownHostException ignore) {
}

block: 
BSPNetUtils
/** 
 * Checks if  {@code host} is a local host name and return {@link InetAddress}corresponding to that address.
 * @param host the specified host
 * @return a valid local {@link InetAddress} or null
 * @throws SocketException if an I/O error occurs
 */
public static InetAddress getLocalInetAddress(String host) throws SocketException {
  if (host == null) {
    return null;
  }
  InetAddress addr=null;
  try {
    addr=InetAddress.getByName(host);
    if (NetworkInterface.getByInetAddress(addr) == null) {
      addr=null;
    }
  }
 catch (  UnknownHostException ignore) {
  }
  return addr;
}

ID 213=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getLocalInetAddress(java.lang.String)
Rmethod: java.net.NetworkInterface#getByInetAddress(java.net.InetAddress)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Checks if  {@code host} is a local host name and return {@link InetAddress}corresponding to that address.
 * @param host the specified host
 * @return a valid local {@link InetAddress} or null
 * @throws SocketException if an I/O error occurs
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Checks if  {@code host} is a local host name and return {@link InetAddress}corresponding to that address.
 * @param host the specified host
 * @return a valid local {@link InetAddress} or null
 * @throws SocketException if an I/O error occurs
 */
public static InetAddress getLocalInetAddress(String host) throws SocketException {
  if (host == null) {
    return null;
  }
  InetAddress addr=null;
  try {
    addr=InetAddress.getByName(host);
    if (NetworkInterface.getByInetAddress(addr) == null) {
      addr=null;
    }
  }
 catch (  UnknownHostException ignore) {
  }
  return addr;
}

ID 214=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#connect(java.net.Socket, java.net.SocketAddress, int)
Rmethod: org.apache.hama.util.BSPNetUtils#connect(java.net.Socket, java.net.SocketAddress, java.net.SocketAddress, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * This is a drop-in replacement for {@link Socket#connect(SocketAddress,int)}. In the case of normal sockets that don't have associated channels, this just invokes <code>socket.connect(endpoint, timeout)</code>. If <code>socket.getChannel()</code> returns a non-null channel, connect is implemented using Hadoop's selectors. This is done mainly to avoid Sun's connect implementation from creating thread-local selectors, since Hadoop does not have control on when these are closed and could end up taking all the available file descriptors.
 * @see java.net.Socket#connect(java.net.SocketAddress,int)
 * @param socket
 * @param address the remote address
 * @param timeout timeout in milliseconds
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * This is a drop-in replacement for {@link Socket#connect(SocketAddress,int)}. In the case of normal sockets that don't have associated channels, this just invokes <code>socket.connect(endpoint, timeout)</code>. If <code>socket.getChannel()</code> returns a non-null channel, connect is implemented using Hadoop's selectors. This is done mainly to avoid Sun's connect implementation from creating thread-local selectors, since Hadoop does not have control on when these are closed and could end up taking all the available file descriptors.
 * @see java.net.Socket#connect(java.net.SocketAddress,int)
 * @param socket
 * @param address the remote address
 * @param timeout timeout in milliseconds
 */
public static void connect(Socket socket,SocketAddress address,int timeout) throws IOException {
  connect(socket,address,null,timeout);
}

ID 215=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#connect(java.net.Socket, java.net.SocketAddress, java.net.SocketAddress, int)
Rmethod: java.net.Socket#bind(java.net.SocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Like  {@link NetUtils#connect(Socket,SocketAddress,int)} but also takes alocal address and port to bind the socket to.
 * @param socket
 * @param endpoint the remote address
 * @param localAddr the local address to bind the socket to
 * @param timeout timeout in milliseconds
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Like  {@link NetUtils#connect(Socket,SocketAddress,int)} but also takes alocal address and port to bind the socket to.
 * @param socket
 * @param endpoint the remote address
 * @param localAddr the local address to bind the socket to
 * @param timeout timeout in milliseconds
 */
public static void connect(Socket socket,SocketAddress endpoint,SocketAddress localAddr,int timeout) throws IOException {
  if (socket == null || endpoint == null || timeout < 0) {
    throw new IllegalArgumentException("Illegal argument for connect()");
  }
  SocketChannel ch=socket.getChannel();
  if (localAddr != null) {
    socket.bind(localAddr);
  }
  if (ch == null) {
    socket.connect(endpoint,timeout);
  }
 else {
    SocketIOWithTimeout.connect(ch,endpoint,timeout);
  }
  if (socket.getLocalPort() == socket.getPort() && socket.getLocalAddress().equals(socket.getInetAddress())) {
    LOG.info("Detected a loopback TCP socket, disconnecting it");
    socket.close();
    throw new ConnectException("Localhost targeted connection resulted in a loopback. " + "No daemon is listening on the target port.");
  }
}

ID 216=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#connect(java.net.Socket, java.net.SocketAddress, java.net.SocketAddress, int)
Rmethod: java.net.Socket#connect(java.net.SocketAddress, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Like  {@link NetUtils#connect(Socket,SocketAddress,int)} but also takes alocal address and port to bind the socket to.
 * @param socket
 * @param endpoint the remote address
 * @param localAddr the local address to bind the socket to
 * @param timeout timeout in milliseconds
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Like  {@link NetUtils#connect(Socket,SocketAddress,int)} but also takes alocal address and port to bind the socket to.
 * @param socket
 * @param endpoint the remote address
 * @param localAddr the local address to bind the socket to
 * @param timeout timeout in milliseconds
 */
public static void connect(Socket socket,SocketAddress endpoint,SocketAddress localAddr,int timeout) throws IOException {
  if (socket == null || endpoint == null || timeout < 0) {
    throw new IllegalArgumentException("Illegal argument for connect()");
  }
  SocketChannel ch=socket.getChannel();
  if (localAddr != null) {
    socket.bind(localAddr);
  }
  if (ch == null) {
    socket.connect(endpoint,timeout);
  }
 else {
    SocketIOWithTimeout.connect(ch,endpoint,timeout);
  }
  if (socket.getLocalPort() == socket.getPort() && socket.getLocalAddress().equals(socket.getInetAddress())) {
    LOG.info("Detected a loopback TCP socket, disconnecting it");
    socket.close();
    throw new ConnectException("Localhost targeted connection resulted in a loopback. " + "No daemon is listening on the target port.");
  }
}

ID 217=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#connect(java.net.Socket, java.net.SocketAddress, java.net.SocketAddress, int)
Rmethod: java.net.Socket#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Like  {@link NetUtils#connect(Socket,SocketAddress,int)} but also takes alocal address and port to bind the socket to.
 * @param socket
 * @param endpoint the remote address
 * @param localAddr the local address to bind the socket to
 * @param timeout timeout in milliseconds
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Like  {@link NetUtils#connect(Socket,SocketAddress,int)} but also takes alocal address and port to bind the socket to.
 * @param socket
 * @param endpoint the remote address
 * @param localAddr the local address to bind the socket to
 * @param timeout timeout in milliseconds
 */
public static void connect(Socket socket,SocketAddress endpoint,SocketAddress localAddr,int timeout) throws IOException {
  if (socket == null || endpoint == null || timeout < 0) {
    throw new IllegalArgumentException("Illegal argument for connect()");
  }
  SocketChannel ch=socket.getChannel();
  if (localAddr != null) {
    socket.bind(localAddr);
  }
  if (ch == null) {
    socket.connect(endpoint,timeout);
  }
 else {
    SocketIOWithTimeout.connect(ch,endpoint,timeout);
  }
  if (socket.getLocalPort() == socket.getPort() && socket.getLocalAddress().equals(socket.getInetAddress())) {
    LOG.info("Detected a loopback TCP socket, disconnecting it");
    socket.close();
    throw new ConnectException("Localhost targeted connection resulted in a loopback. " + "No daemon is listening on the target port.");
  }
}

ID 218=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getInputStream(java.net.Socket)
Rmethod: java.net.Socket#getSoTimeout()
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Same as getInputStream(socket, socket.getSoTimeout()).<br> <br> From documentation for  {@link #getInputStream(Socket,long)}:<br> Returns InputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketInputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getInputStream()} is returned. In the later case, the timeoutargument is ignored and the timeout set with {@link Socket#setSoTimeout(int)} applies for reads.<br><br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getInputStream()}.
 * @see #getInputStream(Socket,long)
 * @param socket
 * @return InputStream for reading from the socket.
 * @throws IOException
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Same as getInputStream(socket, socket.getSoTimeout()).<br> <br> From documentation for  {@link #getInputStream(Socket,long)}:<br> Returns InputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketInputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getInputStream()} is returned. In the later case, the timeoutargument is ignored and the timeout set with {@link Socket#setSoTimeout(int)} applies for reads.<br><br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getInputStream()}.
 * @see #getInputStream(Socket,long)
 * @param socket
 * @return InputStream for reading from the socket.
 * @throws IOException
 */
public static InputStream getInputStream(Socket socket) throws IOException {
  return getInputStream(socket,socket.getSoTimeout());
}

ID 219=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getInputStream(java.net.Socket)
Rmethod: org.apache.hama.util.BSPNetUtils#getInputStream(java.net.Socket, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Same as getInputStream(socket, socket.getSoTimeout()).<br> <br> From documentation for  {@link #getInputStream(Socket,long)}:<br> Returns InputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketInputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getInputStream()} is returned. In the later case, the timeoutargument is ignored and the timeout set with {@link Socket#setSoTimeout(int)} applies for reads.<br><br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getInputStream()}.
 * @see #getInputStream(Socket,long)
 * @param socket
 * @return InputStream for reading from the socket.
 * @throws IOException
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Same as getInputStream(socket, socket.getSoTimeout()).<br> <br> From documentation for  {@link #getInputStream(Socket,long)}:<br> Returns InputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketInputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getInputStream()} is returned. In the later case, the timeoutargument is ignored and the timeout set with {@link Socket#setSoTimeout(int)} applies for reads.<br><br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getInputStream()}.
 * @see #getInputStream(Socket,long)
 * @param socket
 * @return InputStream for reading from the socket.
 * @throws IOException
 */
public static InputStream getInputStream(Socket socket) throws IOException {
  return getInputStream(socket,socket.getSoTimeout());
}

ID 220=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getInputStream(java.net.Socket, long)
Rmethod: java.net.Socket#getInputStream()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Returns InputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketInputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getInputStream()} is returned. In the later case, the timeoutargument is ignored and the timeout set with {@link Socket#setSoTimeout(int)} applies for reads.<br><br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getInputStream()}.
 * @see Socket#getChannel()
 * @param socket
 * @param timeout timeout in milliseconds. This may not always apply. zero forwaiting as long as necessary.
 * @return InputStream for reading from the socket.
 * @throws IOException
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Returns InputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketInputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getInputStream()} is returned. In the later case, the timeoutargument is ignored and the timeout set with {@link Socket#setSoTimeout(int)} applies for reads.<br><br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getInputStream()}.
 * @see Socket#getChannel()
 * @param socket
 * @param timeout timeout in milliseconds. This may not always apply. zero forwaiting as long as necessary.
 * @return InputStream for reading from the socket.
 * @throws IOException
 */
public static InputStream getInputStream(Socket socket,long timeout) throws IOException {
  return (socket.getChannel() == null) ? socket.getInputStream() : new SocketInputStream(socket,timeout);
}

ID 221=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getOutputStream(java.net.Socket)
Rmethod: org.apache.hama.util.BSPNetUtils#getOutputStream(java.net.Socket, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Same as getOutputStream(socket, 0). Timeout of zero implies write will wait until data is available.<br> <br> From documentation for  {@link #getOutputStream(Socket,long)} : <br>Returns OutputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketOutputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getOutputStream()} is returned. In the later case, thetimeout argument is ignored and the write will wait until data is available.<br> <br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getOutputStream()}.
 * @see #getOutputStream(Socket,long)
 * @param socket
 * @return OutputStream for writing to the socket.
 * @throws IOException
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Same as getOutputStream(socket, 0). Timeout of zero implies write will wait until data is available.<br> <br> From documentation for  {@link #getOutputStream(Socket,long)} : <br>Returns OutputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketOutputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getOutputStream()} is returned. In the later case, thetimeout argument is ignored and the write will wait until data is available.<br> <br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getOutputStream()}.
 * @see #getOutputStream(Socket,long)
 * @param socket
 * @return OutputStream for writing to the socket.
 * @throws IOException
 */
public static OutputStream getOutputStream(Socket socket) throws IOException {
  return getOutputStream(socket,0);
}

ID 222=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.BSPNetUtils#getOutputStream(java.net.Socket, long)
Rmethod: java.net.Socket#getOutputStream()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Returns OutputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketOutputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getOutputStream()} is returned. In the later case, thetimeout argument is ignored and the write will wait until data is available.<br> <br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getOutputStream()}.
 * @see Socket#getChannel()
 * @param socket
 * @param timeout timeout in milliseconds. This may not always apply. zero forwaiting as long as necessary.
 * @return OutputStream for writing to the socket.
 * @throws IOException
 */

catch: 
null
block: 
BSPNetUtils
/** 
 * Returns OutputStream for the socket. If the socket has an associated SocketChannel then it returns a  {@link SocketOutputStream} with the giventimeout. If the socket does not have a channel, {@link Socket#getOutputStream()} is returned. In the later case, thetimeout argument is ignored and the write will wait until data is available.<br> <br> Any socket created using socket factories returned by  {@link NetUtils}, must use this interface instead of  {@link Socket#getOutputStream()}.
 * @see Socket#getChannel()
 * @param socket
 * @param timeout timeout in milliseconds. This may not always apply. zero forwaiting as long as necessary.
 * @return OutputStream for writing to the socket.
 * @throws IOException
 */
public static OutputStream getOutputStream(Socket socket,long timeout) throws IOException {
  return (socket.getChannel() == null) ? socket.getOutputStream() : new SocketOutputStream(socket,timeout);
}

ID 223=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#BSPPeerImpl(BSPJob, HamaConfiguration, TaskAttemptID, BSPPeerProtocol, int, java.lang.String, BytesWritable, Counters, long, TaskStatus.State)
Rmethod: org.apache.hama.bsp.BSPPeerImpl#initializeMessaging()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */

catch: 
null
block: 
BSPPeerImpl
/** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */
@SuppressWarnings("unchecked") public BSPPeerImpl(BSPJob job,HamaConfiguration conf,TaskAttemptID taskId,BSPPeerProtocol umbilical,int partition,String splitClass,BytesWritable split,Counters counters,long superstep,TaskStatus.State state) throws Exception {
  this.conf=conf;
  this.taskId=taskId;
  this.umbilical=umbilical;
  this.bspJob=job;
  this.partition=partition;
  this.splitClass=splitClass;
  this.split=split;
  this.counters=counters;
  this.fs=FileSystem.get(conf);
  String bindAddress=conf.get(Constants.PEER_HOST,Constants.DEFAULT_PEER_HOST);
  int bindPort=conf.getInt(Constants.PEER_PORT,Constants.DEFAULT_PEER_PORT);
  peerAddress=new InetSocketAddress(bindAddress,bindPort);
  initializeMessaging();
  conf.set(Constants.PEER_HOST,peerAddress.getHostName());
  conf.setInt(Constants.PEER_PORT,peerAddress.getPort());
  if (LOG.isDebugEnabled()) {
    LOG.debug("Initialized Messaging service.");
  }
  initializeIO();
  initializeSyncService(superstep,state);
  TaskStatus.Phase phase=TaskStatus.Phase.STARTING;
  String stateString="running";
  if (state == TaskStatus.State.RECOVERING) {
    phase=TaskStatus.Phase.RECOVERING;
    stateString="recovering";
  }
  setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
  if (conf.getBoolean(Constants.FAULT_TOLERANCE_FLAG,false)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Fault tolerance enabled.");
    }
    if (superstep > 0)     conf.setInt("attempt.superstep",(int)superstep);
    Class<?> ftClass=conf.getClass(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class,BSPFaultTolerantService.class);
    if (ftClass != null) {
      if (superstep > 0) {
        counters.incrCounter(PeerCounter.SUPERSTEP_SUM,superstep);
      }
      this.faultToleranceService=((BSPFaultTolerantService<M>)ReflectionUtils.newInstance(ftClass,null)).constructPeerFaultTolerance(job,this,syncClient,peerAddress,this.taskId,superstep,conf,messenger);
      TaskStatus.State newState=this.faultToleranceService.onPeerInitialized(state);
      if (state == TaskStatus.State.RECOVERING) {
        if (newState == TaskStatus.State.RUNNING) {
          phase=TaskStatus.Phase.STARTING;
          stateString="running";
          state=newState;
        }
        setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
        if (LOG.isDebugEnabled()) {
          LOG.debug("State after FT service initialization - " + newState.toString());
        }
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Initialized fault tolerance service");
      }
    }
  }
  doFirstSync(superstep);
  if (LOG.isDebugEnabled()) {
    LOG.info(new StringBuffer("BSP Peer successfully initialized for ").append(this.taskId.toString()).append(" ").append(superstep).toString());
  }
}

ID 224=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#BSPPeerImpl(BSPJob, HamaConfiguration, TaskAttemptID, BSPPeerProtocol, int, java.lang.String, BytesWritable, Counters, long, TaskStatus.State)
Rmethod: org.apache.hama.bsp.BSPPeerImpl#initializeIO()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */

catch: 
null
block: 
BSPPeerImpl
/** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */
@SuppressWarnings("unchecked") public BSPPeerImpl(BSPJob job,HamaConfiguration conf,TaskAttemptID taskId,BSPPeerProtocol umbilical,int partition,String splitClass,BytesWritable split,Counters counters,long superstep,TaskStatus.State state) throws Exception {
  this.conf=conf;
  this.taskId=taskId;
  this.umbilical=umbilical;
  this.bspJob=job;
  this.partition=partition;
  this.splitClass=splitClass;
  this.split=split;
  this.counters=counters;
  this.fs=FileSystem.get(conf);
  String bindAddress=conf.get(Constants.PEER_HOST,Constants.DEFAULT_PEER_HOST);
  int bindPort=conf.getInt(Constants.PEER_PORT,Constants.DEFAULT_PEER_PORT);
  peerAddress=new InetSocketAddress(bindAddress,bindPort);
  initializeMessaging();
  conf.set(Constants.PEER_HOST,peerAddress.getHostName());
  conf.setInt(Constants.PEER_PORT,peerAddress.getPort());
  if (LOG.isDebugEnabled()) {
    LOG.debug("Initialized Messaging service.");
  }
  initializeIO();
  initializeSyncService(superstep,state);
  TaskStatus.Phase phase=TaskStatus.Phase.STARTING;
  String stateString="running";
  if (state == TaskStatus.State.RECOVERING) {
    phase=TaskStatus.Phase.RECOVERING;
    stateString="recovering";
  }
  setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
  if (conf.getBoolean(Constants.FAULT_TOLERANCE_FLAG,false)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Fault tolerance enabled.");
    }
    if (superstep > 0)     conf.setInt("attempt.superstep",(int)superstep);
    Class<?> ftClass=conf.getClass(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class,BSPFaultTolerantService.class);
    if (ftClass != null) {
      if (superstep > 0) {
        counters.incrCounter(PeerCounter.SUPERSTEP_SUM,superstep);
      }
      this.faultToleranceService=((BSPFaultTolerantService<M>)ReflectionUtils.newInstance(ftClass,null)).constructPeerFaultTolerance(job,this,syncClient,peerAddress,this.taskId,superstep,conf,messenger);
      TaskStatus.State newState=this.faultToleranceService.onPeerInitialized(state);
      if (state == TaskStatus.State.RECOVERING) {
        if (newState == TaskStatus.State.RUNNING) {
          phase=TaskStatus.Phase.STARTING;
          stateString="running";
          state=newState;
        }
        setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
        if (LOG.isDebugEnabled()) {
          LOG.debug("State after FT service initialization - " + newState.toString());
        }
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Initialized fault tolerance service");
      }
    }
  }
  doFirstSync(superstep);
  if (LOG.isDebugEnabled()) {
    LOG.info(new StringBuffer("BSP Peer successfully initialized for ").append(this.taskId.toString()).append(" ").append(superstep).toString());
  }
}

ID 225=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#BSPPeerImpl(BSPJob, HamaConfiguration, TaskAttemptID, BSPPeerProtocol, int, java.lang.String, BytesWritable, Counters, long, TaskStatus.State)
Rmethod: org.apache.hama.bsp.BSPPeerImpl#initializeSyncService(long, TaskStatus.State)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */

catch: 
null
block: 
BSPPeerImpl
/** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */
@SuppressWarnings("unchecked") public BSPPeerImpl(BSPJob job,HamaConfiguration conf,TaskAttemptID taskId,BSPPeerProtocol umbilical,int partition,String splitClass,BytesWritable split,Counters counters,long superstep,TaskStatus.State state) throws Exception {
  this.conf=conf;
  this.taskId=taskId;
  this.umbilical=umbilical;
  this.bspJob=job;
  this.partition=partition;
  this.splitClass=splitClass;
  this.split=split;
  this.counters=counters;
  this.fs=FileSystem.get(conf);
  String bindAddress=conf.get(Constants.PEER_HOST,Constants.DEFAULT_PEER_HOST);
  int bindPort=conf.getInt(Constants.PEER_PORT,Constants.DEFAULT_PEER_PORT);
  peerAddress=new InetSocketAddress(bindAddress,bindPort);
  initializeMessaging();
  conf.set(Constants.PEER_HOST,peerAddress.getHostName());
  conf.setInt(Constants.PEER_PORT,peerAddress.getPort());
  if (LOG.isDebugEnabled()) {
    LOG.debug("Initialized Messaging service.");
  }
  initializeIO();
  initializeSyncService(superstep,state);
  TaskStatus.Phase phase=TaskStatus.Phase.STARTING;
  String stateString="running";
  if (state == TaskStatus.State.RECOVERING) {
    phase=TaskStatus.Phase.RECOVERING;
    stateString="recovering";
  }
  setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
  if (conf.getBoolean(Constants.FAULT_TOLERANCE_FLAG,false)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Fault tolerance enabled.");
    }
    if (superstep > 0)     conf.setInt("attempt.superstep",(int)superstep);
    Class<?> ftClass=conf.getClass(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class,BSPFaultTolerantService.class);
    if (ftClass != null) {
      if (superstep > 0) {
        counters.incrCounter(PeerCounter.SUPERSTEP_SUM,superstep);
      }
      this.faultToleranceService=((BSPFaultTolerantService<M>)ReflectionUtils.newInstance(ftClass,null)).constructPeerFaultTolerance(job,this,syncClient,peerAddress,this.taskId,superstep,conf,messenger);
      TaskStatus.State newState=this.faultToleranceService.onPeerInitialized(state);
      if (state == TaskStatus.State.RECOVERING) {
        if (newState == TaskStatus.State.RUNNING) {
          phase=TaskStatus.Phase.STARTING;
          stateString="running";
          state=newState;
        }
        setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
        if (LOG.isDebugEnabled()) {
          LOG.debug("State after FT service initialization - " + newState.toString());
        }
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Initialized fault tolerance service");
      }
    }
  }
  doFirstSync(superstep);
  if (LOG.isDebugEnabled()) {
    LOG.info(new StringBuffer("BSP Peer successfully initialized for ").append(this.taskId.toString()).append(" ").append(superstep).toString());
  }
}

ID 226=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#BSPPeerImpl(BSPJob, HamaConfiguration, TaskAttemptID, BSPPeerProtocol, int, java.lang.String, BytesWritable, Counters, long, TaskStatus.State)
Rmethod: org.apache.hama.bsp.BSPPeerImpl#doFirstSync(long)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.SyncException
exception comment: null
method comment: /** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */

catch: 
null
block: 
BSPPeerImpl
/** 
 * BSPPeer Constructor. BSPPeer acts on behalf of clients performing bsp() tasks.
 * @param conf is the configuration file containing bsp peer host, port, etc.
 * @param umbilical is the bsp protocol used to contact its parent process.
 * @param taskId is the id that current process holds.
 * @throws Exception
 */
@SuppressWarnings("unchecked") public BSPPeerImpl(BSPJob job,HamaConfiguration conf,TaskAttemptID taskId,BSPPeerProtocol umbilical,int partition,String splitClass,BytesWritable split,Counters counters,long superstep,TaskStatus.State state) throws Exception {
  this.conf=conf;
  this.taskId=taskId;
  this.umbilical=umbilical;
  this.bspJob=job;
  this.partition=partition;
  this.splitClass=splitClass;
  this.split=split;
  this.counters=counters;
  this.fs=FileSystem.get(conf);
  String bindAddress=conf.get(Constants.PEER_HOST,Constants.DEFAULT_PEER_HOST);
  int bindPort=conf.getInt(Constants.PEER_PORT,Constants.DEFAULT_PEER_PORT);
  peerAddress=new InetSocketAddress(bindAddress,bindPort);
  initializeMessaging();
  conf.set(Constants.PEER_HOST,peerAddress.getHostName());
  conf.setInt(Constants.PEER_PORT,peerAddress.getPort());
  if (LOG.isDebugEnabled()) {
    LOG.debug("Initialized Messaging service.");
  }
  initializeIO();
  initializeSyncService(superstep,state);
  TaskStatus.Phase phase=TaskStatus.Phase.STARTING;
  String stateString="running";
  if (state == TaskStatus.State.RECOVERING) {
    phase=TaskStatus.Phase.RECOVERING;
    stateString="recovering";
  }
  setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
  if (conf.getBoolean(Constants.FAULT_TOLERANCE_FLAG,false)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Fault tolerance enabled.");
    }
    if (superstep > 0)     conf.setInt("attempt.superstep",(int)superstep);
    Class<?> ftClass=conf.getClass(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class,BSPFaultTolerantService.class);
    if (ftClass != null) {
      if (superstep > 0) {
        counters.incrCounter(PeerCounter.SUPERSTEP_SUM,superstep);
      }
      this.faultToleranceService=((BSPFaultTolerantService<M>)ReflectionUtils.newInstance(ftClass,null)).constructPeerFaultTolerance(job,this,syncClient,peerAddress,this.taskId,superstep,conf,messenger);
      TaskStatus.State newState=this.faultToleranceService.onPeerInitialized(state);
      if (state == TaskStatus.State.RECOVERING) {
        if (newState == TaskStatus.State.RUNNING) {
          phase=TaskStatus.Phase.STARTING;
          stateString="running";
          state=newState;
        }
        setCurrentTaskStatus(new TaskStatus(taskId.getJobID(),taskId,1.0f,state,stateString,peerAddress.getHostName(),phase,counters));
        if (LOG.isDebugEnabled()) {
          LOG.debug("State after FT service initialization - " + newState.toString());
        }
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Initialized fault tolerance service");
      }
    }
  }
  doFirstSync(superstep);
  if (LOG.isDebugEnabled()) {
    LOG.info(new StringBuffer("BSP Peer successfully initialized for ").append(this.taskId.toString()).append(" ").append(superstep).toString());
  }
}

ID 227=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#initializeIO()
Rmethod: org.apache.hama.bsp.BSPPeerImpl#initInput()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPPeerImpl
@SuppressWarnings("unchecked") public final void initializeIO() throws Exception {
  if (conf.get(Constants.JOB_INPUT_DIR) != null) {
    initInput();
  }
  String outdir=null;
  if (conf.get(Constants.JOB_OUTPUT_DIR) != null) {
    Path outputDir=new Path(conf.get(Constants.JOB_OUTPUT_DIR,"tmp-" + System.currentTimeMillis()),Task.getOutputName(partition));
    outdir=outputDir.makeQualified(fs).toString();
  }
  outWriter=bspJob.getOutputFormat().getRecordWriter(fs,bspJob,outdir);
  final RecordWriter<K2,V2> finalOut=outWriter;
  collector=new OutputCollector<K2,V2>(){
    @Override public void collect(    K2 key,    V2 value) throws IOException {
      finalOut.write(key,value);
    }
  }
;
  try {
    DistributedCacheUtil.moveLocalFiles(this.conf);
  }
 catch (  Exception e) {
    LOG.error(e);
  }
  URL[] libjars=DistributedCacheUtil.addJarsToJobClasspath(this.conf);
  if (libjars != null)   bspJob.conf.setClassLoader(new URLClassLoader(libjars,bspJob.conf.getClassLoader()));
}

ID 228=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#send(java.lang.String, M)
Rmethod: org.apache.hama.bsp.BSPPeerImpl#sendDirectly(java.lang.String, M)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPPeerImpl
@Override public final void send(String peerName,M msg) throws IOException {
  if (!conf.getBoolean("hama.bsp.messenger.bundle",true)) {
    sendDirectly(peerName,msg);
  }
 else {
    messenger.send(peerName,msg);
  }
}

ID 229=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#sync()
Rmethod: org.apache.hama.bsp.BSPPeerImpl#enterBarrier()
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
BSPPeerImpl
@Override public final void sync() throws IOException, SyncException, InterruptedException {
  Iterator<Entry<InetSocketAddress,BSPMessageBundle<M>>> it;
  it=messenger.getOutgoingBundles();
  while (it.hasNext()) {
    Entry<InetSocketAddress,BSPMessageBundle<M>> entry=it.next();
    final InetSocketAddress addr=entry.getKey();
    final BSPMessageBundle<M> bundle=entry.getValue();
    it.remove();
    try {
      messenger.transfer(addr,bundle);
    }
 catch (    Exception e) {
      LOG.error("Error while sending messages",e);
    }
  }
  if (this.faultToleranceService != null) {
    try {
      this.faultToleranceService.beforeBarrier();
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  long startBarrier=System.currentTimeMillis();
  enterBarrier();
  if (this.faultToleranceService != null) {
    try {
      this.faultToleranceService.duringBarrier();
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  messenger.clearOutgoingMessages();
  leaveBarrier();
  incrementCounter(PeerCounter.TIME_IN_SYNC_MS,(System.currentTimeMillis() - startBarrier));
  incrementCounter(PeerCounter.SUPERSTEP_SUM,1L);
  currentTaskStatus.setCounters(counters);
  if (this.faultToleranceService != null) {
    try {
      this.faultToleranceService.afterBarrier();
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  umbilical.statusUpdate(taskId,currentTaskStatus);
}

ID 230=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#sync()
Rmethod: org.apache.hama.bsp.BSPPeerImpl#leaveBarrier()
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
BSPPeerImpl
@Override public final void sync() throws IOException, SyncException, InterruptedException {
  Iterator<Entry<InetSocketAddress,BSPMessageBundle<M>>> it;
  it=messenger.getOutgoingBundles();
  while (it.hasNext()) {
    Entry<InetSocketAddress,BSPMessageBundle<M>> entry=it.next();
    final InetSocketAddress addr=entry.getKey();
    final BSPMessageBundle<M> bundle=entry.getValue();
    it.remove();
    try {
      messenger.transfer(addr,bundle);
    }
 catch (    Exception e) {
      LOG.error("Error while sending messages",e);
    }
  }
  if (this.faultToleranceService != null) {
    try {
      this.faultToleranceService.beforeBarrier();
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  long startBarrier=System.currentTimeMillis();
  enterBarrier();
  if (this.faultToleranceService != null) {
    try {
      this.faultToleranceService.duringBarrier();
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  messenger.clearOutgoingMessages();
  leaveBarrier();
  incrementCounter(PeerCounter.TIME_IN_SYNC_MS,(System.currentTimeMillis() - startBarrier));
  incrementCounter(PeerCounter.SUPERSTEP_SUM,1L);
  currentTaskStatus.setCounters(counters);
  if (this.faultToleranceService != null) {
    try {
      this.faultToleranceService.afterBarrier();
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  umbilical.statusUpdate(taskId,currentTaskStatus);
}

ID 231=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#close()
Rmethod: org.apache.hama.bsp.BSPPeerImpl#deleteLocalFiles()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(e);
}

block: 
BSPPeerImpl
public final void close(){
  if (conf.get(Constants.COMBINER_CLASS) != null) {
    long combinedMessages=this.getCounter(PeerCounter.TOTAL_MESSAGES_SENT).getCounter() - this.getCounter(PeerCounter.TOTAL_MESSAGES_RECEIVED).getCounter();
    this.getCounter(PeerCounter.TOTAL_MESSAGES_COMBINED).increment(combinedMessages);
  }
  if (in != null) {
    try {
      in.close();
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
  if (outWriter != null) {
    try {
      outWriter.close();
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
  this.clear();
  try {
    syncClient.close();
  }
 catch (  Exception e) {
    LOG.error(e);
  }
  try {
    messenger.close();
  }
 catch (  Exception e) {
    LOG.error(e);
  }
  try {
    deleteLocalFiles();
  }
 catch (  Exception e) {
    LOG.error(e);
  }
}

ID 232=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerImpl#reopenInput()
Rmethod: org.apache.hama.bsp.BSPPeerImpl#initInput()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPPeerImpl
@Override public final void reopenInput() throws IOException {
  initInput();
}

ID 233=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPRunner#BSPRunner(java.lang.String, int, Path)
Rmethod: java.lang.Integer#valueOf(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPRunner
@SuppressWarnings({"unchecked","rawtypes"}) public BSPRunner(String jobId,int taskAttemptId,Path confPath) throws Exception {
  conf=new HamaConfiguration();
  FileSystem fs=FileSystem.get(confPath.toUri(),conf);
  InputStream in=fs.open(confPath);
  conf.addResource(in);
  this.id=new TaskAttemptID(jobId,0,taskAttemptId,0);
  this.id.id=taskAttemptId;
  int port=BSPNetUtils.getFreePort(taskAttemptId * 2 + 16000);
  conf.setInt(Constants.PEER_PORT,port);
  conf.set(Constants.PEER_HOST,BSPNetUtils.getCanonicalHostname());
  String umbilicalAddress=conf.get("hama.umbilical.address");
  if (umbilicalAddress == null || umbilicalAddress.isEmpty() || !umbilicalAddress.contains(":")) {
    throw new IllegalArgumentException("Umbilical address must contain a colon and must be non-empty and not-null! Property \"hama.umbilical.address\" was: " + umbilicalAddress);
  }
  String[] hostPort=umbilicalAddress.split(":");
  InetSocketAddress address=new InetSocketAddress(hostPort[0],Integer.valueOf(hostPort[1]));
  BSPPeerProtocol umbilical=(BSPPeerProtocol)RPC.getProxy(BSPPeerProtocol.class,HamaRPCProtocolVersion.versionID,address,conf);
  BSPJob job=new BSPJob(new HamaConfiguration(conf));
  BSPTask task=(BSPTask)umbilical.getTask(id);
  peer=new BSPPeerImpl(job,conf,id,umbilical,id.id,task.splitClass,task.split,counters);
  bspClass=(Class<? extends BSP>)conf.getClassByName(conf.get("bsp.work.class"));
}

ID 234=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPRunner#main(java.lang.String[])
Rmethod: java.lang.Integer#valueOf(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Main entry point after a container has launched.
 * @param args
 * @throws Exception
 */

catch: 
null
block: 
BSPRunner
/** 
 * Main entry point after a container has launched.
 * @param args
 * @throws Exception
 */
public static void main(String[] args) throws Exception {
  LOG.info("Starting task with arguments: " + Arrays.toString(args));
  if (args.length != 3) {
    throw new IllegalArgumentException("Expected 3 args given, but found: " + Arrays.toString(args));
  }
  BSPRunner bspRunner=new BSPRunner(args[0],Integer.valueOf(args[1]),new Path(args[2]));
  bspRunner.startComputation();
  LOG.info("Task successfully ended!");
}

ID 235=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPRunner#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPRunner#BSPRunner(java.lang.String, int, Path)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * Main entry point after a container has launched.
 * @param args
 * @throws Exception
 */

catch: 
null
block: 
BSPRunner
/** 
 * Main entry point after a container has launched.
 * @param args
 * @throws Exception
 */
public static void main(String[] args) throws Exception {
  LOG.info("Starting task with arguments: " + Arrays.toString(args));
  if (args.length != 3) {
    throw new IllegalArgumentException("Expected 3 args given, but found: " + Arrays.toString(args));
  }
  BSPRunner bspRunner=new BSPRunner(args[0],Integer.valueOf(args[1]),new Path(args[2]));
  bspRunner.startComputation();
  LOG.info("Task successfully ended!");
}

ID 236=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPRunner#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.BSPRunner#startComputation()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * Main entry point after a container has launched.
 * @param args
 * @throws Exception
 */

catch: 
null
block: 
BSPRunner
/** 
 * Main entry point after a container has launched.
 * @param args
 * @throws Exception
 */
public static void main(String[] args) throws Exception {
  LOG.info("Starting task with arguments: " + Arrays.toString(args));
  if (args.length != 3) {
    throw new IllegalArgumentException("Expected 3 args given, but found: " + Arrays.toString(args));
  }
  BSPRunner bspRunner=new BSPRunner(args[0],Integer.valueOf(args[1]),new Path(args[2]));
  bspRunner.startComputation();
  LOG.info("Task successfully ended!");
}

ID 237=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPTask#run(BSPJob, BSPPeerImpl<?,?,?,?,?>, BSPPeerProtocol)
Rmethod: org.apache.hama.bsp.BSPTask#runBSP(BSPJob, BSPPeerImpl<KEYIN,VALUEIN,KEYOUT,VALUEOUT,M>, BytesWritable, BSPPeerProtocol)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPTask
@Override public final void run(BSPJob job,BSPPeerImpl<?,?,?,?,?> bspPeer,BSPPeerProtocol umbilical) throws Exception {
  startPingingGroom(job,umbilical);
  try {
    runBSP(job,bspPeer,split,umbilical);
    done(umbilical);
  }
  finally {
    stopPingingGroom();
  }
}

ID 238=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPTask#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPTask
@Override public final void write(DataOutput out) throws IOException {
  super.write(out);
  if (split != null) {
    out.writeBoolean(true);
    Text.writeString(out,splitClass);
    split.write(out);
    split=null;
  }
 else {
    out.writeBoolean(false);
  }
}

ID 239=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPTask#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPTask
@Override public final void readFields(DataInput in) throws IOException {
  super.readFields(in);
  if (in.readBoolean()) {
    splitClass=Text.readString(in);
    if (split == null) {
      split=new BytesWritable();
    }
    split.readFields(in);
  }
}

ID 240=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.Bytes#readByteArray(java.io.DataInput)
Rmethod: java.io.DataInput#readFully(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read byte-array written with a WritableableUtils.vint prefix.
 * @param in Input to read from.
 * @return byte array read off <code>in</code>
 * @throws IOException e
 */

catch: 
null
block: 
Bytes
/** 
 * Read byte-array written with a WritableableUtils.vint prefix.
 * @param in Input to read from.
 * @return byte array read off <code>in</code>
 * @throws IOException e
 */
public static byte[] readByteArray(final DataInput in) throws IOException {
  int len=WritableUtils.readVInt(in);
  if (len < 0) {
    throw new NegativeArraySizeException(Integer.toString(len));
  }
  byte[] result=new byte[len];
  in.readFully(result,0,len);
  return result;
}

ID 241=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.Bytes#readByteArrayThrowsRuntime(java.io.DataInput)
Rmethod: org.apache.hama.util.Bytes#readByteArray(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read byte-array written with a WritableableUtils.vint prefix. IOException is converted to a RuntimeException.
 * @param in Input to read from.
 * @return byte array read off <code>in</code>
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
Bytes
/** 
 * Read byte-array written with a WritableableUtils.vint prefix. IOException is converted to a RuntimeException.
 * @param in Input to read from.
 * @return byte array read off <code>in</code>
 */
public static byte[] readByteArrayThrowsRuntime(final DataInput in){
  try {
    return readByteArray(in);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}

ID 242=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.Bytes#writeByteArray(java.io.DataOutput, byte[])
Rmethod: org.apache.hama.util.Bytes#writeByteArray(java.io.DataOutput, byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write byte-array with a WritableableUtils.vint prefix.
 * @param out output stream to be written to
 * @param b array to write
 * @throws IOException e
 */

catch: 
null
block: 
Bytes
/** 
 * Write byte-array with a WritableableUtils.vint prefix.
 * @param out output stream to be written to
 * @param b array to write
 * @throws IOException e
 */
public static void writeByteArray(final DataOutput out,final byte[] b) throws IOException {
  if (b == null) {
    WritableUtils.writeVInt(out,0);
  }
 else {
    writeByteArray(out,b,0,b.length);
  }
}

ID 243=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.Bytes#writeByteArray(java.io.DataOutput, byte[], int, int)
Rmethod: java.io.DataOutput#write(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write byte-array to out with a vint length prefix.
 * @param out output stream
 * @param b array
 * @param offset offset into array
 * @param length length past offset
 * @throws IOException e
 */

catch: 
null
block: 
Bytes
/** 
 * Write byte-array to out with a vint length prefix.
 * @param out output stream
 * @param b array
 * @param offset offset into array
 * @param length length past offset
 * @throws IOException e
 */
public static void writeByteArray(final DataOutput out,final byte[] b,final int offset,final int length) throws IOException {
  WritableUtils.writeVInt(out,length);
  out.write(b,offset,length);
}

ID 244=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.Bytes#toString(byte[], int, int)
Rmethod: java.lang.String#String(byte[], int, int, java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

method comment: /** 
 * This method will convert utf8 encoded bytes into a string. If an UnsupportedEncodingException occurs, this method will eat it and return null instead.
 * @param b Presumed UTF-8 encoded byte array.
 * @param off offset into array
 * @param len length of utf-8 sequence
 * @return String made from <code>b</code> or null
 */

catch: 
catch (UnsupportedEncodingException e) {
  LOG.error("UTF-8 not supported?",e);
  return null;
}

block: 
Bytes
/** 
 * This method will convert utf8 encoded bytes into a string. If an UnsupportedEncodingException occurs, this method will eat it and return null instead.
 * @param b Presumed UTF-8 encoded byte array.
 * @param off offset into array
 * @param len length of utf-8 sequence
 * @return String made from <code>b</code> or null
 */
public static String toString(final byte[] b,int off,int len){
  if (b == null) {
    return null;
  }
  if (len == 0) {
    return "";
  }
  try {
    return new String(b,off,len,Constants.UTF8_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    LOG.error("UTF-8 not supported?",e);
    return null;
  }
}

ID 245=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.Bytes#toStringBinary(byte[], int, int)
Rmethod: java.lang.String#String(byte[], int, int, java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

method comment: /** 
 * Write a printable representation of a byte array. Non-printable characters are hex escaped in the format \\x%02X, eg: \x00 \x05 etc
 * @param b array to write out
 * @param off offset to start at
 * @param len length to write
 * @return string output
 */

catch: 
catch (UnsupportedEncodingException e) {
  LOG.error("ISO-8859-1 not supported?",e);
}

block: 
Bytes
/** 
 * Write a printable representation of a byte array. Non-printable characters are hex escaped in the format \\x%02X, eg: \x00 \x05 etc
 * @param b array to write out
 * @param off offset to start at
 * @param len length to write
 * @return string output
 */
public static String toStringBinary(final byte[] b,int off,int len){
  StringBuilder result=new StringBuilder();
  try {
    String first=new String(b,off,len,"ISO-8859-1");
    for (int i=0; i < first.length(); ++i) {
      int ch=first.charAt(i) & 0xFF;
      if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')|| ch == ',' || ch == '_' || ch == '-' || ch == ':' || ch == ' ' || ch == '<' || ch == '>' || ch == '=' || ch == '/' || ch == '.') {
        result.append(first.charAt(i));
      }
 else {
        result.append(String.format("\\x%02X",ch));
      }
    }
  }
 catch (  UnsupportedEncodingException e) {
    LOG.error("ISO-8859-1 not supported?",e);
  }
  return result.toString();
}

ID 246=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.Bytes#toBytes(java.lang.String)
Rmethod: java.lang.String#getBytes(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

method comment: /** 
 * Converts a string to a UTF-8 byte array.
 * @param s string
 * @return the byte array
 */

catch: 
catch (UnsupportedEncodingException e) {
  LOG.error("UTF-8 not supported?",e);
  return null;
}

block: 
Bytes
/** 
 * Converts a string to a UTF-8 byte array.
 * @param s string
 * @return the byte array
 */
public static byte[] toBytes(String s){
  try {
    return s.getBytes(Constants.UTF8_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    LOG.error("UTF-8 not supported?",e);
    return null;
  }
}

ID 247=========================================================================type: Recover
package: org.apache.hama.bsp.message.compress
Method:org.apache.hama.bsp.message.compress.Bzip2Compressor#decompress(byte[])
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Decompresses a BSPCompressedBundle and returns the corresponding BSPMessageBundle.
 * @param compressedBytes
 * @return The result after decompressing BSPMessageBundle.
 */

catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
Bzip2Compressor
/** 
 * Decompresses a BSPCompressedBundle and returns the corresponding BSPMessageBundle.
 * @param compressedBytes
 * @return The result after decompressing BSPMessageBundle.
 */
@Override public byte[] decompress(byte[] compressedBytes){
  ByteArrayInputStream bis=new ByteArrayInputStream(compressedBytes);
  DataInputStream in=new DataInputStream(bis);
  ByteArrayOutputStream outBuffer=new ByteArrayOutputStream();
  DataOutputStream out=new DataOutputStream(outBuffer);
  try {
    final CompressorInputStream cin=new CompressorStreamFactory().createCompressorInputStream("bzip2",in);
    IOUtils.copy(cin,out);
    in.close();
  }
 catch (  CompressorException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return outBuffer.toByteArray();
}

ID 248=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.CenterMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CenterMessage
@Override public final void readFields(DataInput in) throws IOException {
  centerIndex=in.readInt();
  incrementCounter=in.readInt();
  newCenter=VectorWritable.readVector(in);
}

ID 249=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.CenterMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CenterMessage
@Override public final void write(DataOutput out) throws IOException {
  out.writeInt(centerIndex);
  out.writeInt(incrementCounter);
  VectorWritable.writeVector(newCenter,out);
}

ID 250=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.PingInputStream#handleTimeout(java.net.SocketTimeoutException)
Rmethod: org.apache.hama.ipc.Connection#sendPing()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PingInputStream
private void handleTimeout(SocketTimeoutException e) throws IOException {
  if (shouldCloseConnection.get() || !running.get() || rpcTimeout > 0) {
    throw e;
  }
 else {
    sendPing();
  }
}

ID 251=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.PingInputStream#read()
Rmethod: org.apache.hama.ipc.PingInputStream#handleTimeout(java.net.SocketTimeoutException)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read a byte from the stream. Send a ping if timeout on read. Retries if no failure is detected until a byte is read.
 * @throws IOException for any IO problem other than socket timeout
 */

catch: 
null
block: 
PingInputStream
/** 
 * Read a byte from the stream. Send a ping if timeout on read. Retries if no failure is detected until a byte is read.
 * @throws IOException for any IO problem other than socket timeout
 */
public int read() throws IOException {
  do {
    try {
      return super.read();
    }
 catch (    SocketTimeoutException e) {
      handleTimeout(e);
    }
  }
 while (true);
}

ID 252=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.PingInputStream#read(byte[], int, int)
Rmethod: org.apache.hama.ipc.PingInputStream#handleTimeout(java.net.SocketTimeoutException)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read bytes into a buffer starting from offset <code>off</code> Send a ping if timeout on read. Retries if no failure is detected until a byte is read.
 * @return the total number of bytes read; -1 if the connection is closed.
 */

catch: 
null
block: 
PingInputStream
/** 
 * Read bytes into a buffer starting from offset <code>off</code> Send a ping if timeout on read. Retries if no failure is detected until a byte is read.
 * @return the total number of bytes read; -1 if the connection is closed.
 */
public int read(byte[] buf,int off,int len) throws IOException {
  do {
    try {
      return super.read(buf,off,len);
    }
 catch (    SocketTimeoutException e) {
      handleTimeout(e);
    }
  }
 while (true);
}

ID 253=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: javax.net.SocketFactory#createSocket()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie) {
  if (updateAddress()) {
    timeoutFailures=ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
private synchronized void setupConnection() throws IOException {
  short ioFailures=0;
  short timeoutFailures=0;
  while (true) {
    try {
      this.socket=socketFactory.createSocket();
      this.socket.setTcpNoDelay(tcpNoDelay);
      BSPNetUtils.connect(this.socket,server,20000);
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      this.socket.setSoTimeout(pingInterval);
      return;
    }
 catch (    SocketTimeoutException toe) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(timeoutFailures++,45,toe);
    }
catch (    IOException ie) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 254=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: java.net.Socket#setTcpNoDelay(boolean)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie) {
  if (updateAddress()) {
    timeoutFailures=ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
private synchronized void setupConnection() throws IOException {
  short ioFailures=0;
  short timeoutFailures=0;
  while (true) {
    try {
      this.socket=socketFactory.createSocket();
      this.socket.setTcpNoDelay(tcpNoDelay);
      BSPNetUtils.connect(this.socket,server,20000);
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      this.socket.setSoTimeout(pingInterval);
      return;
    }
 catch (    SocketTimeoutException toe) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(timeoutFailures++,45,toe);
    }
catch (    IOException ie) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 255=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: java.net.Socket#setSoTimeout(int)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie) {
  if (updateAddress()) {
    timeoutFailures=ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
private synchronized void setupConnection() throws IOException {
  short ioFailures=0;
  short timeoutFailures=0;
  while (true) {
    try {
      this.socket=socketFactory.createSocket();
      this.socket.setTcpNoDelay(tcpNoDelay);
      BSPNetUtils.connect(this.socket,server,20000);
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      this.socket.setSoTimeout(pingInterval);
      return;
    }
 catch (    SocketTimeoutException toe) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(timeoutFailures++,45,toe);
    }
catch (    IOException ie) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 256=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: org.apache.hama.ipc.Connection#updateAddress()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie) {
  if (updateAddress()) {
    timeoutFailures=ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
private synchronized void setupConnection() throws IOException {
  short ioFailures=0;
  short timeoutFailures=0;
  while (true) {
    try {
      this.socket=socketFactory.createSocket();
      this.socket.setTcpNoDelay(tcpNoDelay);
      BSPNetUtils.connect(this.socket,server,20000);
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      this.socket.setSoTimeout(pingInterval);
      return;
    }
 catch (    SocketTimeoutException toe) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(timeoutFailures++,45,toe);
    }
catch (    IOException ie) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 257=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: org.apache.hama.ipc.Connection#handleConnectionFailure(int, int, java.io.IOException)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie) {
  if (updateAddress()) {
    timeoutFailures=ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
private synchronized void setupConnection() throws IOException {
  short ioFailures=0;
  short timeoutFailures=0;
  while (true) {
    try {
      this.socket=socketFactory.createSocket();
      this.socket.setTcpNoDelay(tcpNoDelay);
      BSPNetUtils.connect(this.socket,server,20000);
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      this.socket.setSoTimeout(pingInterval);
      return;
    }
 catch (    SocketTimeoutException toe) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(timeoutFailures++,45,toe);
    }
catch (    IOException ie) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 258=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupConnection()
Rmethod: org.apache.hama.ipc.Connection#handleConnectionFailure(int, java.io.IOException)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie) {
  if (updateAddress()) {
    timeoutFailures=ioFailures=0;
  }
  handleConnectionFailure(ioFailures++,ie);
}

block: 
Connection
private synchronized void setupConnection() throws IOException {
  short ioFailures=0;
  short timeoutFailures=0;
  while (true) {
    try {
      this.socket=socketFactory.createSocket();
      this.socket.setTcpNoDelay(tcpNoDelay);
      BSPNetUtils.connect(this.socket,server,20000);
      if (rpcTimeout > 0) {
        pingInterval=rpcTimeout;
      }
      this.socket.setSoTimeout(pingInterval);
      return;
    }
 catch (    SocketTimeoutException toe) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(timeoutFailures++,45,toe);
    }
catch (    IOException ie) {
      if (updateAddress()) {
        timeoutFailures=ioFailures=0;
      }
      handleConnectionFailure(ioFailures++,ie);
    }
  }
}

ID 259=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupIOstreams()
Rmethod: org.apache.hama.ipc.Connection#setupConnection()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server and starts the connection thread that waits for responses.
 */

catch: 
catch (Throwable t) {
  if (t instanceof IOException) {
    markClosed((IOException)t);
  }
 else {
    markClosed(new IOException("Couldn't set up IO streams",t));
  }
  close();
}

block: 
Connection
/** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server and starts the connection thread that waits for responses.
 */
private synchronized void setupIOstreams() throws InterruptedException {
  if (socket != null || shouldCloseConnection.get()) {
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Connecting to " + server);
    }
    while (true) {
      setupConnection();
      InputStream inStream=BSPNetUtils.getInputStream(socket);
      OutputStream outStream=BSPNetUtils.getOutputStream(socket);
      writeRpcHeader(outStream);
      this.in=new DataInputStream(new BufferedInputStream(new PingInputStream(inStream)));
      this.out=new DataOutputStream(new BufferedOutputStream(outStream));
      writeHeader();
      touch();
      start();
      return;
    }
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      markClosed((IOException)t);
    }
 else {
      markClosed(new IOException("Couldn't set up IO streams",t));
    }
    close();
  }
}

ID 260=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupIOstreams()
Rmethod: org.apache.hama.ipc.Connection#writeRpcHeader(java.io.OutputStream)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server and starts the connection thread that waits for responses.
 */

catch: 
catch (Throwable t) {
  if (t instanceof IOException) {
    markClosed((IOException)t);
  }
 else {
    markClosed(new IOException("Couldn't set up IO streams",t));
  }
  close();
}

block: 
Connection
/** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server and starts the connection thread that waits for responses.
 */
private synchronized void setupIOstreams() throws InterruptedException {
  if (socket != null || shouldCloseConnection.get()) {
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Connecting to " + server);
    }
    while (true) {
      setupConnection();
      InputStream inStream=BSPNetUtils.getInputStream(socket);
      OutputStream outStream=BSPNetUtils.getOutputStream(socket);
      writeRpcHeader(outStream);
      this.in=new DataInputStream(new BufferedInputStream(new PingInputStream(inStream)));
      this.out=new DataOutputStream(new BufferedOutputStream(outStream));
      writeHeader();
      touch();
      start();
      return;
    }
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      markClosed((IOException)t);
    }
 else {
      markClosed(new IOException("Couldn't set up IO streams",t));
    }
    close();
  }
}

ID 261=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#setupIOstreams()
Rmethod: org.apache.hama.ipc.Connection#writeHeader()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server and starts the connection thread that waits for responses.
 */

catch: 
catch (Throwable t) {
  if (t instanceof IOException) {
    markClosed((IOException)t);
  }
 else {
    markClosed(new IOException("Couldn't set up IO streams",t));
  }
  close();
}

block: 
Connection
/** 
 * Connect to the server and set up the I/O streams. It then sends a header to the server and starts the connection thread that waits for responses.
 */
private synchronized void setupIOstreams() throws InterruptedException {
  if (socket != null || shouldCloseConnection.get()) {
    return;
  }
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Connecting to " + server);
    }
    while (true) {
      setupConnection();
      InputStream inStream=BSPNetUtils.getInputStream(socket);
      OutputStream outStream=BSPNetUtils.getOutputStream(socket);
      writeRpcHeader(outStream);
      this.in=new DataInputStream(new BufferedInputStream(new PingInputStream(inStream)));
      this.out=new DataOutputStream(new BufferedOutputStream(outStream));
      writeHeader();
      touch();
      start();
      return;
    }
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      markClosed((IOException)t);
    }
 else {
      markClosed(new IOException("Couldn't set up IO streams",t));
    }
    close();
  }
}

ID 262=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#closeConnection()
Rmethod: java.net.Socket#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.warn("Not able to close a socket",e);
}

block: 
Connection
private void closeConnection(){
  try {
    socket.close();
  }
 catch (  IOException e) {
    LOG.warn("Not able to close a socket",e);
  }
  socket=null;
}

ID 263=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#handleConnectionFailure(int, int, java.io.IOException)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ignored) {
}

block: 
Connection
private void handleConnectionFailure(int curRetries,int maxRetries,IOException ioe) throws IOException {
  closeConnection();
  if (curRetries >= maxRetries) {
    throw ioe;
  }
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException ignored) {
  }
  LOG.info("Retrying connect to server: " + server + ". Already tried "+ curRetries+ " time(s); maxRetries="+ maxRetries);
}

ID 264=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#writeRpcHeader(java.io.OutputStream)
Rmethod: java.io.FilterOutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void writeRpcHeader(OutputStream outStream) throws IOException {
  DataOutputStream out=new DataOutputStream(new BufferedOutputStream(outStream));
  out.write(Server.HEADER.array());
  out.write(Server.CURRENT_VERSION);
  authMethod.write(out);
  out.flush();
}

ID 265=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#writeRpcHeader(java.io.OutputStream)
Rmethod: java.io.DataOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void writeRpcHeader(OutputStream outStream) throws IOException {
  DataOutputStream out=new DataOutputStream(new BufferedOutputStream(outStream));
  out.write(Server.HEADER.array());
  out.write(Server.CURRENT_VERSION);
  authMethod.write(out);
  out.flush();
}

ID 266=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#writeHeader()
Rmethod: java.io.DataOutputStream#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void writeHeader() throws IOException {
  DataOutputBuffer buf=new DataOutputBuffer();
  header.write(buf);
  int bufLen=buf.getLength();
  out.writeInt(bufLen);
  out.write(buf.getData(),0,bufLen);
}

ID 267=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#writeHeader()
Rmethod: java.io.DataOutputStream#write(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void writeHeader() throws IOException {
  DataOutputBuffer buf=new DataOutputBuffer();
  header.write(buf);
  int bufLen=buf.getLength();
  out.writeInt(bufLen);
  out.write(buf.getData(),0,bufLen);
}

ID 268=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#waitForWork()
Rmethod: java.lang.Object#wait(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
}

block: 
Connection
private synchronized boolean waitForWork(){
  if (calls.isEmpty() && !shouldCloseConnection.get() && running.get()) {
    long timeout=maxIdleTime - (System.currentTimeMillis() - lastActivity.get());
    if (timeout > 0) {
      try {
        wait(timeout);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  if (!calls.isEmpty() && !shouldCloseConnection.get() && running.get()) {
    return true;
  }
 else   if (shouldCloseConnection.get()) {
    return false;
  }
 else   if (calls.isEmpty()) {
    markClosed(null);
    return false;
  }
 else {
    markClosed((IOException)new IOException().initCause(new InterruptedException()));
    return false;
  }
}

ID 269=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#sendPing()
Rmethod: java.io.DataOutputStream#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private synchronized void sendPing() throws IOException {
  long curTime=System.currentTimeMillis();
  if (curTime - lastActivity.get() >= pingInterval) {
    lastActivity.set(curTime);
synchronized (out) {
      out.writeInt(PING_CALL_ID);
      out.flush();
    }
  }
}

ID 270=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#sendPing()
Rmethod: java.io.DataOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private synchronized void sendPing() throws IOException {
  long curTime=System.currentTimeMillis();
  if (curTime - lastActivity.get() >= pingInterval) {
    lastActivity.set(curTime);
synchronized (out) {
      out.writeInt(PING_CALL_ID);
      out.flush();
    }
  }
}

ID 271=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#sendParam(org.apache.hama.ipc.Client.Call)
Rmethod: java.io.DataOutputStream#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Initiates a call by sending the parameter to the remote server. Note: this is not called from the Connection thread, but by other threads.
 */

catch: 
catch (IOException e) {
  markClosed(e);
}

block: 
Connection
/** 
 * Initiates a call by sending the parameter to the remote server. Note: this is not called from the Connection thread, but by other threads.
 */
public void sendParam(Call call){
  if (shouldCloseConnection.get()) {
    return;
  }
  DataOutputBuffer d=null;
  try {
synchronized (this.out) {
      if (LOG.isDebugEnabled())       LOG.debug(getName() + " sending #" + call.id);
      d=new DataOutputBuffer();
      d.writeInt(call.id);
      call.param.write(d);
      byte[] data=d.getData();
      int dataLength=d.getLength();
      out.writeInt(dataLength);
      out.write(data,0,dataLength);
      out.flush();
    }
  }
 catch (  IOException e) {
    markClosed(e);
  }
 finally {
    IOUtils.closeStream(d);
  }
}

ID 272=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#sendParam(org.apache.hama.ipc.Client.Call)
Rmethod: java.io.DataOutputStream#write(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Initiates a call by sending the parameter to the remote server. Note: this is not called from the Connection thread, but by other threads.
 */

catch: 
catch (IOException e) {
  markClosed(e);
}

block: 
Connection
/** 
 * Initiates a call by sending the parameter to the remote server. Note: this is not called from the Connection thread, but by other threads.
 */
public void sendParam(Call call){
  if (shouldCloseConnection.get()) {
    return;
  }
  DataOutputBuffer d=null;
  try {
synchronized (this.out) {
      if (LOG.isDebugEnabled())       LOG.debug(getName() + " sending #" + call.id);
      d=new DataOutputBuffer();
      d.writeInt(call.id);
      call.param.write(d);
      byte[] data=d.getData();
      int dataLength=d.getLength();
      out.writeInt(dataLength);
      out.write(data,0,dataLength);
      out.flush();
    }
  }
 catch (  IOException e) {
    markClosed(e);
  }
 finally {
    IOUtils.closeStream(d);
  }
}

ID 273=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#sendParam(org.apache.hama.ipc.Client.Call)
Rmethod: java.io.DataOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Initiates a call by sending the parameter to the remote server. Note: this is not called from the Connection thread, but by other threads.
 */

catch: 
catch (IOException e) {
  markClosed(e);
}

block: 
Connection
/** 
 * Initiates a call by sending the parameter to the remote server. Note: this is not called from the Connection thread, but by other threads.
 */
public void sendParam(Call call){
  if (shouldCloseConnection.get()) {
    return;
  }
  DataOutputBuffer d=null;
  try {
synchronized (this.out) {
      if (LOG.isDebugEnabled())       LOG.debug(getName() + " sending #" + call.id);
      d=new DataOutputBuffer();
      d.writeInt(call.id);
      call.param.write(d);
      byte[] data=d.getData();
      int dataLength=d.getLength();
      out.writeInt(dataLength);
      out.write(data,0,dataLength);
      out.flush();
    }
  }
 catch (  IOException e) {
    markClosed(e);
  }
 finally {
    IOUtils.closeStream(d);
  }
}

ID 274=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#receiveResponse()
Rmethod: java.io.DataInputStream#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  markClosed(e);
}

block: 
Connection
private void receiveResponse(){
  if (shouldCloseConnection.get()) {
    return;
  }
  touch();
  try {
    int id=in.readInt();
    if (LOG.isDebugEnabled())     LOG.debug(getName() + " got value #" + id);
    Call call=calls.get(id);
    int state=in.readInt();
    if (state == Status.SUCCESS.state) {
      Writable value=ReflectionUtils.newInstance(valueClass,conf);
      value.readFields(in);
      call.setValue(value);
      calls.remove(id);
    }
 else     if (state == Status.ERROR.state) {
      call.setException(new RemoteException(WritableUtils.readString(in),WritableUtils.readString(in)));
      calls.remove(id);
    }
 else     if (state == Status.FATAL.state) {
      markClosed(new RemoteException(WritableUtils.readString(in),WritableUtils.readString(in)));
    }
  }
 catch (  IOException e) {
    markClosed(e);
  }
}

ID 275=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#stop()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Stop all threads related to this client. No further calls may be made using this client.
 */

catch: 
catch (InterruptedException e) {
}

block: 
Client
/** 
 * Stop all threads related to this client. No further calls may be made using this client.
 */
public void stop(){
  if (LOG.isDebugEnabled()) {
    LOG.debug("Stopping client");
  }
  if (!running.compareAndSet(true,false)) {
    return;
  }
synchronized (connections) {
    for (    Connection conn : connections.values()) {
      conn.interrupt();
    }
  }
  while (!connections.isEmpty()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}

ID 276=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress)
Rmethod: org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, UserGroupInformation)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress address) throws InterruptedException, IOException {
  return call(param,address,null);
}

ID 277=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress)
Rmethod: org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, UserGroupInformation)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress address) throws InterruptedException, IOException {
  return call(param,address,null);
}

ID 278=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, UserGroupInformation)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> with the <code>ticket</code> credentials, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> with the <code>ticket</code> credentials, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress addr,UserGroupInformation ticket) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,null,ticket,0,conf);
  return call(param,remoteId);
}

ID 279=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, UserGroupInformation)
Rmethod: org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> with the <code>ticket</code> credentials, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> with the <code>ticket</code> credentials, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress addr,UserGroupInformation ticket) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,null,ticket,0,conf);
  return call(param,remoteId);
}

ID 280=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, UserGroupInformation)
Rmethod: org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> with the <code>ticket</code> credentials, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> with the <code>ticket</code> credentials, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress addr,UserGroupInformation ticket) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,null,ticket,0,conf);
  return call(param,remoteId);
}

ID 281=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials and <code>rpcTimeout</code> as timeout, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials and <code>rpcTimeout</code> as timeout, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 282=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int)
Rmethod: org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials and <code>rpcTimeout</code> as timeout, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials and <code>rpcTimeout</code> as timeout, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 283=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int)
Rmethod: org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials and <code>rpcTimeout</code> as timeout, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials and <code>rpcTimeout</code> as timeout, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 * @deprecated Use {@link #call(Writable,ConnectionId)} instead
 */
@Deprecated public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 284=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */
public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,Configuration conf) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 285=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
Rmethod: org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */
public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,Configuration conf) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 286=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
Rmethod: org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server running at <code>address</code> which is servicing the <code>protocol</code> protocol, with the <code>ticket</code> credentials, <code>rpcTimeout</code> as timeout and <code>conf</code> as configuration for this connection, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */
public Writable call(Writable param,InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,Configuration conf) throws InterruptedException, IOException {
  ConnectionId remoteId=ConnectionId.getConnectionId(addr,protocol,ticket,rpcTimeout,conf);
  return call(param,remoteId);
}

ID 287=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
Rmethod: org.apache.hama.ipc.Client#getConnection(org.apache.hama.ipc.Client.ConnectionId, org.apache.hama.ipc.Client.Call)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */
public Writable call(Writable param,ConnectionId remoteId) throws InterruptedException, IOException {
  Call call=new Call(param);
  Connection connection=getConnection(remoteId,call);
  connection.sendParam(call);
  boolean interrupted=false;
synchronized (call) {
    while (!call.done) {
      try {
        call.wait();
      }
 catch (      InterruptedException ie) {
        interrupted=true;
      }
    }
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
    if (call.error != null) {
      if (call.error instanceof RemoteException) {
        call.error.fillInStackTrace();
        throw call.error;
      }
 else {
        throw wrapException(connection.getRemoteAddress(),call.error);
      }
    }
 else {
      return call.value;
    }
  }
}

ID 288=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
Rmethod: org.apache.hama.ipc.Client#getConnection(org.apache.hama.ipc.Client.ConnectionId, org.apache.hama.ipc.Client.Call)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */

catch: 
null
block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */
public Writable call(Writable param,ConnectionId remoteId) throws InterruptedException, IOException {
  Call call=new Call(param);
  Connection connection=getConnection(remoteId,call);
  connection.sendParam(call);
  boolean interrupted=false;
synchronized (call) {
    while (!call.done) {
      try {
        call.wait();
      }
 catch (      InterruptedException ie) {
        interrupted=true;
      }
    }
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
    if (call.error != null) {
      if (call.error instanceof RemoteException) {
        call.error.fillInStackTrace();
        throw call.error;
      }
 else {
        throw wrapException(connection.getRemoteAddress(),call.error);
      }
    }
 else {
      return call.value;
    }
  }
}

ID 289=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable, org.apache.hama.ipc.Client.ConnectionId)
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */

catch: 
catch (InterruptedException ie) {
  interrupted=true;
}

block: 
Client
/** 
 * Make a call, passing <code>param</code>, to the IPC server defined by <code>remoteId</code>, returning the value. Throws exceptions if there are network problems or if the remote code threw an exception.
 */
public Writable call(Writable param,ConnectionId remoteId) throws InterruptedException, IOException {
  Call call=new Call(param);
  Connection connection=getConnection(remoteId,call);
  connection.sendParam(call);
  boolean interrupted=false;
synchronized (call) {
    while (!call.done) {
      try {
        call.wait();
      }
 catch (      InterruptedException ie) {
        interrupted=true;
      }
    }
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
    if (call.error != null) {
      if (call.error instanceof RemoteException) {
        call.error.fillInStackTrace();
        throw call.error;
      }
 else {
        throw wrapException(connection.getRemoteAddress(),call.error);
      }
    }
 else {
      return call.value;
    }
  }
}

ID 290=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[])
Rmethod: org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */

catch: 
null
block: 
Client
/** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */
@Deprecated public Writable[] call(Writable[] params,InetSocketAddress[] addresses) throws IOException, InterruptedException {
  return call(params,addresses,null,null,conf);
}

ID 291=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[])
Rmethod: org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */

catch: 
null
block: 
Client
/** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */
@Deprecated public Writable[] call(Writable[] params,InetSocketAddress[] addresses) throws IOException, InterruptedException {
  return call(params,addresses,null,null,conf);
}

ID 292=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation)
Rmethod: org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */

catch: 
null
block: 
Client
/** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */
@Deprecated public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket) throws IOException, InterruptedException {
  return call(params,addresses,protocol,ticket,conf);
}

ID 293=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation)
Rmethod: org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */

catch: 
null
block: 
Client
/** 
 * @deprecated Use{@link #call(Writable[],InetSocketAddress[],Class,UserGroupInformation,Configuration)}instead
 */
@Deprecated public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket) throws IOException, InterruptedException {
  return call(params,addresses,protocol,ticket,conf);
}

ID 294=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, Configuration)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */

catch: 
catch (IOException e) {
  LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
  results.size--;
}

block: 
Client
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        ConnectionId remoteId=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId,call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 295=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: org.apache.hama.ipc.Client#getConnection(org.apache.hama.ipc.Client.ConnectionId, org.apache.hama.ipc.Client.Call)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */

catch: 
catch (IOException e) {
  LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
  results.size--;
}

block: 
Client
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        ConnectionId remoteId=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId,call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 296=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: org.apache.hama.ipc.Client#getConnection(org.apache.hama.ipc.Client.ConnectionId, org.apache.hama.ipc.Client.Call)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */

catch: 
null
block: 
Client
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        ConnectionId remoteId=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId,call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 297=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#call(Writable[], java.net.InetSocketAddress[], Class<?>, UserGroupInformation, Configuration)
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */

catch: 
catch (InterruptedException e) {
}

block: 
Client
/** 
 * Makes a set of calls in parallel. Each parameter is sent to the corresponding address. When all values are available, or have timed out or errored, the collected results are returned in an array. The array contains nulls for calls that timed out or errored.
 */
public Writable[] call(Writable[] params,InetSocketAddress[] addresses,Class<?> protocol,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  if (addresses.length == 0)   return new Writable[0];
  ParallelResults results=new ParallelResults(params.length);
synchronized (results) {
    for (int i=0; i < params.length; i++) {
      ParallelCall call=new ParallelCall(params[i],results,i);
      try {
        ConnectionId remoteId=ConnectionId.getConnectionId(addresses[i],protocol,ticket,0,conf);
        Connection connection=getConnection(remoteId,call);
        connection.sendParam(call);
      }
 catch (      IOException e) {
        LOG.info("Calling " + addresses[i] + " caught: "+ e.getMessage(),e);
        results.size--;
      }
    }
    while (results.count != results.size) {
      try {
        results.wait();
      }
 catch (      InterruptedException e) {
      }
    }
    return results.values;
  }
}

ID 298=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#getConnection(org.apache.hama.ipc.Client.ConnectionId, org.apache.hama.ipc.Client.Call)
Rmethod: org.apache.hama.ipc.Connection#Connection(org.apache.hama.ipc.Client.ConnectionId)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 */

catch: 
null
block: 
Client
/** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 */
private Connection getConnection(ConnectionId remoteId,Call call) throws IOException, InterruptedException {
  if (!running.get()) {
    throw new IOException("The client is stopped");
  }
  Connection connection;
  do {
synchronized (connections) {
      connection=connections.get(remoteId);
      if (connection == null) {
        connection=new Connection(remoteId);
        connections.put(remoteId,connection);
      }
    }
  }
 while (!connection.addCall(call));
  connection.setupIOstreams();
  return connection;
}

ID 299=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Client#getConnection(org.apache.hama.ipc.Client.ConnectionId, org.apache.hama.ipc.Client.Call)
Rmethod: org.apache.hama.ipc.Connection#setupIOstreams()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 */

catch: 
null
block: 
Client
/** 
 * Get a connection from the pool, or create a new one and add it to the pool. Connections to a given ConnectionId are reused.
 */
private Connection getConnection(ConnectionId remoteId,Call call) throws IOException, InterruptedException {
  if (!running.get()) {
    throw new IOException("The client is stopped");
  }
  Connection connection;
  do {
synchronized (connections) {
      connection=connections.get(remoteId);
      if (connection == null) {
        connection=new Connection(remoteId);
        connections.put(remoteId,connection);
      }
    }
  }
 while (!connection.addCall(call));
  connection.setupIOstreams();
  return connection;
}

ID 300=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.ConnectionId#getConnectionId(java.net.InetSocketAddress, Class<?>, UserGroupInformation, int, RetryPolicy, Configuration)
Rmethod: org.apache.hama.ipc.ConnectionId#getRemotePrincipal(Configuration, java.net.InetSocketAddress, Class<?>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ConnectionId
static ConnectionId getConnectionId(InetSocketAddress addr,Class<?> protocol,UserGroupInformation ticket,int rpcTimeout,RetryPolicy connectionRetryPolicy,Configuration conf) throws IOException {
  if (connectionRetryPolicy == null) {
    final int max=conf.getInt(IPC_CLIENT_CONNECT_MAX_RETRIES_KEY,IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT);
    connectionRetryPolicy=RetryPolicies.retryUpToMaximumCountWithFixedSleep(max,1,TimeUnit.SECONDS);
  }
  String remotePrincipal=getRemotePrincipal(conf,addr,protocol);
  return new ConnectionId(addr,protocol,ticket,rpcTimeout,remotePrincipal,conf.getInt("ipc.client.connection.maxidletime",10000),connectionRetryPolicy,conf.getBoolean("ipc.client.tcpnodelay",false),Client.getPingInterval(conf));
}

ID 301=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ClusterStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ClusterStatus
@Override public void write(DataOutput out) throws IOException {
  if (activeGrooms.isEmpty()) {
    out.writeInt(numActiveGrooms);
    out.writeBoolean(false);
  }
 else {
    out.writeInt(activeGrooms.size());
    out.writeBoolean(true);
    for (    Entry<String,GroomServerStatus> entry : activeGrooms.entrySet()) {
      out.writeUTF(entry.getKey());
      entry.getValue().write(out);
    }
  }
  out.writeInt(tasks);
  out.writeInt(maxTasks);
  WritableUtils.writeEnum(out,state);
}

ID 302=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ClusterStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ClusterStatus
@Override public void write(DataOutput out) throws IOException {
  if (activeGrooms.isEmpty()) {
    out.writeInt(numActiveGrooms);
    out.writeBoolean(false);
  }
 else {
    out.writeInt(activeGrooms.size());
    out.writeBoolean(true);
    for (    Entry<String,GroomServerStatus> entry : activeGrooms.entrySet()) {
      out.writeUTF(entry.getKey());
      entry.getValue().write(out);
    }
  }
  out.writeInt(tasks);
  out.writeInt(maxTasks);
  WritableUtils.writeEnum(out,state);
}

ID 303=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ClusterStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ClusterStatus
@Override public void write(DataOutput out) throws IOException {
  if (activeGrooms.isEmpty()) {
    out.writeInt(numActiveGrooms);
    out.writeBoolean(false);
  }
 else {
    out.writeInt(activeGrooms.size());
    out.writeBoolean(true);
    for (    Entry<String,GroomServerStatus> entry : activeGrooms.entrySet()) {
      out.writeUTF(entry.getKey());
      entry.getValue().write(out);
    }
  }
  out.writeInt(tasks);
  out.writeInt(maxTasks);
  WritableUtils.writeEnum(out,state);
}

ID 304=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ClusterStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ClusterStatus
@Override public void readFields(DataInput in) throws IOException {
  numActiveGrooms=in.readInt();
  boolean groomListFollows=in.readBoolean();
  if (groomListFollows) {
    activeGrooms=new HashMap<String,GroomServerStatus>(numActiveGrooms);
    for (int i=0; i < numActiveGrooms; i++) {
      final String groomName=in.readUTF();
      final GroomServerStatus status=new GroomServerStatus();
      status.readFields(in);
      activeGrooms.put(groomName,status);
    }
  }
  tasks=in.readInt();
  maxTasks=in.readInt();
  state=WritableUtils.readEnum(in,BSPMaster.State.class);
}

ID 305=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ClusterStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ClusterStatus
@Override public void readFields(DataInput in) throws IOException {
  numActiveGrooms=in.readInt();
  boolean groomListFollows=in.readBoolean();
  if (groomListFollows) {
    activeGrooms=new HashMap<String,GroomServerStatus>(numActiveGrooms);
    for (int i=0; i < numActiveGrooms; i++) {
      final String groomName=in.readUTF();
      final GroomServerStatus status=new GroomServerStatus();
      status.readFields(in);
      activeGrooms.put(groomName,status);
    }
  }
  tasks=in.readInt();
  maxTasks=in.readInt();
  state=WritableUtils.readEnum(in,BSPMaster.State.class);
}

ID 306=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ClusterStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ClusterStatus
@Override public void readFields(DataInput in) throws IOException {
  numActiveGrooms=in.readInt();
  boolean groomListFollows=in.readBoolean();
  if (groomListFollows) {
    activeGrooms=new HashMap<String,GroomServerStatus>(numActiveGrooms);
    for (int i=0; i < numActiveGrooms; i++) {
      final String groomName=in.readUTF();
      final GroomServerStatus status=new GroomServerStatus();
      status.readFields(in);
      activeGrooms.put(groomName,status);
    }
  }
  tasks=in.readInt();
  maxTasks=in.readInt();
  state=WritableUtils.readEnum(in,BSPMaster.State.class);
}

ID 307=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.GroomServerThread#waitForServerOnline()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Block until the groom server has come online, indicating it is ready to be used.
 */

catch: 
catch (InterruptedException e) {
}

block: 
GroomServerThread
/** 
 * Block until the groom server has come online, indicating it is ready to be used.
 */
public void waitForServerOnline(){
  while (!groomServer.isRunning()) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
}

ID 308=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.ClusterUtil#createGroomServerThread(Configuration, Class<? extends GroomServer>, int)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: /** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */

catch: 
catch (Exception e) {
  IOException ioe=new IOException();
  ioe.initCause(e);
  throw ioe;
}

block: 
ClusterUtil
/** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */
public static ClusterUtil.GroomServerThread createGroomServerThread(final Configuration c,final Class<? extends GroomServer> hrsc,final int index) throws IOException {
  GroomServer server;
  try {
    server=hrsc.getConstructor(Configuration.class).newInstance(c);
  }
 catch (  Exception e) {
    IOException ioe=new IOException();
    ioe.initCause(e);
    throw ioe;
  }
  return new ClusterUtil.GroomServerThread(server,index);
}

ID 309=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.ClusterUtil#createGroomServerThread(Configuration, Class<? extends GroomServer>, int)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */

catch: 
catch (Exception e) {
  IOException ioe=new IOException();
  ioe.initCause(e);
  throw ioe;
}

block: 
ClusterUtil
/** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */
public static ClusterUtil.GroomServerThread createGroomServerThread(final Configuration c,final Class<? extends GroomServer> hrsc,final int index) throws IOException {
  GroomServer server;
  try {
    server=hrsc.getConstructor(Configuration.class).newInstance(c);
  }
 catch (  Exception e) {
    IOException ioe=new IOException();
    ioe.initCause(e);
    throw ioe;
  }
  return new ClusterUtil.GroomServerThread(server,index);
}

ID 310=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.ClusterUtil#createGroomServerThread(Configuration, Class<? extends GroomServer>, int)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: /** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */

catch: 
catch (Exception e) {
  IOException ioe=new IOException();
  ioe.initCause(e);
  throw ioe;
}

block: 
ClusterUtil
/** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */
public static ClusterUtil.GroomServerThread createGroomServerThread(final Configuration c,final Class<? extends GroomServer> hrsc,final int index) throws IOException {
  GroomServer server;
  try {
    server=hrsc.getConstructor(Configuration.class).newInstance(c);
  }
 catch (  Exception e) {
    IOException ioe=new IOException();
    ioe.initCause(e);
    throw ioe;
  }
  return new ClusterUtil.GroomServerThread(server,index);
}

ID 311=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.ClusterUtil#createGroomServerThread(Configuration, Class<? extends GroomServer>, int)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */

catch: 
catch (Exception e) {
  IOException ioe=new IOException();
  ioe.initCause(e);
  throw ioe;
}

block: 
ClusterUtil
/** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */
public static ClusterUtil.GroomServerThread createGroomServerThread(final Configuration c,final Class<? extends GroomServer> hrsc,final int index) throws IOException {
  GroomServer server;
  try {
    server=hrsc.getConstructor(Configuration.class).newInstance(c);
  }
 catch (  Exception e) {
    IOException ioe=new IOException();
    ioe.initCause(e);
    throw ioe;
  }
  return new ClusterUtil.GroomServerThread(server,index);
}

ID 312=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.ClusterUtil#createGroomServerThread(Configuration, Class<? extends GroomServer>, int)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */

catch: 
catch (Exception e) {
  IOException ioe=new IOException();
  ioe.initCause(e);
  throw ioe;
}

block: 
ClusterUtil
/** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */
public static ClusterUtil.GroomServerThread createGroomServerThread(final Configuration c,final Class<? extends GroomServer> hrsc,final int index) throws IOException {
  GroomServer server;
  try {
    server=hrsc.getConstructor(Configuration.class).newInstance(c);
  }
 catch (  Exception e) {
    IOException ioe=new IOException();
    ioe.initCause(e);
    throw ioe;
  }
  return new ClusterUtil.GroomServerThread(server,index);
}

ID 313=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.ClusterUtil#createGroomServerThread(Configuration, Class<? extends GroomServer>, int)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: /** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */

catch: 
catch (Exception e) {
  IOException ioe=new IOException();
  ioe.initCause(e);
  throw ioe;
}

block: 
ClusterUtil
/** 
 * Creates a  {@link GroomServerThread}. Call 'start' on the returned thread to make it run.
 * @param c Configuration to use.
 * @param hrsc Class to create.
 * @param index Used distingushing the object returned.
 * @throws IOException
 * @return Groom server added.
 */
public static ClusterUtil.GroomServerThread createGroomServerThread(final Configuration c,final Class<? extends GroomServer> hrsc,final int index) throws IOException {
  GroomServer server;
  try {
    server=hrsc.getConstructor(Configuration.class).newInstance(c);
  }
 catch (  Exception e) {
    IOException ioe=new IOException();
    ioe.initCause(e);
    throw ioe;
  }
  return new ClusterUtil.GroomServerThread(server,index);
}

ID 314=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.CombineExample#main(java.lang.String[])
Rmethod: org.apache.hama.examples.CombineExample#printOutput(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CombineExample
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {
  HamaConfiguration conf=new HamaConfiguration();
  BSPJob bsp=new BSPJob(conf,CombineExample.class);
  bsp.setJobName("Combine Example");
  bsp.setBspClass(MyBSP.class);
  bsp.setCombinerClass(SumCombiner.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(IntWritable.class);
  bsp.setOutputFormat(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,TMP_OUTPUT);
  bsp.setNumBspTask(2);
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    printOutput(conf);
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 315=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.CombineFileInputFormat#getSplits(BSPJob, int)
Rmethod: org.apache.hama.bsp.CombineFileInputFormat#getMoreSplits(BSPJob, Path[], long, long, long, List<CombineFileSplit>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CombineFileInputFormat
@Override public InputSplit[] getSplits(BSPJob bspJob,int numSplits) throws IOException {
  Configuration job=bspJob.getConfiguration();
  long minSizeNode=0;
  long minSizeRack=0;
  long maxSize=0;
  if (minSplitSizeNode != 0) {
    minSizeNode=minSplitSizeNode;
  }
 else {
    minSizeNode=job.getLong("mapred.min.split.size.per.node",0);
  }
  if (minSplitSizeRack != 0) {
    minSizeRack=minSplitSizeRack;
  }
 else {
    minSizeRack=job.getLong("mapred.min.split.size.per.rack",0);
  }
  if (maxSplitSize != 0) {
    maxSize=maxSplitSize;
  }
 else {
    maxSize=job.getLong("mapred.max.split.size",0);
  }
  if (minSizeNode != 0 && maxSize != 0 && minSizeNode > maxSize) {
    throw new IOException("Minimum split size pernode " + minSizeNode + " cannot be larger than maximum split size "+ maxSize);
  }
  if (minSizeRack != 0 && maxSize != 0 && minSizeRack > maxSize) {
    throw new IOException("Minimum split size per rack" + minSizeRack + " cannot be larger than maximum split size "+ maxSize);
  }
  if (minSizeRack != 0 && minSizeNode > minSizeRack) {
    throw new IOException("Minimum split size per node" + minSizeNode + " cannot be smaller than minimum split size per rack "+ minSizeRack);
  }
  Path[] paths=FileUtil.stat2Paths(listStatus(bspJob));
  List<CombineFileSplit> splits=new ArrayList<CombineFileSplit>();
  if (paths.length == 0) {
    return splits.toArray(new CombineFileSplit[splits.size()]);
  }
  for (  MultiPathFilter onepool : pools) {
    ArrayList<Path> myPaths=new ArrayList<Path>();
    for (int i=0; i < paths.length; i++) {
      if (paths[i] == null) {
        continue;
      }
      Path p=new Path(paths[i].toUri().getPath());
      if (onepool.accept(p)) {
        myPaths.add(paths[i]);
        paths[i]=null;
      }
    }
    getMoreSplits(bspJob,myPaths.toArray(new Path[myPaths.size()]),maxSize,minSizeNode,minSizeRack,splits);
  }
  ArrayList<Path> myPaths=new ArrayList<Path>();
  for (  Path path : paths) {
    if (path == null) {
      continue;
    }
    myPaths.add(path);
  }
  getMoreSplits(bspJob,myPaths.toArray(new Path[myPaths.size()]),maxSize,minSizeNode,minSizeRack,splits);
  rackToNodes.clear();
  return splits.toArray(new CombineFileSplit[splits.size()]);
}

ID 316=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.CombineFileInputFormat#getMoreSplits(BSPJob, Path[], long, long, long, List<CombineFileSplit>)
Rmethod: org.apache.hama.bsp.OneFileInfo#OneFileInfo(Path, BSPJob, HashMap<java.lang.String,List<org.apache.hama.bsp.CombineFileInputFormat.OneBlockInfo>>, HashMap<org.apache.hama.bsp.CombineFileInputFormat.OneBlockInfo,java.lang.String[]>, HashMap<java.lang.String,List<org.apache.hama.bsp.CombineFileInputFormat.OneBlockInfo>>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Return all the splits in the specified set of paths
 */

catch: 
null
block: 
CombineFileInputFormat
/** 
 * Return all the splits in the specified set of paths
 */
private static void getMoreSplits(BSPJob job,Path[] paths,long maxSize,long minSizeNode,long minSizeRack,List<CombineFileSplit> splits) throws IOException {
  OneFileInfo[] files;
  HashMap<String,List<OneBlockInfo>> rackToBlocks=new HashMap<String,List<OneBlockInfo>>();
  HashMap<OneBlockInfo,String[]> blockToNodes=new HashMap<OneBlockInfo,String[]>();
  HashMap<String,List<OneBlockInfo>> nodeToBlocks=new HashMap<String,List<OneBlockInfo>>();
  files=new OneFileInfo[paths.length];
  if (paths.length == 0) {
    return;
  }
  for (int i=0; i < paths.length; i++) {
    files[i]=new OneFileInfo(paths[i],job,rackToBlocks,blockToNodes,nodeToBlocks);
  }
  ArrayList<OneBlockInfo> validBlocks=new ArrayList<OneBlockInfo>();
  ArrayList<String> nodes=new ArrayList<String>();
  long curSplitSize=0;
  for (  Map.Entry<String,List<OneBlockInfo>> one : nodeToBlocks.entrySet()) {
    nodes.add(one.getKey());
    List<OneBlockInfo> blocksInNode=one.getValue();
    for (    OneBlockInfo oneblock : blocksInNode) {
      if (blockToNodes.containsKey(oneblock)) {
        validBlocks.add(oneblock);
        blockToNodes.remove(oneblock);
        curSplitSize+=oneblock.length;
        if (maxSize != 0 && curSplitSize >= maxSize) {
          addCreatedSplit(job,splits,nodes,validBlocks);
          curSplitSize=0;
          validBlocks.clear();
        }
      }
    }
    if (minSizeNode != 0 && curSplitSize >= minSizeNode) {
      addCreatedSplit(job,splits,nodes,validBlocks);
    }
 else {
      for (      OneBlockInfo oneblock : validBlocks) {
        blockToNodes.put(oneblock,oneblock.hosts);
      }
    }
    validBlocks.clear();
    nodes.clear();
    curSplitSize=0;
  }
  ArrayList<OneBlockInfo> overflowBlocks=new ArrayList<OneBlockInfo>();
  ArrayList<String> racks=new ArrayList<String>();
  while (blockToNodes.size() > 0) {
    for (    Map.Entry<String,List<OneBlockInfo>> one : rackToBlocks.entrySet()) {
      racks.add(one.getKey());
      List<OneBlockInfo> blocks=one.getValue();
      boolean createdSplit=false;
      for (      OneBlockInfo oneblock : blocks) {
        if (blockToNodes.containsKey(oneblock)) {
          validBlocks.add(oneblock);
          blockToNodes.remove(oneblock);
          curSplitSize+=oneblock.length;
          if (maxSize != 0 && curSplitSize >= maxSize) {
            addCreatedSplit(job,splits,getHosts(racks),validBlocks);
            createdSplit=true;
            break;
          }
        }
      }
      if (createdSplit) {
        curSplitSize=0;
        validBlocks.clear();
        racks.clear();
        continue;
      }
      if (!validBlocks.isEmpty()) {
        if (minSizeRack != 0 && curSplitSize >= minSizeRack) {
          addCreatedSplit(job,splits,getHosts(racks),validBlocks);
        }
 else {
          overflowBlocks.addAll(validBlocks);
        }
      }
      curSplitSize=0;
      validBlocks.clear();
      racks.clear();
    }
  }
  assert blockToNodes.isEmpty();
  assert curSplitSize == 0;
  assert validBlocks.isEmpty();
  assert racks.isEmpty();
  for (  OneBlockInfo oneblock : overflowBlocks) {
    validBlocks.add(oneblock);
    curSplitSize+=oneblock.length;
    Collections.addAll(racks,oneblock.racks);
    if (maxSize != 0 && curSplitSize >= maxSize) {
      addCreatedSplit(job,splits,getHosts(racks),validBlocks);
      curSplitSize=0;
      validBlocks.clear();
      racks.clear();
    }
  }
  if (!validBlocks.isEmpty()) {
    addCreatedSplit(job,splits,getHosts(racks),validBlocks);
  }
}

ID 317=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.CombineFileSplit#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CombineFileSplit
@Override public void readFields(DataInput in) throws IOException {
  totLength=in.readLong();
  int arrLength=in.readInt();
  lengths=new long[arrLength];
  for (int i=0; i < arrLength; i++) {
    lengths[i]=in.readLong();
  }
  int filesLength=in.readInt();
  paths=new Path[filesLength];
  for (int i=0; i < filesLength; i++) {
    paths[i]=new Path(Text.readString(in));
  }
  arrLength=in.readInt();
  startoffset=new long[arrLength];
  for (int i=0; i < arrLength; i++) {
    startoffset[i]=in.readLong();
  }
}

ID 318=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.CombineFileSplit#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CombineFileSplit
@Override public void readFields(DataInput in) throws IOException {
  totLength=in.readLong();
  int arrLength=in.readInt();
  lengths=new long[arrLength];
  for (int i=0; i < arrLength; i++) {
    lengths[i]=in.readLong();
  }
  int filesLength=in.readInt();
  paths=new Path[filesLength];
  for (int i=0; i < filesLength; i++) {
    paths[i]=new Path(Text.readString(in));
  }
  arrLength=in.readInt();
  startoffset=new long[arrLength];
  for (int i=0; i < arrLength; i++) {
    startoffset[i]=in.readLong();
  }
}

ID 319=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.CombineFileSplit#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CombineFileSplit
@Override public void readFields(DataInput in) throws IOException {
  totLength=in.readLong();
  int arrLength=in.readInt();
  lengths=new long[arrLength];
  for (int i=0; i < arrLength; i++) {
    lengths[i]=in.readLong();
  }
  int filesLength=in.readInt();
  paths=new Path[filesLength];
  for (int i=0; i < filesLength; i++) {
    paths[i]=new Path(Text.readString(in));
  }
  arrLength=in.readInt();
  startoffset=new long[arrLength];
  for (int i=0; i < arrLength; i++) {
    startoffset[i]=in.readLong();
  }
}

ID 320=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.CombineFileSplit#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CombineFileSplit
@Override public void write(DataOutput out) throws IOException {
  out.writeLong(totLength);
  out.writeInt(lengths.length);
  for (  long length : lengths) {
    out.writeLong(length);
  }
  out.writeInt(paths.length);
  for (  Path p : paths) {
    Text.writeString(out,p.toString());
  }
  out.writeInt(startoffset.length);
  for (  long length : startoffset) {
    out.writeLong(length);
  }
}

ID 321=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.CombineFileSplit#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
CombineFileSplit
@Override public void write(DataOutput out) throws IOException {
  out.writeLong(totLength);
  out.writeInt(lengths.length);
  for (  long length : lengths) {
    out.writeLong(length);
  }
  out.writeInt(paths.length);
  for (  Path p : paths) {
    Text.writeString(out,p.toString());
  }
  out.writeInt(startoffset.length);
  for (  long length : startoffset) {
    out.writeLong(length);
  }
}

ID 322=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CompositeInputFormat#setFormat(BSPJob)
Rmethod: org.apache.hama.bsp.join.CompositeInputFormat#addUserIdentifiers(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Interpret a given string as a composite expression. {@code func  ::= <ident>([<func>,]*<func>) func  ::= tbl(<class>,"<path>") class ::= @see java.lang.Class#forName(java.lang.String) path  ::= @see org.apache.hadoop.fs.Path#Path(java.lang.String)} Reads expression from the <tt>mapred.join.expr</tt> property anduser-supplied join types from <tt>mapred.join.define.&lt;ident&gt;</tt> types. Paths supplied to <tt>tbl</tt> are given as input paths to the InputFormat class listed.
 * @see #compose(java.lang.String,java.lang.Class,java.lang.String...)
 */

catch: 
null
block: 
CompositeInputFormat
/** 
 * Interpret a given string as a composite expression. {@code func  ::= <ident>([<func>,]*<func>) func  ::= tbl(<class>,"<path>") class ::= @see java.lang.Class#forName(java.lang.String) path  ::= @see org.apache.hadoop.fs.Path#Path(java.lang.String)} Reads expression from the <tt>mapred.join.expr</tt> property anduser-supplied join types from <tt>mapred.join.define.&lt;ident&gt;</tt> types. Paths supplied to <tt>tbl</tt> are given as input paths to the InputFormat class listed.
 * @see #compose(java.lang.String,java.lang.Class,java.lang.String...)
 */
public void setFormat(BSPJob job) throws IOException {
  addDefaults();
  addUserIdentifiers(job);
  root=Parser.parse(job.get("bsp.join.expr"),job);
}

ID 323=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CompositeInputFormat#getSplits(BSPJob, int)
Rmethod: org.apache.hama.bsp.join.CompositeInputFormat#setFormat(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Build a CompositeInputSplit from the child InputFormats by assigning the ith split from each child to the ith composite split.
 */

catch: 
null
block: 
CompositeInputFormat
/** 
 * Build a CompositeInputSplit from the child InputFormats by assigning the ith split from each child to the ith composite split.
 */
public InputSplit[] getSplits(BSPJob job,int numBspTask) throws IOException {
  setFormat(job);
  job.getConfiguration().setLong("bsp.min.split.size",Long.MAX_VALUE);
  return root.getSplits(job,numBspTask);
}

ID 324=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CompositeInputFormat#getRecordReader(InputSplit, BSPJob)
Rmethod: org.apache.hama.bsp.join.CompositeInputFormat#setFormat(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a CompositeRecordReader for the children of this InputFormat as defined in the init expression. The outermost join need only be composable, not necessarily a composite. Mandating TupleWritable isn't strictly correct.
 */

catch: 
null
block: 
CompositeInputFormat
/** 
 * Construct a CompositeRecordReader for the children of this InputFormat as defined in the init expression. The outermost join need only be composable, not necessarily a composite. Mandating TupleWritable isn't strictly correct.
 */
@SuppressWarnings("unchecked") public ComposableRecordReader<K,TupleWritable> getRecordReader(InputSplit split,BSPJob job) throws IOException {
  setFormat(job);
  return root.getRecordReader(split,job);
}

ID 325=========================================================================type: Recover
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CompositeInputSplit#readFields(java.io.DataInput)
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: true
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * {@inheritDoc}
 * @throws IOException If the child InputSplit cannot be read, typically forfaliing access checks.
 */

catch: 
catch (ClassNotFoundException e) {
  throw (IOException)new IOException("Failed split init").initCause(e);
}

block: 
CompositeInputSplit
/** 
 * {@inheritDoc}
 * @throws IOException If the child InputSplit cannot be read, typically forfaliing access checks.
 */
@SuppressWarnings("unchecked") public void readFields(DataInput in) throws IOException {
  int card=WritableUtils.readVInt(in);
  if (splits == null || splits.length != card) {
    splits=new InputSplit[card];
  }
  Class<? extends InputSplit>[] cls=new Class[card];
  try {
    for (int i=0; i < card; ++i) {
      cls[i]=Class.forName(Text.readString(in)).asSubclass(InputSplit.class);
    }
    for (int i=0; i < card; ++i) {
      splits[i]=ReflectionUtils.newInstance(cls[i],null);
      splits[i].readFields(in);
    }
  }
 catch (  ClassNotFoundException e) {
    throw (IOException)new IOException("Failed split init").initCause(e);
  }
}

ID 326=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.JoinCollector#flush(TupleWritable)
Rmethod: org.apache.hama.bsp.join.JoinCollector#next(TupleWritable)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write the next value into key, value as accepted by the operation associated with this set of RecordReaders.
 */

catch: 
null
block: 
JoinCollector
/** 
 * Write the next value into key, value as accepted by the operation associated with this set of RecordReaders.
 */
public boolean flush(TupleWritable value) throws IOException {
  while (hasNext()) {
    value.clearWritten();
    if (next(value) && combine(kids,value)) {
      return true;
    }
  }
  return false;
}

ID 327=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CompositeRecordReader#accept(JoinCollector#RAW, K)
Rmethod: org.apache.hama.bsp.join.CompositeRecordReader#fillJoinCollector(K)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * If key provided matches that of this Composite, give JoinCollector iterator over values it may emit.
 */

catch: 
null
block: 
CompositeRecordReader
/** 
 * If key provided matches that of this Composite, give JoinCollector iterator over values it may emit.
 */
@SuppressWarnings("unchecked") public void accept(CompositeRecordReader.JoinCollector jc,K key) throws IOException {
  if (hasNext() && 0 == cmp.compare(key,key())) {
    fillJoinCollector(createKey());
    jc.add(id,getDelegate());
    return;
  }
  jc.add(id,EMPTY);
}

ID 328=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CompositeRecordReader#accept(JoinCollector#RAW, K)
Rmethod: org.apache.hama.bsp.join.JoinCollector#add(int, ResetableIterator<X>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * If key provided matches that of this Composite, give JoinCollector iterator over values it may emit.
 */

catch: 
null
block: 
CompositeRecordReader
/** 
 * If key provided matches that of this Composite, give JoinCollector iterator over values it may emit.
 */
@SuppressWarnings("unchecked") public void accept(CompositeRecordReader.JoinCollector jc,K key) throws IOException {
  if (hasNext() && 0 == cmp.compare(key,key())) {
    fillJoinCollector(createKey());
    jc.add(id,getDelegate());
    return;
  }
  jc.add(id,EMPTY);
}

ID 329=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CompositeRecordReader#close()
Rmethod: org.apache.hama.bsp.join.JoinCollector#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Close all child RRs.
 */

catch: 
null
block: 
CompositeRecordReader
/** 
 * Close all child RRs.
 */
public void close() throws IOException {
  if (kids != null) {
    for (    RecordReader<K,? extends Writable> rr : kids) {
      rr.close();
    }
  }
  if (jc != null) {
    jc.close();
  }
}

ID 330=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Configurator#configure(HamaConfiguration, MonitorListener)
Rmethod: org.apache.hama.monitor.Configurator#load(java.io.File, java.lang.ClassLoader)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Configure plugins directory for monitoring GroomServer.
 * @param conf file points out the plugin dir location.
 * @return Map contains jar path and task to be executed; null if plugindirectory, default set to $HAMA_HOME/plugins, doesn't exist.
 */

catch: 
null
block: 
Configurator
/** 
 * Configure plugins directory for monitoring GroomServer.
 * @param conf file points out the plugin dir location.
 * @return Map contains jar path and task to be executed; null if plugindirectory, default set to $HAMA_HOME/plugins, doesn't exist.
 */
public static Map<String,Task> configure(HamaConfiguration conf,MonitorListener listener) throws IOException {
  String hamaHome=System.getProperty("hama.home.dir");
  String pluginPath=conf.get("bsp.monitor.plugins.dir",hamaHome + File.separator + DEFAULT_PLUGINS_DIR);
  File pluginDir=new File(pluginPath);
  if (null == pluginDir || null == pluginDir.listFiles())   return null;
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  Map<String,Task> taskList=new HashMap<String,Task>();
  LOG.debug("Scanning jar files within " + pluginDir + ".");
  for (  File jar : pluginDir.listFiles()) {
    String jarPath=jar.getPath();
    Long timestamp=repos.get(jarPath);
    if (null == timestamp || jar.lastModified() > timestamp) {
      Task t=load(jar,loader);
      if (null != t) {
        t.setListener(listener);
        taskList.put(jarPath,t);
        repos.put(jarPath,jar.lastModified());
        LOG.debug(jar.getName() + " is loaded.");
      }
    }
  }
  return taskList;
}

ID 331=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Configurator#load(java.io.File, java.lang.ClassLoader)
Rmethod: java.util.jar.JarFile#JarFile(java.io.File)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */

catch: 
null
block: 
Configurator
/** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */
private static Task load(File path,ClassLoader loader) throws IOException {
  JarFile jar=new JarFile(path);
  Manifest manifest=jar.getManifest();
  String pkg=manifest.getMainAttributes().getValue("Package");
  String main=manifest.getMainAttributes().getValue("Main-Class");
  if (null == pkg || null == main)   throw new NullPointerException("Package or main class not found " + "in menifest file.");
  String namespace=pkg + File.separator + main;
  namespace=namespace.replaceAll(File.separator,".");
  LOG.debug("Task class to be loaded: " + namespace);
  URLClassLoader child=new URLClassLoader(new URL[]{path.toURI().toURL()},loader);
  Thread.currentThread().setContextClassLoader(child);
  Class<?> taskClass=null;
  try {
    taskClass=Class.forName(namespace,true,child);
  }
 catch (  ClassNotFoundException cnfe) {
    LOG.warn("Task class is not found.",cnfe);
  }
  if (null == taskClass)   return null;
  try {
    return (Task)taskClass.newInstance();
  }
 catch (  InstantiationException ie) {
    LOG.warn("Unable to instantiate task class." + namespace,ie);
  }
catch (  IllegalAccessException iae) {
    LOG.warn(iae);
  }
  return null;
}

ID 332=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Configurator#load(java.io.File, java.lang.ClassLoader)
Rmethod: java.util.jar.JarFile#getManifest()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */

catch: 
null
block: 
Configurator
/** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */
private static Task load(File path,ClassLoader loader) throws IOException {
  JarFile jar=new JarFile(path);
  Manifest manifest=jar.getManifest();
  String pkg=manifest.getMainAttributes().getValue("Package");
  String main=manifest.getMainAttributes().getValue("Main-Class");
  if (null == pkg || null == main)   throw new NullPointerException("Package or main class not found " + "in menifest file.");
  String namespace=pkg + File.separator + main;
  namespace=namespace.replaceAll(File.separator,".");
  LOG.debug("Task class to be loaded: " + namespace);
  URLClassLoader child=new URLClassLoader(new URL[]{path.toURI().toURL()},loader);
  Thread.currentThread().setContextClassLoader(child);
  Class<?> taskClass=null;
  try {
    taskClass=Class.forName(namespace,true,child);
  }
 catch (  ClassNotFoundException cnfe) {
    LOG.warn("Task class is not found.",cnfe);
  }
  if (null == taskClass)   return null;
  try {
    return (Task)taskClass.newInstance();
  }
 catch (  InstantiationException ie) {
    LOG.warn("Unable to instantiate task class." + namespace,ie);
  }
catch (  IllegalAccessException iae) {
    LOG.warn(iae);
  }
  return null;
}

ID 333=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Configurator#load(java.io.File, java.lang.ClassLoader)
Rmethod: java.net.URI#toURL()
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

method comment: /** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */

catch: 
null
block: 
Configurator
/** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */
private static Task load(File path,ClassLoader loader) throws IOException {
  JarFile jar=new JarFile(path);
  Manifest manifest=jar.getManifest();
  String pkg=manifest.getMainAttributes().getValue("Package");
  String main=manifest.getMainAttributes().getValue("Main-Class");
  if (null == pkg || null == main)   throw new NullPointerException("Package or main class not found " + "in menifest file.");
  String namespace=pkg + File.separator + main;
  namespace=namespace.replaceAll(File.separator,".");
  LOG.debug("Task class to be loaded: " + namespace);
  URLClassLoader child=new URLClassLoader(new URL[]{path.toURI().toURL()},loader);
  Thread.currentThread().setContextClassLoader(child);
  Class<?> taskClass=null;
  try {
    taskClass=Class.forName(namespace,true,child);
  }
 catch (  ClassNotFoundException cnfe) {
    LOG.warn("Task class is not found.",cnfe);
  }
  if (null == taskClass)   return null;
  try {
    return (Task)taskClass.newInstance();
  }
 catch (  InstantiationException ie) {
    LOG.warn("Unable to instantiate task class." + namespace,ie);
  }
catch (  IllegalAccessException iae) {
    LOG.warn(iae);
  }
  return null;
}

ID 334=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Configurator#load(java.io.File, java.lang.ClassLoader)
Rmethod: java.lang.Class#forName(java.lang.String, boolean, java.lang.ClassLoader)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */

catch: 
catch (ClassNotFoundException cnfe) {
  LOG.warn("Task class is not found.",cnfe);
}

block: 
Configurator
/** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */
private static Task load(File path,ClassLoader loader) throws IOException {
  JarFile jar=new JarFile(path);
  Manifest manifest=jar.getManifest();
  String pkg=manifest.getMainAttributes().getValue("Package");
  String main=manifest.getMainAttributes().getValue("Main-Class");
  if (null == pkg || null == main)   throw new NullPointerException("Package or main class not found " + "in menifest file.");
  String namespace=pkg + File.separator + main;
  namespace=namespace.replaceAll(File.separator,".");
  LOG.debug("Task class to be loaded: " + namespace);
  URLClassLoader child=new URLClassLoader(new URL[]{path.toURI().toURL()},loader);
  Thread.currentThread().setContextClassLoader(child);
  Class<?> taskClass=null;
  try {
    taskClass=Class.forName(namespace,true,child);
  }
 catch (  ClassNotFoundException cnfe) {
    LOG.warn("Task class is not found.",cnfe);
  }
  if (null == taskClass)   return null;
  try {
    return (Task)taskClass.newInstance();
  }
 catch (  InstantiationException ie) {
    LOG.warn("Unable to instantiate task class." + namespace,ie);
  }
catch (  IllegalAccessException iae) {
    LOG.warn(iae);
  }
  return null;
}

ID 335=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Configurator#load(java.io.File, java.lang.ClassLoader)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: /** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */

catch: 
catch (InstantiationException ie) {
  LOG.warn("Unable to instantiate task class." + namespace,ie);
}

block: 
Configurator
/** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */
private static Task load(File path,ClassLoader loader) throws IOException {
  JarFile jar=new JarFile(path);
  Manifest manifest=jar.getManifest();
  String pkg=manifest.getMainAttributes().getValue("Package");
  String main=manifest.getMainAttributes().getValue("Main-Class");
  if (null == pkg || null == main)   throw new NullPointerException("Package or main class not found " + "in menifest file.");
  String namespace=pkg + File.separator + main;
  namespace=namespace.replaceAll(File.separator,".");
  LOG.debug("Task class to be loaded: " + namespace);
  URLClassLoader child=new URLClassLoader(new URL[]{path.toURI().toURL()},loader);
  Thread.currentThread().setContextClassLoader(child);
  Class<?> taskClass=null;
  try {
    taskClass=Class.forName(namespace,true,child);
  }
 catch (  ClassNotFoundException cnfe) {
    LOG.warn("Task class is not found.",cnfe);
  }
  if (null == taskClass)   return null;
  try {
    return (Task)taskClass.newInstance();
  }
 catch (  InstantiationException ie) {
    LOG.warn("Unable to instantiate task class." + namespace,ie);
  }
catch (  IllegalAccessException iae) {
    LOG.warn(iae);
  }
  return null;
}

ID 336=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Configurator#load(java.io.File, java.lang.ClassLoader)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */

catch: 
catch (IllegalAccessException iae) {
  LOG.warn(iae);
}

block: 
Configurator
/** 
 * Load jar from specified path.
 * @param path to the jar file.
 * @param loader of the current thread.
 * @return task to be run.
 */
private static Task load(File path,ClassLoader loader) throws IOException {
  JarFile jar=new JarFile(path);
  Manifest manifest=jar.getManifest();
  String pkg=manifest.getMainAttributes().getValue("Package");
  String main=manifest.getMainAttributes().getValue("Main-Class");
  if (null == pkg || null == main)   throw new NullPointerException("Package or main class not found " + "in menifest file.");
  String namespace=pkg + File.separator + main;
  namespace=namespace.replaceAll(File.separator,".");
  LOG.debug("Task class to be loaded: " + namespace);
  URLClassLoader child=new URLClassLoader(new URL[]{path.toURI().toURL()},loader);
  Thread.currentThread().setContextClassLoader(child);
  Class<?> taskClass=null;
  try {
    taskClass=Class.forName(namespace,true,child);
  }
 catch (  ClassNotFoundException cnfe) {
    LOG.warn("Task class is not found.",cnfe);
  }
  if (null == taskClass)   return null;
  try {
    return (Task)taskClass.newInstance();
  }
 catch (  InstantiationException ie) {
    LOG.warn("Unable to instantiate task class." + namespace,ie);
  }
catch (  IllegalAccessException iae) {
    LOG.warn(iae);
  }
  return null;
}

ID 337=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.ConnectionHeader#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ConnectionHeader
@Override public void readFields(DataInput in) throws IOException {
  protocol=Text.readString(in);
  if (protocol.isEmpty()) {
    protocol=null;
  }
  boolean ugiUsernamePresent=in.readBoolean();
  if (ugiUsernamePresent) {
    String username=in.readUTF();
    boolean realUserNamePresent=in.readBoolean();
    if (realUserNamePresent) {
      String realUserName=in.readUTF();
      UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(realUserName);
      ugi=UserGroupInformation.createProxyUser(username,realUserUgi);
    }
 else {
      ugi=UserGroupInformation.createRemoteUser(username);
    }
  }
 else {
    ugi=null;
  }
}

ID 338=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.ConnectionHeader#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ConnectionHeader
@Override public void readFields(DataInput in) throws IOException {
  protocol=Text.readString(in);
  if (protocol.isEmpty()) {
    protocol=null;
  }
  boolean ugiUsernamePresent=in.readBoolean();
  if (ugiUsernamePresent) {
    String username=in.readUTF();
    boolean realUserNamePresent=in.readBoolean();
    if (realUserNamePresent) {
      String realUserName=in.readUTF();
      UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(realUserName);
      ugi=UserGroupInformation.createProxyUser(username,realUserUgi);
    }
 else {
      ugi=UserGroupInformation.createRemoteUser(username);
    }
  }
 else {
    ugi=null;
  }
}

ID 339=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.ConnectionHeader#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ConnectionHeader
@Override public void write(DataOutput out) throws IOException {
  Text.writeString(out,(protocol == null) ? "" : protocol);
  if (ugi != null) {
    if (authMethod == AuthMethod.KERBEROS) {
      out.writeBoolean(true);
      out.writeUTF(ugi.getUserName());
      out.writeBoolean(false);
    }
 else     if (authMethod == AuthMethod.DIGEST) {
      out.writeBoolean(false);
    }
 else {
      out.writeBoolean(true);
      out.writeUTF(ugi.getUserName());
      if (ugi.getRealUser() != null) {
        out.writeBoolean(true);
        out.writeUTF(ugi.getRealUser().getUserName());
      }
 else {
        out.writeBoolean(false);
      }
    }
  }
 else {
    out.writeBoolean(false);
  }
}

ID 340=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.ConnectionHeader#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ConnectionHeader
@Override public void write(DataOutput out) throws IOException {
  Text.writeString(out,(protocol == null) ? "" : protocol);
  if (ugi != null) {
    if (authMethod == AuthMethod.KERBEROS) {
      out.writeBoolean(true);
      out.writeUTF(ugi.getUserName());
      out.writeBoolean(false);
    }
 else     if (authMethod == AuthMethod.DIGEST) {
      out.writeBoolean(false);
    }
 else {
      out.writeBoolean(true);
      out.writeUTF(ugi.getUserName());
      if (ugi.getRealUser() != null) {
        out.writeBoolean(true);
        out.writeUTF(ugi.getRealUser().getUserName());
      }
 else {
        out.writeBoolean(false);
      }
    }
  }
 else {
    out.writeBoolean(false);
  }
}

ID 341=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counter#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read the binary representation of the counter
 */

catch: 
null
block: 
Counter
/** 
 * Read the binary representation of the counter
 */
@Override public synchronized void readFields(DataInput in) throws IOException {
  name=Text.readString(in);
  if (in.readBoolean()) {
    displayName=Text.readString(in);
  }
 else {
    displayName=name;
  }
  value=WritableUtils.readVLong(in);
}

ID 342=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counter#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write the binary representation of the counter
 */

catch: 
null
block: 
Counter
/** 
 * Write the binary representation of the counter
 */
@Override public synchronized void write(DataOutput out) throws IOException {
  Text.writeString(out,name);
  boolean distinctDisplayName=!name.equals(displayName);
  out.writeBoolean(distinctDisplayName);
  if (distinctDisplayName) {
    Text.writeString(out,displayName);
  }
  WritableUtils.writeVLong(out,value);
}

ID 343=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Group#write(java.io.DataOutput)
Rmethod: org.apache.hama.bsp.Counter#write(java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Group
@Override public synchronized void write(DataOutput out) throws IOException {
  Text.writeString(out,displayName);
  WritableUtils.writeVInt(out,subcounters.size());
  for (  Counter counter : subcounters.values()) {
    counter.write(out);
  }
}

ID 344=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Group#readFields(java.io.DataInput)
Rmethod: org.apache.hama.bsp.Counter#readFields(java.io.DataInput)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Group
@Override public synchronized void readFields(DataInput in) throws IOException {
  displayName=Text.readString(in);
  subcounters.clear();
  int size=WritableUtils.readVInt(in);
  for (int i=0; i < size; i++) {
    Counter counter=new Counter();
    counter.readFields(in);
    subcounters.put(counter.getName(),counter);
  }
}

ID 345=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counters#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write the set of groups. The external format is: #groups (groupName group) i.e. the number of groups followed by 0 or more groups, where each group is of the form: groupDisplayName #counters (false | true counter) where each counter is of the form: name (false | true displayName) value
 */

catch: 
null
block: 
Counters
/** 
 * Write the set of groups. The external format is: #groups (groupName group) i.e. the number of groups followed by 0 or more groups, where each group is of the form: groupDisplayName #counters (false | true counter) where each counter is of the form: name (false | true displayName) value
 */
@Override public synchronized void write(DataOutput out) throws IOException {
  out.writeInt(counters.size());
  for (  Group group : counters.values()) {
    Text.writeString(out,group.getName());
    group.write(out);
  }
}

ID 346=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counters#write(java.io.DataOutput)
Rmethod: org.apache.hama.bsp.Group#write(java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write the set of groups. The external format is: #groups (groupName group) i.e. the number of groups followed by 0 or more groups, where each group is of the form: groupDisplayName #counters (false | true counter) where each counter is of the form: name (false | true displayName) value
 */

catch: 
null
block: 
Counters
/** 
 * Write the set of groups. The external format is: #groups (groupName group) i.e. the number of groups followed by 0 or more groups, where each group is of the form: groupDisplayName #counters (false | true counter) where each counter is of the form: name (false | true displayName) value
 */
@Override public synchronized void write(DataOutput out) throws IOException {
  out.writeInt(counters.size());
  for (  Group group : counters.values()) {
    Text.writeString(out,group.getName());
    group.write(out);
  }
}

ID 347=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counters#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read a set of groups.
 */

catch: 
null
block: 
Counters
/** 
 * Read a set of groups.
 */
@Override public synchronized void readFields(DataInput in) throws IOException {
  int numClasses=in.readInt();
  counters.clear();
  while (numClasses-- > 0) {
    String groupName=Text.readString(in);
    Group group=new Group(groupName);
    group.readFields(in);
    counters.put(groupName,group);
  }
}

ID 348=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counters#readFields(java.io.DataInput)
Rmethod: org.apache.hama.bsp.Group#readFields(java.io.DataInput)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read a set of groups.
 */

catch: 
null
block: 
Counters
/** 
 * Read a set of groups.
 */
@Override public synchronized void readFields(DataInput in) throws IOException {
  int numClasses=in.readInt();
  counters.clear();
  while (numClasses-- > 0) {
    String groupName=Text.readString(in);
    Group group=new Group(groupName);
    group.readFields(in);
    counters.put(groupName,group);
  }
}

ID 349=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counters#fromEscapedCompactString(java.lang.String)
Rmethod: org.apache.hama.bsp.Counters#getBlock(java.lang.String, char, char, IntWritable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.text.ParseException
exception comment: /** 
 * Signals that an error has been reached unexpectedly while parsing.
 * @see java.lang.Exception
 * @see java.text.Format
 * @see java.text.FieldPosition
 * @author      Mark Davis
 */

method comment: /** 
 * Convert a stringified counter representation into a counter object. Note that the counter can be recovered if its stringified using {@link #makeEscapedCompactString()}.
 * @return a Counter
 */

catch: 
null
block: 
Counters
/** 
 * Convert a stringified counter representation into a counter object. Note that the counter can be recovered if its stringified using {@link #makeEscapedCompactString()}.
 * @return a Counter
 */
public static Counters fromEscapedCompactString(String compactString) throws ParseException {
  Counters counters=new Counters();
  IntWritable index=new IntWritable(0);
  String groupString=getBlock(compactString,GROUP_OPEN,GROUP_CLOSE,index);
  while (groupString != null) {
    IntWritable groupIndex=new IntWritable(0);
    String groupName=getBlock(groupString,UNIT_OPEN,UNIT_CLOSE,groupIndex);
    groupName=unescape(groupName);
    String groupDisplayName=getBlock(groupString,UNIT_OPEN,UNIT_CLOSE,groupIndex);
    groupDisplayName=unescape(groupDisplayName);
    Group group=counters.getGroup(groupName);
    group.setDisplayName(groupDisplayName);
    String counterString=getBlock(groupString,COUNTER_OPEN,COUNTER_CLOSE,groupIndex);
    while (counterString != null) {
      IntWritable counterIndex=new IntWritable(0);
      String counterName=getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex);
      counterName=unescape(counterName);
      String counterDisplayName=getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex);
      counterDisplayName=unescape(counterDisplayName);
      long value=Long.parseLong(getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex));
      Counter counter=group.getCounterForName(counterName);
      counter.setDisplayName(counterDisplayName);
      counter.increment(value);
      counterString=getBlock(groupString,COUNTER_OPEN,COUNTER_CLOSE,groupIndex);
    }
    groupString=getBlock(compactString,GROUP_OPEN,GROUP_CLOSE,index);
  }
  return counters;
}

ID 350=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counters#fromEscapedCompactString(java.lang.String)
Rmethod: org.apache.hama.bsp.Counters#getBlock(java.lang.String, char, char, IntWritable)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.text.ParseException
exception comment: /** 
 * Signals that an error has been reached unexpectedly while parsing.
 * @see java.lang.Exception
 * @see java.text.Format
 * @see java.text.FieldPosition
 * @author      Mark Davis
 */

method comment: /** 
 * Convert a stringified counter representation into a counter object. Note that the counter can be recovered if its stringified using {@link #makeEscapedCompactString()}.
 * @return a Counter
 */

catch: 
null
block: 
Counters
/** 
 * Convert a stringified counter representation into a counter object. Note that the counter can be recovered if its stringified using {@link #makeEscapedCompactString()}.
 * @return a Counter
 */
public static Counters fromEscapedCompactString(String compactString) throws ParseException {
  Counters counters=new Counters();
  IntWritable index=new IntWritable(0);
  String groupString=getBlock(compactString,GROUP_OPEN,GROUP_CLOSE,index);
  while (groupString != null) {
    IntWritable groupIndex=new IntWritable(0);
    String groupName=getBlock(groupString,UNIT_OPEN,UNIT_CLOSE,groupIndex);
    groupName=unescape(groupName);
    String groupDisplayName=getBlock(groupString,UNIT_OPEN,UNIT_CLOSE,groupIndex);
    groupDisplayName=unescape(groupDisplayName);
    Group group=counters.getGroup(groupName);
    group.setDisplayName(groupDisplayName);
    String counterString=getBlock(groupString,COUNTER_OPEN,COUNTER_CLOSE,groupIndex);
    while (counterString != null) {
      IntWritable counterIndex=new IntWritable(0);
      String counterName=getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex);
      counterName=unescape(counterName);
      String counterDisplayName=getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex);
      counterDisplayName=unescape(counterDisplayName);
      long value=Long.parseLong(getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex));
      Counter counter=group.getCounterForName(counterName);
      counter.setDisplayName(counterDisplayName);
      counter.increment(value);
      counterString=getBlock(groupString,COUNTER_OPEN,COUNTER_CLOSE,groupIndex);
    }
    groupString=getBlock(compactString,GROUP_OPEN,GROUP_CLOSE,index);
  }
  return counters;
}

ID 351=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Counters#fromEscapedCompactString(java.lang.String)
Rmethod: java.lang.Long#parseLong(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Convert a stringified counter representation into a counter object. Note that the counter can be recovered if its stringified using {@link #makeEscapedCompactString()}.
 * @return a Counter
 */

catch: 
null
block: 
Counters
/** 
 * Convert a stringified counter representation into a counter object. Note that the counter can be recovered if its stringified using {@link #makeEscapedCompactString()}.
 * @return a Counter
 */
public static Counters fromEscapedCompactString(String compactString) throws ParseException {
  Counters counters=new Counters();
  IntWritable index=new IntWritable(0);
  String groupString=getBlock(compactString,GROUP_OPEN,GROUP_CLOSE,index);
  while (groupString != null) {
    IntWritable groupIndex=new IntWritable(0);
    String groupName=getBlock(groupString,UNIT_OPEN,UNIT_CLOSE,groupIndex);
    groupName=unescape(groupName);
    String groupDisplayName=getBlock(groupString,UNIT_OPEN,UNIT_CLOSE,groupIndex);
    groupDisplayName=unescape(groupDisplayName);
    Group group=counters.getGroup(groupName);
    group.setDisplayName(groupDisplayName);
    String counterString=getBlock(groupString,COUNTER_OPEN,COUNTER_CLOSE,groupIndex);
    while (counterString != null) {
      IntWritable counterIndex=new IntWritable(0);
      String counterName=getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex);
      counterName=unescape(counterName);
      String counterDisplayName=getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex);
      counterDisplayName=unescape(counterDisplayName);
      long value=Long.parseLong(getBlock(counterString,UNIT_OPEN,UNIT_CLOSE,counterIndex));
      Counter counter=group.getCounterForName(counterName);
      counter.setDisplayName(counterDisplayName);
      counter.increment(value);
      counterString=getBlock(groupString,COUNTER_OPEN,COUNTER_CLOSE,groupIndex);
    }
    groupString=getBlock(compactString,GROUP_OPEN,GROUP_CLOSE,index);
  }
  return counters;
}

ID 352=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.DenseVectorWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DenseVectorWritable
@Override public void readFields(DataInput in) throws IOException {
  int size=in.readInt();
  int len=in.readInt();
  setSize(size);
  for (int i=0; i < len; i++) {
    int index=in.readInt();
    double value=in.readDouble();
    values[index]=value;
  }
}

ID 353=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.DenseVectorWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DenseVectorWritable
@Override public void readFields(DataInput in) throws IOException {
  int size=in.readInt();
  int len=in.readInt();
  setSize(size);
  for (int i=0; i < len; i++) {
    int index=in.readInt();
    double value=in.readDouble();
    values[index]=value;
  }
}

ID 354=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.DenseVectorWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readDouble()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DenseVectorWritable
@Override public void readFields(DataInput in) throws IOException {
  int size=in.readInt();
  int len=in.readInt();
  setSize(size);
  for (int i=0; i < len; i++) {
    int index=in.readInt();
    double value=in.readDouble();
    values[index]=value;
  }
}

ID 355=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.DenseVectorWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DenseVectorWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(getSize());
  out.writeInt(getSize());
  for (int i=0; i < getSize(); i++) {
    out.writeInt(i);
    out.writeDouble(values[i]);
  }
}

ID 356=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.DenseVectorWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DenseVectorWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(getSize());
  out.writeInt(getSize());
  for (int i=0; i < getSize(); i++) {
    out.writeInt(i);
    out.writeDouble(values[i]);
  }
}

ID 357=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.DenseVectorWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeDouble(double)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DenseVectorWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(getSize());
  out.writeInt(getSize());
  for (int i=0; i < getSize(); i++) {
    out.writeInt(i);
    out.writeDouble(values[i]);
  }
}

ID 358=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Directive#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Command for BSPMaster or GroomServer to execute. public abstract void execute() throws Exception;
 */

catch: 
null
block: 
Directive
/** 
 * Command for BSPMaster or GroomServer to execute. public abstract void execute() throws Exception;
 */
@Override public void write(DataOutput out) throws IOException {
  out.writeLong(this.timestamp);
  out.writeInt(this.type.value());
}

ID 359=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Directive#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Command for BSPMaster or GroomServer to execute. public abstract void execute() throws Exception;
 */

catch: 
null
block: 
Directive
/** 
 * Command for BSPMaster or GroomServer to execute. public abstract void execute() throws Exception;
 */
@Override public void write(DataOutput out) throws IOException {
  out.writeLong(this.timestamp);
  out.writeInt(this.type.value());
}

ID 360=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Directive#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Directive
@Override public void readFields(DataInput in) throws IOException {
  this.timestamp=in.readLong();
  int t=in.readInt();
  if (Directive.Type.Request.value() == t) {
    this.type=Directive.Type.Request;
  }
 else {
    this.type=Directive.Type.Response;
  }
}

ID 361=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Directive#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Directive
@Override public void readFields(DataInput in) throws IOException {
  this.timestamp=in.readLong();
  int t=in.readInt();
  if (Directive.Type.Request.value() == t) {
    this.type=Directive.Type.Request;
  }
 else {
    this.type=Directive.Type.Response;
  }
}

ID 362=========================================================================type: Rethrow
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.DistributedCacheUtil#addFilesToHDFS(Configuration, java.lang.String)
Rmethod: java.net.URI#URI(java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.net.URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

method comment: /** 
 * Add the Files to HDFS
 * @param conf The job's configuration
 * @param files Paths that should be transfered to HDFS
 */

catch: 
catch (URISyntaxException e) {
  throw new IllegalArgumentException(e);
}

block: 
DistributedCacheUtil
/** 
 * Add the Files to HDFS
 * @param conf The job's configuration
 * @param files Paths that should be transfered to HDFS
 */
public static String addFilesToHDFS(Configuration conf,String files){
  if (files == null)   return null;
  String[] fileArr=files.split(",");
  String[] finalArr=new String[fileArr.length];
  for (int i=0; i < fileArr.length; i++) {
    String tmp=fileArr[i];
    String finalPath;
    URI pathURI;
    try {
      pathURI=new URI(tmp);
    }
 catch (    URISyntaxException e) {
      throw new IllegalArgumentException(e);
    }
    try {
      LocalFileSystem local=LocalFileSystem.getLocal(conf);
      Path pathSrc=new Path(pathURI);
      if (local.exists(pathSrc)) {
        FileSystem hdfs=FileSystem.get(conf);
        Path pathDst=new Path(hdfs.getWorkingDirectory() + "/temp",pathSrc.getName());
        LOG.debug("copyToHDFSFile: " + pathDst);
        hdfs.copyFromLocalFile(pathSrc,pathDst);
        hdfs.deleteOnExit(pathDst);
        finalPath=pathDst.makeQualified(hdfs).toString();
        finalArr[i]=finalPath;
      }
    }
 catch (    IOException e) {
      LOG.error(e);
    }
  }
  return StringUtils.arrayToString(finalArr);
}

ID 363=========================================================================type: Rethrow
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.DistributedCacheUtil#addJarsToJobClasspath(Configuration)
Rmethod: java.net.URI#URI(java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.net.URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

method comment: /** 
 * Add the JARs from the given HDFS paths to the Classpath
 * @param conf The job's configuration
 */

catch: 
catch (URISyntaxException e) {
  throw new IllegalArgumentException(e);
}

block: 
DistributedCacheUtil
/** 
 * Add the JARs from the given HDFS paths to the Classpath
 * @param conf The job's configuration
 */
public static URL[] addJarsToJobClasspath(Configuration conf){
  URL[] classLoaderURLs=((URLClassLoader)conf.getClassLoader()).getURLs();
  String files=conf.get("tmpjars","");
  if (!files.isEmpty()) {
    String[] fileArr=files.split(",");
    URL[] libjars=new URL[fileArr.length + classLoaderURLs.length];
    for (int i=0; i < fileArr.length; i++) {
      String tmp=fileArr[i];
      URI pathURI;
      try {
        pathURI=new URI(tmp);
      }
 catch (      URISyntaxException e) {
        throw new IllegalArgumentException(e);
      }
      try {
        FileSystem hdfs=FileSystem.get(conf);
        Path pathSrc=new Path(pathURI.getPath());
        if (hdfs.exists(pathSrc)) {
          LocalFileSystem local=LocalFileSystem.getLocal(conf);
          Path pathDst=new Path(local.getWorkingDirectory(),pathSrc.getName());
          LOG.debug("copyToLocalFile: " + pathDst);
          hdfs.copyToLocalFile(pathSrc,pathDst);
          local.deleteOnExit(pathDst);
          libjars[i]=new URL(local.makeQualified(pathDst).toString());
        }
      }
 catch (      IOException ex) {
        throw new RuntimeException("Error setting up classpath",ex);
      }
    }
    int index=fileArr.length;
    for (int i=0; i < classLoaderURLs.length; i++) {
      libjars[index]=classLoaderURLs[i];
      index++;
    }
    conf.setClassLoader(new URLClassLoader(libjars,conf.getClassLoader()));
    Thread.currentThread().setContextClassLoader(new URLClassLoader(libjars,Thread.currentThread().getContextClassLoader()));
    String jars="";
    for (int i=0; i < fileArr.length; i++) {
      URL url=libjars[i];
      if (jars.length() > 0) {
        jars+=",";
      }
      jars+=url.toString();
    }
    conf.set("tmpjars",jars);
    return libjars;
  }
  return null;
}

ID 364=========================================================================type: Rethrow
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.DistributedCacheUtil#addJarsToJobClasspath(Configuration)
Rmethod: java.net.URL#URL(java.lang.String)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.net.MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

method comment: /** 
 * Add the JARs from the given HDFS paths to the Classpath
 * @param conf The job's configuration
 */

catch: 
catch (IOException ex) {
  throw new RuntimeException("Error setting up classpath",ex);
}

block: 
DistributedCacheUtil
/** 
 * Add the JARs from the given HDFS paths to the Classpath
 * @param conf The job's configuration
 */
public static URL[] addJarsToJobClasspath(Configuration conf){
  URL[] classLoaderURLs=((URLClassLoader)conf.getClassLoader()).getURLs();
  String files=conf.get("tmpjars","");
  if (!files.isEmpty()) {
    String[] fileArr=files.split(",");
    URL[] libjars=new URL[fileArr.length + classLoaderURLs.length];
    for (int i=0; i < fileArr.length; i++) {
      String tmp=fileArr[i];
      URI pathURI;
      try {
        pathURI=new URI(tmp);
      }
 catch (      URISyntaxException e) {
        throw new IllegalArgumentException(e);
      }
      try {
        FileSystem hdfs=FileSystem.get(conf);
        Path pathSrc=new Path(pathURI.getPath());
        if (hdfs.exists(pathSrc)) {
          LocalFileSystem local=LocalFileSystem.getLocal(conf);
          Path pathDst=new Path(local.getWorkingDirectory(),pathSrc.getName());
          LOG.debug("copyToLocalFile: " + pathDst);
          hdfs.copyToLocalFile(pathSrc,pathDst);
          local.deleteOnExit(pathDst);
          libjars[i]=new URL(local.makeQualified(pathDst).toString());
        }
      }
 catch (      IOException ex) {
        throw new RuntimeException("Error setting up classpath",ex);
      }
    }
    int index=fileArr.length;
    for (int i=0; i < classLoaderURLs.length; i++) {
      libjars[index]=classLoaderURLs[i];
      index++;
    }
    conf.setClassLoader(new URLClassLoader(libjars,conf.getClassLoader()));
    Thread.currentThread().setContextClassLoader(new URLClassLoader(libjars,Thread.currentThread().getContextClassLoader()));
    String jars="";
    for (int i=0; i < fileArr.length; i++) {
      URL url=libjars[i];
      if (jars.length() > 0) {
        jars+=",";
      }
      jars+=url.toString();
    }
    conf.set("tmpjars",jars);
    return libjars;
  }
  return null;
}

ID 365=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.GraphTextReader#parseVertex(LongWritable, Text, Vertex<Text,NullWritable,IntWritable>)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphTextReader
@Override public boolean parseVertex(LongWritable key,Text value,Vertex<Text,NullWritable,IntWritable> vertex) throws Exception {
  vertex.setVertexID(value);
  vertex.setValue(new IntWritable(Integer.parseInt(value.toString())));
  return true;
}

ID 366=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.GraphVertex#compute(Iterable<IntWritable>)
Rmethod: org.apache.hama.examples.GraphVertex#createSumVertex()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphVertex
@Override public void compute(Iterable<IntWritable> msgs) throws IOException {
  if (this.getSuperstepCount() == 0) {
    createSumVertex();
  }
 else   if (this.getSuperstepCount() == 1) {
    sendAllValuesToSumAndRemove();
  }
 else   if (this.getSuperstepCount() == 2) {
    calculateSum(msgs);
  }
 else   if (this.getSuperstepCount() == 3) {
    this.voteToHalt();
  }
}

ID 367=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.GraphVertex#compute(Iterable<IntWritable>)
Rmethod: org.apache.hama.examples.GraphVertex#sendAllValuesToSumAndRemove()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphVertex
@Override public void compute(Iterable<IntWritable> msgs) throws IOException {
  if (this.getSuperstepCount() == 0) {
    createSumVertex();
  }
 else   if (this.getSuperstepCount() == 1) {
    sendAllValuesToSumAndRemove();
  }
 else   if (this.getSuperstepCount() == 2) {
    calculateSum(msgs);
  }
 else   if (this.getSuperstepCount() == 3) {
    this.voteToHalt();
  }
}

ID 368=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.GraphVertex#compute(Iterable<IntWritable>)
Rmethod: org.apache.hama.examples.GraphVertex#calculateSum(Iterable<IntWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphVertex
@Override public void compute(Iterable<IntWritable> msgs) throws IOException {
  if (this.getSuperstepCount() == 0) {
    createSumVertex();
  }
 else   if (this.getSuperstepCount() == 1) {
    sendAllValuesToSumAndRemove();
  }
 else   if (this.getSuperstepCount() == 2) {
    calculateSum(msgs);
  }
 else   if (this.getSuperstepCount() == 3) {
    this.voteToHalt();
  }
}

ID 369=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.DynamicGraph#main(java.lang.String[])
Rmethod: org.apache.hama.examples.DynamicGraph#createJob(java.lang.String[], HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DynamicGraph
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length != 2) {
    printUsage();
  }
  HamaConfiguration conf=new HamaConfiguration(new Configuration());
  GraphJob graphJob=createJob(args,conf);
  long startTime=System.currentTimeMillis();
  if (graphJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 370=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.DynamicGraphTest#verifyResult()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DynamicGraphTest
private void verifyResult() throws IOException {
  FileStatus[] globStatus=fs.globStatus(new Path(OUTPUT + "/part-*"));
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line=null;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      assertTrue(split[0].equals("sum"));
      assertTrue(split[1].equals("11"));
      System.out.println(split[0] + " : " + split[1]);
    }
  }
}

ID 371=========================================================================type: only_throws
package: org.apache.hama.examples.util
Method:org.apache.hama.examples.util.FastGraphGen#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FastGraphGen
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException, ParseException {
  Options opts=new Options();
  opts.addOption("v","vertices",true,"The total number of vertices. Default value is 10.");
  opts.addOption("e","edges",true,"The maximum number of edges per vertex. Default value is 3.");
  opts.addOption("o","output_path",true,"The Location of output path.");
  opts.addOption("t","task_num",true,"The number of tasks. Default value is one.");
  opts.addOption("h","help",false,"Print usage");
  opts.addOption("of","output_format",true,"OutputFormat Type which is \"text\", " + "tab delimiter separated or \"json\". Default value - text");
  opts.addOption("w","weight",true,"Enable to set weight of graph edges." + "Default value - 0.");
  CommandLine cliParser=new GnuParser().parse(opts,args);
  boolean outputType=false;
  if (args.length == 0) {
    new HelpFormatter().printHelp("gen -o OUTPUT_PATH [options]",opts);
    System.exit(-1);
  }
  if (cliParser.hasOption("h")) {
    new HelpFormatter().printHelp("FastGraphGen -o OUTPUT_PATH [options]",opts);
    return;
  }
  if (!cliParser.hasOption("o")) {
    System.out.println("No output path specified for FastGraphGen, exiting.");
    System.exit(-1);
  }
  if (cliParser.hasOption("of")) {
    if (cliParser.getOptionValue("of").equals("json"))     outputType=true;
  }
  HamaConfiguration conf=new HamaConfiguration();
  conf.setInt(SIZE_OF_MATRIX,Integer.parseInt(cliParser.getOptionValue("vertices","5")));
  conf.setInt(MAX_EDGES,Integer.parseInt(cliParser.getOptionValue("edges","3")));
  conf.setBoolean(OUTPUT_FORMAT,outputType);
  conf.setInt(WEIGHT,Integer.parseInt(cliParser.getOptionValue("weight","1")));
  BSPJob bsp=new BSPJob(conf,FastGraphGenBSP.class);
  bsp.setJobName("Random Fast Matrix Generator");
  bsp.setBspClass(FastGraphGenBSP.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(TextArrayWritable.class);
  bsp.setOutputFormat(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,new Path(cliParser.getOptionValue("output_path")));
  bsp.setNumBspTask(Integer.parseInt(cliParser.getOptionValue("task_num","1")));
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 372=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ServiceWorker#call()
Rmethod: org.apache.hama.monitor.Collector#harvest()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ServiceWorker
@Override public Object call() throws Exception {
  return this.collector.harvest();
}

ID 373=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Federator#register(org.apache.hama.monitor.Federator.Act)
Rmethod: java.util.concurrent.BlockingQueue#put(E)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.error(ie);
  Thread.currentThread().interrupt();
}

block: 
Federator
public final void register(final Act act){
  try {
    if (null == act || null == act.collector() || null == act.handler())     throw new NullPointerException("Collector or CollectorHandler " + " is not provided.");
    commands.put(act);
  }
 catch (  InterruptedException ie) {
    LOG.error(ie);
    Thread.currentThread().interrupt();
  }
}

ID 374=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Federator#run()
Rmethod: java.util.concurrent.BlockingQueue#take()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.error(ie);
  Thread.currentThread().interrupt();
}

block: 
Federator
@Override public void run(){
  try {
    while (!Thread.interrupted()) {
      Act act=commands.take();
      act.handler().handle(workers.submit(new ServiceWorker(act.collector())));
    }
  }
 catch (  InterruptedException ie) {
    LOG.error(ie);
    Thread.currentThread().interrupt();
  }
}

ID 375=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.FileInputFormat#getSplits(BSPJob, int)
Rmethod: org.apache.hama.bsp.FileInputFormat#listStatus(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Splits files returned by  {@link #listStatus(BSPJob)} when they're too big. <br/>numSplits will be ignored by the framework.
 */

catch: 
null
block: 
FileInputFormat
/** 
 * Splits files returned by  {@link #listStatus(BSPJob)} when they're too big. <br/>numSplits will be ignored by the framework.
 */
@Override public InputSplit[] getSplits(BSPJob job,int numSplits) throws IOException {
  long minSize=Math.max(getFormatMinSplitSize(),getMinSplitSize(job));
  long maxSize=getMaxSplitSize(job);
  List<InputSplit> splits=new ArrayList<InputSplit>();
  FileStatus[] files=listStatus(job);
  for (  FileStatus file : files) {
    Path path=file.getPath();
    FileSystem fs=path.getFileSystem(job.getConfiguration());
    long length=file.getLen();
    BlockLocation[] blkLocations=fs.getFileBlockLocations(file,0,length);
    if ((length != 0) && isSplitable(job,path)) {
      long blockSize=file.getBlockSize();
      long splitSize=computeSplitSize(blockSize,minSize,maxSize);
      long bytesRemaining=length;
      while (((double)bytesRemaining) / splitSize > SPLIT_SLOP) {
        int blkIndex=getBlockIndex(blkLocations,length - bytesRemaining);
        splits.add(new FileSplit(path,length - bytesRemaining,splitSize,blkLocations[blkIndex].getHosts()));
        bytesRemaining-=splitSize;
      }
      if (bytesRemaining != 0) {
        splits.add(new FileSplit(path,length - bytesRemaining,bytesRemaining,blkLocations[blkLocations.length - 1].getHosts()));
      }
    }
 else     if (length != 0) {
      splits.add(new FileSplit(path,0,length,blkLocations[0].getHosts()));
    }
 else {
      splits.add(new FileSplit(path,0,length,new String[0]));
    }
  }
  job.getConfiguration().setLong("bsp.input.files",files.length);
  LOG.debug("Total # of splits: " + splits.size());
  return splits.toArray(new InputSplit[splits.size()]);
}

ID 376=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.FileInputFormat#getSplitHosts(BlockLocation[], long, long, NetworkTopology)
Rmethod: org.apache.hama.bsp.FileInputFormat#fakeRacks(BlockLocation[], int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * This function identifies and returns the hosts that contribute most for a given split. For calculating the contribution, rack locality is treated on par with host locality, so hosts from racks that contribute the most are preferred over hosts on racks that contribute less
 * @param blkLocations The list of block locations
 * @param offset
 * @param pSplitSize
 * @return array of hosts that contribute most to this split
 * @throws IOException
 */

catch: 
null
block: 
FileInputFormat
/** 
 * This function identifies and returns the hosts that contribute most for a given split. For calculating the contribution, rack locality is treated on par with host locality, so hosts from racks that contribute the most are preferred over hosts on racks that contribute less
 * @param blkLocations The list of block locations
 * @param offset
 * @param pSplitSize
 * @return array of hosts that contribute most to this split
 * @throws IOException
 */
protected String[] getSplitHosts(BlockLocation[] blkLocations,long offset,long pSplitSize,NetworkTopology clusterMap) throws IOException {
  long splitSize=pSplitSize;
  int startIndex=getBlockIndex(blkLocations,offset);
  long bytesInThisBlock=blkLocations[startIndex].getOffset() + blkLocations[startIndex].getLength() - offset;
  if (bytesInThisBlock >= splitSize) {
    return blkLocations[startIndex].getHosts();
  }
  long bytesInFirstBlock=bytesInThisBlock;
  int index=startIndex + 1;
  splitSize-=bytesInThisBlock;
  while (splitSize > 0) {
    bytesInThisBlock=Math.min(splitSize,blkLocations[index++].getLength());
    splitSize-=bytesInThisBlock;
  }
  long bytesInLastBlock=bytesInThisBlock;
  int endIndex=index - 1;
  Map<Node,NodeInfo> hostsMap=new IdentityHashMap<Node,NodeInfo>();
  Map<Node,NodeInfo> racksMap=new IdentityHashMap<Node,NodeInfo>();
  String[] allTopos=new String[0];
  for (index=startIndex; index <= endIndex; index++) {
    if (index == startIndex) {
      bytesInThisBlock=bytesInFirstBlock;
    }
 else     if (index == endIndex) {
      bytesInThisBlock=bytesInLastBlock;
    }
 else {
      bytesInThisBlock=blkLocations[index].getLength();
    }
    allTopos=blkLocations[index].getTopologyPaths();
    if (allTopos.length == 0) {
      allTopos=fakeRacks(blkLocations,index);
    }
    for (    String topo : allTopos) {
      Node node, parentNode;
      NodeInfo nodeInfo, parentNodeInfo;
      node=clusterMap.getNode(topo);
      if (node == null) {
        node=new NodeBase(topo);
        clusterMap.add(node);
      }
      nodeInfo=hostsMap.get(node);
      if (nodeInfo == null) {
        nodeInfo=new NodeInfo(node);
        hostsMap.put(node,nodeInfo);
        parentNode=node.getParent();
        parentNodeInfo=racksMap.get(parentNode);
        if (parentNodeInfo == null) {
          parentNodeInfo=new NodeInfo(parentNode);
          racksMap.put(parentNode,parentNodeInfo);
        }
        parentNodeInfo.addLeaf(nodeInfo);
      }
 else {
        nodeInfo=hostsMap.get(node);
        parentNode=node.getParent();
        parentNodeInfo=racksMap.get(parentNode);
      }
      nodeInfo.addValue(index,bytesInThisBlock);
      parentNodeInfo.addValue(index,bytesInThisBlock);
    }
  }
  return identifyHosts(allTopos.length,racksMap);
}

ID 377=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.FileSplit#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FileSplit
@Override public void write(DataOutput out) throws IOException {
  Text.writeString(out,file.toString());
  out.writeLong(start);
  out.writeLong(length);
}

ID 378=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.FileSplit#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FileSplit
@Override public void readFields(DataInput in) throws IOException {
  file=new Path(Text.readString(in));
  start=in.readLong();
  length=in.readLong();
  hosts=null;
}

ID 379=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatMatrixWritable#readFields(java.io.DataInput)
Rmethod: org.apache.hama.commons.io.FloatMatrixWritable#read(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatMatrixWritable
@Override public void readFields(DataInput in) throws IOException {
  mat=read(in);
}

ID 380=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatMatrixWritable#write(java.io.DataOutput)
Rmethod: org.apache.hama.commons.io.FloatMatrixWritable#write(FloatMatrix, java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatMatrixWritable
@Override public void write(DataOutput out) throws IOException {
  write(mat,out);
}

ID 381=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatMatrixWritable#write(FloatMatrix, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatMatrixWritable
public static void write(FloatMatrix mat,DataOutput out) throws IOException {
  out.writeInt(mat.getRowCount());
  out.writeInt(mat.getColumnCount());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      out.writeFloat(mat.get(row,col));
    }
  }
}

ID 382=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatMatrixWritable#write(FloatMatrix, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeFloat(float)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatMatrixWritable
public static void write(FloatMatrix mat,DataOutput out) throws IOException {
  out.writeInt(mat.getRowCount());
  out.writeInt(mat.getColumnCount());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      out.writeFloat(mat.get(row,col));
    }
  }
}

ID 383=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatMatrixWritable#read(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatMatrixWritable
public static FloatMatrix read(DataInput in) throws IOException {
  FloatMatrix mat=new DenseFloatMatrix(in.readInt(),in.readInt());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      mat.set(row,col,in.readFloat());
    }
  }
  return mat;
}

ID 384=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatMatrixWritable#read(java.io.DataInput)
Rmethod: java.io.DataInput#readFloat()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatMatrixWritable
public static FloatMatrix read(DataInput in) throws IOException {
  FloatMatrix mat=new DenseFloatMatrix(in.readInt(),in.readInt());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      mat.set(row,col,in.readFloat());
    }
  }
  return mat;
}

ID 385=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#write(java.io.DataOutput)
Rmethod: org.apache.hama.commons.io.FloatVectorWritable#writeVector(FloatVector, java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
@Override public void write(DataOutput out) throws IOException {
  writeVector(this.vector,out);
}

ID 386=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#readFields(java.io.DataInput)
Rmethod: org.apache.hama.commons.io.FloatVectorWritable#readVector(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
@Override public void readFields(DataInput in) throws IOException {
  this.vector=readVector(in);
}

ID 387=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#writeVector(FloatVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static void writeVector(FloatVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeFloat(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 388=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#writeVector(FloatVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeFloat(float)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static void writeVector(FloatVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeFloat(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 389=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#writeVector(FloatVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static void writeVector(FloatVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeFloat(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 390=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#writeVector(FloatVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static void writeVector(FloatVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeFloat(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 391=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static FloatVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  FloatVector vector;
  vector=new DenseFloatVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readFloat());
  }
  if (in.readBoolean()) {
    vector=new NamedFloatVector(in.readUTF(),vector);
  }
  return vector;
}

ID 392=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readFloat()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static FloatVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  FloatVector vector;
  vector=new DenseFloatVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readFloat());
  }
  if (in.readBoolean()) {
    vector=new NamedFloatVector(in.readUTF(),vector);
  }
  return vector;
}

ID 393=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static FloatVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  FloatVector vector;
  vector=new DenseFloatVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readFloat());
  }
  if (in.readBoolean()) {
    vector=new NamedFloatVector(in.readUTF(),vector);
  }
  return vector;
}

ID 394=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.FloatVectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FloatVectorWritable
public static FloatVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  FloatVector vector;
  vector=new DenseFloatVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readFloat());
  }
  if (in.readBoolean()) {
    vector=new NamedFloatVector(in.readUTF(),vector);
  }
  return vector;
}

ID 395=========================================================================type: Rethrow
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#setup(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new IOException(e);
}

block: 
GradientDescentBSP
@SuppressWarnings("unchecked") @Override public void setup(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  master=peer.getPeerIndex() == peer.getNumPeers() / 2;
  cost=Double.MAX_VALUE;
  costThreshold=peer.getConfiguration().getFloat(COST_THRESHOLD,0.1f);
  iterationsThreshold=peer.getConfiguration().getInt(ITERATIONS_THRESHOLD,10000);
  alpha=peer.getConfiguration().getFloat(ALPHA,0.003f);
  try {
    regressionModel=((Class<? extends RegressionModel>)peer.getConfiguration().getClass(REGRESSION_MODEL_CLASS,LinearRegressionModel.class)).newInstance();
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}

ID 396=========================================================================type: Rethrow
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#setup(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new IOException(e);
}

block: 
GradientDescentBSP
@SuppressWarnings("unchecked") @Override public void setup(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  master=peer.getPeerIndex() == peer.getNumPeers() / 2;
  cost=Double.MAX_VALUE;
  costThreshold=peer.getConfiguration().getFloat(COST_THRESHOLD,0.1f);
  iterationsThreshold=peer.getConfiguration().getInt(ITERATIONS_THRESHOLD,10000);
  alpha=peer.getConfiguration().getFloat(ALPHA,0.003f);
  try {
    regressionModel=((Class<? extends RegressionModel>)peer.getConfiguration().getClass(REGRESSION_MODEL_CLASS,LinearRegressionModel.class)).newInstance();
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}

ID 397=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#getInitialTheta(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 398=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#getInitialTheta(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.regression.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 399=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#getInitialTheta(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 400=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#broadcastVector(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>, double[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 401=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#aggregateItemsNumber(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 402=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#calculateLocalCost(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 403=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#broadcastVector(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>, double[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 404=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#aggregateTotalCost(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>, double)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 405=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#calculatePartialDerivatives(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 406=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#aggregatePartialDerivatives(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>, double[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
@Override public void bsp(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  getInitialTheta(peer);
  int itemCount=0;
  while (peer.readNext() != null) {
    itemCount++;
  }
  broadcastVector(peer,new double[]{itemCount});
  peer.sync();
  aggregateItemsNumber(peer,itemCount);
  peer.reopenInput();
  int iterations=0;
  while (true) {
    double localCost=calculateLocalCost(peer);
    broadcastVector(peer,new double[]{localCost});
    peer.sync();
    double totalCost=aggregateTotalCost(peer,localCost);
    if (checkCost(peer,iterations,totalCost))     break;
    peer.sync();
    peer.reopenInput();
    double[] thetaDelta=calculatePartialDerivatives(peer);
    broadcastVector(peer,thetaDelta);
    peer.sync();
    double[] newTheta=aggregatePartialDerivatives(peer,thetaDelta);
    updateTheta(newTheta);
    if (log.isDebugEnabled()) {
      log.debug("{}: new theta for cost {} is {}",new Object[]{peer.getPeerName(),cost,theta});
    }
    if (master) {
      peer.write(new VectorWritable(theta),new DoubleWritable(cost));
    }
    peer.reopenInput();
    peer.sync();
    iterations++;
  }
}

ID 407=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#getInitialTheta(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#getXSize(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
void getInitialTheta(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  if (theta == null) {
    if (master) {
      int size=getXSize(peer);
      theta=new DenseDoubleVector(size,peer.getConfiguration().getInt(INITIAL_THETA_VALUES,1));
      broadcastVector(peer,theta.toArray());
      if (log.isDebugEnabled()) {
        log.debug("{}: sending theta",peer.getPeerName());
      }
      peer.sync();
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("{}: getting theta",peer.getPeerName());
      }
      peer.sync();
      VectorWritable vectorWritable=peer.getCurrentMessage();
      theta=vectorWritable.getVector();
    }
  }
}

ID 408=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.GradientDescentBSP#getInitialTheta(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>)
Rmethod: org.apache.hama.ml.regression.GradientDescentBSP#broadcastVector(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable>, double[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentBSP
void getInitialTheta(BSPPeer<VectorWritable,DoubleWritable,VectorWritable,DoubleWritable,VectorWritable> peer) throws IOException, SyncException, InterruptedException {
  if (theta == null) {
    if (master) {
      int size=getXSize(peer);
      theta=new DenseDoubleVector(size,peer.getConfiguration().getInt(INITIAL_THETA_VALUES,1));
      broadcastVector(peer,theta.toArray());
      if (log.isDebugEnabled()) {
        log.debug("{}: sending theta",peer.getPeerName());
      }
      peer.sync();
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("{}: getting theta",peer.getPeerName());
      }
      peer.sync();
      VectorWritable vectorWritable=peer.getCurrentMessage();
      theta=vectorWritable.getVector();
    }
  }
}

ID 409=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.GradientDescentExample#main(java.lang.String[])
Rmethod: org.apache.hama.examples.GradientDescentExample#printOutput(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GradientDescentExample
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {
  if (!(args.length == 1 || args.length == 2)) {
    System.out.println("USAGE: <INPUT_PATH> [<REGRESSION_MODEL>]");
    return;
  }
  HamaConfiguration conf=new HamaConfiguration();
  conf.setFloat(GradientDescentBSP.ALPHA,0.002f);
  conf.setFloat(GradientDescentBSP.COST_THRESHOLD,0.5f);
  conf.setInt(GradientDescentBSP.ITERATIONS_THRESHOLD,300);
  conf.setInt(GradientDescentBSP.INITIAL_THETA_VALUES,10);
  if (args.length == 2 && args[1] != null) {
    if (args[1].equals("logistic")) {
      conf.setClass(GradientDescentBSP.REGRESSION_MODEL_CLASS,LogisticRegressionModel.class,RegressionModel.class);
    }
 else     if (args[1].equals("linear")) {
    }
 else {
      throw new RuntimeException(new StringBuilder("unsupported RegressionModel").append(args[1]).append(", use 'logistic' or 'linear'").toString());
    }
  }
  BSPJob bsp=new BSPJob(conf,GradientDescentExample.class);
  bsp.setJobName("Gradient Descent Example");
  bsp.setBspClass(GradientDescentBSP.class);
  bsp.setInputFormat(VectorDoubleFileInputFormat.class);
  bsp.setInputPath(new Path(args[0]));
  bsp.setInputKeyClass(VectorWritable.class);
  bsp.setInputValueClass(DoubleWritable.class);
  bsp.setOutputKeyClass(VectorWritable.class);
  bsp.setOutputValueClass(DoubleWritable.class);
  bsp.setOutputFormat(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,TMP_OUTPUT);
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    printOutput(conf);
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 410=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJob#GraphJob(HamaConfiguration, Class<?>)
Rmethod: org.apache.hama.graph.GraphJob#setVertexIDClass(Class<? extends Writable>)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: /** 
 * Creates a new Graph Job with the given configuration and an exampleClass. The exampleClass is used to determine the user's jar to distribute in the cluster. This constructor sets the vertex id class to  {@link Text}, the vertex value class to  {@link IntWritable} and the edge value class to{@link IntWritable}.
 */

catch: 
null
block: 
GraphJob
/** 
 * Creates a new Graph Job with the given configuration and an exampleClass. The exampleClass is used to determine the user's jar to distribute in the cluster. This constructor sets the vertex id class to  {@link Text}, the vertex value class to  {@link IntWritable} and the edge value class to{@link IntWritable}.
 */
public GraphJob(HamaConfiguration conf,Class<?> exampleClass) throws IOException {
  super(conf);
  conf.setClass(MessageManager.OUTGOING_MESSAGE_MANAGER_CLASS,OutgoingVertexMessageManager.class,OutgoingMessageManager.class);
  conf.setBoolean(Constants.FORCE_SET_BSP_TASKS,true);
  conf.setBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false);
  conf.setBoolean("hama.use.unsafeserialization",true);
  this.setBspClass(GraphJobRunner.class);
  this.setJarByClass(exampleClass);
  this.setVertexIDClass(Text.class);
  this.setVertexValueClass(IntWritable.class);
  this.setEdgeValueClass(IntWritable.class);
  this.setPartitioner(HashPartitioner.class);
  this.setMessageQueueBehaviour(MessageQueue.PERSISTENT_QUEUE);
}

ID 411=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJob#GraphJob(HamaConfiguration, Class<?>)
Rmethod: org.apache.hama.graph.GraphJob#setVertexValueClass(Class<? extends Writable>)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: /** 
 * Creates a new Graph Job with the given configuration and an exampleClass. The exampleClass is used to determine the user's jar to distribute in the cluster. This constructor sets the vertex id class to  {@link Text}, the vertex value class to  {@link IntWritable} and the edge value class to{@link IntWritable}.
 */

catch: 
null
block: 
GraphJob
/** 
 * Creates a new Graph Job with the given configuration and an exampleClass. The exampleClass is used to determine the user's jar to distribute in the cluster. This constructor sets the vertex id class to  {@link Text}, the vertex value class to  {@link IntWritable} and the edge value class to{@link IntWritable}.
 */
public GraphJob(HamaConfiguration conf,Class<?> exampleClass) throws IOException {
  super(conf);
  conf.setClass(MessageManager.OUTGOING_MESSAGE_MANAGER_CLASS,OutgoingVertexMessageManager.class,OutgoingMessageManager.class);
  conf.setBoolean(Constants.FORCE_SET_BSP_TASKS,true);
  conf.setBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false);
  conf.setBoolean("hama.use.unsafeserialization",true);
  this.setBspClass(GraphJobRunner.class);
  this.setJarByClass(exampleClass);
  this.setVertexIDClass(Text.class);
  this.setVertexValueClass(IntWritable.class);
  this.setEdgeValueClass(IntWritable.class);
  this.setPartitioner(HashPartitioner.class);
  this.setMessageQueueBehaviour(MessageQueue.PERSISTENT_QUEUE);
}

ID 412=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJob#GraphJob(HamaConfiguration, Class<?>)
Rmethod: org.apache.hama.graph.GraphJob#setEdgeValueClass(Class<? extends Writable>)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: /** 
 * Creates a new Graph Job with the given configuration and an exampleClass. The exampleClass is used to determine the user's jar to distribute in the cluster. This constructor sets the vertex id class to  {@link Text}, the vertex value class to  {@link IntWritable} and the edge value class to{@link IntWritable}.
 */

catch: 
null
block: 
GraphJob
/** 
 * Creates a new Graph Job with the given configuration and an exampleClass. The exampleClass is used to determine the user's jar to distribute in the cluster. This constructor sets the vertex id class to  {@link Text}, the vertex value class to  {@link IntWritable} and the edge value class to{@link IntWritable}.
 */
public GraphJob(HamaConfiguration conf,Class<?> exampleClass) throws IOException {
  super(conf);
  conf.setClass(MessageManager.OUTGOING_MESSAGE_MANAGER_CLASS,OutgoingVertexMessageManager.class,OutgoingMessageManager.class);
  conf.setBoolean(Constants.FORCE_SET_BSP_TASKS,true);
  conf.setBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false);
  conf.setBoolean("hama.use.unsafeserialization",true);
  this.setBspClass(GraphJobRunner.class);
  this.setJarByClass(exampleClass);
  this.setVertexIDClass(Text.class);
  this.setVertexValueClass(IntWritable.class);
  this.setEdgeValueClass(IntWritable.class);
  this.setPartitioner(HashPartitioner.class);
  this.setMessageQueueBehaviour(MessageQueue.PERSISTENT_QUEUE);
}

ID 413=========================================================================type: Recover
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#addValuesBytes(byte[], int)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
GraphJobMessage
public void addValuesBytes(byte[] values,int numOfValues){
  try {
    byteBuffer.write(values);
    this.numOfValues+=numOfValues;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}

ID 414=========================================================================type: Recover
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#add(byte[])
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
GraphJobMessage
public void add(byte[] value){
  try {
    byteBuffer.write(value);
    numOfValues++;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}

ID 415=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeByte(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
@Override public void write(DataOutput out) throws IOException {
  out.writeByte(this.flag);
  if (isVertexMessage()) {
    vertexId.write(out);
    out.writeInt(numOfValues);
    out.writeInt(byteBuffer.size());
    out.write(byteBuffer.toByteArray());
  }
 else   if (isMapMessage()) {
    map.write(out);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage.write(out);
  }
 else   if (isPartitioningMessage()) {
    out.writeInt(numOfValues);
    out.writeInt(byteBuffer.size());
    out.write(byteBuffer.toByteArray());
  }
 else {
    vertexId.write(out);
  }
}

ID 416=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
@Override public void write(DataOutput out) throws IOException {
  out.writeByte(this.flag);
  if (isVertexMessage()) {
    vertexId.write(out);
    out.writeInt(numOfValues);
    out.writeInt(byteBuffer.size());
    out.write(byteBuffer.toByteArray());
  }
 else   if (isMapMessage()) {
    map.write(out);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage.write(out);
  }
 else   if (isPartitioningMessage()) {
    out.writeInt(numOfValues);
    out.writeInt(byteBuffer.size());
    out.write(byteBuffer.toByteArray());
  }
 else {
    vertexId.write(out);
  }
}

ID 417=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
@Override public void write(DataOutput out) throws IOException {
  out.writeByte(this.flag);
  if (isVertexMessage()) {
    vertexId.write(out);
    out.writeInt(numOfValues);
    out.writeInt(byteBuffer.size());
    out.write(byteBuffer.toByteArray());
  }
 else   if (isMapMessage()) {
    map.write(out);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage.write(out);
  }
 else   if (isPartitioningMessage()) {
    out.writeInt(numOfValues);
    out.writeInt(byteBuffer.size());
    out.write(byteBuffer.toByteArray());
  }
 else {
    vertexId.write(out);
  }
}

ID 418=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#fastReadFields(java.io.DataInput)
Rmethod: java.io.DataInput#readByte()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
public void fastReadFields(DataInput in) throws IOException {
  flag=in.readByte();
  if (isVertexMessage()) {
    vertexId=GraphJobRunner.createVertexIDObject();
    vertexId.readFields(in);
  }
 else   if (isMapMessage()) {
    map=new MapWritable();
    map.readFields(in);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage=new IntWritable();
    integerMessage.readFields(in);
  }
 else {
    vertexId=ReflectionUtils.newInstance(GraphJobRunner.VERTEX_ID_CLASS,null);
    vertexId.readFields(in);
  }
}

ID 419=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readByte()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
@Override public void readFields(DataInput in) throws IOException {
  flag=in.readByte();
  if (isVertexMessage()) {
    vertexId=GraphJobRunner.createVertexIDObject();
    vertexId.readFields(in);
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else   if (isMapMessage()) {
    map=new MapWritable();
    map.readFields(in);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage=new IntWritable();
    integerMessage.readFields(in);
  }
 else   if (isPartitioningMessage()) {
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else {
    vertexId=ReflectionUtils.newInstance(GraphJobRunner.VERTEX_ID_CLASS,null);
    vertexId.readFields(in);
  }
}

ID 420=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
@Override public void readFields(DataInput in) throws IOException {
  flag=in.readByte();
  if (isVertexMessage()) {
    vertexId=GraphJobRunner.createVertexIDObject();
    vertexId.readFields(in);
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else   if (isMapMessage()) {
    map=new MapWritable();
    map.readFields(in);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage=new IntWritable();
    integerMessage.readFields(in);
  }
 else   if (isPartitioningMessage()) {
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else {
    vertexId=ReflectionUtils.newInstance(GraphJobRunner.VERTEX_ID_CLASS,null);
    vertexId.readFields(in);
  }
}

ID 421=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readFully(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
@Override public void readFields(DataInput in) throws IOException {
  flag=in.readByte();
  if (isVertexMessage()) {
    vertexId=GraphJobRunner.createVertexIDObject();
    vertexId.readFields(in);
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else   if (isMapMessage()) {
    map=new MapWritable();
    map.readFields(in);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage=new IntWritable();
    integerMessage.readFields(in);
  }
 else   if (isPartitioningMessage()) {
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else {
    vertexId=ReflectionUtils.newInstance(GraphJobRunner.VERTEX_ID_CLASS,null);
    vertexId.readFields(in);
  }
}

ID 422=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessage#readFields(java.io.DataInput)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobMessage
@Override public void readFields(DataInput in) throws IOException {
  flag=in.readByte();
  if (isVertexMessage()) {
    vertexId=GraphJobRunner.createVertexIDObject();
    vertexId.readFields(in);
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else   if (isMapMessage()) {
    map=new MapWritable();
    map.readFields(in);
  }
 else   if (isVerticesSizeMessage()) {
    integerMessage=new IntWritable();
    integerMessage.readFields(in);
  }
 else   if (isPartitioningMessage()) {
    this.numOfValues=in.readInt();
    int bytesLength=in.readInt();
    byte[] temp=new byte[bytesLength];
    in.readFully(temp);
    byteBuffer.write(temp);
  }
 else {
    vertexId=ReflectionUtils.newInstance(GraphJobRunner.VERTEX_ID_CLASS,null);
    vertexId.readFields(in);
  }
}

ID 423=========================================================================type: Rethrow
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobMessageComparator#compare(byte[], int, int, byte[], int, int)
Rmethod: org.apache.hama.graph.GraphJobMessage#fastReadFields(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  throw new RuntimeException(e);
}

block: 
GraphJobMessageComparator
@Override public synchronized int compare(byte[] b1,int s1,int l1,byte[] b2,int s2,int l2){
  try {
    buffer.reset(b1,s1,l1);
    key1.fastReadFields(buffer);
    buffer.reset(b2,s2,l2);
    key2.fastReadFields(buffer);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return compare(key1,key2);
}

ID 424=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#setupFields(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 425=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#loadVertices(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 426=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#loadVertices(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.graph.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 427=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#loadVertices(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 428=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#countGlobalVertexCount(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 429=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#countGlobalVertexCount(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.graph.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 430=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#countGlobalVertexCount(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 431=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#doInitialSuperstep(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void setup(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  setupFields(peer);
  long startTime=System.currentTimeMillis();
  loadVertices(peer);
  LOG.info("Total time spent for loading vertices: " + (System.currentTimeMillis() - startTime) + " ms");
  startTime=System.currentTimeMillis();
  countGlobalVertexCount(peer);
  LOG.info("Total time spent for broadcasting global vertex count: " + (System.currentTimeMillis() - startTime) + " ms");
  if (peer.getSuperstepCount() == 2) {
    startTime=System.currentTimeMillis();
    doInitialSuperstep(peer);
    LOG.info("Total time spent for initial superstep: " + (System.currentTimeMillis() - startTime) + " ms");
  }
}

ID 432=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  while (updated && !((maxIteration > 0) && iteration > maxIteration)) {
    globalUpdateCounts=0;
    peer.sync();
    GraphJobMessage firstVertexMessage=parseMessages(peer);
    long startTime=System.currentTimeMillis();
    doAggregationUpdates(peer);
    LOG.info("Total time spent for broadcasting aggregation values: " + (System.currentTimeMillis() - startTime) + " ms");
    if (!updated) {
      break;
    }
    doSuperstep(firstVertexMessage,peer);
  }
}

ID 433=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: true
parentException: Object 
thrown: org.apache.hama.graph.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  while (updated && !((maxIteration > 0) && iteration > maxIteration)) {
    globalUpdateCounts=0;
    peer.sync();
    GraphJobMessage firstVertexMessage=parseMessages(peer);
    long startTime=System.currentTimeMillis();
    doAggregationUpdates(peer);
    LOG.info("Total time spent for broadcasting aggregation values: " + (System.currentTimeMillis() - startTime) + " ms");
    if (!updated) {
      break;
    }
    doSuperstep(firstVertexMessage,peer);
  }
}

ID 434=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  while (updated && !((maxIteration > 0) && iteration > maxIteration)) {
    globalUpdateCounts=0;
    peer.sync();
    GraphJobMessage firstVertexMessage=parseMessages(peer);
    long startTime=System.currentTimeMillis();
    doAggregationUpdates(peer);
    LOG.info("Total time spent for broadcasting aggregation values: " + (System.currentTimeMillis() - startTime) + " ms");
    if (!updated) {
      break;
    }
    doSuperstep(firstVertexMessage,peer);
  }
}

ID 435=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#doAggregationUpdates(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  while (updated && !((maxIteration > 0) && iteration > maxIteration)) {
    globalUpdateCounts=0;
    peer.sync();
    GraphJobMessage firstVertexMessage=parseMessages(peer);
    long startTime=System.currentTimeMillis();
    doAggregationUpdates(peer);
    LOG.info("Total time spent for broadcasting aggregation values: " + (System.currentTimeMillis() - startTime) + " ms");
    if (!updated) {
      break;
    }
    doSuperstep(firstVertexMessage,peer);
  }
}

ID 436=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#doAggregationUpdates(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: true
parentException: Object 
thrown: org.apache.hama.graph.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  while (updated && !((maxIteration > 0) && iteration > maxIteration)) {
    globalUpdateCounts=0;
    peer.sync();
    GraphJobMessage firstVertexMessage=parseMessages(peer);
    long startTime=System.currentTimeMillis();
    doAggregationUpdates(peer);
    LOG.info("Total time spent for broadcasting aggregation values: " + (System.currentTimeMillis() - startTime) + " ms");
    if (!updated) {
      break;
    }
    doSuperstep(firstVertexMessage,peer);
  }
}

ID 437=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#doAggregationUpdates(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  while (updated && !((maxIteration > 0) && iteration > maxIteration)) {
    globalUpdateCounts=0;
    peer.sync();
    GraphJobMessage firstVertexMessage=parseMessages(peer);
    long startTime=System.currentTimeMillis();
    doAggregationUpdates(peer);
    LOG.info("Total time spent for broadcasting aggregation values: " + (System.currentTimeMillis() - startTime) + " ms");
    if (!updated) {
      break;
    }
    doSuperstep(firstVertexMessage,peer);
  }
}

ID 438=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#doSuperstep(GraphJobMessage, BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GraphJobRunner
@Override public final void bsp(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  while (updated && !((maxIteration > 0) && iteration > maxIteration)) {
    globalUpdateCounts=0;
    peer.sync();
    GraphJobMessage firstVertexMessage=parseMessages(peer);
    long startTime=System.currentTimeMillis();
    doAggregationUpdates(peer);
    LOG.info("Total time spent for broadcasting aggregation values: " + (System.currentTimeMillis() - startTime) + " ms");
    if (!updated) {
      break;
    }
    doSuperstep(firstVertexMessage,peer);
  }
}

ID 439=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#doSuperstep(GraphJobMessage, BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.ComputeRunnable#ComputeRunnable(GraphJobMessage)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Do the main logic of a superstep, namely checking if vertices are active, feeding compute with messages and controlling combiners/aggregators. We iterate over our messages and vertices in sorted order. That means that we need to seek the first vertex that has the same ID as the iterated message.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Do the main logic of a superstep, namely checking if vertices are active, feeding compute with messages and controlling combiners/aggregators. We iterate over our messages and vertices in sorted order. That means that we need to seek the first vertex that has the same ID as the iterated message.
 */
@SuppressWarnings("unchecked") private void doSuperstep(GraphJobMessage currentMessage,BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException {
  this.errorCount.set(0);
  long startTime=System.currentTimeMillis();
  this.changedVertexCnt=0;
  vertices.startSuperstep();
  ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  long loopStartTime=System.currentTimeMillis();
  while (currentMessage != null) {
    executor.execute(new ComputeRunnable(currentMessage));
    currentMessage=peer.getCurrentMessage();
  }
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " looping: "+ (System.currentTimeMillis() - loopStartTime)+ " ms");
  executor.shutdown();
  try {
    executor.awaitTermination(60,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (errorCount.get() > 0) {
    throw new IOException("there were " + errorCount + " exceptions during compute vertices.");
  }
  Iterator it=vertices.iterator();
  while (it.hasNext()) {
    Vertex<V,E,M> vertex=(Vertex<V,E,M>)it.next();
    if (!vertex.isHalted() && !vertex.isComputed()) {
      vertex.compute(Collections.<M>emptyList());
      vertices.finishVertexComputation(vertex);
    }
  }
  getAggregationRunner().sendAggregatorValues(peer,vertices.getActiveVerticesNum(),this.changedVertexCnt);
  this.iteration++;
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " computing vertices: "+ (System.currentTimeMillis() - startTime)+ " ms");
  startTime=System.currentTimeMillis();
  finishSuperstep();
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " synchronizing: "+ (System.currentTimeMillis() - startTime)+ " ms");
}

ID 440=========================================================================type: Rethrow
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#doSuperstep(GraphJobMessage, BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: java.util.concurrent.ThreadPoolExecutor#awaitTermination(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Do the main logic of a superstep, namely checking if vertices are active, feeding compute with messages and controlling combiners/aggregators. We iterate over our messages and vertices in sorted order. That means that we need to seek the first vertex that has the same ID as the iterated message.
 */

catch: 
catch (InterruptedException e) {
  throw new IOException(e);
}

block: 
GraphJobRunner
/** 
 * Do the main logic of a superstep, namely checking if vertices are active, feeding compute with messages and controlling combiners/aggregators. We iterate over our messages and vertices in sorted order. That means that we need to seek the first vertex that has the same ID as the iterated message.
 */
@SuppressWarnings("unchecked") private void doSuperstep(GraphJobMessage currentMessage,BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException {
  this.errorCount.set(0);
  long startTime=System.currentTimeMillis();
  this.changedVertexCnt=0;
  vertices.startSuperstep();
  ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  long loopStartTime=System.currentTimeMillis();
  while (currentMessage != null) {
    executor.execute(new ComputeRunnable(currentMessage));
    currentMessage=peer.getCurrentMessage();
  }
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " looping: "+ (System.currentTimeMillis() - loopStartTime)+ " ms");
  executor.shutdown();
  try {
    executor.awaitTermination(60,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (errorCount.get() > 0) {
    throw new IOException("there were " + errorCount + " exceptions during compute vertices.");
  }
  Iterator it=vertices.iterator();
  while (it.hasNext()) {
    Vertex<V,E,M> vertex=(Vertex<V,E,M>)it.next();
    if (!vertex.isHalted() && !vertex.isComputed()) {
      vertex.compute(Collections.<M>emptyList());
      vertices.finishVertexComputation(vertex);
    }
  }
  getAggregationRunner().sendAggregatorValues(peer,vertices.getActiveVerticesNum(),this.changedVertexCnt);
  this.iteration++;
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " computing vertices: "+ (System.currentTimeMillis() - startTime)+ " ms");
  startTime=System.currentTimeMillis();
  finishSuperstep();
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " synchronizing: "+ (System.currentTimeMillis() - startTime)+ " ms");
}

ID 441=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#doSuperstep(GraphJobMessage, BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#finishSuperstep()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Do the main logic of a superstep, namely checking if vertices are active, feeding compute with messages and controlling combiners/aggregators. We iterate over our messages and vertices in sorted order. That means that we need to seek the first vertex that has the same ID as the iterated message.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Do the main logic of a superstep, namely checking if vertices are active, feeding compute with messages and controlling combiners/aggregators. We iterate over our messages and vertices in sorted order. That means that we need to seek the first vertex that has the same ID as the iterated message.
 */
@SuppressWarnings("unchecked") private void doSuperstep(GraphJobMessage currentMessage,BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException {
  this.errorCount.set(0);
  long startTime=System.currentTimeMillis();
  this.changedVertexCnt=0;
  vertices.startSuperstep();
  ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  long loopStartTime=System.currentTimeMillis();
  while (currentMessage != null) {
    executor.execute(new ComputeRunnable(currentMessage));
    currentMessage=peer.getCurrentMessage();
  }
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " looping: "+ (System.currentTimeMillis() - loopStartTime)+ " ms");
  executor.shutdown();
  try {
    executor.awaitTermination(60,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (errorCount.get() > 0) {
    throw new IOException("there were " + errorCount + " exceptions during compute vertices.");
  }
  Iterator it=vertices.iterator();
  while (it.hasNext()) {
    Vertex<V,E,M> vertex=(Vertex<V,E,M>)it.next();
    if (!vertex.isHalted() && !vertex.isComputed()) {
      vertex.compute(Collections.<M>emptyList());
      vertices.finishVertexComputation(vertex);
    }
  }
  getAggregationRunner().sendAggregatorValues(peer,vertices.getActiveVerticesNum(),this.changedVertexCnt);
  this.iteration++;
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " computing vertices: "+ (System.currentTimeMillis() - startTime)+ " ms");
  startTime=System.currentTimeMillis();
  finishSuperstep();
  LOG.info("Total time spent for superstep-" + peer.getSuperstepCount() + " synchronizing: "+ (System.currentTimeMillis() - startTime)+ " ms");
}

ID 442=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#doInitialSuperstep(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.ComputeRunnable#ComputeRunnable(V)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Seed the vertices first with their own values in compute. This is the first superstep after the vertices have been loaded.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Seed the vertices first with their own values in compute. This is the first superstep after the vertices have been loaded.
 */
private void doInitialSuperstep(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException {
  this.changedVertexCnt=0;
  this.errorCount.set(0);
  vertices.startSuperstep();
  ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  for (  V v : vertices.keySet()) {
    executor.execute(new ComputeRunnable(v));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(60,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (errorCount.get() > 0) {
    throw new IOException("there were " + errorCount + " exceptions during compute vertices.");
  }
  getAggregationRunner().sendAggregatorValues(peer,1,this.changedVertexCnt);
  iteration++;
  finishSuperstep();
}

ID 443=========================================================================type: Rethrow
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#doInitialSuperstep(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: java.util.concurrent.ThreadPoolExecutor#awaitTermination(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Seed the vertices first with their own values in compute. This is the first superstep after the vertices have been loaded.
 */

catch: 
catch (InterruptedException e) {
  throw new IOException(e);
}

block: 
GraphJobRunner
/** 
 * Seed the vertices first with their own values in compute. This is the first superstep after the vertices have been loaded.
 */
private void doInitialSuperstep(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException {
  this.changedVertexCnt=0;
  this.errorCount.set(0);
  vertices.startSuperstep();
  ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  for (  V v : vertices.keySet()) {
    executor.execute(new ComputeRunnable(v));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(60,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (errorCount.get() > 0) {
    throw new IOException("there were " + errorCount + " exceptions during compute vertices.");
  }
  getAggregationRunner().sendAggregatorValues(peer,1,this.changedVertexCnt);
  iteration++;
  finishSuperstep();
}

ID 444=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#doInitialSuperstep(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#finishSuperstep()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Seed the vertices first with their own values in compute. This is the first superstep after the vertices have been loaded.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Seed the vertices first with their own values in compute. This is the first superstep after the vertices have been loaded.
 */
private void doInitialSuperstep(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException {
  this.changedVertexCnt=0;
  this.errorCount.set(0);
  vertices.startSuperstep();
  ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  for (  V v : vertices.keySet()) {
    executor.execute(new ComputeRunnable(v));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(60,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (errorCount.get() > 0) {
    throw new IOException("there were " + errorCount + " exceptions during compute vertices.");
  }
  getAggregationRunner().sendAggregatorValues(peer,1,this.changedVertexCnt);
  iteration++;
  finishSuperstep();
}

ID 445=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#loadVertices(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: java.util.concurrent.ThreadPoolExecutor#awaitTermination(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Loads vertices into memory of each peer.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Loads vertices into memory of each peer.
 */
@SuppressWarnings("unchecked") private void loadVertices(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  for (int i=0; i < peer.getNumPeers(); i++) {
    partitionMessages.put(i,new GraphJobMessage());
  }
  VertexInputReader<Writable,Writable,V,E,M> reader=(VertexInputReader<Writable,Writable,V,E,M>)ReflectionUtils.newInstance(conf.getClass(Constants.RUNTIME_PARTITION_RECORDCONVERTER,VertexInputReader.class));
  ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  KeyValuePair<Writable,Writable> next=null;
  while ((next=peer.readNext()) != null) {
    Vertex<V,E,M> vertex=GraphJobRunner.<V,E,M>newVertexInstance(VERTEX_CLASS);
    boolean vertexFinished=false;
    try {
      vertexFinished=reader.parseVertex(next.getKey(),next.getValue(),vertex);
    }
 catch (    Exception e) {
      throw new IOException("Parse exception occured: " + e);
    }
    if (!vertexFinished) {
      continue;
    }
    Runnable worker=new Parser(vertex);
    executor.execute(worker);
  }
  executor.shutdown();
  executor.awaitTermination(60,TimeUnit.SECONDS);
  Iterator<Entry<Integer,GraphJobMessage>> it;
  it=partitionMessages.entrySet().iterator();
  while (it.hasNext()) {
    Entry<Integer,GraphJobMessage> e=it.next();
    it.remove();
    GraphJobMessage msg=e.getValue();
    msg.setFlag(GraphJobMessage.PARTITION_FLAG);
    peer.send(getHostName(e.getKey()),msg);
  }
  peer.sync();
  executor=(ThreadPoolExecutor)Executors.newCachedThreadPool();
  executor.setMaximumPoolSize(conf.getInt(DEFAULT_THREAD_POOL_SIZE,64));
  executor.setRejectedExecutionHandler(retryHandler);
  GraphJobMessage msg;
  while ((msg=peer.getCurrentMessage()) != null) {
    executor.execute(new AddVertex(msg));
  }
  executor.shutdown();
  executor.awaitTermination(60,TimeUnit.SECONDS);
  LOG.info(vertices.size() + " vertices are loaded into " + peer.getPeerName());
}

ID 446=========================================================================type: Rethrow
package: org.apache.hama.graph
Method:org.apache.hama.graph.AddVertex#run()
Rmethod: org.apache.hama.graph.GraphJobRunner#addVertex(Vertex<V,E,M>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  throw new RuntimeException(e);
}

block: 
AddVertex
@Override public void run(){
  ByteArrayInputStream bis=new ByteArrayInputStream(msg.getValuesBytes());
  DataInputStream dis=new DataInputStream(bis);
  for (int i=0; i < msg.getNumOfValues(); i++) {
    try {
      Vertex<V,E,M> vertex=newVertexInstance(VERTEX_CLASS);
      vertex.readFields(dis);
      addVertex(vertex);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}

ID 447=========================================================================type: Rethrow
package: org.apache.hama.graph
Method:org.apache.hama.graph.Parser#run()
Rmethod: org.apache.hama.graph.GraphJobRunner#addVertex(Vertex<V,E,M>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
Parser
@Override public void run(){
  try {
    int partition=getPartitionID(vertex.getVertexID());
    if (peer.getPeerIndex() == partition) {
      addVertex(vertex);
    }
 else {
      partitionMessages.get(partition).add(WritableUtils.serialize(vertex));
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}

ID 448=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#addVertex(Vertex<V,E,M>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Parses the messages in every superstep and does actions according to flags in the messages.
 * @return the first vertex message, null if none received.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Parses the messages in every superstep and does actions according to flags in the messages.
 * @return the first vertex message, null if none received.
 */
@SuppressWarnings("unchecked") private GraphJobMessage parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  GraphJobMessage msg=null;
  boolean dynamicAdditions=false;
  boolean dynamicRemovals=false;
  while ((msg=peer.getCurrentMessage()) != null) {
    if (msg.isVertexMessage()) {
      break;
    }
 else     if (msg.isMapMessage()) {
      for (      Entry<Writable,Writable> e : msg.getMap().entrySet()) {
        Text vertexID=(Text)e.getKey();
        if (FLAG_MESSAGE_COUNTS.equals(vertexID)) {
          if (((IntWritable)e.getValue()).get() == Integer.MIN_VALUE) {
            updated=false;
          }
 else {
            globalUpdateCounts+=((IntWritable)e.getValue()).get();
          }
        }
 else         if (getAggregationRunner().isEnabled() && vertexID.toString().startsWith(S_FLAG_AGGREGATOR_VALUE)) {
          getAggregationRunner().masterReadAggregatedValue(vertexID,(M)e.getValue());
        }
 else         if (getAggregationRunner().isEnabled() && vertexID.toString().startsWith(S_FLAG_AGGREGATOR_INCREMENT)) {
          getAggregationRunner().masterReadAggregatedIncrementalValue(vertexID,(M)e.getValue());
        }
 else         if (FLAG_VERTEX_INCREASE.equals(vertexID)) {
          dynamicAdditions=true;
          addVertex((Vertex<V,E,M>)e.getValue());
        }
 else         if (FLAG_VERTEX_DECREASE.equals(vertexID)) {
          dynamicRemovals=true;
          removeVertex((V)e.getValue());
        }
 else         if (FLAG_VERTEX_TOTAL_VERTICES.equals(vertexID)) {
          this.numberVertices=((LongWritable)e.getValue()).get();
        }
 else         if (FLAG_VERTEX_ALTER_COUNTER.equals(vertexID)) {
          if (isMasterTask(peer)) {
            peer.getCounter(GraphJobCounter.INPUT_VERTICES).increment(((LongWritable)e.getValue()).get());
          }
 else {
            throw new UnsupportedOperationException("A message to increase vertex count is in a wrong place: " + peer);
          }
        }
      }
    }
 else {
      throw new UnsupportedOperationException("Unknown message type: " + msg);
    }
  }
  if (dynamicAdditions) {
    finishAdditions();
  }
  if (dynamicRemovals) {
    finishRemovals();
  }
  return msg;
}

ID 449=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#finishAdditions()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Parses the messages in every superstep and does actions according to flags in the messages.
 * @return the first vertex message, null if none received.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Parses the messages in every superstep and does actions according to flags in the messages.
 * @return the first vertex message, null if none received.
 */
@SuppressWarnings("unchecked") private GraphJobMessage parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  GraphJobMessage msg=null;
  boolean dynamicAdditions=false;
  boolean dynamicRemovals=false;
  while ((msg=peer.getCurrentMessage()) != null) {
    if (msg.isVertexMessage()) {
      break;
    }
 else     if (msg.isMapMessage()) {
      for (      Entry<Writable,Writable> e : msg.getMap().entrySet()) {
        Text vertexID=(Text)e.getKey();
        if (FLAG_MESSAGE_COUNTS.equals(vertexID)) {
          if (((IntWritable)e.getValue()).get() == Integer.MIN_VALUE) {
            updated=false;
          }
 else {
            globalUpdateCounts+=((IntWritable)e.getValue()).get();
          }
        }
 else         if (getAggregationRunner().isEnabled() && vertexID.toString().startsWith(S_FLAG_AGGREGATOR_VALUE)) {
          getAggregationRunner().masterReadAggregatedValue(vertexID,(M)e.getValue());
        }
 else         if (getAggregationRunner().isEnabled() && vertexID.toString().startsWith(S_FLAG_AGGREGATOR_INCREMENT)) {
          getAggregationRunner().masterReadAggregatedIncrementalValue(vertexID,(M)e.getValue());
        }
 else         if (FLAG_VERTEX_INCREASE.equals(vertexID)) {
          dynamicAdditions=true;
          addVertex((Vertex<V,E,M>)e.getValue());
        }
 else         if (FLAG_VERTEX_DECREASE.equals(vertexID)) {
          dynamicRemovals=true;
          removeVertex((V)e.getValue());
        }
 else         if (FLAG_VERTEX_TOTAL_VERTICES.equals(vertexID)) {
          this.numberVertices=((LongWritable)e.getValue()).get();
        }
 else         if (FLAG_VERTEX_ALTER_COUNTER.equals(vertexID)) {
          if (isMasterTask(peer)) {
            peer.getCounter(GraphJobCounter.INPUT_VERTICES).increment(((LongWritable)e.getValue()).get());
          }
 else {
            throw new UnsupportedOperationException("A message to increase vertex count is in a wrong place: " + peer);
          }
        }
      }
    }
 else {
      throw new UnsupportedOperationException("Unknown message type: " + msg);
    }
  }
  if (dynamicAdditions) {
    finishAdditions();
  }
  if (dynamicRemovals) {
    finishRemovals();
  }
  return msg;
}

ID 450=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.GraphJobRunner#parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage>)
Rmethod: org.apache.hama.graph.GraphJobRunner#finishRemovals()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Parses the messages in every superstep and does actions according to flags in the messages.
 * @return the first vertex message, null if none received.
 */

catch: 
null
block: 
GraphJobRunner
/** 
 * Parses the messages in every superstep and does actions according to flags in the messages.
 * @return the first vertex message, null if none received.
 */
@SuppressWarnings("unchecked") private GraphJobMessage parseMessages(BSPPeer<Writable,Writable,Writable,Writable,GraphJobMessage> peer) throws IOException, SyncException, InterruptedException {
  GraphJobMessage msg=null;
  boolean dynamicAdditions=false;
  boolean dynamicRemovals=false;
  while ((msg=peer.getCurrentMessage()) != null) {
    if (msg.isVertexMessage()) {
      break;
    }
 else     if (msg.isMapMessage()) {
      for (      Entry<Writable,Writable> e : msg.getMap().entrySet()) {
        Text vertexID=(Text)e.getKey();
        if (FLAG_MESSAGE_COUNTS.equals(vertexID)) {
          if (((IntWritable)e.getValue()).get() == Integer.MIN_VALUE) {
            updated=false;
          }
 else {
            globalUpdateCounts+=((IntWritable)e.getValue()).get();
          }
        }
 else         if (getAggregationRunner().isEnabled() && vertexID.toString().startsWith(S_FLAG_AGGREGATOR_VALUE)) {
          getAggregationRunner().masterReadAggregatedValue(vertexID,(M)e.getValue());
        }
 else         if (getAggregationRunner().isEnabled() && vertexID.toString().startsWith(S_FLAG_AGGREGATOR_INCREMENT)) {
          getAggregationRunner().masterReadAggregatedIncrementalValue(vertexID,(M)e.getValue());
        }
 else         if (FLAG_VERTEX_INCREASE.equals(vertexID)) {
          dynamicAdditions=true;
          addVertex((Vertex<V,E,M>)e.getValue());
        }
 else         if (FLAG_VERTEX_DECREASE.equals(vertexID)) {
          dynamicRemovals=true;
          removeVertex((V)e.getValue());
        }
 else         if (FLAG_VERTEX_TOTAL_VERTICES.equals(vertexID)) {
          this.numberVertices=((LongWritable)e.getValue()).get();
        }
 else         if (FLAG_VERTEX_ALTER_COUNTER.equals(vertexID)) {
          if (isMasterTask(peer)) {
            peer.getCounter(GraphJobCounter.INPUT_VERTICES).increment(((LongWritable)e.getValue()).get());
          }
 else {
            throw new UnsupportedOperationException("A message to increase vertex count is in a wrong place: " + peer);
          }
        }
      }
    }
 else {
      throw new UnsupportedOperationException("Unknown message type: " + msg);
    }
  }
  if (dynamicAdditions) {
    finishAdditions();
  }
  if (dynamicRemovals) {
    finishRemovals();
  }
  return msg;
}

ID 451=========================================================================type: Ignore_Log
package: org.apache.hama.graph
Method:org.apache.hama.graph.RetryRejectedExecutionHandler#rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.error(e);
}

block: 
RetryRejectedExecutionHandler
@Override public void rejectedExecution(Runnable r,ThreadPoolExecutor executor){
  try {
    Thread.sleep(10);
  }
 catch (  InterruptedException e) {
    LOG.error(e);
  }
  executor.execute(r);
}

ID 452=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.DispatchTasksHandler#handle(Directive)
Rmethod: org.apache.hama.bsp.TaskInProgress#killAndCleanup(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  throw new DirectiveException("Error when killing a " + "TaskInProgress.",ioe);
}

block: 
DispatchTasksHandler
@Override public void handle(Directive directive) throws DirectiveException {
  GroomServerAction[] actions=((DispatchTasksDirective)directive).getActions();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Got Response from BSPMaster with " + ((actions != null) ? actions.length : 0) + " actions");
  }
  if (actions != null) {
    int prevPort=Constants.DEFAULT_PEER_PORT;
    for (    GroomServerAction action : actions) {
      if (action instanceof LaunchTaskAction) {
        Task t=((LaunchTaskAction)action).getTask();
synchronized (assignedPeerNames) {
          prevPort=BSPNetUtils.getNextAvailable(prevPort);
          assignedPeerNames.put(t.getTaskID(),prevPort);
        }
        LOG.info("Launch " + actions.length + " tasks.");
        startNewTask((LaunchTaskAction)action);
      }
 else       if (action instanceof KillTaskAction) {
        LOG.info("Kill " + actions.length + " tasks.");
        KillTaskAction killAction=(KillTaskAction)action;
        if (tasks.containsKey(killAction.getTaskID())) {
          TaskInProgress tip=tasks.get(killAction.getTaskID());
          tip.taskStatus.setRunState(TaskStatus.State.FAILED);
          try {
            tip.killAndCleanup(false);
            tasks.remove(killAction.getTaskID());
            runningTasks.remove(killAction.getTaskID());
            assignedPeerNames.remove(killAction.getTaskID());
          }
 catch (          IOException ioe) {
            throw new DirectiveException("Error when killing a " + "TaskInProgress.",ioe);
          }
        }
      }
 else       if (action instanceof RecoverTaskAction) {
        LOG.info("Recovery action task.");
        RecoverTaskAction recoverAction=(RecoverTaskAction)action;
        Task t=recoverAction.getTask();
synchronized (assignedPeerNames) {
          prevPort=BSPNetUtils.getNextAvailable(prevPort);
          assignedPeerNames.put(t.getTaskID(),prevPort);
        }
        LOG.info("Recovery action task." + t.getTaskID());
        try {
          startRecoveryTask(recoverAction);
        }
 catch (        IOException e) {
          throw new DirectiveException(new StringBuffer().append("Error starting the recovery task").append(t.getTaskID()).toString(),e);
        }
      }
    }
  }
}

ID 453=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.DispatchTasksHandler#handle(Directive)
Rmethod: org.apache.hama.bsp.GroomServer#startRecoveryTask(RecoverTaskAction)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  throw new DirectiveException(new StringBuffer().append("Error starting the recovery task").append(t.getTaskID()).toString(),e);
}

block: 
DispatchTasksHandler
@Override public void handle(Directive directive) throws DirectiveException {
  GroomServerAction[] actions=((DispatchTasksDirective)directive).getActions();
  if (LOG.isDebugEnabled()) {
    LOG.debug("Got Response from BSPMaster with " + ((actions != null) ? actions.length : 0) + " actions");
  }
  if (actions != null) {
    int prevPort=Constants.DEFAULT_PEER_PORT;
    for (    GroomServerAction action : actions) {
      if (action instanceof LaunchTaskAction) {
        Task t=((LaunchTaskAction)action).getTask();
synchronized (assignedPeerNames) {
          prevPort=BSPNetUtils.getNextAvailable(prevPort);
          assignedPeerNames.put(t.getTaskID(),prevPort);
        }
        LOG.info("Launch " + actions.length + " tasks.");
        startNewTask((LaunchTaskAction)action);
      }
 else       if (action instanceof KillTaskAction) {
        LOG.info("Kill " + actions.length + " tasks.");
        KillTaskAction killAction=(KillTaskAction)action;
        if (tasks.containsKey(killAction.getTaskID())) {
          TaskInProgress tip=tasks.get(killAction.getTaskID());
          tip.taskStatus.setRunState(TaskStatus.State.FAILED);
          try {
            tip.killAndCleanup(false);
            tasks.remove(killAction.getTaskID());
            runningTasks.remove(killAction.getTaskID());
            assignedPeerNames.remove(killAction.getTaskID());
          }
 catch (          IOException ioe) {
            throw new DirectiveException("Error when killing a " + "TaskInProgress.",ioe);
          }
        }
      }
 else       if (action instanceof RecoverTaskAction) {
        LOG.info("Recovery action task.");
        RecoverTaskAction recoverAction=(RecoverTaskAction)action;
        Task t=recoverAction.getTask();
synchronized (assignedPeerNames) {
          prevPort=BSPNetUtils.getNextAvailable(prevPort);
          assignedPeerNames.put(t.getTaskID(),prevPort);
        }
        LOG.info("Recovery action task." + t.getTaskID());
        try {
          startRecoveryTask(recoverAction);
        }
 catch (        IOException e) {
          throw new DirectiveException(new StringBuffer().append("Error starting the recovery task").append(t.getTaskID()).toString(),e);
        }
      }
    }
  }
}

ID 454=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPTasksMonitor#run()
Rmethod: org.apache.hama.bsp.GroomServer#purgeTask(org.apache.hama.bsp.GroomServer.TaskInProgress, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(new StringBuilder("Error while removing a timed-out task - ").append(tip.toString()),e);
}

block: 
BSPTasksMonitor
@Override public void run(){
  getObliviousTasks(outOfContactTasks);
  if (outOfContactTasks.size() > 0) {
    LOG.debug("Got " + outOfContactTasks.size() + " oblivious tasks");
  }
  for (  TaskInProgress tip : outOfContactTasks) {
    try {
      LOG.debug("Purging task " + tip);
      purgeTask(tip,true);
    }
 catch (    Exception e) {
      LOG.error(new StringBuilder("Error while removing a timed-out task - ").append(tip.toString()),e);
    }
  }
  outOfContactTasks.clear();
}

ID 455=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#initialize()
Rmethod: org.apache.hama.bsp.GroomServer#checkLocalDirs(java.lang.String[])
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.DiskErrorException
exception comment: null
method comment: null
catch: 
null
block: 
GroomServer
public synchronized void initialize() throws IOException {
  if (this.conf.get(Constants.PEER_HOST) != null) {
    this.localHostname=conf.get(Constants.PEER_HOST);
  }
  if (localHostname == null) {
    this.localHostname=DNS.getDefaultHost(conf.get("bsp.dns.interface","default"),conf.get("bsp.dns.nameserver","default"));
  }
  checkLocalDirs(getLocalDirs());
  deleteLocalFiles(SUBDIR);
  this.tasks.clear();
  this.runningJobs=new TreeMap<BSPJobID,RunningJob>();
  this.runningTasks=new ConcurrentHashMap<TaskAttemptID,TaskInProgress>();
  this.finishedTasks=new LinkedHashMap<TaskAttemptID,TaskInProgress>();
  this.conf.set(Constants.PEER_HOST,localHostname);
  this.conf.set(Constants.GROOM_RPC_HOST,localHostname);
  this.maxCurrentTasks=conf.getInt(Constants.MAX_TASKS_PER_GROOM,3);
  this.assignedPeerNames=new HashMap<TaskAttemptID,Integer>(2 * this.maxCurrentTasks);
  int rpcPort=-1;
  String rpcAddr=null;
  if (false == this.initialized) {
    rpcAddr=conf.get(Constants.GROOM_RPC_HOST,Constants.DEFAULT_GROOM_RPC_HOST);
    rpcPort=conf.getInt(Constants.GROOM_RPC_PORT,Constants.DEFAULT_GROOM_RPC_PORT);
    if (-1 == rpcPort || null == rpcAddr)     throw new IllegalArgumentException("Error rpc address " + rpcAddr + " port"+ rpcPort);
    this.workerServer=RPC.getServer(this,rpcAddr,rpcPort,conf);
    this.workerServer.start();
    this.rpcServer=rpcAddr + ":" + rpcPort;
  }
  server=new HttpServer("groomserver",rpcAddr,conf.getInt("bsp.http.groomserver.port",Constants.DEFAULT_GROOM_INFO_SERVER),true,conf);
  FileSystem local=FileSystem.getLocal(conf);
  server.setAttribute("groom.server",this);
  server.setAttribute("local.file.system",local);
  server.setAttribute("conf",conf);
  server.setAttribute("log",LOG);
  server.addServlet("taskLog","/tasklog",TaskLogServlet.class);
  LOG.info("starting webserver: " + rpcAddr);
  server.start();
  String address=BSPNetUtils.getServerAddress(conf,"bsp.groom.report.bindAddress","bsp.groom.report.port","bsp.groom.report.address");
  InetSocketAddress socAddr=BSPNetUtils.createSocketAddr(address);
  String bindAddress=socAddr.getHostName();
  int tmpPort=socAddr.getPort();
  this.taskReportServer=RPC.getServer(this,bindAddress,tmpPort,conf.getInt("hama.groom.report.server.handler.threads.num",5),false,this.conf);
  this.taskReportServer.start();
  this.taskReportAddress=taskReportServer.getListenerAddress();
  this.conf.set("bsp.groom.report.address",taskReportAddress.getHostName() + ":" + taskReportAddress.getPort());
  LOG.info("TaskReportServer up at: " + this.taskReportAddress);
  this.groomHostName=rpcAddr;
  this.groomServerName="groomd_" + this.rpcServer.replace(':','_');
  LOG.info("Starting groom: " + this.rpcServer);
  this.masterClient=(MasterProtocol)RPC.waitForProxy(MasterProtocol.class,HamaRPCProtocolVersion.versionID,bspMasterAddr,conf);
  this.instructor=new Instructor();
  this.instructor.bind(DispatchTasksDirective.class,new DispatchTasksHandler());
  instructor.start();
  if (this.taskMonitorService == null) {
    this.taskMonitorService=Executors.newScheduledThreadPool(1);
    long monitorPeriod=this.conf.getLong(Constants.GROOM_PING_PERIOD,Constants.DEFAULT_GROOM_PING_PERIOD);
    if (monitorPeriod > 0) {
      this.taskMonitorService.scheduleWithFixedDelay(new BSPTasksMonitor(),1000,monitorPeriod,TimeUnit.MILLISECONDS);
    }
  }
  if (conf.getBoolean("bsp.monitor.enabled",false)) {
    new Monitor(conf,zk,this.groomServerName).start();
  }
  if (conf.getBoolean("bsp.monitor.fd.enabled",false)) {
    this.sensor.set(FDProvider.createSensor(conf.getClass("bsp.monitor.fd.sensor.class",UDPSensor.class,Sensor.class),(HamaConfiguration)conf));
    this.sensor.get().start();
  }
  if (-1 == rpcPort || null == rpcAddr)   throw new IllegalArgumentException("Error rpc address " + rpcAddr + " port"+ rpcPort);
  if (!this.masterClient.register(new GroomServerStatus(groomServerName,cloneAndResetRunningTaskStatuses(),failures,maxCurrentTasks,this.rpcServer,groomHostName))) {
    LOG.error("There is a problem in establishing communication" + " link with BSPMaster");
    throw new IOException("There is a problem in establishing" + " communication link with BSPMaster.");
  }
  this.running=true;
  this.initialized=true;
}

ID 456=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#initialize()
Rmethod: org.apache.hama.bsp.GroomServer#deleteLocalFiles(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GroomServer
public synchronized void initialize() throws IOException {
  if (this.conf.get(Constants.PEER_HOST) != null) {
    this.localHostname=conf.get(Constants.PEER_HOST);
  }
  if (localHostname == null) {
    this.localHostname=DNS.getDefaultHost(conf.get("bsp.dns.interface","default"),conf.get("bsp.dns.nameserver","default"));
  }
  checkLocalDirs(getLocalDirs());
  deleteLocalFiles(SUBDIR);
  this.tasks.clear();
  this.runningJobs=new TreeMap<BSPJobID,RunningJob>();
  this.runningTasks=new ConcurrentHashMap<TaskAttemptID,TaskInProgress>();
  this.finishedTasks=new LinkedHashMap<TaskAttemptID,TaskInProgress>();
  this.conf.set(Constants.PEER_HOST,localHostname);
  this.conf.set(Constants.GROOM_RPC_HOST,localHostname);
  this.maxCurrentTasks=conf.getInt(Constants.MAX_TASKS_PER_GROOM,3);
  this.assignedPeerNames=new HashMap<TaskAttemptID,Integer>(2 * this.maxCurrentTasks);
  int rpcPort=-1;
  String rpcAddr=null;
  if (false == this.initialized) {
    rpcAddr=conf.get(Constants.GROOM_RPC_HOST,Constants.DEFAULT_GROOM_RPC_HOST);
    rpcPort=conf.getInt(Constants.GROOM_RPC_PORT,Constants.DEFAULT_GROOM_RPC_PORT);
    if (-1 == rpcPort || null == rpcAddr)     throw new IllegalArgumentException("Error rpc address " + rpcAddr + " port"+ rpcPort);
    this.workerServer=RPC.getServer(this,rpcAddr,rpcPort,conf);
    this.workerServer.start();
    this.rpcServer=rpcAddr + ":" + rpcPort;
  }
  server=new HttpServer("groomserver",rpcAddr,conf.getInt("bsp.http.groomserver.port",Constants.DEFAULT_GROOM_INFO_SERVER),true,conf);
  FileSystem local=FileSystem.getLocal(conf);
  server.setAttribute("groom.server",this);
  server.setAttribute("local.file.system",local);
  server.setAttribute("conf",conf);
  server.setAttribute("log",LOG);
  server.addServlet("taskLog","/tasklog",TaskLogServlet.class);
  LOG.info("starting webserver: " + rpcAddr);
  server.start();
  String address=BSPNetUtils.getServerAddress(conf,"bsp.groom.report.bindAddress","bsp.groom.report.port","bsp.groom.report.address");
  InetSocketAddress socAddr=BSPNetUtils.createSocketAddr(address);
  String bindAddress=socAddr.getHostName();
  int tmpPort=socAddr.getPort();
  this.taskReportServer=RPC.getServer(this,bindAddress,tmpPort,conf.getInt("hama.groom.report.server.handler.threads.num",5),false,this.conf);
  this.taskReportServer.start();
  this.taskReportAddress=taskReportServer.getListenerAddress();
  this.conf.set("bsp.groom.report.address",taskReportAddress.getHostName() + ":" + taskReportAddress.getPort());
  LOG.info("TaskReportServer up at: " + this.taskReportAddress);
  this.groomHostName=rpcAddr;
  this.groomServerName="groomd_" + this.rpcServer.replace(':','_');
  LOG.info("Starting groom: " + this.rpcServer);
  this.masterClient=(MasterProtocol)RPC.waitForProxy(MasterProtocol.class,HamaRPCProtocolVersion.versionID,bspMasterAddr,conf);
  this.instructor=new Instructor();
  this.instructor.bind(DispatchTasksDirective.class,new DispatchTasksHandler());
  instructor.start();
  if (this.taskMonitorService == null) {
    this.taskMonitorService=Executors.newScheduledThreadPool(1);
    long monitorPeriod=this.conf.getLong(Constants.GROOM_PING_PERIOD,Constants.DEFAULT_GROOM_PING_PERIOD);
    if (monitorPeriod > 0) {
      this.taskMonitorService.scheduleWithFixedDelay(new BSPTasksMonitor(),1000,monitorPeriod,TimeUnit.MILLISECONDS);
    }
  }
  if (conf.getBoolean("bsp.monitor.enabled",false)) {
    new Monitor(conf,zk,this.groomServerName).start();
  }
  if (conf.getBoolean("bsp.monitor.fd.enabled",false)) {
    this.sensor.set(FDProvider.createSensor(conf.getClass("bsp.monitor.fd.sensor.class",UDPSensor.class,Sensor.class),(HamaConfiguration)conf));
    this.sensor.get().start();
  }
  if (-1 == rpcPort || null == rpcAddr)   throw new IllegalArgumentException("Error rpc address " + rpcAddr + " port"+ rpcPort);
  if (!this.masterClient.register(new GroomServerStatus(groomServerName,cloneAndResetRunningTaskStatuses(),failures,maxCurrentTasks,this.rpcServer,groomHostName))) {
    LOG.error("There is a problem in establishing communication" + " link with BSPMaster");
    throw new IOException("There is a problem in establishing" + " communication link with BSPMaster.");
  }
  this.running=true;
  this.initialized=true;
}

ID 457=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#cleanupStorage()
Rmethod: org.apache.hama.bsp.GroomServer#deleteLocalFiles()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GroomServer
public void cleanupStorage() throws IOException {
  deleteLocalFiles();
}

ID 458=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#offerService()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
}

block: 
GroomServer
public State offerService() throws Exception {
  while (running && !shuttingDown) {
    try {
      List<TaskStatus> taskStatuses=new ArrayList<TaskStatus>();
      for (      Map.Entry<TaskAttemptID,TaskInProgress> e : runningTasks.entrySet()) {
        TaskInProgress tip=e.getValue();
        TaskStatus taskStatus=tip.getStatus();
        taskStatuses.add(taskStatus);
      }
      doReport(taskStatuses);
      Thread.sleep(REPORT_INTERVAL);
    }
 catch (    InterruptedException ie) {
    }
    try {
      if (justInited) {
        String dir=masterClient.getSystemDir();
        if (dir == null) {
          LOG.error("Fail to get system directory.");
          throw new IOException("Fail to get system directory.");
        }
        systemDirectory=new Path(dir);
        systemFS=systemDirectory.getFileSystem(conf);
      }
      justInited=false;
    }
 catch (    DiskErrorException de) {
      String msg="Exiting groom server for disk error:\n" + StringUtils.stringifyException(de);
      LOG.error(msg);
      return State.STALE;
    }
catch (    RemoteException re) {
      return State.DENIED;
    }
catch (    Exception except) {
      String msg="Caught exception: " + StringUtils.stringifyException(except);
      LOG.error(msg);
    }
    Thread.sleep(REPORT_INTERVAL);
  }
  return State.NORMAL;
}

ID 459=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#offerService()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GroomServer
public State offerService() throws Exception {
  while (running && !shuttingDown) {
    try {
      List<TaskStatus> taskStatuses=new ArrayList<TaskStatus>();
      for (      Map.Entry<TaskAttemptID,TaskInProgress> e : runningTasks.entrySet()) {
        TaskInProgress tip=e.getValue();
        TaskStatus taskStatus=tip.getStatus();
        taskStatuses.add(taskStatus);
      }
      doReport(taskStatuses);
      Thread.sleep(REPORT_INTERVAL);
    }
 catch (    InterruptedException ie) {
    }
    try {
      if (justInited) {
        String dir=masterClient.getSystemDir();
        if (dir == null) {
          LOG.error("Fail to get system directory.");
          throw new IOException("Fail to get system directory.");
        }
        systemDirectory=new Path(dir);
        systemFS=systemDirectory.getFileSystem(conf);
      }
      justInited=false;
    }
 catch (    DiskErrorException de) {
      String msg="Exiting groom server for disk error:\n" + StringUtils.stringifyException(de);
      LOG.error(msg);
      return State.STALE;
    }
catch (    RemoteException re) {
      return State.DENIED;
    }
catch (    Exception except) {
      String msg="Caught exception: " + StringUtils.stringifyException(except);
      LOG.error(msg);
    }
    Thread.sleep(REPORT_INTERVAL);
  }
  return State.NORMAL;
}

ID 460=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#startNewTask(LaunchTaskAction)
Rmethod: org.apache.hama.bsp.GroomServer#localizeJob(org.apache.hama.bsp.GroomServer.TaskInProgress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  String msg=("Error initializing " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(e));
  LOG.warn(msg);
  try {
    tip.killAndCleanup(true);
  }
 catch (  IOException ie2) {
    LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
  }
}

block: 
GroomServer
private void startNewTask(LaunchTaskAction action){
  Task t=action.getTask();
  BSPJob jobConf=null;
  try {
    jobConf=new BSPJob(t.getJobID(),t.getJobFile());
  }
 catch (  IOException e1) {
    LOG.error(e1);
  }
  TaskInProgress tip=new TaskInProgress(t,jobConf,this.groomServerName);
synchronized (this) {
    tasks.put(t.getTaskID(),tip);
    runningTasks.put(t.getTaskID(),tip);
  }
  try {
    localizeJob(tip);
  }
 catch (  Throwable e) {
    String msg=("Error initializing " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(e));
    LOG.warn(msg);
    try {
      tip.killAndCleanup(true);
    }
 catch (    IOException ie2) {
      LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
    }
  }
}

ID 461=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#startNewTask(LaunchTaskAction)
Rmethod: org.apache.hama.bsp.TaskInProgress#killAndCleanup(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie2) {
  LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
}

block: 
GroomServer
private void startNewTask(LaunchTaskAction action){
  Task t=action.getTask();
  BSPJob jobConf=null;
  try {
    jobConf=new BSPJob(t.getJobID(),t.getJobFile());
  }
 catch (  IOException e1) {
    LOG.error(e1);
  }
  TaskInProgress tip=new TaskInProgress(t,jobConf,this.groomServerName);
synchronized (this) {
    tasks.put(t.getTaskID(),tip);
    runningTasks.put(t.getTaskID(),tip);
  }
  try {
    localizeJob(tip);
  }
 catch (  Throwable e) {
    String msg=("Error initializing " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(e));
    LOG.warn(msg);
    try {
      tip.killAndCleanup(true);
    }
 catch (    IOException ie2) {
      LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
    }
  }
}

ID 462=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#startRecoveryTask(RecoverTaskAction)
Rmethod: org.apache.hama.bsp.TaskInProgress#killRunner()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.error("Error killing the current process for " + t.getTaskID(),e);
  throw e;
}

block: 
GroomServer
private void startRecoveryTask(RecoverTaskAction action) throws IOException {
  Task t=action.getTask();
  BSPJob jobConf=null;
  try {
    jobConf=new BSPJob(t.getJobID(),t.getJobFile());
  }
 catch (  IOException e1) {
    LOG.error(e1);
    throw e1;
  }
  TaskInProgress tip=new TaskInProgress(t,jobConf,this.groomServerName);
  tip.markAsRecoveryTask(action.getSuperstepCount());
synchronized (this) {
    if (tasks.containsKey(t.getTaskID())) {
      TaskInProgress oldTip=tasks.get(t.getTaskID());
      try {
        oldTip.killRunner();
      }
 catch (      IOException e) {
        LOG.error("Error killing the current process for " + t.getTaskID(),e);
        throw e;
      }
    }
    Iterator<TaskAttemptID> taskIterator=tasks.keySet().iterator();
    while (taskIterator.hasNext()) {
      TaskAttemptID taskAttId=taskIterator.next();
      if (taskAttId.getTaskID().equals(t.getTaskID().getTaskID())) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Removing tasks with id = " + t.getTaskID().getTaskID());
        }
        taskIterator.remove();
        runningTasks.remove(taskAttId);
      }
    }
    tasks.put(t.getTaskID(),tip);
    runningTasks.put(t.getTaskID(),tip);
  }
  try {
    localizeJob(tip);
  }
 catch (  Throwable e) {
    String msg=("Error initializing " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(e));
    LOG.warn(msg);
    try {
      tip.killAndCleanup(true);
    }
 catch (    IOException ie2) {
      LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
    }
    throw new IOException("Errro localizing the job.",e);
  }
}

ID 463=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#startRecoveryTask(RecoverTaskAction)
Rmethod: org.apache.hama.bsp.GroomServer#localizeJob(org.apache.hama.bsp.GroomServer.TaskInProgress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  String msg=("Error initializing " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(e));
  LOG.warn(msg);
  try {
    tip.killAndCleanup(true);
  }
 catch (  IOException ie2) {
    LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
  }
  throw new IOException("Errro localizing the job.",e);
}

block: 
GroomServer
private void startRecoveryTask(RecoverTaskAction action) throws IOException {
  Task t=action.getTask();
  BSPJob jobConf=null;
  try {
    jobConf=new BSPJob(t.getJobID(),t.getJobFile());
  }
 catch (  IOException e1) {
    LOG.error(e1);
    throw e1;
  }
  TaskInProgress tip=new TaskInProgress(t,jobConf,this.groomServerName);
  tip.markAsRecoveryTask(action.getSuperstepCount());
synchronized (this) {
    if (tasks.containsKey(t.getTaskID())) {
      TaskInProgress oldTip=tasks.get(t.getTaskID());
      try {
        oldTip.killRunner();
      }
 catch (      IOException e) {
        LOG.error("Error killing the current process for " + t.getTaskID(),e);
        throw e;
      }
    }
    Iterator<TaskAttemptID> taskIterator=tasks.keySet().iterator();
    while (taskIterator.hasNext()) {
      TaskAttemptID taskAttId=taskIterator.next();
      if (taskAttId.getTaskID().equals(t.getTaskID().getTaskID())) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Removing tasks with id = " + t.getTaskID().getTaskID());
        }
        taskIterator.remove();
        runningTasks.remove(taskAttId);
      }
    }
    tasks.put(t.getTaskID(),tip);
    runningTasks.put(t.getTaskID(),tip);
  }
  try {
    localizeJob(tip);
  }
 catch (  Throwable e) {
    String msg=("Error initializing " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(e));
    LOG.warn(msg);
    try {
      tip.killAndCleanup(true);
    }
 catch (    IOException ie2) {
      LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
    }
    throw new IOException("Errro localizing the job.",e);
  }
}

ID 464=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#startRecoveryTask(RecoverTaskAction)
Rmethod: org.apache.hama.bsp.TaskInProgress#killAndCleanup(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ie2) {
  LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
}

block: 
GroomServer
private void startRecoveryTask(RecoverTaskAction action) throws IOException {
  Task t=action.getTask();
  BSPJob jobConf=null;
  try {
    jobConf=new BSPJob(t.getJobID(),t.getJobFile());
  }
 catch (  IOException e1) {
    LOG.error(e1);
    throw e1;
  }
  TaskInProgress tip=new TaskInProgress(t,jobConf,this.groomServerName);
  tip.markAsRecoveryTask(action.getSuperstepCount());
synchronized (this) {
    if (tasks.containsKey(t.getTaskID())) {
      TaskInProgress oldTip=tasks.get(t.getTaskID());
      try {
        oldTip.killRunner();
      }
 catch (      IOException e) {
        LOG.error("Error killing the current process for " + t.getTaskID(),e);
        throw e;
      }
    }
    Iterator<TaskAttemptID> taskIterator=tasks.keySet().iterator();
    while (taskIterator.hasNext()) {
      TaskAttemptID taskAttId=taskIterator.next();
      if (taskAttId.getTaskID().equals(t.getTaskID().getTaskID())) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Removing tasks with id = " + t.getTaskID().getTaskID());
        }
        taskIterator.remove();
        runningTasks.remove(taskAttId);
      }
    }
    tasks.put(t.getTaskID(),tip);
    runningTasks.put(t.getTaskID(),tip);
  }
  try {
    localizeJob(tip);
  }
 catch (  Throwable e) {
    String msg=("Error initializing " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(e));
    LOG.warn(msg);
    try {
      tip.killAndCleanup(true);
    }
 catch (    IOException ie2) {
      LOG.info("Error cleaning up " + tip.getTask().getTaskID() + ":\n"+ StringUtils.stringifyException(ie2));
    }
    throw new IOException("Errro localizing the job.",e);
  }
}

ID 465=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#localizeJob(org.apache.hama.bsp.GroomServer.TaskInProgress)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.warn("Sleep failed",e);
}

block: 
GroomServer
private void localizeJob(TaskInProgress tip) throws IOException {
  Task task=tip.getTask();
  conf.addResource(task.getJobFile());
  BSPJob defaultJobConf=new BSPJob((HamaConfiguration)conf);
  Path localJobFile=defaultJobConf.getLocalPath(SUBDIR + "/" + task.getTaskID()+ "/"+ "job.xml");
  RunningJob rjob=addTaskToJob(task.getJobID(),localJobFile,tip);
  BSPJob jobConf=null;
synchronized (rjob) {
    if (!rjob.localized) {
      FileSystem dfs=FileSystem.get(conf);
      FileSystem localFs=FileSystem.getLocal(conf);
      Path jobDir=localJobFile.getParent();
      if (localFs.exists(jobDir)) {
        localFs.delete(jobDir,true);
        boolean b=localFs.mkdirs(jobDir);
        if (!b)         throw new IOException("Not able to create job directory " + jobDir.toString());
      }
      Path localJarFile=defaultJobConf.getLocalPath(SUBDIR + "/" + task.getTaskID()+ "/"+ "job.jar");
      Path jobFilePath=new Path(task.getJobFile());
      for (int i=0; i < 300 & !dfs.exists(jobFilePath); i++) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          LOG.warn("Sleep failed",e);
        }
      }
      dfs.copyToLocalFile(jobFilePath,localJobFile);
      HamaConfiguration conf=new HamaConfiguration();
      conf.addResource(localJobFile);
      jobConf=new BSPJob(conf,task.getJobID().toString());
      Path jarFile=null;
      if (jobConf.getJar() != null) {
        jarFile=new Path(jobConf.getJar());
      }
 else {
        LOG.warn("No jar file for job " + task.getJobID() + " has been defined!");
      }
      jobConf.setJar(localJarFile.toString());
      if (jarFile != null) {
        dfs.copyToLocalFile(jarFile,localJarFile);
        File workDir=new File(new File(localJobFile.toString()).getParent(),"work");
        if (!workDir.mkdirs()) {
          if (!workDir.isDirectory()) {
            throw new IOException("Mkdirs failed to create " + workDir.toString());
          }
        }
        RunJar.unJar(new File(localJarFile.toString()),workDir);
      }
      rjob.localized=true;
    }
 else {
      HamaConfiguration conf=new HamaConfiguration();
      conf.addResource(rjob.getJobFile());
      jobConf=new BSPJob(conf,rjob.getJobId().toString());
    }
  }
  launchTaskForJob(tip,jobConf);
}

ID 466=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#launchTaskForJob(org.apache.hama.bsp.GroomServer.TaskInProgress, BSPJob)
Rmethod: org.apache.hama.bsp.TaskInProgress#launchTask()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable ie) {
  tip.taskStatus.setRunState(TaskStatus.State.FAILED);
  String error=StringUtils.stringifyException(ie);
  LOG.info(error);
}

block: 
GroomServer
private static void launchTaskForJob(TaskInProgress tip,BSPJob jobConf){
  try {
    tip.setJobConf(jobConf);
    tip.launchTask();
  }
 catch (  Throwable ie) {
    tip.taskStatus.setRunState(TaskStatus.State.FAILED);
    String error=StringUtils.stringifyException(ie);
    LOG.info(error);
  }
}

ID 467=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#run()
Rmethod: org.apache.hama.bsp.GroomServer#initialize()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
  return;
}

block: 
GroomServer
@Override public void run(){
  try {
    initialize();
    startCleanupThreads();
    boolean denied=false;
    while (running && !shuttingDown && !denied) {
      boolean staleState=false;
      try {
        while (running && !staleState && !shuttingDown&& !denied) {
          try {
            State osState=offerService();
            if (osState == State.STALE) {
              staleState=true;
            }
 else             if (osState == State.DENIED) {
              denied=true;
            }
          }
 catch (          Exception e) {
            if (!shuttingDown) {
              LOG.info("Lost connection to BSP Master [" + bspMasterAddr + "].  Retrying...",e);
              try {
                Thread.sleep(5000);
              }
 catch (              InterruptedException ie) {
              }
            }
          }
        }
      }
  finally {
      }
      if (shuttingDown) {
        return;
      }
      LOG.warn("Reinitializing local state");
      initialize();
    }
  }
 catch (  IOException ioe) {
    LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
    return;
  }
}

ID 468=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#run()
Rmethod: org.apache.hama.bsp.GroomServer#startCleanupThreads()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
  return;
}

block: 
GroomServer
@Override public void run(){
  try {
    initialize();
    startCleanupThreads();
    boolean denied=false;
    while (running && !shuttingDown && !denied) {
      boolean staleState=false;
      try {
        while (running && !staleState && !shuttingDown&& !denied) {
          try {
            State osState=offerService();
            if (osState == State.STALE) {
              staleState=true;
            }
 else             if (osState == State.DENIED) {
              denied=true;
            }
          }
 catch (          Exception e) {
            if (!shuttingDown) {
              LOG.info("Lost connection to BSP Master [" + bspMasterAddr + "].  Retrying...",e);
              try {
                Thread.sleep(5000);
              }
 catch (              InterruptedException ie) {
              }
            }
          }
        }
      }
  finally {
      }
      if (shuttingDown) {
        return;
      }
      LOG.warn("Reinitializing local state");
      initialize();
    }
  }
 catch (  IOException ioe) {
    LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
    return;
  }
}

ID 469=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#run()
Rmethod: org.apache.hama.bsp.GroomServer#offerService()
hasForStatement: true
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  if (!shuttingDown) {
    LOG.info("Lost connection to BSP Master [" + bspMasterAddr + "].  Retrying...",e);
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException ie) {
    }
  }
}

block: 
GroomServer
@Override public void run(){
  try {
    initialize();
    startCleanupThreads();
    boolean denied=false;
    while (running && !shuttingDown && !denied) {
      boolean staleState=false;
      try {
        while (running && !staleState && !shuttingDown&& !denied) {
          try {
            State osState=offerService();
            if (osState == State.STALE) {
              staleState=true;
            }
 else             if (osState == State.DENIED) {
              denied=true;
            }
          }
 catch (          Exception e) {
            if (!shuttingDown) {
              LOG.info("Lost connection to BSP Master [" + bspMasterAddr + "].  Retrying...",e);
              try {
                Thread.sleep(5000);
              }
 catch (              InterruptedException ie) {
              }
            }
          }
        }
      }
  finally {
      }
      if (shuttingDown) {
        return;
      }
      LOG.warn("Reinitializing local state");
      initialize();
    }
  }
 catch (  IOException ioe) {
    LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
    return;
  }
}

ID 470=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#run()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
}

block: 
GroomServer
@Override public void run(){
  try {
    initialize();
    startCleanupThreads();
    boolean denied=false;
    while (running && !shuttingDown && !denied) {
      boolean staleState=false;
      try {
        while (running && !staleState && !shuttingDown&& !denied) {
          try {
            State osState=offerService();
            if (osState == State.STALE) {
              staleState=true;
            }
 else             if (osState == State.DENIED) {
              denied=true;
            }
          }
 catch (          Exception e) {
            if (!shuttingDown) {
              LOG.info("Lost connection to BSP Master [" + bspMasterAddr + "].  Retrying...",e);
              try {
                Thread.sleep(5000);
              }
 catch (              InterruptedException ie) {
              }
            }
          }
        }
      }
  finally {
      }
      if (shuttingDown) {
        return;
      }
      LOG.warn("Reinitializing local state");
      initialize();
    }
  }
 catch (  IOException ioe) {
    LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
    return;
  }
}

ID 471=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#run()
Rmethod: org.apache.hama.bsp.GroomServer#initialize()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
  return;
}

block: 
GroomServer
@Override public void run(){
  try {
    initialize();
    startCleanupThreads();
    boolean denied=false;
    while (running && !shuttingDown && !denied) {
      boolean staleState=false;
      try {
        while (running && !staleState && !shuttingDown&& !denied) {
          try {
            State osState=offerService();
            if (osState == State.STALE) {
              staleState=true;
            }
 else             if (osState == State.DENIED) {
              denied=true;
            }
          }
 catch (          Exception e) {
            if (!shuttingDown) {
              LOG.info("Lost connection to BSP Master [" + bspMasterAddr + "].  Retrying...",e);
              try {
                Thread.sleep(5000);
              }
 catch (              InterruptedException ie) {
              }
            }
          }
        }
      }
  finally {
      }
      if (shuttingDown) {
        return;
      }
      LOG.warn("Reinitializing local state");
      initialize();
    }
  }
 catch (  IOException ioe) {
    LOG.error("Got fatal exception while reinitializing GroomServer: " + StringUtils.stringifyException(ioe));
    return;
  }
}

ID 472=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#shutdown()
Rmethod: org.apache.hama.bsp.GroomServer#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GroomServer
public synchronized void shutdown() throws IOException {
  shuttingDown=true;
  close();
}

ID 473=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#close()
Rmethod: org.apache.hama.bsp.GroomServer#cleanupStorage()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GroomServer
@Override public synchronized void close() throws IOException {
  try {
    zk.close();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  if (null != this.sensor.get()) {
    this.sensor.get().stop();
  }
  if (taskMonitorService != null) {
    taskMonitorService.shutdownNow();
    taskMonitorService=null;
  }
  this.running=false;
  this.initialized=false;
  cleanupStorage();
  this.workerServer.stop();
  RPC.stopProxy(masterClient);
  if (taskReportServer != null) {
    taskReportServer.stop();
    taskReportServer=null;
  }
}

ID 474=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskInProgress#launchTask()
Rmethod: org.apache.hama.bsp.TaskInProgress#localizeTask(Task)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskInProgress
public void launchTask() throws IOException {
  localizeTask(task);
  taskStatus.setRunState(TaskStatus.State.RUNNING);
  this.runner=task.createRunner(GroomServer.this);
  this.runner.start();
  startTime=Calendar.getInstance().getTimeInMillis();
  LOG.info("Task '" + task.getTaskID().toString() + "' has started.");
}

ID 475=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskInProgress#jobHasFinished(boolean)
Rmethod: org.apache.hama.bsp.TaskInProgress#killAndCleanup(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskInProgress
public void jobHasFinished(boolean wasFailure) throws IOException {
synchronized (this) {
    if (getRunState() == TaskStatus.State.RUNNING || getRunState() == TaskStatus.State.UNASSIGNED || getRunState() == TaskStatus.State.COMMIT_PENDING) {
      killAndCleanup(wasFailure);
    }
  }
}

ID 476=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#constructGroomServer(Class<? extends org.apache.hama.bsp.GroomServer>, Configuration)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
}

block: 
GroomServer
public static GroomServer constructGroomServer(Class<? extends GroomServer> groomServerClass,final Configuration conf2){
  try {
    Constructor<? extends GroomServer> c=groomServerClass.getConstructor(Configuration.class);
    return c.newInstance(conf2);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
  }
}

ID 477=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#constructGroomServer(Class<? extends org.apache.hama.bsp.GroomServer>, Configuration)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
}

block: 
GroomServer
public static GroomServer constructGroomServer(Class<? extends GroomServer> groomServerClass,final Configuration conf2){
  try {
    Constructor<? extends GroomServer> c=groomServerClass.getConstructor(Configuration.class);
    return c.newInstance(conf2);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
  }
}

ID 478=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#constructGroomServer(Class<? extends org.apache.hama.bsp.GroomServer>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
}

block: 
GroomServer
public static GroomServer constructGroomServer(Class<? extends GroomServer> groomServerClass,final Configuration conf2){
  try {
    Constructor<? extends GroomServer> c=groomServerClass.getConstructor(Configuration.class);
    return c.newInstance(conf2);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
  }
}

ID 479=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#constructGroomServer(Class<? extends org.apache.hama.bsp.GroomServer>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
}

block: 
GroomServer
public static GroomServer constructGroomServer(Class<? extends GroomServer> groomServerClass,final Configuration conf2){
  try {
    Constructor<? extends GroomServer> c=groomServerClass.getConstructor(Configuration.class);
    return c.newInstance(conf2);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
  }
}

ID 480=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#constructGroomServer(Class<? extends org.apache.hama.bsp.GroomServer>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
}

block: 
GroomServer
public static GroomServer constructGroomServer(Class<? extends GroomServer> groomServerClass,final Configuration conf2){
  try {
    Constructor<? extends GroomServer> c=groomServerClass.getConstructor(Configuration.class);
    return c.newInstance(conf2);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
  }
}

ID 481=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#constructGroomServer(Class<? extends org.apache.hama.bsp.GroomServer>, Configuration)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
}

block: 
GroomServer
public static GroomServer constructGroomServer(Class<? extends GroomServer> groomServerClass,final Configuration conf2){
  try {
    Constructor<? extends GroomServer> c=groomServerClass.getConstructor(Configuration.class);
    return c.newInstance(conf2);
  }
 catch (  Exception e) {
    throw new RuntimeException("Failed construction of " + "Master: " + groomServerClass.toString(),e);
  }
}

ID 482=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#purgeTask(org.apache.hama.bsp.GroomServer.TaskInProgress, boolean)
Rmethod: org.apache.hama.bsp.TaskInProgress#jobHasFinished(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Remove the tip and update all relevant state.
 * @param tip {@link TaskInProgress} to be removed.
 * @param wasFailure did the task fail or was it killed?
 */

catch: 
null
block: 
GroomServer
/** 
 * Remove the tip and update all relevant state.
 * @param tip {@link TaskInProgress} to be removed.
 * @param wasFailure did the task fail or was it killed?
 */
private void purgeTask(TaskInProgress tip,boolean wasFailure) throws IOException {
  if (tip != null) {
    LOG.info("About to purge task: " + tip.getTask().getTaskID());
    removeTaskFromJob(tip.getTask().getJobID(),tip);
    tip.jobHasFinished(wasFailure);
  }
}

ID 483=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerChild#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPPeerChild
public static void main(String[] args) throws Throwable {
  if (LOG.isDebugEnabled())   LOG.debug("BSPPeerChild starting");
  final HamaConfiguration defaultConf=new HamaConfiguration();
  String host=args[0];
  int port=Integer.parseInt(args[1]);
  InetSocketAddress address=new InetSocketAddress(host,port);
  TaskAttemptID taskid=TaskAttemptID.forName(args[2]);
  BSPPeerProtocol umbilical=(BSPPeerProtocol)RPC.getProxy(BSPPeerProtocol.class,HamaRPCProtocolVersion.versionID,address,defaultConf);
  final BSPTask task=(BSPTask)umbilical.getTask(taskid);
  int peerPort=umbilical.getAssignedPortNum(taskid);
  defaultConf.addResource(new Path(task.getJobFile()));
  BSPJob job=new BSPJob(task.getJobID(),task.getJobFile());
  defaultConf.set(Constants.PEER_HOST,args[3]);
  if (null != args && 5 == args.length) {
    defaultConf.setInt("bsp.checkpoint.port",Integer.parseInt(args[4]));
  }
  defaultConf.setInt(Constants.PEER_PORT,peerPort);
  long superstep=Long.parseLong(args[4]);
  TaskStatus.State state=TaskStatus.State.valueOf(args[5]);
  LOG.debug("Starting peer for step " + superstep + " state = "+ state);
  try {
    FileSystem.get(job.getConfiguration()).setWorkingDirectory(job.getWorkingDirectory());
    @SuppressWarnings("rawtypes") final BSPPeerImpl<?,?,?,?,?> bspPeer=new BSPPeerImpl(job,defaultConf,taskid,umbilical,task.partition,task.splitClass,task.split,task.getCounters(),superstep,state);
    task.run(job,bspPeer,umbilical);
  }
 catch (  FSError e) {
    LOG.fatal("FSError from child",e);
    umbilical.fsError(taskid,e.getMessage());
    e.printStackTrace();
  }
catch (  SyncException e) {
    LOG.fatal("SyncError from child",e);
    umbilical.fatalError(taskid,e.toString());
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    e.printStackTrace(new PrintStream(baos));
    e.printStackTrace();
  }
catch (  Throwable throwable) {
    LOG.fatal("Error running child",throwable);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    throwable.printStackTrace(new PrintStream(baos));
    throwable.printStackTrace();
  }
 finally {
    RPC.stopProxy(umbilical);
    LogManager.shutdown();
  }
}

ID 484=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPPeerChild#main(java.lang.String[])
Rmethod: java.lang.Long#parseLong(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPPeerChild
public static void main(String[] args) throws Throwable {
  if (LOG.isDebugEnabled())   LOG.debug("BSPPeerChild starting");
  final HamaConfiguration defaultConf=new HamaConfiguration();
  String host=args[0];
  int port=Integer.parseInt(args[1]);
  InetSocketAddress address=new InetSocketAddress(host,port);
  TaskAttemptID taskid=TaskAttemptID.forName(args[2]);
  BSPPeerProtocol umbilical=(BSPPeerProtocol)RPC.getProxy(BSPPeerProtocol.class,HamaRPCProtocolVersion.versionID,address,defaultConf);
  final BSPTask task=(BSPTask)umbilical.getTask(taskid);
  int peerPort=umbilical.getAssignedPortNum(taskid);
  defaultConf.addResource(new Path(task.getJobFile()));
  BSPJob job=new BSPJob(task.getJobID(),task.getJobFile());
  defaultConf.set(Constants.PEER_HOST,args[3]);
  if (null != args && 5 == args.length) {
    defaultConf.setInt("bsp.checkpoint.port",Integer.parseInt(args[4]));
  }
  defaultConf.setInt(Constants.PEER_PORT,peerPort);
  long superstep=Long.parseLong(args[4]);
  TaskStatus.State state=TaskStatus.State.valueOf(args[5]);
  LOG.debug("Starting peer for step " + superstep + " state = "+ state);
  try {
    FileSystem.get(job.getConfiguration()).setWorkingDirectory(job.getWorkingDirectory());
    @SuppressWarnings("rawtypes") final BSPPeerImpl<?,?,?,?,?> bspPeer=new BSPPeerImpl(job,defaultConf,taskid,umbilical,task.partition,task.splitClass,task.split,task.getCounters(),superstep,state);
    task.run(job,bspPeer,umbilical);
  }
 catch (  FSError e) {
    LOG.fatal("FSError from child",e);
    umbilical.fsError(taskid,e.getMessage());
    e.printStackTrace();
  }
catch (  SyncException e) {
    LOG.fatal("SyncError from child",e);
    umbilical.fatalError(taskid,e.toString());
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    e.printStackTrace(new PrintStream(baos));
    e.printStackTrace();
  }
catch (  Throwable throwable) {
    LOG.fatal("Error running child",throwable);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    throwable.printStackTrace(new PrintStream(baos));
    throwable.printStackTrace();
  }
 finally {
    RPC.stopProxy(umbilical);
    LogManager.shutdown();
  }
}

ID 485=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServer#fatalError(TaskAttemptID, java.lang.String)
Rmethod: org.apache.hama.bsp.GroomServer#purgeTask(org.apache.hama.bsp.GroomServer.TaskInProgress, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * A child task had a fatal error. Kill the task.
 */

catch: 
null
block: 
GroomServer
/** 
 * A child task had a fatal error. Kill the task.
 */
@Override public void fatalError(TaskAttemptID taskId,String message) throws IOException {
  LOG.fatal("Task: " + taskId + " - Killed : "+ message);
  TaskInProgress tip=runningTasks.get(taskId);
  purgeTask(tip,true);
}

ID 486=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServerStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GroomServerStatus
@Override public void readFields(DataInput in) throws IOException {
  this.groomName=Text.readString(in);
  this.rpcServer=Text.readString(in);
  this.hostName=Text.readString(in);
  this.failures=in.readInt();
  this.maxTasks=in.readInt();
  taskReports.clear();
  int numTasks=in.readInt();
  TaskStatus status;
  for (int i=0; i < numTasks; i++) {
    status=new TaskStatus();
    status.readFields(in);
    taskReports.add(status);
  }
}

ID 487=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.GroomServerStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
GroomServerStatus
@Override public void write(DataOutput out) throws IOException {
  Text.writeString(out,groomName);
  Text.writeString(out,rpcServer);
  Text.writeString(out,hostName);
  out.writeInt(failures);
  out.writeInt(maxTasks);
  out.writeInt(taskReports.size());
  for (  TaskStatus taskStatus : taskReports) {
    taskStatus.write(out);
  }
}

ID 488=========================================================================type: Rethrow
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#startRPCServer(Configuration, java.net.InetSocketAddress)
Rmethod: org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#startServer(java.lang.String, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Fail to start RPC server!",ioe);
  throw new RuntimeException("RPC Server could not be launched!");
}

block: 
HamaAsyncMessageManagerImpl
private final void startRPCServer(Configuration conf,InetSocketAddress peerAddress){
  try {
    startServer(peerAddress.getHostName(),peerAddress.getPort());
  }
 catch (  IOException ioe) {
    LOG.error("Fail to start RPC server!",ioe);
    throw new RuntimeException("RPC Server could not be launched!");
  }
}

ID 489=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#startServer(java.lang.String, int)
Rmethod: org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#startServer(java.lang.String, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
HamaAsyncMessageManagerImpl
private void startServer(String hostName,int port) throws IOException {
  try {
    this.server=AsyncRPC.getServer(this,hostName,port,conf.getInt("hama.default.messenger.handler.threads.num",5),false,conf);
    server.start();
    LOG.info("BSPPeer address:" + server.getAddress().getHostName() + " port:"+ server.getAddress().getPort());
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Thread.currentThread().interrupt();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
    if (e.getCause() instanceof BindException) {
      final int nextPort=port + 1;
      LOG.warn("Address already in use. Retrying " + hostName + ":"+ nextPort);
      if (retry++ >= MAX_RETRY) {
        throw new RuntimeException("RPC Server could not be launched!");
      }
      startServer(hostName,nextPort);
    }
  }
}

ID 490=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#transfer(java.net.InetSocketAddress, BSPMessageBundle<M>)
Rmethod: org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#getBSPPeerConnection(java.net.InetSocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
HamaAsyncMessageManagerImpl
@Override public final void transfer(InetSocketAddress addr,BSPMessageBundle<M> bundle) throws IOException {
  HamaMessageManager<M> bspPeerConnection=this.getBSPPeerConnection(addr);
  if (bspPeerConnection == null) {
    throw new IllegalArgumentException("Can not find " + addr.toString() + " to transfer messages to!");
  }
 else {
    if (conf.getBoolean(Constants.MESSENGER_RUNTIME_COMPRESSION,false)) {
      ByteArrayOutputStream byteBuffer=new ByteArrayOutputStream();
      DataOutputStream bufferDos=new DataOutputStream(byteBuffer);
      bundle.write(bufferDos);
      byte[] compressed=compressor.compress(byteBuffer.toByteArray());
      peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_MESSAGE_BYTES_TRANSFERED,compressed.length);
      bspPeerConnection.put(compressed);
    }
 else {
      bspPeerConnection.put(bundle);
    }
  }
}

ID 491=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#transfer(java.net.InetSocketAddress, M)
Rmethod: org.apache.hama.bsp.message.HamaAsyncMessageManagerImpl#getBSPPeerConnection(java.net.InetSocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
HamaAsyncMessageManagerImpl
@Override public void transfer(InetSocketAddress addr,M msg) throws IOException {
  HamaMessageManager<M> bspPeerConnection=this.getBSPPeerConnection(addr);
  if (bspPeerConnection == null) {
    throw new IllegalArgumentException("Can not find " + addr.toString() + " to transfer messages to!");
  }
 else {
    bspPeerConnection.put(msg);
  }
}

ID 492=========================================================================type: Recover
package: org.apache.hama
Method:org.apache.hama.HamaClusterTestCase#setUp()
Rmethod: org.apache.hama.HamaClusterTestCase#hamaClusterSetup()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  if (zooKeeperCluster != null) {
    zooKeeperCluster.shutdown();
  }
  if (dfsCluster != null) {
    shutdownDfs(dfsCluster);
  }
  throw e;
}

block: 
HamaClusterTestCase
@Override protected void setUp() throws Exception {
  try {
    if (this.startDfs) {
      this.dfsCluster=new MiniDFSCluster(0,this.conf,2,true,true,true,null,null,null,null);
      FileSystem filesystem=dfsCluster.getFileSystem();
      conf.set("fs.defaultFS",filesystem.getUri().toString());
      Path parentdir=filesystem.getHomeDirectory();
      filesystem.mkdirs(parentdir);
    }
    super.setUp();
    hamaClusterSetup();
  }
 catch (  Exception e) {
    if (zooKeeperCluster != null) {
      zooKeeperCluster.shutdown();
    }
    if (dfsCluster != null) {
      shutdownDfs(dfsCluster);
    }
    throw e;
  }
}

ID 493=========================================================================type: Rethrow
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaMessageManagerImpl#startRPCServer(Configuration, java.net.InetSocketAddress)
Rmethod: org.apache.hama.bsp.message.HamaMessageManagerImpl#startServer(java.lang.String, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Fail to start RPC server!",ioe);
  throw new RuntimeException("RPC Server could not be launched!");
}

block: 
HamaMessageManagerImpl
private final void startRPCServer(Configuration conf,InetSocketAddress peerAddress){
  try {
    startServer(peerAddress.getHostName(),peerAddress.getPort());
  }
 catch (  IOException ioe) {
    LOG.error("Fail to start RPC server!",ioe);
    throw new RuntimeException("RPC Server could not be launched!");
  }
}

ID 494=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaMessageManagerImpl#startServer(java.lang.String, int)
Rmethod: org.apache.hama.bsp.message.HamaMessageManagerImpl#startServer(java.lang.String, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
HamaMessageManagerImpl
private void startServer(String hostName,int port) throws IOException {
  try {
    this.server=RPC.getServer(this,hostName,port,conf.getInt("hama.default.messenger.handler.threads.num",5),false,conf);
    server.start();
    LOG.info("BSPPeer address:" + server.getListenerAddress().getHostName() + " port:"+ server.getListenerAddress().getPort());
  }
 catch (  BindException e) {
    final int nextPort=port + 1;
    LOG.warn("Address already in use. Retrying " + hostName + ":"+ nextPort);
    if (retry++ >= MAX_RETRY) {
      throw new RuntimeException("RPC Server could not be launched!");
    }
    startServer(hostName,nextPort);
  }
}

ID 495=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaMessageManagerImpl#transfer(java.net.InetSocketAddress, BSPMessageBundle<M>)
Rmethod: org.apache.hama.bsp.message.HamaMessageManagerImpl#getBSPPeerConnection(java.net.InetSocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
HamaMessageManagerImpl
@Override public final void transfer(InetSocketAddress addr,BSPMessageBundle<M> bundle) throws IOException {
  HamaMessageManager<M> bspPeerConnection=this.getBSPPeerConnection(addr);
  if (bspPeerConnection == null) {
    throw new IllegalArgumentException("Can not find " + addr.toString() + " to transfer messages to!");
  }
 else {
    if (conf.getBoolean(Constants.MESSENGER_RUNTIME_COMPRESSION,false)) {
      ByteArrayOutputStream byteBuffer=new ByteArrayOutputStream();
      DataOutputStream bufferDos=new DataOutputStream(byteBuffer);
      bundle.write(bufferDos);
      byte[] compressed=compressor.compress(byteBuffer.toByteArray());
      peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_COMPRESSED_BYTES_TRANSFERED,compressed.length);
      peer.incrementCounter(BSPPeerImpl.PeerCounter.TOTAL_DECOMPRESSED_BYTES,byteBuffer.size());
      bspPeerConnection.put(compressed);
    }
 else {
      bspPeerConnection.put(bundle);
    }
  }
}

ID 496=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.HamaMessageManagerImpl#transfer(java.net.InetSocketAddress, M)
Rmethod: org.apache.hama.bsp.message.HamaMessageManagerImpl#getBSPPeerConnection(java.net.InetSocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
HamaMessageManagerImpl
@Override public void transfer(InetSocketAddress addr,M msg) throws IOException {
  HamaMessageManager<M> bspPeerConnection=this.getBSPPeerConnection(addr);
  if (bspPeerConnection == null) {
    throw new IllegalArgumentException("Can not find " + addr.toString() + " to transfer messages to!");
  }
 else {
    bspPeerConnection.put(msg);
  }
}

ID 497=========================================================================type: only_throws
package: org.apache.hama.http
Method:org.apache.hama.http.HttpServer#HttpServer(java.lang.String, java.lang.String, int, boolean, Configuration)
Rmethod: org.apache.hama.http.HttpServer#createBaseListener(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a status server on the given port. The jsp scripts are taken from src/main/webapp/<name>.
 * @param name The name of the server
 * @param port The port to use on the server
 * @param findPort whether the server should start at the given port andincrement by 1 until it finds a free port.
 * @param conf Configuration
 */

catch: 
null
block: 
HttpServer
/** 
 * Create a status server on the given port. The jsp scripts are taken from src/main/webapp/<name>.
 * @param name The name of the server
 * @param port The port to use on the server
 * @param findPort whether the server should start at the given port andincrement by 1 until it finds a free port.
 * @param conf Configuration
 */
public HttpServer(String name,String bindAddress,int port,boolean findPort,Configuration conf) throws IOException {
  webServer=new Server();
  this.findPort=findPort;
  listener=createBaseListener(conf);
  listener.setHost(bindAddress);
  listener.setPort(port);
  webServer.addConnector(listener);
  webServer.setThreadPool(new QueuedThreadPool());
  final String appDir=getWebAppsPath();
  ContextHandlerCollection contexts=new ContextHandlerCollection();
  webServer.setHandler(contexts);
  webAppContext=new WebAppContext();
  System.setProperty("java.naming.factory.initial","org.mortbay.naming.InitialContextFactory");
  System.setProperty("java.naming.factory.url.pkgs","org.mortbay.naming");
  webAppContext.setContextPath("/");
  String warPath=appDir + "/" + name;
  if (!warPath.endsWith("/")) {
    warPath=warPath + "/";
  }
  webAppContext.setWar(warPath);
  webAppContext.getServletContext().setAttribute(CONF_CONTEXT_ATTRIBUTE,conf);
  webServer.addHandler(webAppContext);
  addDefaultApps(contexts,appDir);
  addDefaultServlets();
}

ID 498=========================================================================type: only_throws
package: org.apache.hama.http
Method:org.apache.hama.http.HttpServer#HttpServer(java.lang.String, java.lang.String, int, boolean, Configuration)
Rmethod: org.apache.hama.http.HttpServer#getWebAppsPath()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a status server on the given port. The jsp scripts are taken from src/main/webapp/<name>.
 * @param name The name of the server
 * @param port The port to use on the server
 * @param findPort whether the server should start at the given port andincrement by 1 until it finds a free port.
 * @param conf Configuration
 */

catch: 
null
block: 
HttpServer
/** 
 * Create a status server on the given port. The jsp scripts are taken from src/main/webapp/<name>.
 * @param name The name of the server
 * @param port The port to use on the server
 * @param findPort whether the server should start at the given port andincrement by 1 until it finds a free port.
 * @param conf Configuration
 */
public HttpServer(String name,String bindAddress,int port,boolean findPort,Configuration conf) throws IOException {
  webServer=new Server();
  this.findPort=findPort;
  listener=createBaseListener(conf);
  listener.setHost(bindAddress);
  listener.setPort(port);
  webServer.addConnector(listener);
  webServer.setThreadPool(new QueuedThreadPool());
  final String appDir=getWebAppsPath();
  ContextHandlerCollection contexts=new ContextHandlerCollection();
  webServer.setHandler(contexts);
  webAppContext=new WebAppContext();
  System.setProperty("java.naming.factory.initial","org.mortbay.naming.InitialContextFactory");
  System.setProperty("java.naming.factory.url.pkgs","org.mortbay.naming");
  webAppContext.setContextPath("/");
  String warPath=appDir + "/" + name;
  if (!warPath.endsWith("/")) {
    warPath=warPath + "/";
  }
  webAppContext.setWar(warPath);
  webAppContext.getServletContext().setAttribute(CONF_CONTEXT_ATTRIBUTE,conf);
  webServer.addHandler(webAppContext);
  addDefaultApps(contexts,appDir);
  addDefaultServlets();
}

ID 499=========================================================================type: only_throws
package: org.apache.hama.http
Method:org.apache.hama.http.HttpServer#HttpServer(java.lang.String, java.lang.String, int, boolean, Configuration)
Rmethod: org.apache.hama.http.HttpServer#addDefaultApps(ContextHandlerCollection, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a status server on the given port. The jsp scripts are taken from src/main/webapp/<name>.
 * @param name The name of the server
 * @param port The port to use on the server
 * @param findPort whether the server should start at the given port andincrement by 1 until it finds a free port.
 * @param conf Configuration
 */

catch: 
null
block: 
HttpServer
/** 
 * Create a status server on the given port. The jsp scripts are taken from src/main/webapp/<name>.
 * @param name The name of the server
 * @param port The port to use on the server
 * @param findPort whether the server should start at the given port andincrement by 1 until it finds a free port.
 * @param conf Configuration
 */
public HttpServer(String name,String bindAddress,int port,boolean findPort,Configuration conf) throws IOException {
  webServer=new Server();
  this.findPort=findPort;
  listener=createBaseListener(conf);
  listener.setHost(bindAddress);
  listener.setPort(port);
  webServer.addConnector(listener);
  webServer.setThreadPool(new QueuedThreadPool());
  final String appDir=getWebAppsPath();
  ContextHandlerCollection contexts=new ContextHandlerCollection();
  webServer.setHandler(contexts);
  webAppContext=new WebAppContext();
  System.setProperty("java.naming.factory.initial","org.mortbay.naming.InitialContextFactory");
  System.setProperty("java.naming.factory.url.pkgs","org.mortbay.naming");
  webAppContext.setContextPath("/");
  String warPath=appDir + "/" + name;
  if (!warPath.endsWith("/")) {
    warPath=warPath + "/";
  }
  webAppContext.setWar(warPath);
  webAppContext.getServletContext().setAttribute(CONF_CONTEXT_ATTRIBUTE,conf);
  webServer.addHandler(webAppContext);
  addDefaultApps(contexts,appDir);
  addDefaultServlets();
}

ID 500=========================================================================type: only_throws
package: org.apache.hama.http
Method:org.apache.hama.http.HttpServer#addContext(java.lang.String, java.lang.String, boolean)
Rmethod: org.apache.hama.http.HttpServer#addContext(Context, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Add a context
 * @param pathSpec The path spec for the context
 * @param dir The directory containing the context
 * @param isFiltered if true, the servlet is added to the filter path mapping
 * @throws IOException
 */

catch: 
null
block: 
HttpServer
/** 
 * Add a context
 * @param pathSpec The path spec for the context
 * @param dir The directory containing the context
 * @param isFiltered if true, the servlet is added to the filter path mapping
 * @throws IOException
 */
protected void addContext(String pathSpec,String dir,boolean isFiltered) throws IOException {
  if (0 == webServer.getHandlers().length) {
    throw new RuntimeException("Couldn't find handler");
  }
  WebAppContext webAppCtx=new WebAppContext();
  webAppCtx.setContextPath(pathSpec);
  webAppCtx.setWar(dir);
  addContext(webAppCtx,isFiltered);
}

ID 501=========================================================================type: only_throws
package: org.apache.hama.http
Method:org.apache.hama.http.HttpServer#start()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Start the server. Does not wait for the server to start.
 */

catch: 
null
block: 
HttpServer
/** 
 * Start the server. Does not wait for the server to start.
 */
public void start() throws IOException {
  try {
    int port;
    int oriPort=listener.getPort();
    while (true) {
      try {
        port=webServer.getConnectors()[0].getLocalPort();
        LOG.info("Port returned by webServer.getConnectors()[0]." + "getLocalPort() before open() is " + port + ". Opening the listener on "+ oriPort);
        listener.open();
        port=listener.getLocalPort();
        LOG.info("listener.getLocalPort() returned " + listener.getLocalPort() + " webServer.getConnectors()[0].getLocalPort() returned "+ webServer.getConnectors()[0].getLocalPort());
        if (port < 0) {
          Thread.sleep(100);
          int numRetries=1;
          while (port < 0) {
            LOG.warn("listener.getLocalPort returned " + port);
            if (numRetries++ > MAX_RETRIES) {
              throw new Exception(" listener.getLocalPort is returning " + "less than 0 even after " + numRetries + " resets");
            }
            for (int i=0; i < 2; i++) {
              LOG.info("Retrying listener.getLocalPort()");
              port=listener.getLocalPort();
              if (port > 0) {
                break;
              }
              Thread.sleep(200);
            }
            if (port > 0) {
              break;
            }
            LOG.info("Bouncing the listener");
            listener.close();
            Thread.sleep(1000);
            listener.setPort(oriPort == 0 ? 0 : (oriPort+=1));
            listener.open();
            Thread.sleep(100);
            port=listener.getLocalPort();
          }
        }
        LOG.info("Jetty bound to port " + port);
        webServer.start();
        port=listener.getLocalPort();
        if (port < 0) {
          LOG.warn("Bounds port is " + port + " after webserver start");
          for (int i=0; i < MAX_RETRIES / 2; i++) {
            try {
              webServer.stop();
            }
 catch (            Exception e) {
              LOG.warn("Can't stop  web-server",e);
            }
            Thread.sleep(1000);
            listener.setPort(oriPort == 0 ? 0 : (oriPort+=1));
            listener.open();
            Thread.sleep(100);
            webServer.start();
            LOG.info(i + "attempts to restart webserver");
            port=listener.getLocalPort();
            if (port > 0)             break;
          }
          if (port < 0)           throw new Exception("listener.getLocalPort() is returning " + "less than 0 even after " + MAX_RETRIES + " resets");
        }
        break;
      }
 catch (      IOException ex) {
        if (ex instanceof BindException) {
          if (!findPort) {
            throw (BindException)ex;
          }
        }
 else {
          LOG.info("HttpServer.start() threw a non Bind IOException");
          throw ex;
        }
      }
catch (      MultiException ex) {
        LOG.info("HttpServer.start() threw a MultiException");
        throw ex;
      }
      listener.setPort((oriPort+=1));
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  Exception e) {
    throw new IOException("Problem starting http server",e);
  }
}

ID 502=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ID#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ID
@Override public void readFields(DataInput in) throws IOException {
  this.id=in.readInt();
}

ID 503=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ID#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ID
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(id);
}

ID 504=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.InlinkCount#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
InlinkCount
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length < 2)   printUsage();
  Optional<Integer> absent=Optional.absent();
  GraphJob inlinkJob=getJob(args[0],args[1],args.length >= 3 ? Optional.of(Integer.parseInt(args[3])) : absent);
  long startTime=System.currentTimeMillis();
  if (inlinkJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 505=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.InlinkCount#main(java.lang.String[])
Rmethod: org.apache.hama.examples.InlinkCount#getJob(java.lang.String, java.lang.String, Optional<java.lang.Integer>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
InlinkCount
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length < 2)   printUsage();
  Optional<Integer> absent=Optional.absent();
  GraphJob inlinkJob=getJob(args[0],args[1],args.length >= 3 ? Optional.of(Integer.parseInt(args[3])) : absent);
  long startTime=System.currentTimeMillis();
  if (inlinkJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 506=========================================================================type: Recover
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.InputConverter#convert(java.lang.String)
Rmethod: org.apache.hama.ml.recommendation.cf.InputConverter#writeToFile(java.lang.String, java.lang.String, KeyValueParser<Text,VectorWritable>, FileSystem, SequenceFile.Writer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * converting given inputs into compatible output and save
 * @param outputPath - output path of converted input
 * @return true if success
 */

catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
InputConverter
/** 
 * converting given inputs into compatible output and save
 * @param outputPath - output path of converted input
 * @return true if success
 */
public boolean convert(String outputPath){
  try {
    Configuration conf=new Configuration();
    Path outputDataPath=new Path(outputPath);
    FileSystem fs=FileSystem.get(conf);
    fs.delete(outputDataPath,true);
    fs.createNewFile(outputDataPath);
    SequenceFile.Writer writer=new SequenceFile.Writer(fs,conf,outputDataPath,Text.class,VectorWritable.class);
    writeToFile(inputPreferences,OnlineCF.Settings.DFLT_PREFERENCE_DELIM,preferencesParser,fs,writer);
    writeToFile(inputUserFeatures,OnlineCF.Settings.DFLT_USER_DELIM,userFeatureParser,fs,writer);
    writeToFile(inputItemFeatures,OnlineCF.Settings.DFLT_ITEM_DELIM,itemFeatureParser,fs,writer);
    writer.close();
    return true;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return false;
}

ID 507=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JobInProgress#initTasks()
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
JobInProgress
public synchronized void initTasks() throws IOException {
  if (tasksInited) {
    return;
  }
  Path sysDir=new Path(this.master.getSystemDir());
  FileSystem fs=sysDir.getFileSystem(conf);
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(this.jobSplit));
    BSPJobClient.RawSplit[] splits;
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
    LOG.debug("numBSPTasks: " + numBSPTasks + ", splits.length: "+ splits.length);
    this.tasks=new TaskInProgress[numBSPTasks];
    for (int i=0; i < splits.length; i++) {
      tasks[i]=new TaskInProgress(getJobID(),this.jobFile.toString(),splits[i],this.conf,this,i);
    }
    for (int i=splits.length; i < numBSPTasks; i++) {
      tasks[i]=new TaskInProgress(getJobID(),this.jobFile.toString(),null,this.conf,this,i);
    }
  }
 else {
    this.tasks=new TaskInProgress[numBSPTasks];
    for (int i=0; i < numBSPTasks; i++) {
      tasks[i]=new TaskInProgress(getJobID(),this.jobFile.toString(),null,this.conf,this,i);
    }
  }
  this.taskToGroomMap=new HashMap<Task,GroomServerStatus>(2 * tasks.length);
  this.taskCountInGroomMap=new HashMap<GroomServerStatus,Integer>();
  this.recoveryTasks=new HashSet<TaskInProgress>(2 * tasks.length);
  this.status=new JobStatus(this.status.getJobID(),this.profile.getUser(),0L,0L,JobStatus.RUNNING,counters);
  MasterSyncClient syncClient=master.getSyncClient();
  syncClient.registerJob(this.getJobID().toString());
  tasksInited=true;
  Class<?> taskAllocatorClass=conf.getClass(Constants.TASK_ALLOCATOR_CLASS,BestEffortDataLocalTaskAllocator.class,TaskAllocationStrategy.class);
  this.taskAllocationStrategy=(TaskAllocationStrategy)ReflectionUtils.newInstance(taskAllocatorClass,new Object[0]);
  if (conf.getBoolean(Constants.FAULT_TOLERANCE_FLAG,false)) {
    Class<?> ftClass=conf.getClass(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class,BSPFaultTolerantService.class);
    if (ftClass != null) {
      try {
        faultToleranceService=((BSPFaultTolerantService<?>)ReflectionUtils.newInstance(ftClass,new Object[0])).constructMasterFaultTolerance(jobId,maxTaskAttempts,tasks,conf,master.getSyncClient(),taskAllocationStrategy);
        LOG.info("Initialized fault tolerance service with " + ftClass.getCanonicalName());
      }
 catch (      Exception e) {
        throw new IOException(e);
      }
    }
  }
  LOG.info("Job is initialized.");
}

ID 508=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JobStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
JobStatus
@Override public synchronized void write(DataOutput out) throws IOException {
  jobid.write(out);
  out.writeLong(setupProgress);
  out.writeLong(progress);
  out.writeLong(cleanupProgress);
  out.writeInt(runState);
  out.writeLong(startTime);
  out.writeLong(finishTime);
  Text.writeString(out,user);
  Text.writeString(out,schedulingInfo);
  out.writeLong(superstepCount);
  counter.write(out);
}

ID 509=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JobStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
JobStatus
@Override public synchronized void write(DataOutput out) throws IOException {
  jobid.write(out);
  out.writeLong(setupProgress);
  out.writeLong(progress);
  out.writeLong(cleanupProgress);
  out.writeInt(runState);
  out.writeLong(startTime);
  out.writeLong(finishTime);
  Text.writeString(out,user);
  Text.writeString(out,schedulingInfo);
  out.writeLong(superstepCount);
  counter.write(out);
}

ID 510=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JobStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
JobStatus
@Override public synchronized void readFields(DataInput in) throws IOException {
  this.jobid=new BSPJobID();
  jobid.readFields(in);
  this.setupProgress=in.readLong();
  this.progress=in.readLong();
  this.cleanupProgress=in.readLong();
  this.runState=in.readInt();
  this.startTime=in.readLong();
  this.finishTime=in.readLong();
  this.user=Text.readString(in);
  this.schedulingInfo=Text.readString(in);
  this.superstepCount=in.readLong();
  counter=new Counters();
  counter.readFields(in);
}

ID 511=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JobStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
JobStatus
@Override public synchronized void readFields(DataInput in) throws IOException {
  this.jobid=new BSPJobID();
  jobid.readFields(in);
  this.setupProgress=in.readLong();
  this.progress=in.readLong();
  this.cleanupProgress=in.readLong();
  this.runState=in.readInt();
  this.startTime=in.readLong();
  this.finishTime=in.readLong();
  this.user=Text.readString(in);
  this.schedulingInfo=Text.readString(in);
  this.superstepCount=in.readLong();
  counter=new Counters();
  counter.readFields(in);
}

ID 512=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.KCore#main(java.lang.String[])
Rmethod: org.apache.hama.examples.KCore#createJob(java.lang.String[], HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCore
public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {
  if (args.length != 2) {
    printUsage();
  }
  HamaConfiguration conf=new HamaConfiguration(new Configuration());
  GraphJob graphJob=createJob(args,conf);
  long startTime=System.currentTimeMillis();
  if (graphJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 513=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreMessage
@Override public void readFields(DataInput input) throws IOException {
  vertexID=input.readLong();
  core=input.readInt();
}

ID 514=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreMessage
@Override public void readFields(DataInput input) throws IOException {
  vertexID=input.readLong();
  core=input.readInt();
}

ID 515=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreMessage
@Override public void write(DataOutput output) throws IOException {
  output.writeLong(vertexID);
  output.writeInt(core);
}

ID 516=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreMessage
@Override public void write(DataOutput output) throws IOException {
  output.writeLong(vertexID);
  output.writeInt(core);
}

ID 517=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.KCoreTest#verifyResult()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreTest
private void verifyResult() throws IllegalArgumentException, IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(new Path(OUTPUT + "/part-00000"))));
  String line=null;
  while ((line=reader.readLine()) != null) {
    String[] temp=line.split("\t");
    assertTrue(outResults.containsKey(temp[0]));
    assertEquals(temp[1],outResults.get(temp[0]));
  }
}

ID 518=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertex#readState(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertex
@Override public void readState(DataInput in) throws IOException {
  core=in.readInt();
  changed=in.readBoolean();
  this.estimates=new HashMap<Long,Integer>();
  if (in.readBoolean()) {
    int num=in.readInt();
    for (int i=0; i < num; ++i) {
      long key=in.readLong();
      int value=in.readInt();
      estimates.put(key,value);
    }
  }
}

ID 519=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertex#readState(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertex
@Override public void readState(DataInput in) throws IOException {
  core=in.readInt();
  changed=in.readBoolean();
  this.estimates=new HashMap<Long,Integer>();
  if (in.readBoolean()) {
    int num=in.readInt();
    for (int i=0; i < num; ++i) {
      long key=in.readLong();
      int value=in.readInt();
      estimates.put(key,value);
    }
  }
}

ID 520=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertex#readState(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertex
@Override public void readState(DataInput in) throws IOException {
  core=in.readInt();
  changed=in.readBoolean();
  this.estimates=new HashMap<Long,Integer>();
  if (in.readBoolean()) {
    int num=in.readInt();
    for (int i=0; i < num; ++i) {
      long key=in.readLong();
      int value=in.readInt();
      estimates.put(key,value);
    }
  }
}

ID 521=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertex#readState(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertex
@Override public void readState(DataInput in) throws IOException {
  core=in.readInt();
  changed=in.readBoolean();
  this.estimates=new HashMap<Long,Integer>();
  if (in.readBoolean()) {
    int num=in.readInt();
    for (int i=0; i < num; ++i) {
      long key=in.readLong();
      int value=in.readInt();
      estimates.put(key,value);
    }
  }
}

ID 522=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertex#writeState(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertex
@Override public void writeState(DataOutput out) throws IOException {
  out.writeInt(core);
  out.writeBoolean(changed);
  if (this.estimates == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.estimates.size());
    for (    Map.Entry<Long,Integer> entry : estimates.entrySet()) {
      out.writeLong(entry.getKey());
      out.writeInt(entry.getValue());
    }
  }
}

ID 523=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertex#writeState(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertex
@Override public void writeState(DataOutput out) throws IOException {
  out.writeInt(core);
  out.writeBoolean(changed);
  if (this.estimates == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.estimates.size());
    for (    Map.Entry<Long,Integer> entry : estimates.entrySet()) {
      out.writeLong(entry.getKey());
      out.writeInt(entry.getValue());
    }
  }
}

ID 524=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertex#writeState(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertex
@Override public void writeState(DataOutput out) throws IOException {
  out.writeInt(core);
  out.writeBoolean(changed);
  if (this.estimates == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.estimates.size());
    for (    Map.Entry<Long,Integer> entry : estimates.entrySet()) {
      out.writeLong(entry.getKey());
      out.writeInt(entry.getValue());
    }
  }
}

ID 525=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertexReader#parseVertex(LongWritable, Text, Vertex<LongWritable,LongWritable,KCoreMessage>)
Rmethod: java.lang.Long#parseLong(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertexReader
@Override public boolean parseVertex(LongWritable key,Text value,Vertex<LongWritable,LongWritable,KCoreMessage> vertex) throws Exception {
  String[] vertices=value.toString().split("\t");
  List<Edge<LongWritable,LongWritable>> edges=new ArrayList<Edge<LongWritable,LongWritable>>();
  for (int i=1; i < vertices.length; i++) {
    LongWritable destID=new LongWritable(Long.parseLong(vertices[i]));
    edges.add(new Edge<LongWritable,LongWritable>(destID,new LongWritable(0)));
  }
  vertex.setEdges(edges);
  vertex.setValue(new KCoreMessage());
  vertex.setVertexID(new LongWritable(Long.parseLong(vertices[0])));
  return true;
}

ID 526=========================================================================type: only_throws
package: org.apache.hama.ml.kcore
Method:org.apache.hama.ml.kcore.KCoreVertexReader#parseVertex(LongWritable, Text, Vertex<LongWritable,LongWritable,KCoreMessage>)
Rmethod: java.lang.Long#parseLong(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KCoreVertexReader
@Override public boolean parseVertex(LongWritable key,Text value,Vertex<LongWritable,LongWritable,KCoreMessage> vertex) throws Exception {
  String[] vertices=value.toString().split("\t");
  List<Edge<LongWritable,LongWritable>> edges=new ArrayList<Edge<LongWritable,LongWritable>>();
  for (int i=1; i < vertices.length; i++) {
    LongWritable destID=new LongWritable(Long.parseLong(vertices[i]));
    edges.add(new Edge<LongWritable,LongWritable>(destID,new LongWritable(0)));
  }
  vertex.setEdges(edges);
  vertex.setValue(new KCoreMessage());
  vertex.setVertexID(new LongWritable(Long.parseLong(vertices[0])));
  return true;
}

ID 527=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.Kmeans#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Kmeans
public static void main(String[] args) throws Exception {
  if (args.length < 4 || (args.length > 4 && args.length != 7)) {
    System.out.println("USAGE: <INPUT_PATH> <OUTPUT_PATH> <MAXITERATIONS> <K (how many centers)> -g [<COUNT> <DIMENSION OF VECTORS>]");
    return;
  }
  HamaConfiguration conf=new HamaConfiguration();
  Path in=new Path(args[0]);
  Path out=new Path(args[1]);
  FileSystem fs=FileSystem.get(conf);
  Path center=null;
  if (fs.isFile(in)) {
    center=new Path(in.getParent(),"center/cen.seq");
  }
 else {
    center=new Path(in,"center/cen.seq");
  }
  Path centerOut=new Path(out,"center/center_output.seq");
  conf.set(KMeansBSP.CENTER_IN_PATH,center.toString());
  conf.set(KMeansBSP.CENTER_OUT_PATH,centerOut.toString());
  int iterations=Integer.parseInt(args[2]);
  conf.setInt(KMeansBSP.MAX_ITERATIONS_KEY,iterations);
  int k=Integer.parseInt(args[3]);
  if (args.length == 7 && args[4].equals("-g")) {
    int count=Integer.parseInt(args[5]);
    if (k > count)     throw new IllegalArgumentException("K can't be greater than n!");
    int dimension=Integer.parseInt(args[6]);
    System.out.println("N: " + count + " Dimension: "+ dimension+ " Iterations: "+ iterations);
    if (!fs.isFile(in)) {
      in=new Path(in,"input.seq");
    }
    KMeansBSP.prepareInput(count,k,dimension,conf,in,center,out,fs);
  }
 else {
    if (!fs.isFile(in)) {
      System.out.println("Cannot read text input file: " + in.toString());
      return;
    }
    in=KMeansBSP.prepareInputText(k,conf,in,center,out,fs,true);
  }
  BSPJob job=KMeansBSP.createJob(conf,in,out,true);
  long startTime=System.currentTimeMillis();
  if (job.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
  System.out.println("\nHere are a few lines of output:");
  List<String> results=KMeansBSP.readOutput(conf,out,fs,4);
  for (  String line : results) {
    System.out.println(line);
  }
  System.out.println("...");
}

ID 528=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#bsp(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage>)
Rmethod: org.apache.hama.ml.kmeans.KMeansBSP#assignCenters(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KMeansBSP
@Override public final void bsp(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage> peer) throws IOException, InterruptedException, SyncException {
  long converged;
  while (true) {
    assignCenters(peer);
    peer.sync();
    converged=updateCenters(peer);
    peer.reopenInput();
    if (converged == 0)     break;
    if (maxIterations > 0 && maxIterations < peer.getSuperstepCount())     break;
  }
  LOG.info("Finished! Writing the assignments...");
  recalculateAssignmentsAndWrite(peer);
  LOG.info("Done.");
}

ID 529=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#bsp(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage>)
Rmethod: org.apache.hama.ml.kmeans.KMeansBSP#updateCenters(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KMeansBSP
@Override public final void bsp(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage> peer) throws IOException, InterruptedException, SyncException {
  long converged;
  while (true) {
    assignCenters(peer);
    peer.sync();
    converged=updateCenters(peer);
    peer.reopenInput();
    if (converged == 0)     break;
    if (maxIterations > 0 && maxIterations < peer.getSuperstepCount())     break;
  }
  LOG.info("Finished! Writing the assignments...");
  recalculateAssignmentsAndWrite(peer);
  LOG.info("Done.");
}

ID 530=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#bsp(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage>)
Rmethod: org.apache.hama.ml.kmeans.KMeansBSP#recalculateAssignmentsAndWrite(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KMeansBSP
@Override public final void bsp(BSPPeer<VectorWritable,NullWritable,IntWritable,VectorWritable,CenterMessage> peer) throws IOException, InterruptedException, SyncException {
  long converged;
  while (true) {
    assignCenters(peer);
    peer.sync();
    converged=updateCenters(peer);
    peer.reopenInput();
    if (converged == 0)     break;
    if (maxIterations > 0 && maxIterations < peer.getSuperstepCount())     break;
  }
  LOG.info("Finished! Writing the assignments...");
  recalculateAssignmentsAndWrite(peer);
  LOG.info("Done.");
}

ID 531=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KMeansBSP
public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {
  if (args.length < 6) {
    LOG.info("USAGE: <INPUT_PATH> <OUTPUT_PATH> <COUNT> <K> <DIMENSION OF VECTORS> <MAXITERATIONS> <optional: num of tasks>");
    return;
  }
  Configuration conf=new Configuration();
  int count=Integer.parseInt(args[2]);
  int k=Integer.parseInt(args[3]);
  int dimension=Integer.parseInt(args[4]);
  int iterations=Integer.parseInt(args[5]);
  conf.setInt(MAX_ITERATIONS_KEY,iterations);
  Path in=new Path(args[0]);
  Path out=new Path(args[1]);
  Path center=new Path(in,"center/cen.seq");
  Path centerOut=new Path(out,"center/center_output.seq");
  conf.set(CENTER_IN_PATH,center.toString());
  conf.set(CENTER_OUT_PATH,centerOut.toString());
  conf.set("bsp.local.tasks.maximum","" + Runtime.getRuntime().availableProcessors());
  conf.setBoolean(CACHING_ENABLED_KEY,true);
  BSPJob job=createJob(conf,in,out,false);
  LOG.info("N: " + count + " k: "+ k+ " Dimension: "+ dimension+ " Iterations: "+ iterations);
  FileSystem fs=FileSystem.get(conf);
  prepareInput(count,k,dimension,conf,in,center,out,fs);
  if (args.length == 7) {
    job.setNumBspTask(Integer.parseInt(args[6]));
  }
  job.waitForCompletion(true);
}

ID 532=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#main(java.lang.String[])
Rmethod: org.apache.hama.ml.kmeans.KMeansBSP#createJob(Configuration, Path, Path, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KMeansBSP
public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {
  if (args.length < 6) {
    LOG.info("USAGE: <INPUT_PATH> <OUTPUT_PATH> <COUNT> <K> <DIMENSION OF VECTORS> <MAXITERATIONS> <optional: num of tasks>");
    return;
  }
  Configuration conf=new Configuration();
  int count=Integer.parseInt(args[2]);
  int k=Integer.parseInt(args[3]);
  int dimension=Integer.parseInt(args[4]);
  int iterations=Integer.parseInt(args[5]);
  conf.setInt(MAX_ITERATIONS_KEY,iterations);
  Path in=new Path(args[0]);
  Path out=new Path(args[1]);
  Path center=new Path(in,"center/cen.seq");
  Path centerOut=new Path(out,"center/center_output.seq");
  conf.set(CENTER_IN_PATH,center.toString());
  conf.set(CENTER_OUT_PATH,centerOut.toString());
  conf.set("bsp.local.tasks.maximum","" + Runtime.getRuntime().availableProcessors());
  conf.setBoolean(CACHING_ENABLED_KEY,true);
  BSPJob job=createJob(conf,in,out,false);
  LOG.info("N: " + count + " k: "+ k+ " Dimension: "+ dimension+ " Iterations: "+ iterations);
  FileSystem fs=FileSystem.get(conf);
  prepareInput(count,k,dimension,conf,in,center,out,fs);
  if (args.length == 7) {
    job.setNumBspTask(Integer.parseInt(args[6]));
  }
  job.waitForCompletion(true);
}

ID 533=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#main(java.lang.String[])
Rmethod: org.apache.hama.ml.kmeans.KMeansBSP#prepareInput(int, int, int, Configuration, Path, Path, Path, FileSystem)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KMeansBSP
public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {
  if (args.length < 6) {
    LOG.info("USAGE: <INPUT_PATH> <OUTPUT_PATH> <COUNT> <K> <DIMENSION OF VECTORS> <MAXITERATIONS> <optional: num of tasks>");
    return;
  }
  Configuration conf=new Configuration();
  int count=Integer.parseInt(args[2]);
  int k=Integer.parseInt(args[3]);
  int dimension=Integer.parseInt(args[4]);
  int iterations=Integer.parseInt(args[5]);
  conf.setInt(MAX_ITERATIONS_KEY,iterations);
  Path in=new Path(args[0]);
  Path out=new Path(args[1]);
  Path center=new Path(in,"center/cen.seq");
  Path centerOut=new Path(out,"center/center_output.seq");
  conf.set(CENTER_IN_PATH,center.toString());
  conf.set(CENTER_OUT_PATH,centerOut.toString());
  conf.set("bsp.local.tasks.maximum","" + Runtime.getRuntime().availableProcessors());
  conf.setBoolean(CACHING_ENABLED_KEY,true);
  BSPJob job=createJob(conf,in,out,false);
  LOG.info("N: " + count + " k: "+ k+ " Dimension: "+ dimension+ " Iterations: "+ iterations);
  FileSystem fs=FileSystem.get(conf);
  prepareInput(count,k,dimension,conf,in,center,out,fs);
  if (args.length == 7) {
    job.setNumBspTask(Integer.parseInt(args[6]));
  }
  job.waitForCompletion(true);
}

ID 534=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#readOutput(Configuration, Path, FileSystem, int)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Reads output. The list of output records can be restricted to maxlines.
 * @param conf
 * @param outPath
 * @param fs
 * @param maxlines
 * @return the list of output records
 * @throws IOException
 */

catch: 
null
block: 
KMeansBSP
/** 
 * Reads output. The list of output records can be restricted to maxlines.
 * @param conf
 * @param outPath
 * @param fs
 * @param maxlines
 * @return the list of output records
 * @throws IOException
 */
public static List<String> readOutput(Configuration conf,Path outPath,FileSystem fs,int maxlines) throws IOException {
  List<String> output=new ArrayList<String>();
  FileStatus[] globStatus=fs.globStatus(new Path(outPath + "/part-*"));
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line=null;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      output.add(split[1] + " belongs to cluster " + split[0]);
      if (output.size() >= maxlines)       return output;
    }
  }
  return output;
}

ID 535=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#prepareInputText(int, Configuration, Path, Path, Path, FileSystem, boolean)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Reads input text files and writes it to a sequencefile.
 * @param k
 * @param conf
 * @param txtIn
 * @param center
 * @param out
 * @param fs
 * @param hasKey true if first column is required to be the key.
 * @return the path of a sequencefile.
 * @throws IOException
 */

catch: 
null
block: 
KMeansBSP
/** 
 * Reads input text files and writes it to a sequencefile.
 * @param k
 * @param conf
 * @param txtIn
 * @param center
 * @param out
 * @param fs
 * @param hasKey true if first column is required to be the key.
 * @return the path of a sequencefile.
 * @throws IOException
 */
public static Path prepareInputText(int k,Configuration conf,Path txtIn,Path center,Path out,FileSystem fs,boolean hasKey) throws IOException {
  Path in;
  if (fs.isFile(txtIn)) {
    in=new Path(txtIn.getParent(),"textinput/in.seq");
  }
 else {
    in=new Path(txtIn,"textinput/in.seq");
  }
  if (fs.exists(out))   fs.delete(out,true);
  if (fs.exists(center))   fs.delete(center,true);
  if (fs.exists(in))   fs.delete(in,true);
  final NullWritable value=NullWritable.get();
  Writer centerWriter=new SequenceFile.Writer(fs,conf,center,VectorWritable.class,NullWritable.class);
  final SequenceFile.Writer dataWriter=SequenceFile.createWriter(fs,conf,in,VectorWritable.class,NullWritable.class,CompressionType.NONE);
  int i=0;
  BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(txtIn)));
  String line;
  while ((line=br.readLine()) != null) {
    String[] split=line.split("\t");
    int columnLength=split.length;
    int indexPos=0;
    if (hasKey) {
      columnLength=columnLength - 1;
      indexPos++;
    }
    DenseDoubleVector vec=new DenseDoubleVector(columnLength);
    for (int j=0; j < columnLength; j++) {
      vec.set(j,Double.parseDouble(split[j + indexPos]));
    }
    VectorWritable vector;
    if (hasKey) {
      NamedDoubleVector named=new NamedDoubleVector(split[0],vec);
      vector=new VectorWritable(named);
    }
 else {
      vector=new VectorWritable(vec);
    }
    dataWriter.append(vector,value);
    if (k > i) {
      centerWriter.append(vector,value);
    }
    i++;
  }
  br.close();
  centerWriter.close();
  dataWriter.close();
  return in;
}

ID 536=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#prepareInputText(int, Configuration, Path, Path, Path, FileSystem, boolean)
Rmethod: java.lang.Double#parseDouble(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Reads input text files and writes it to a sequencefile.
 * @param k
 * @param conf
 * @param txtIn
 * @param center
 * @param out
 * @param fs
 * @param hasKey true if first column is required to be the key.
 * @return the path of a sequencefile.
 * @throws IOException
 */

catch: 
null
block: 
KMeansBSP
/** 
 * Reads input text files and writes it to a sequencefile.
 * @param k
 * @param conf
 * @param txtIn
 * @param center
 * @param out
 * @param fs
 * @param hasKey true if first column is required to be the key.
 * @return the path of a sequencefile.
 * @throws IOException
 */
public static Path prepareInputText(int k,Configuration conf,Path txtIn,Path center,Path out,FileSystem fs,boolean hasKey) throws IOException {
  Path in;
  if (fs.isFile(txtIn)) {
    in=new Path(txtIn.getParent(),"textinput/in.seq");
  }
 else {
    in=new Path(txtIn,"textinput/in.seq");
  }
  if (fs.exists(out))   fs.delete(out,true);
  if (fs.exists(center))   fs.delete(center,true);
  if (fs.exists(in))   fs.delete(in,true);
  final NullWritable value=NullWritable.get();
  Writer centerWriter=new SequenceFile.Writer(fs,conf,center,VectorWritable.class,NullWritable.class);
  final SequenceFile.Writer dataWriter=SequenceFile.createWriter(fs,conf,in,VectorWritable.class,NullWritable.class,CompressionType.NONE);
  int i=0;
  BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(txtIn)));
  String line;
  while ((line=br.readLine()) != null) {
    String[] split=line.split("\t");
    int columnLength=split.length;
    int indexPos=0;
    if (hasKey) {
      columnLength=columnLength - 1;
      indexPos++;
    }
    DenseDoubleVector vec=new DenseDoubleVector(columnLength);
    for (int j=0; j < columnLength; j++) {
      vec.set(j,Double.parseDouble(split[j + indexPos]));
    }
    VectorWritable vector;
    if (hasKey) {
      NamedDoubleVector named=new NamedDoubleVector(split[0],vec);
      vector=new VectorWritable(named);
    }
 else {
      vector=new VectorWritable(vec);
    }
    dataWriter.append(vector,value);
    if (k > i) {
      centerWriter.append(vector,value);
    }
    i++;
  }
  br.close();
  centerWriter.close();
  dataWriter.close();
  return in;
}

ID 537=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.KMeansBSP#prepareInputText(int, Configuration, Path, Path, Path, FileSystem, boolean)
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Reads input text files and writes it to a sequencefile.
 * @param k
 * @param conf
 * @param txtIn
 * @param center
 * @param out
 * @param fs
 * @param hasKey true if first column is required to be the key.
 * @return the path of a sequencefile.
 * @throws IOException
 */

catch: 
null
block: 
KMeansBSP
/** 
 * Reads input text files and writes it to a sequencefile.
 * @param k
 * @param conf
 * @param txtIn
 * @param center
 * @param out
 * @param fs
 * @param hasKey true if first column is required to be the key.
 * @return the path of a sequencefile.
 * @throws IOException
 */
public static Path prepareInputText(int k,Configuration conf,Path txtIn,Path center,Path out,FileSystem fs,boolean hasKey) throws IOException {
  Path in;
  if (fs.isFile(txtIn)) {
    in=new Path(txtIn.getParent(),"textinput/in.seq");
  }
 else {
    in=new Path(txtIn,"textinput/in.seq");
  }
  if (fs.exists(out))   fs.delete(out,true);
  if (fs.exists(center))   fs.delete(center,true);
  if (fs.exists(in))   fs.delete(in,true);
  final NullWritable value=NullWritable.get();
  Writer centerWriter=new SequenceFile.Writer(fs,conf,center,VectorWritable.class,NullWritable.class);
  final SequenceFile.Writer dataWriter=SequenceFile.createWriter(fs,conf,in,VectorWritable.class,NullWritable.class,CompressionType.NONE);
  int i=0;
  BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(txtIn)));
  String line;
  while ((line=br.readLine()) != null) {
    String[] split=line.split("\t");
    int columnLength=split.length;
    int indexPos=0;
    if (hasKey) {
      columnLength=columnLength - 1;
      indexPos++;
    }
    DenseDoubleVector vec=new DenseDoubleVector(columnLength);
    for (int j=0; j < columnLength; j++) {
      vec.set(j,Double.parseDouble(split[j + indexPos]));
    }
    VectorWritable vector;
    if (hasKey) {
      NamedDoubleVector named=new NamedDoubleVector(split[0],vec);
      vector=new VectorWritable(named);
    }
 else {
      vector=new VectorWritable(vec);
    }
    dataWriter.append(vector,value);
    if (k > i) {
      centerWriter.append(vector,value);
    }
    i++;
  }
  br.close();
  centerWriter.close();
  dataWriter.close();
  return in;
}

ID 538=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordReader#LineRecordReader(Configuration, FileSplit)
Rmethod: org.apache.hama.bsp.LineReader#LineReader(java.io.InputStream, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
LineRecordReader
public LineRecordReader(Configuration job,FileSplit split) throws IOException {
  this.maxLineLength=job.getInt("bsp.linerecordreader.maxlength",Integer.MAX_VALUE);
  start=split.getStart();
  end=start + split.getLength();
  final Path file=split.getPath();
  compressionCodecs=new CompressionCodecFactory(job);
  final CompressionCodec codec=compressionCodecs.getCodec(file);
  FileSystem fs=file.getFileSystem(job);
  FSDataInputStream fileIn=fs.open(split.getPath());
  boolean skipFirstLine=false;
  if (codec != null) {
    in=new LineReader(codec.createInputStream(fileIn),job);
    end=Long.MAX_VALUE;
  }
 else {
    if (start != 0) {
      skipFirstLine=true;
      --start;
      fileIn.seek(start);
    }
    in=new LineReader(fileIn,job);
  }
  if (skipFirstLine) {
    start+=in.readLine(new Text(),0,(int)Math.min(Integer.MAX_VALUE,end - start));
  }
  this.pos=start;
}

ID 539=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordReader#LineRecordReader(java.io.InputStream, long, long, Configuration)
Rmethod: org.apache.hama.bsp.LineReader#LineReader(java.io.InputStream, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
LineRecordReader
public LineRecordReader(InputStream in,long offset,long endOffset,Configuration job) throws IOException {
  this.maxLineLength=job.getInt("bsp.linerecordreader.maxlength",Integer.MAX_VALUE);
  this.in=new LineReader(in,job);
  this.start=offset;
  this.pos=offset;
  this.end=endOffset;
}

ID 540=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LocalBSPRunner#submitJob(BSPJobID, java.lang.String)
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
LocalBSPRunner
@Override public JobStatus submitJob(BSPJobID jobID,String jobFile) throws IOException {
  this.jobFile=jobFile;
  if (fs == null) {
    this.fs=FileSystem.get(conf);
  }
  conf.addResource(fs.open(new Path(jobFile)));
  conf.setClass(MessageManagerFactory.MESSAGE_MANAGER_CLASS,LocalMessageManager.class,MessageManager.class);
  conf.setClass(SyncServiceFactory.SYNC_CLIENT_CLASS,LocalSyncClient.class,SyncClient.class);
  BSPJob job=new BSPJob(new HamaConfiguration(conf),jobID);
  currentJobStatus=new JobStatus(jobID,System.getProperty("user.name"),0L,JobStatus.RUNNING,globalCounters);
  int numBspTask=job.getNumBspTask();
  String jobSplit=conf.get("bsp.job.split.file");
  BSPJobClient.RawSplit[] splits=null;
  if (jobSplit != null) {
    DataInputStream splitFile=fs.open(new Path(jobSplit));
    try {
      splits=BSPJobClient.readSplitFile(splitFile);
    }
  finally {
      splitFile.close();
    }
  }
  threadPool=(ThreadPoolExecutor)Executors.newFixedThreadPool(numBspTask);
  @SuppressWarnings("rawtypes") ExecutorCompletionService<BSPPeerImpl> completionService=new ExecutorCompletionService<BSPPeerImpl>(threadPool);
  peerNames=new String[numBspTask];
  for (int i=0; i < numBspTask; i++) {
    peerNames[i]="local:" + i;
    completionService.submit(new BSPRunner(new HamaConfiguration(conf),job,i,splits));
    globalCounters.incrCounter(JobInProgress.JobCounter.LAUNCHED_TASKS,1L);
  }
  new Thread(new ThreadObserver(numBspTask,completionService)).start();
  return currentJobStatus;
}

ID 541=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BSPRunner#call()
Rmethod: org.apache.hama.bsp.BSPRunner#run()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BSPRunner
@Override public BSPPeerImpl call() throws Exception {
  run();
  return peer;
}

ID 542=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LocalSyncClient#enterBarrier(BSPJobID, TaskAttemptID, long)
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new SyncException(e.toString());
}

block: 
LocalSyncClient
@Override public void enterBarrier(BSPJobID jobId,TaskAttemptID taskId,long superstep) throws SyncException {
  try {
    barrier.await();
  }
 catch (  Exception e) {
    throw new SyncException(e.toString());
  }
}

ID 543=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LocalSyncClient#enterBarrier(BSPJobID, TaskAttemptID, long)
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.BrokenBarrierException
exception comment: /** 
 * Exception thrown when a thread tries to wait upon a barrier that is in a broken state, or which enters the broken state while the thread is waiting.
 * @see CyclicBarrier
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (Exception e) {
  throw new SyncException(e.toString());
}

block: 
LocalSyncClient
@Override public void enterBarrier(BSPJobID jobId,TaskAttemptID taskId,long superstep) throws SyncException {
  try {
    barrier.await();
  }
 catch (  Exception e) {
    throw new SyncException(e.toString());
  }
}

ID 544=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LocalSyncClient#leaveBarrier(BSPJobID, TaskAttemptID, long)
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new SyncException(e.toString());
}

block: 
LocalSyncClient
@Override public void leaveBarrier(BSPJobID jobId,TaskAttemptID taskId,long superstep) throws SyncException {
  try {
    barrier.await();
  }
 catch (  Exception e) {
    throw new SyncException(e.toString());
  }
  if (superstep > superStepCount)   superStepCount=superstep;
}

ID 545=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LocalSyncClient#leaveBarrier(BSPJobID, TaskAttemptID, long)
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.BrokenBarrierException
exception comment: /** 
 * Exception thrown when a thread tries to wait upon a barrier that is in a broken state, or which enters the broken state while the thread is waiting.
 * @see CyclicBarrier
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (Exception e) {
  throw new SyncException(e.toString());
}

block: 
LocalSyncClient
@Override public void leaveBarrier(BSPJobID jobId,TaskAttemptID taskId,long superstep) throws SyncException {
  try {
    barrier.await();
  }
 catch (  Exception e) {
    throw new SyncException(e.toString());
  }
  if (superstep > superStepCount)   superStepCount=superstep;
}

ID 546=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */

catch: 
catch (Exception e) {
  response.reset();
  response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
}

block: 
LogView
/** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */
public static void downloadFile(HttpServletResponse response,String filePath) throws ServletException, IOException {
  File file=new File(filePath);
  if (!file.exists()) {
    throw new ServletException("File doesn't exists.");
  }
  String headerKey="Content-Disposition";
  String headerValue="attachment; filename=\"" + file.getName() + "\"";
  BufferedInputStream in=null;
  BufferedOutputStream out=null;
  try {
    response.setContentType("application/octet-stream");
    response.setContentLength((int)file.length());
    response.setHeader(headerKey,headerValue);
    in=new BufferedInputStream(new FileInputStream(file));
    out=new BufferedOutputStream(response.getOutputStream());
    byte[] buffer=new byte[4 * 1024];
    int read=-1;
    while ((read=in.read(buffer)) != -1) {
      out.write(buffer,0,read);
    }
  }
 catch (  SocketException e) {
  }
catch (  Exception e) {
    response.reset();
    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
  }
 finally {
    if (in != null) {
      in.close();
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}

ID 547=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
Rmethod: java.io.FilterInputStream#read(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */

catch: 
catch (Exception e) {
  response.reset();
  response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
}

block: 
LogView
/** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */
public static void downloadFile(HttpServletResponse response,String filePath) throws ServletException, IOException {
  File file=new File(filePath);
  if (!file.exists()) {
    throw new ServletException("File doesn't exists.");
  }
  String headerKey="Content-Disposition";
  String headerValue="attachment; filename=\"" + file.getName() + "\"";
  BufferedInputStream in=null;
  BufferedOutputStream out=null;
  try {
    response.setContentType("application/octet-stream");
    response.setContentLength((int)file.length());
    response.setHeader(headerKey,headerValue);
    in=new BufferedInputStream(new FileInputStream(file));
    out=new BufferedOutputStream(response.getOutputStream());
    byte[] buffer=new byte[4 * 1024];
    int read=-1;
    while ((read=in.read(buffer)) != -1) {
      out.write(buffer,0,read);
    }
  }
 catch (  SocketException e) {
  }
catch (  Exception e) {
    response.reset();
    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
  }
 finally {
    if (in != null) {
      in.close();
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}

ID 548=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
Rmethod: java.io.BufferedOutputStream#write(byte[], int, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */

catch: 
catch (Exception e) {
  response.reset();
  response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
}

block: 
LogView
/** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */
public static void downloadFile(HttpServletResponse response,String filePath) throws ServletException, IOException {
  File file=new File(filePath);
  if (!file.exists()) {
    throw new ServletException("File doesn't exists.");
  }
  String headerKey="Content-Disposition";
  String headerValue="attachment; filename=\"" + file.getName() + "\"";
  BufferedInputStream in=null;
  BufferedOutputStream out=null;
  try {
    response.setContentType("application/octet-stream");
    response.setContentLength((int)file.length());
    response.setHeader(headerKey,headerValue);
    in=new BufferedInputStream(new FileInputStream(file));
    out=new BufferedOutputStream(response.getOutputStream());
    byte[] buffer=new byte[4 * 1024];
    int read=-1;
    while ((read=in.read(buffer)) != -1) {
      out.write(buffer,0,read);
    }
  }
 catch (  SocketException e) {
  }
catch (  Exception e) {
    response.reset();
    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
  }
 finally {
    if (in != null) {
      in.close();
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}

ID 549=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
Rmethod: java.io.BufferedInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */

catch: 
catch (Exception e) {
  response.reset();
  response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
}

block: 
LogView
/** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */
public static void downloadFile(HttpServletResponse response,String filePath) throws ServletException, IOException {
  File file=new File(filePath);
  if (!file.exists()) {
    throw new ServletException("File doesn't exists.");
  }
  String headerKey="Content-Disposition";
  String headerValue="attachment; filename=\"" + file.getName() + "\"";
  BufferedInputStream in=null;
  BufferedOutputStream out=null;
  try {
    response.setContentType("application/octet-stream");
    response.setContentLength((int)file.length());
    response.setHeader(headerKey,headerValue);
    in=new BufferedInputStream(new FileInputStream(file));
    out=new BufferedOutputStream(response.getOutputStream());
    byte[] buffer=new byte[4 * 1024];
    int read=-1;
    while ((read=in.read(buffer)) != -1) {
      out.write(buffer,0,read);
    }
  }
 catch (  SocketException e) {
  }
catch (  Exception e) {
    response.reset();
    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
  }
 finally {
    if (in != null) {
      in.close();
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}

ID 550=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
Rmethod: java.io.BufferedOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */

catch: 
catch (Exception e) {
  response.reset();
  response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
}

block: 
LogView
/** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */
public static void downloadFile(HttpServletResponse response,String filePath) throws ServletException, IOException {
  File file=new File(filePath);
  if (!file.exists()) {
    throw new ServletException("File doesn't exists.");
  }
  String headerKey="Content-Disposition";
  String headerValue="attachment; filename=\"" + file.getName() + "\"";
  BufferedInputStream in=null;
  BufferedOutputStream out=null;
  try {
    response.setContentType("application/octet-stream");
    response.setContentLength((int)file.length());
    response.setHeader(headerKey,headerValue);
    in=new BufferedInputStream(new FileInputStream(file));
    out=new BufferedOutputStream(response.getOutputStream());
    byte[] buffer=new byte[4 * 1024];
    int read=-1;
    while ((read=in.read(buffer)) != -1) {
      out.write(buffer,0,read);
    }
  }
 catch (  SocketException e) {
  }
catch (  Exception e) {
    response.reset();
    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
  }
 finally {
    if (in != null) {
      in.close();
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}

ID 551=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */

catch: 
catch (Exception e) {
  response.reset();
  response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
}

block: 
LogView
/** 
 * download log file.
 * @param filPath log file path.
 * @throws Exception
 */
public static void downloadFile(HttpServletResponse response,String filePath) throws ServletException, IOException {
  File file=new File(filePath);
  if (!file.exists()) {
    throw new ServletException("File doesn't exists.");
  }
  String headerKey="Content-Disposition";
  String headerValue="attachment; filename=\"" + file.getName() + "\"";
  BufferedInputStream in=null;
  BufferedOutputStream out=null;
  try {
    response.setContentType("application/octet-stream");
    response.setContentLength((int)file.length());
    response.setHeader(headerKey,headerValue);
    in=new BufferedInputStream(new FileInputStream(file));
    out=new BufferedOutputStream(response.getOutputStream());
    byte[] buffer=new byte[4 * 1024];
    int read=-1;
    while ((read=in.read(buffer)) != -1) {
      out.write(buffer,0,read);
    }
  }
 catch (  SocketException e) {
  }
catch (  Exception e) {
    response.reset();
    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,e.toString());
  }
 finally {
    if (in != null) {
      in.close();
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}

ID 552=========================================================================type: only_throws
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.manager.ServletException
exception comment: null
method comment: null
catch: 
null
block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 553=========================================================================type: only_throws
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: org.apache.hama.manager.LogView#downloadFile(HttpServletResponse, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 554=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.io.FileReader#FileReader(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 555=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 556=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 557=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.lang.Runtime#exec(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 558=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.io.InputStreamReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 559=========================================================================type: Recover
package: org.apache.hama.manager
Method:org.apache.hama.manager.Servlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.io.InputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
Servlet
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  final String targetUri=request.getRequestURI();
  String dirName=request.getParameter("dir");
  String fileName=request.getParameter("file");
  String pageType=request.getParameter("type");
  pageType=(pageType == null) ? "list" : pageType;
  dirName=(dirName == null) ? "" : dirName;
  String hamaLogDir=getLogHomeDir();
  String logDirPath;
  if (dirName == "") {
    logDirPath=hamaLogDir;
  }
 else {
    dirName=dirName.replaceAll("\\.\\.[/]|\\.\\.[//]|\\.\\.","");
    logDirPath=hamaLogDir + "/" + dirName;
  }
  String logfilePath=logDirPath + "/" + fileName;
  if (pageType.equals("download")) {
    LogView.downloadFile(response,logfilePath);
  }
 else {
    response.setContentType("text/html");
    PrintWriter out=response.getWriter();
    UITemplate uit=new UITemplate();
    String tplPath="webapp/commons/tpl/";
    String tplfile=uit.load(tplPath + "tpl.logview.html");
    HashMap<String,String> vars=new HashMap<String,String>();
    String tplHead=uit.getArea(tplfile,"head");
    String tplTail=uit.getArea(tplfile,"tail");
    vars.put("title","logview");
    vars.put("hamaLogDir",hamaLogDir);
    out.println(uit.convert(tplHead,vars));
    vars.clear();
    if (pageType.equals("list")) {
      String[] listArea=new String[4];
      listArea[0]=uit.getArea(tplfile,"list0");
      listArea[1]=uit.getArea(tplfile,"list1");
      listArea[2]=uit.getArea(tplfile,"list2");
      listArea[3]=uit.getArea(tplfile,"list3");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      List<File> arrayList=LogView.getLogFileList(logDirPath);
      File file;
      for (int i=0; i < arrayList.size(); i++) {
        file=arrayList.get(i);
        vars.put("dirName",dirName);
        vars.put("fileName",file.getName());
        vars.put("fileLastModified",new Date(file.lastModified()).toString());
        vars.put("targetUri",targetUri);
        if (file.isDirectory()) {
          vars.put("type","dir");
          out.println(uit.convert(listArea[1],vars));
        }
 else {
          vars.put("fileLength",LogView.convertFileSize(file.length()));
          vars.put("type","file");
          out.println(uit.convert(listArea[2],vars));
        }
      }
      vars.clear();
      out.println(uit.convert(listArea[3],vars));
    }
 else     if (pageType.equals("detail")) {
      String[] detailArea=new String[4];
      detailArea[0]=uit.getArea(tplfile,"detail0");
      detailArea[1]=uit.getArea(tplfile,"detail1");
      detailArea[2]=uit.getArea(tplfile,"detail2");
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(detailArea[0],vars));
      BufferedReader br=null;
      String logLine;
      try {
        br=new BufferedReader(new FileReader(logfilePath));
        while ((logLine=br.readLine()) != null) {
          vars.put("logLine",logLine);
          out.println(uit.convert(detailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
      }
      out.println(uit.convert(detailArea[2],vars));
    }
 else     if (pageType.equals("tail")) {
      String tailLine=request.getParameter("tailLine");
      tailLine=(tailLine == null) ? "100" : tailLine;
      String[] tailArea=new String[3];
      tailArea[0]=uit.getArea(tplfile,"logtail0");
      tailArea[1]=uit.getArea(tplfile,"logtail1");
      tailArea[2]=uit.getArea(tplfile,"logtail2");
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("fileName",fileName);
      vars.put("tailLine",tailLine);
      vars.put("pageType",pageType);
      vars.put("targetUri",targetUri);
      out.println(uit.convert(tailArea[0],vars));
      vars.clear();
      InputStream is=null;
      InputStreamReader isr=null;
      BufferedReader br=null;
      try {
        String tailcmd="tail -" + tailLine + "  "+ logfilePath;
        Runtime runtime=Runtime.getRuntime();
        Process process=runtime.exec(tailcmd);
        is=process.getInputStream();
        isr=new InputStreamReader(is);
        br=new BufferedReader(isr);
        String eachLine="";
        int lineNum=0;
        while ((eachLine=br.readLine()) != null) {
          vars.put("lineNum",Integer.toString(++lineNum));
          vars.put("logLine",eachLine);
          out.println(uit.convert(tailArea[1],vars));
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
 finally {
        if (br != null) {
          br.close();
        }
        if (isr != null) {
          isr.close();
        }
        if (is != null) {
          is.close();
        }
      }
      vars.clear();
      out.println(uit.convert(tailArea[2],vars));
    }
 else     if (pageType.equals("tasklist")) {
      String jobId=request.getParameter("jobId");
      String[] listArea=new String[3];
      listArea[0]=uit.getArea(tplfile,"tasklist0");
      listArea[1]=uit.getArea(tplfile,"tasklist1");
      listArea[2]=uit.getArea(tplfile,"tasklist2");
      ServletContext ctx=getServletContext();
      BSPMaster tracker=(BSPMaster)ctx.getAttribute("bsp.master");
      ClusterStatus status=tracker.getClusterStatus(true);
      JobStatus jobStatus=tracker.getJobStatus(BSPJobID.forName(jobId));
      vars.put("hamaLogDir",hamaLogDir);
      vars.put("dirName",dirName);
      vars.put("targetUri",targetUri);
      vars.put("jobId",jobId);
      vars.put("jobStatus",jobStatus.getState().toString());
      vars.put("jobName",jobStatus.getName());
      out.println(uit.convert(listArea[0],vars));
      vars.clear();
      for (      Entry<String,GroomServerStatus> entry : status.getActiveGroomServerStatus().entrySet()) {
        vars.put("jobId",jobId);
        vars.put("dirName",dirName);
        vars.put("serverName",entry.getKey());
        vars.put("hostName",entry.getValue().getGroomHostName());
        vars.put("targetUri",targetUri);
        vars.put("type","dir");
        out.println(uit.convert(listArea[1],vars));
      }
      vars.clear();
      out.println(uit.convert(listArea[2],vars));
    }
    out.println(tplTail);
  }
}

ID 560=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.MapVerticesInfo#put(Vertex<V,E,M>)
Rmethod: org.apache.hama.graph.MapVerticesInfo#get(V)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MapVerticesInfo
@Override public void put(Vertex<V,E,M> vertex) throws IOException {
  if (!vertices.containsKey(vertex.getVertexID())) {
    if (!conf.getBoolean("hama.use.unsafeserialization",false)) {
      vertices.putIfAbsent(vertex.getVertexID(),WritableUtils.serialize(vertex));
    }
 else {
      vertices.putIfAbsent(vertex.getVertexID(),WritableUtils.unsafeSerialize(vertex));
    }
  }
 else {
    Vertex<V,E,M> v=this.get(vertex.getVertexID());
    for (    Edge<V,E> e : vertex.getEdges()) {
      v.addEdge(e);
    }
    if (!conf.getBoolean("hama.use.unsafeserialization",false)) {
      vertices.put(vertex.getVertexID(),WritableUtils.serialize(v));
    }
 else {
      vertices.put(vertex.getVertexID(),WritableUtils.unsafeSerialize(v));
    }
  }
}

ID 561=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.MatrixWritable#readFields(java.io.DataInput)
Rmethod: org.apache.hama.commons.io.MatrixWritable#read(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MatrixWritable
@Override public void readFields(DataInput in) throws IOException {
  mat=read(in);
}

ID 562=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.MatrixWritable#write(java.io.DataOutput)
Rmethod: org.apache.hama.commons.io.MatrixWritable#write(DoubleMatrix, java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MatrixWritable
@Override public void write(DataOutput out) throws IOException {
  write(mat,out);
}

ID 563=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.MatrixWritable#write(DoubleMatrix, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MatrixWritable
public static void write(DoubleMatrix mat,DataOutput out) throws IOException {
  out.writeInt(mat.getRowCount());
  out.writeInt(mat.getColumnCount());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      out.writeDouble(mat.get(row,col));
    }
  }
}

ID 564=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.MatrixWritable#write(DoubleMatrix, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeDouble(double)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MatrixWritable
public static void write(DoubleMatrix mat,DataOutput out) throws IOException {
  out.writeInt(mat.getRowCount());
  out.writeInt(mat.getColumnCount());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      out.writeDouble(mat.get(row,col));
    }
  }
}

ID 565=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.MatrixWritable#read(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MatrixWritable
public static DoubleMatrix read(DataInput in) throws IOException {
  DoubleMatrix mat=new DenseDoubleMatrix(in.readInt(),in.readInt());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      mat.set(row,col,in.readDouble());
    }
  }
  return mat;
}

ID 566=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.MatrixWritable#read(java.io.DataInput)
Rmethod: java.io.DataInput#readDouble()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MatrixWritable
public static DoubleMatrix read(DataInput in) throws IOException {
  DoubleMatrix mat=new DenseDoubleMatrix(in.readInt(),in.readInt());
  for (int row=0; row < mat.getRowCount(); row++) {
    for (int col=0; col < mat.getColumnCount(); col++) {
      mat.set(row,col,in.readDouble());
    }
  }
  return mat;
}

ID 567=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.MesosExecutor#launchTask(ExecutorDriver, TaskInfo)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.error("Failed to sleep TaskTracker thread",e);
}

block: 
MesosExecutor
@Override public void launchTask(final ExecutorDriver driver,final TaskInfo task){
  LOG.info("Launching task : " + task.getTaskId().getValue());
  HamaConfiguration conf=configure(task);
  Thread.currentThread().setContextClassLoader(FileSystem.class.getClassLoader());
  try {
    groomServer=new GroomServer(conf);
  }
 catch (  IOException e) {
    LOG.fatal("Failed to start GroomServer",e);
    System.exit(1);
  }
  new Thread("GroomServer Run Thread"){
    @Override public void run(){
      try {
        groomServer.run();
        driver.sendStatusUpdate(TaskStatus.newBuilder().setTaskId(task.getTaskId()).setState(TaskState.TASK_FINISHED).build());
        try {
          Thread.sleep(2000);
        }
 catch (        InterruptedException e) {
          LOG.error("Failed to sleep TaskTracker thread",e);
        }
        driver.stop();
      }
 catch (      Throwable t) {
        LOG.error("Caught exception, committing suicide.",t);
        driver.stop();
        System.exit(1);
      }
    }
  }
.start();
  driver.sendStatusUpdate(TaskStatus.newBuilder().setTaskId(task.getTaskId()).setState(TaskState.TASK_RUNNING).build());
}

ID 568=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp#run()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.error("Failed to sleep TaskTracker thread",e);
}

block: 

@Override public void run(){
  try {
    groomServer.run();
    driver.sendStatusUpdate(TaskStatus.newBuilder().setTaskId(task.getTaskId()).setState(TaskState.TASK_FINISHED).build());
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException e) {
      LOG.error("Failed to sleep TaskTracker thread",e);
    }
    driver.stop();
  }
 catch (  Throwable t) {
    LOG.error("Caught exception, committing suicide.",t);
    driver.stop();
    System.exit(1);
  }
}

ID 569=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.MindistSearch#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MindistSearch
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length < 2)   printUsage();
  Optional<Integer> absent=Optional.absent();
  GraphJob job=getJob(args[0],args[1],args.length >= 3 ? Optional.of(Integer.parseInt(args[3])) : absent,args.length >= 4 ? Optional.of(Integer.parseInt(args[4])) : absent);
  long startTime=System.currentTimeMillis();
  if (job.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 570=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.MindistSearch#main(java.lang.String[])
Rmethod: org.apache.hama.examples.MindistSearch#getJob(java.lang.String, java.lang.String, Optional<java.lang.Integer>, Optional<java.lang.Integer>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MindistSearch
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length < 2)   printUsage();
  Optional<Integer> absent=Optional.absent();
  GraphJob job=getJob(args[0],args[1],args.length >= 3 ? Optional.of(Integer.parseInt(args[3])) : absent,args.length >= 4 ? Optional.of(Integer.parseInt(args[4])) : absent);
  long startTime=System.currentTimeMillis();
  if (job.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 571=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.MindistSearchTest#testMindistSearch()
Rmethod: org.apache.hama.examples.MindistSearchTest#verifyResult()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MindistSearchTest
public void testMindistSearch() throws Exception {
  generateTestData();
  try {
    GraphJob job=MindistSearch.getJob(INPUT,OUTPUT,Optional.of(3),Optional.of(30));
    job.setInputFormat(SequenceFileInputFormat.class);
    job.setInputKeyClass(LongWritable.class);
    job.setInputValueClass(Text.class);
    assertTrue(job.waitForCompletion(true));
    verifyResult();
  }
  finally {
    deleteTempDirs();
  }
}

ID 572=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.MindistSearchTest#verifyResult()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MindistSearchTest
private void verifyResult() throws IOException {
  FileStatus[] globStatus=fs.globStatus(new Path(OUTPUT + "/part-*"));
  int itemsRead=0;
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line=null;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      System.out.println(split[0] + " | " + split[1]);
      assertEquals(resultList[Integer.parseInt(split[0])],split[1]);
      itemsRead++;
    }
  }
  assertEquals(resultList.length,itemsRead);
}

ID 573=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.MindistSearchTest#verifyResult()
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MindistSearchTest
private void verifyResult() throws IOException {
  FileStatus[] globStatus=fs.globStatus(new Path(OUTPUT + "/part-*"));
  int itemsRead=0;
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line=null;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      System.out.println(split[0] + " | " + split[1]);
      assertEquals(resultList[Integer.parseInt(split[0])],split[1]);
      itemsRead++;
    }
  }
  assertEquals(resultList.length,itemsRead);
}

ID 574=========================================================================type: Ignore_Log
package: org.apache.hama
Method:org.apache.hama.MiniBSPCluster#startGroomServers()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.error("Fail to check BSP Master's state.",ie);
  Thread.currentThread().interrupt();
}

block: 
MiniBSPCluster
public void startGroomServers(){
  if (null == this.scheduler)   throw new NullPointerException("No ScheduledExecutorService exists.");
  if (null == this.master)   throw new NullPointerException("No BSPMaster exists.");
  int cnt=0;
  while (!this.master.isRunning()) {
    LOG.info("Waiting BSPMaster up.");
    try {
      Thread.sleep(1000);
      cnt++;
      if (100 < cnt) {
        fail("Fail to launch BSPMaster.");
      }
    }
 catch (    InterruptedException ie) {
      LOG.error("Fail to check BSP Master's state.",ie);
      Thread.currentThread().interrupt();
    }
  }
  for (int i=0; i < this.grooms; i++) {
    HamaConfiguration c=new HamaConfiguration(this.configuration);
    randomPort(c);
    GroomServerRunner gsr=new GroomServerRunner(c);
    groomServerList.add(gsr);
    scheduler.schedule(gsr,0,SECONDS);
    cnt=0;
    while (!gsr.isRunning()) {
      LOG.info("Waitin for GroomServer up.");
      try {
        Thread.sleep(1000);
        cnt++;
        if (10 < cnt) {
          fail("Fail to launch groom server.");
        }
      }
 catch (      InterruptedException ie) {
        LOG.error("Fail to check Groom Server's state.",ie);
        Thread.currentThread().interrupt();
      }
    }
  }
}

ID 575=========================================================================type: Ignore_Log
package: org.apache.hama
Method:org.apache.hama.MiniBSPCluster#randomPort(HamaConfiguration)
Rmethod: java.net.ServerSocket#ServerSocket(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Can not find a free port for BSPPeer.",ioe);
}

block: 
MiniBSPCluster
private static void randomPort(HamaConfiguration conf){
  try {
    ServerSocket skt=new ServerSocket(0);
    int p=skt.getLocalPort();
    skt.close();
    conf.set(Constants.PEER_PORT,new Integer(p).toString());
    conf.setInt(Constants.GROOM_RPC_PORT,p + 100);
  }
 catch (  IOException ioe) {
    LOG.error("Can not find a free port for BSPPeer.",ioe);
  }
}

ID 576=========================================================================type: Ignore_Log
package: org.apache.hama
Method:org.apache.hama.MiniBSPCluster#randomPort(HamaConfiguration)
Rmethod: java.net.ServerSocket#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Can not find a free port for BSPPeer.",ioe);
}

block: 
MiniBSPCluster
private static void randomPort(HamaConfiguration conf){
  try {
    ServerSocket skt=new ServerSocket(0);
    int p=skt.getLocalPort();
    skt.close();
    conf.set(Constants.PEER_PORT,new Integer(p).toString());
    conf.setInt(Constants.GROOM_RPC_PORT,p + 100);
  }
 catch (  IOException ioe) {
    LOG.error("Can not find a free port for BSPPeer.",ioe);
  }
}

ID 577=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#startup(java.io.File)
Rmethod: org.apache.hama.MiniZooKeeperCluster#shutdown()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * @param baseDir
 * @return ClientPort server bound to.
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
MiniZooKeeperCluster
/** 
 * @param baseDir
 * @return ClientPort server bound to.
 * @throws IOException
 * @throws InterruptedException
 */
public int startup(File baseDir) throws IOException, InterruptedException {
  setupTestEnv();
  shutdown();
  File dir=new File(baseDir,"zookeeper").getAbsoluteFile();
  recreateDir(dir);
  int tickTimeToUse;
  if (this.tickTime > 0) {
    tickTimeToUse=this.tickTime;
  }
 else {
    tickTimeToUse=TICK_TIME;
  }
  ZooKeeperServer server=new ZooKeeperServer(dir,dir,tickTimeToUse);
  while (true) {
    try {
      standaloneServerFactory=new NIOServerCnxnFactory();
      standaloneServerFactory.configure(new InetSocketAddress(clientPort),CONNECTION_TIMEOUT);
    }
 catch (    BindException e) {
      LOG.info("Faild binding ZK Server to client port: " + clientPort);
      clientPort++;
      continue;
    }
    break;
  }
  standaloneServerFactory.startup(server);
  if (!waitForServerUp(clientPort,CONNECTION_TIMEOUT)) {
    throw new IOException("Waiting for startup of standalone server");
  }
  started=true;
  return clientPort;
}

ID 578=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#startup(java.io.File)
Rmethod: org.apache.hama.MiniZooKeeperCluster#recreateDir(java.io.File)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * @param baseDir
 * @return ClientPort server bound to.
 * @throws IOException
 * @throws InterruptedException
 */

catch: 
null
block: 
MiniZooKeeperCluster
/** 
 * @param baseDir
 * @return ClientPort server bound to.
 * @throws IOException
 * @throws InterruptedException
 */
public int startup(File baseDir) throws IOException, InterruptedException {
  setupTestEnv();
  shutdown();
  File dir=new File(baseDir,"zookeeper").getAbsoluteFile();
  recreateDir(dir);
  int tickTimeToUse;
  if (this.tickTime > 0) {
    tickTimeToUse=this.tickTime;
  }
 else {
    tickTimeToUse=TICK_TIME;
  }
  ZooKeeperServer server=new ZooKeeperServer(dir,dir,tickTimeToUse);
  while (true) {
    try {
      standaloneServerFactory=new NIOServerCnxnFactory();
      standaloneServerFactory.configure(new InetSocketAddress(clientPort),CONNECTION_TIMEOUT);
    }
 catch (    BindException e) {
      LOG.info("Faild binding ZK Server to client port: " + clientPort);
      clientPort++;
      continue;
    }
    break;
  }
  standaloneServerFactory.startup(server);
  if (!waitForServerUp(clientPort,CONNECTION_TIMEOUT)) {
    throw new IOException("Waiting for startup of standalone server");
  }
  started=true;
  return clientPort;
}

ID 579=========================================================================type: Recover
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerDown(int, long)
Rmethod: java.net.Socket#Socket(java.lang.String, int)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.net.UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

method comment: null
catch: 
catch (IOException e) {
  return true;
}

block: 
MiniZooKeeperCluster
private static boolean waitForServerDown(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
      }
  finally {
        sock.close();
      }
    }
 catch (    IOException e) {
      return true;
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 580=========================================================================type: Recover
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerDown(int, long)
Rmethod: java.net.Socket#Socket(java.lang.String, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  return true;
}

block: 
MiniZooKeeperCluster
private static boolean waitForServerDown(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
      }
  finally {
        sock.close();
      }
    }
 catch (    IOException e) {
      return true;
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 581=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerDown(int, long)
Rmethod: java.net.Socket#getOutputStream()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerDown(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
      }
  finally {
        sock.close();
      }
    }
 catch (    IOException e) {
      return true;
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 582=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerDown(int, long)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerDown(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
      }
  finally {
        sock.close();
      }
    }
 catch (    IOException e) {
      return true;
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 583=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerDown(int, long)
Rmethod: java.io.OutputStream#flush()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerDown(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
      }
  finally {
        sock.close();
      }
    }
 catch (    IOException e) {
      return true;
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 584=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerDown(int, long)
Rmethod: java.net.Socket#close()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerDown(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
      }
  finally {
        sock.close();
      }
    }
 catch (    IOException e) {
      return true;
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 585=========================================================================type: Ignore_Log
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerDown(int, long)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
}

block: 
MiniZooKeeperCluster
private static boolean waitForServerDown(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
      }
  finally {
        sock.close();
      }
    }
 catch (    IOException e) {
      return true;
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 586=========================================================================type: Ignore_Log
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.net.Socket#Socket(java.lang.String, int)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.net.UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.info("server localhost:" + port + " not up "+ e);
}

block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 587=========================================================================type: Ignore_Log
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.net.Socket#Socket(java.lang.String, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.info("server localhost:" + port + " not up "+ e);
}

block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 588=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.net.Socket#getOutputStream()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 589=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 590=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.io.OutputStream#flush()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 591=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.net.Socket#getInputStream()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 592=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 593=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.net.Socket#close()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 594=========================================================================type: only_throws
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.io.BufferedReader#close()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 595=========================================================================type: Ignore_Log
package: org.apache.hama
Method:org.apache.hama.MiniZooKeeperCluster#waitForServerUp(int, long)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
}

block: 
MiniZooKeeperCluster
private static boolean waitForServerUp(int port,long timeout){
  long start=System.currentTimeMillis();
  while (true) {
    try {
      Socket sock=new Socket("localhost",port);
      BufferedReader reader=null;
      try {
        OutputStream outstream=sock.getOutputStream();
        outstream.write("stat".getBytes());
        outstream.flush();
        Reader isr=new InputStreamReader(sock.getInputStream());
        reader=new BufferedReader(isr);
        String line=reader.readLine();
        if (line != null && line.startsWith("Zookeeper version:")) {
          return true;
        }
      }
  finally {
        sock.close();
        if (reader != null) {
          reader.close();
        }
      }
    }
 catch (    IOException e) {
      LOG.info("server localhost:" + port + " not up "+ e);
    }
    if (System.currentTimeMillis() > start + timeout) {
      break;
    }
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
    }
  }
  return false;
}

ID 596=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.TaskWorker#call()
Rmethod: org.apache.hama.monitor.Task#run()
hasForStatement: false
parentException: Exception Throwable 
thrown: org.apache.hama.monitor.TaskException
exception comment: null
method comment: null
catch: 
null
block: 
TaskWorker
@Override public Object call() throws Exception {
  return task.run();
}

ID 597=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKHandler#toBytes(java.lang.Number)
Rmethod: java.io.DataOutputStream#writeDouble(double)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Fail writing data to output stream.",ioe);
}

block: 
ZKHandler
static byte[] toBytes(Number value){
  if (value instanceof Byte) {
    return new byte[]{value.byteValue()};
  }
  byte[] bytes=null;
  ByteArrayOutputStream dout=new ByteArrayOutputStream();
  DataOutputStream output=new DataOutputStream(dout);
  try {
    if (value instanceof Double) {
      output.writeDouble(value.doubleValue());
    }
 else     if (value instanceof Float) {
      output.writeFloat(value.floatValue());
    }
 else     if (value instanceof Integer) {
      output.writeInt(value.intValue());
    }
 else     if (value instanceof Short) {
      output.writeShort(value.shortValue());
    }
 else     if (value instanceof Long) {
      output.writeLong(value.longValue());
    }
 else {
      LOG.warn("Unkown data type: " + value);
    }
    bytes=dout.toByteArray();
    if (LOG.isDebugEnabled()) {
      LOG.debug("bytes's length after value (" + value + ") is converted: "+ ((null != bytes) ? bytes.length : 0));
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Fail writing data to output stream.",ioe);
  }
 finally {
    try {
      output.close();
    }
 catch (    IOException ioe) {
      LOG.warn("Fail closing output stream.",ioe);
    }
  }
  return bytes;
}

ID 598=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKHandler#toBytes(java.lang.Number)
Rmethod: java.io.DataOutputStream#writeFloat(float)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Fail writing data to output stream.",ioe);
}

block: 
ZKHandler
static byte[] toBytes(Number value){
  if (value instanceof Byte) {
    return new byte[]{value.byteValue()};
  }
  byte[] bytes=null;
  ByteArrayOutputStream dout=new ByteArrayOutputStream();
  DataOutputStream output=new DataOutputStream(dout);
  try {
    if (value instanceof Double) {
      output.writeDouble(value.doubleValue());
    }
 else     if (value instanceof Float) {
      output.writeFloat(value.floatValue());
    }
 else     if (value instanceof Integer) {
      output.writeInt(value.intValue());
    }
 else     if (value instanceof Short) {
      output.writeShort(value.shortValue());
    }
 else     if (value instanceof Long) {
      output.writeLong(value.longValue());
    }
 else {
      LOG.warn("Unkown data type: " + value);
    }
    bytes=dout.toByteArray();
    if (LOG.isDebugEnabled()) {
      LOG.debug("bytes's length after value (" + value + ") is converted: "+ ((null != bytes) ? bytes.length : 0));
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Fail writing data to output stream.",ioe);
  }
 finally {
    try {
      output.close();
    }
 catch (    IOException ioe) {
      LOG.warn("Fail closing output stream.",ioe);
    }
  }
  return bytes;
}

ID 599=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKHandler#toBytes(java.lang.Number)
Rmethod: java.io.DataOutputStream#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Fail writing data to output stream.",ioe);
}

block: 
ZKHandler
static byte[] toBytes(Number value){
  if (value instanceof Byte) {
    return new byte[]{value.byteValue()};
  }
  byte[] bytes=null;
  ByteArrayOutputStream dout=new ByteArrayOutputStream();
  DataOutputStream output=new DataOutputStream(dout);
  try {
    if (value instanceof Double) {
      output.writeDouble(value.doubleValue());
    }
 else     if (value instanceof Float) {
      output.writeFloat(value.floatValue());
    }
 else     if (value instanceof Integer) {
      output.writeInt(value.intValue());
    }
 else     if (value instanceof Short) {
      output.writeShort(value.shortValue());
    }
 else     if (value instanceof Long) {
      output.writeLong(value.longValue());
    }
 else {
      LOG.warn("Unkown data type: " + value);
    }
    bytes=dout.toByteArray();
    if (LOG.isDebugEnabled()) {
      LOG.debug("bytes's length after value (" + value + ") is converted: "+ ((null != bytes) ? bytes.length : 0));
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Fail writing data to output stream.",ioe);
  }
 finally {
    try {
      output.close();
    }
 catch (    IOException ioe) {
      LOG.warn("Fail closing output stream.",ioe);
    }
  }
  return bytes;
}

ID 600=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKHandler#toBytes(java.lang.Number)
Rmethod: java.io.DataOutputStream#writeShort(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Fail writing data to output stream.",ioe);
}

block: 
ZKHandler
static byte[] toBytes(Number value){
  if (value instanceof Byte) {
    return new byte[]{value.byteValue()};
  }
  byte[] bytes=null;
  ByteArrayOutputStream dout=new ByteArrayOutputStream();
  DataOutputStream output=new DataOutputStream(dout);
  try {
    if (value instanceof Double) {
      output.writeDouble(value.doubleValue());
    }
 else     if (value instanceof Float) {
      output.writeFloat(value.floatValue());
    }
 else     if (value instanceof Integer) {
      output.writeInt(value.intValue());
    }
 else     if (value instanceof Short) {
      output.writeShort(value.shortValue());
    }
 else     if (value instanceof Long) {
      output.writeLong(value.longValue());
    }
 else {
      LOG.warn("Unkown data type: " + value);
    }
    bytes=dout.toByteArray();
    if (LOG.isDebugEnabled()) {
      LOG.debug("bytes's length after value (" + value + ") is converted: "+ ((null != bytes) ? bytes.length : 0));
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Fail writing data to output stream.",ioe);
  }
 finally {
    try {
      output.close();
    }
 catch (    IOException ioe) {
      LOG.warn("Fail closing output stream.",ioe);
    }
  }
  return bytes;
}

ID 601=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKHandler#toBytes(java.lang.Number)
Rmethod: java.io.DataOutputStream#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Fail writing data to output stream.",ioe);
}

block: 
ZKHandler
static byte[] toBytes(Number value){
  if (value instanceof Byte) {
    return new byte[]{value.byteValue()};
  }
  byte[] bytes=null;
  ByteArrayOutputStream dout=new ByteArrayOutputStream();
  DataOutputStream output=new DataOutputStream(dout);
  try {
    if (value instanceof Double) {
      output.writeDouble(value.doubleValue());
    }
 else     if (value instanceof Float) {
      output.writeFloat(value.floatValue());
    }
 else     if (value instanceof Integer) {
      output.writeInt(value.intValue());
    }
 else     if (value instanceof Short) {
      output.writeShort(value.shortValue());
    }
 else     if (value instanceof Long) {
      output.writeLong(value.longValue());
    }
 else {
      LOG.warn("Unkown data type: " + value);
    }
    bytes=dout.toByteArray();
    if (LOG.isDebugEnabled()) {
      LOG.debug("bytes's length after value (" + value + ") is converted: "+ ((null != bytes) ? bytes.length : 0));
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Fail writing data to output stream.",ioe);
  }
 finally {
    try {
      output.close();
    }
 catch (    IOException ioe) {
      LOG.warn("Fail closing output stream.",ioe);
    }
  }
  return bytes;
}

ID 602=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKHandler#toBytes(java.lang.Number)
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.warn("Fail closing output stream.",ioe);
}

block: 
ZKHandler
static byte[] toBytes(Number value){
  if (value instanceof Byte) {
    return new byte[]{value.byteValue()};
  }
  byte[] bytes=null;
  ByteArrayOutputStream dout=new ByteArrayOutputStream();
  DataOutputStream output=new DataOutputStream(dout);
  try {
    if (value instanceof Double) {
      output.writeDouble(value.doubleValue());
    }
 else     if (value instanceof Float) {
      output.writeFloat(value.floatValue());
    }
 else     if (value instanceof Integer) {
      output.writeInt(value.intValue());
    }
 else     if (value instanceof Short) {
      output.writeShort(value.shortValue());
    }
 else     if (value instanceof Long) {
      output.writeLong(value.longValue());
    }
 else {
      LOG.warn("Unkown data type: " + value);
    }
    bytes=dout.toByteArray();
    if (LOG.isDebugEnabled()) {
      LOG.debug("bytes's length after value (" + value + ") is converted: "+ ((null != bytes) ? bytes.length : 0));
    }
  }
 catch (  IOException ioe) {
    LOG.warn("Fail writing data to output stream.",ioe);
  }
 finally {
    try {
      output.close();
    }
 catch (    IOException ioe) {
      LOG.warn("Fail closing output stream.",ioe);
    }
  }
  return bytes;
}

ID 603=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Publisher#run()
Rmethod: java.util.concurrent.BlockingQueue#take()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  pool.shutdown();
  LOG.warn("Publisher is interrupted.",ie);
  Thread.currentThread().interrupt();
}

block: 
Publisher
@Override public void run(){
  try {
    while (!Thread.interrupted()) {
      final Result result=results.take();
      pool.submit(new Callable<Object>(){
        @Override public Object call() throws Exception {
          for (          Destination dest : result.destinations()) {
            Publisher.this.get(dest).handle(result);
          }
          return null;
        }
      }
);
      int period=conf.getInt("bsp.monitor.publisher.period",5);
      Thread.sleep(period * 1000);
    }
  }
 catch (  InterruptedException ie) {
    pool.shutdown();
    LOG.warn("Publisher is interrupted.",ie);
    Thread.currentThread().interrupt();
  }
}

ID 604=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Publisher#run()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  pool.shutdown();
  LOG.warn("Publisher is interrupted.",ie);
  Thread.currentThread().interrupt();
}

block: 
Publisher
@Override public void run(){
  try {
    while (!Thread.interrupted()) {
      final Result result=results.take();
      pool.submit(new Callable<Object>(){
        @Override public Object call() throws Exception {
          for (          Destination dest : result.destinations()) {
            Publisher.this.get(dest).handle(result);
          }
          return null;
        }
      }
);
      int period=conf.getInt("bsp.monitor.publisher.period",5);
      Thread.sleep(period * 1000);
    }
  }
 catch (  InterruptedException ie) {
    pool.shutdown();
    LOG.warn("Publisher is interrupted.",ie);
    Thread.currentThread().interrupt();
  }
}

ID 605=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Collector#run()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  pool.shutdown();
  LOG.warn(this.getClass().getSimpleName() + " is interrupted.",ie);
  Thread.currentThread().interrupt();
}

block: 
Collector
@Override public void run(){
  try {
    Thread.currentThread();
    while (!Thread.interrupted()) {
      LOG.debug("How many workers will be executed by collector? " + workers.size());
      for (      TaskWorker worker : workers.values()) {
        pool.submit(worker);
      }
      int period=conf.getInt("bsp.monitor.collector.period",5);
      Thread.sleep(period * 1000);
    }
  }
 catch (  InterruptedException ie) {
    pool.shutdown();
    LOG.warn(this.getClass().getSimpleName() + " is interrupted.",ie);
    Thread.currentThread().interrupt();
  }
}

ID 606=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Initializer#run()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Load jar from plugin directory for executing task.
 */

catch: 
catch (InterruptedException ie) {
  LOG.warn(this.getClass().getSimpleName() + " is interrupted.",ie);
  Thread.currentThread().interrupt();
}

block: 
Initializer
/** 
 * Load jar from plugin directory for executing task.
 */
@Override public void run(){
  try {
    Thread.currentThread();
    while (!Thread.interrupted()) {
      Map<String,Task> tasks=Configurator.configure((HamaConfiguration)this.conf,listener);
      if (null != tasks) {
        for (        Map.Entry<String,Task> entry : tasks.entrySet()) {
          String jarPath=entry.getKey();
          Task t=entry.getValue();
          TaskWorker old=((ConcurrentMap<String,TaskWorker>)this.workers).putIfAbsent(jarPath,new TaskWorker(t));
          if (null != old) {
            ((ConcurrentMap<String,TaskWorker>)this.workers).replace(jarPath,new TaskWorker(t));
          }
        }
      }
      LOG.debug("Task worker list's size: " + workers.size());
      int period=conf.getInt("bsp.monitor.initializer.period",5);
      Thread.sleep(period * 1000);
    }
  }
 catch (  InterruptedException ie) {
    LOG.warn(this.getClass().getSimpleName() + " is interrupted.",ie);
    Thread.currentThread().interrupt();
  }
catch (  IOException ioe) {
    LOG.warn(this.getClass().getSimpleName() + " can not load jar file " + " from plugin directory.",ioe);
    Thread.currentThread().interrupt();
  }
}

ID 607=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.Monitor#notify(org.apache.hama.monitor.Monitor.Result)
Rmethod: java.util.concurrent.BlockingQueue#put(E)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.warn(this.getClass().getSimpleName() + " is interrupted.",ie);
  Thread.currentThread().interrupt();
}

block: 
Monitor
@Override public void notify(Result result){
  try {
    results.put(result);
    LOG.debug(result.name() + " is put to queue (size is " + results.size()+ ")");
  }
 catch (  InterruptedException ie) {
    LOG.warn(this.getClass().getSimpleName() + " is interrupted.",ie);
    Thread.currentThread().interrupt();
  }
}

ID 608=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.MultiFilterRecordReader#next(K, V)
Rmethod: org.apache.hama.bsp.join.MultiFilterRecordReader#emit(TupleWritable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * {@inheritDoc} 
 */

catch: 
null
block: 
MultiFilterRecordReader
/** 
 * {@inheritDoc} 
 */
public boolean next(K key,V value) throws IOException {
  if (jc.flush(ivalue)) {
    WritableUtils.cloneInto(key,jc.key());
    WritableUtils.cloneInto(value,emit(ivalue));
    return true;
  }
  jc.clear();
  K iterkey=createKey();
  final PriorityQueue<ComposableRecordReader<K,?>> q=getRecordReaderQueue();
  while (!q.isEmpty()) {
    fillJoinCollector(iterkey);
    jc.reset(iterkey);
    if (jc.flush(ivalue)) {
      WritableUtils.cloneInto(key,jc.key());
      WritableUtils.cloneInto(value,emit(ivalue));
      return true;
    }
    jc.clear();
  }
  return false;
}

ID 609=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.MultiFilterRecordReader#next(K, V)
Rmethod: org.apache.hama.bsp.join.MultiFilterRecordReader#emit(TupleWritable)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * {@inheritDoc} 
 */

catch: 
null
block: 
MultiFilterRecordReader
/** 
 * {@inheritDoc} 
 */
public boolean next(K key,V value) throws IOException {
  if (jc.flush(ivalue)) {
    WritableUtils.cloneInto(key,jc.key());
    WritableUtils.cloneInto(value,emit(ivalue));
    return true;
  }
  jc.clear();
  K iterkey=createKey();
  final PriorityQueue<ComposableRecordReader<K,?>> q=getRecordReaderQueue();
  while (!q.isEmpty()) {
    fillJoinCollector(iterkey);
    jc.reset(iterkey);
    if (jc.flush(ivalue)) {
      WritableUtils.cloneInto(key,jc.key());
      WritableUtils.cloneInto(value,emit(ivalue));
      return true;
    }
    jc.clear();
  }
  return false;
}

ID 610=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.MultiFilterDelegationIterator#next(V)
Rmethod: org.apache.hama.bsp.join.MultiFilterRecordReader#emit(TupleWritable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MultiFilterDelegationIterator
public boolean next(V val) throws IOException {
  boolean ret;
  if (ret=jc.flush(ivalue)) {
    WritableUtils.cloneInto(val,emit(ivalue));
  }
  return ret;
}

ID 611=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.MultiFilterDelegationIterator#replay(V)
Rmethod: org.apache.hama.bsp.join.MultiFilterRecordReader#emit(TupleWritable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MultiFilterDelegationIterator
public boolean replay(V val) throws IOException {
  WritableUtils.cloneInto(val,emit(ivalue));
  return true;
}

ID 612=========================================================================type: Recover
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineCF#train()
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineCF#setupJob()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * {@inheritDoc}
 */

catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
OnlineCF
/** 
 * {@inheritDoc}
 */
@Override public boolean train(){
  try {
    BSPJob job=setupJob();
    boolean res=job.waitForCompletion(true);
    return res;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  return false;
}

ID 613=========================================================================type: Recover
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineCF#load(java.lang.String, boolean)
Rmethod: java.lang.Long#valueOf(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  actualKey=new Long(0);
}

block: 
OnlineCF
@Override public boolean load(String path,boolean lazy){
  this.isLazyLoadModel=lazy;
  this.modelPath=path;
  if (lazy == false) {
    Configuration conf=new Configuration();
    Path dataPath=new Path(modelPath);
    try {
      FileSystem fs=dataPath.getFileSystem(conf);
      LinkedList<Path> files=new LinkedList<Path>();
      if (!fs.exists(dataPath)) {
        this.isLazyLoadModel=false;
        this.modelPath=null;
        return false;
      }
      if (!fs.isFile(dataPath)) {
        for (int i=0; i < 100000; i++) {
          Path partFile=new Path(modelPath + "/part-" + String.valueOf(100000 + i).substring(1,6));
          if (fs.exists(partFile)) {
            files.add(partFile);
          }
 else {
            break;
          }
        }
      }
 else {
        files.add(dataPath);
      }
      LOG.info("loading model from " + path);
      for (      Path file : files) {
        SequenceFile.Reader reader=new SequenceFile.Reader(fs,file,conf);
        Text key=new Text();
        VectorWritable value=new VectorWritable();
        String strKey=null;
        Long actualKey=null;
        String firstSymbol=null;
        while (reader.next(key,value) != false) {
          strKey=key.toString();
          firstSymbol=strKey.substring(0,1);
          try {
            actualKey=Long.valueOf(strKey.substring(1));
          }
 catch (          Exception e) {
            actualKey=new Long(0);
          }
          if (firstSymbol.equals(OnlineCF.Settings.DFLT_MODEL_ITEM_DELIM)) {
            modelItemFactorizedValues.put(actualKey,new VectorWritable(value));
          }
 else           if (firstSymbol.equals(OnlineCF.Settings.DFLT_MODEL_USER_DELIM)) {
            modelUserFactorizedValues.put(actualKey,new VectorWritable(value));
          }
 else           if (firstSymbol.equals(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM)) {
            modelUserFeatures.put(actualKey,new VectorWritable(value));
          }
 else           if (firstSymbol.equals(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM)) {
            modelItemFeatures.put(actualKey,new VectorWritable(value));
          }
 else           if (firstSymbol.equals(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM)) {
            modelUserFeatureFactorizedValues=convertVectorWritable(value);
          }
 else           if (firstSymbol.equals(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM)) {
            modelItemFeatureFactorizedValues=convertVectorWritable(value);
          }
 else {
            continue;
          }
        }
        reader.close();
      }
      LOG.info("loaded: " + modelUserFactorizedValues.size() + " users, "+ modelUserFeatures.size()+ " user features, "+ modelItemFactorizedValues.size()+ " items, "+ modelItemFeatures.size()+ " item feature values");
    }
 catch (    Exception e) {
      e.printStackTrace();
      this.isLazyLoadModel=false;
      this.modelPath=null;
      return false;
    }
  }
  return true;
}

ID 614=========================================================================type: Ignore_Log
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineCF#estimatePreference(long, long)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
OnlineCF
@Override public double estimatePreference(long userId,long itemId){
  if (isLazyLoadModel == false) {
    if (function == null) {
      Class<?> cls=conf.getClass(OnlineCF.Settings.CONF_ONLINE_UPDATE_FUNCTION,null);
      try {
        function=(OnlineUpdate.Function)(cls.newInstance());
      }
 catch (      Exception e) {
      }
    }
    InputStructure e=new InputStructure();
    e.item=this.modelItemFactorizedValues.get(Long.valueOf(itemId));
    e.user=this.modelUserFactorizedValues.get(Long.valueOf(userId));
    e.itemFeatureFactorized=this.modelItemFeatureFactorizedValues;
    e.userFeatureFactorized=this.modelUserFeatureFactorizedValues;
    e.itemFeatures=this.modelItemFeatures.get(Long.valueOf(itemId));
    e.userFeatures=this.modelUserFeatures.get(Long.valueOf(userId));
    if (e.item == null || e.user == null) {
      return 0;
    }
    return function.predict(e);
  }
  return 0;
}

ID 615=========================================================================type: Ignore_Log
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineCF#estimatePreference(long, long)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
OnlineCF
@Override public double estimatePreference(long userId,long itemId){
  if (isLazyLoadModel == false) {
    if (function == null) {
      Class<?> cls=conf.getClass(OnlineCF.Settings.CONF_ONLINE_UPDATE_FUNCTION,null);
      try {
        function=(OnlineUpdate.Function)(cls.newInstance());
      }
 catch (      Exception e) {
      }
    }
    InputStructure e=new InputStructure();
    e.item=this.modelItemFactorizedValues.get(Long.valueOf(itemId));
    e.user=this.modelUserFactorizedValues.get(Long.valueOf(userId));
    e.itemFeatureFactorized=this.modelItemFeatureFactorizedValues;
    e.userFeatureFactorized=this.modelUserFeatureFactorizedValues;
    e.itemFeatures=this.modelItemFeatures.get(Long.valueOf(itemId));
    e.userFeatures=this.modelUserFeatures.get(Long.valueOf(userId));
    if (e.item == null || e.user == null) {
      return 0;
    }
    return function.predict(e);
  }
  return 0;
}

ID 616=========================================================================type: Ignore_Log
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineCF#getMostPreferredItems(long, int)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
OnlineCF
@Override public List<Preference<Long,Long>> getMostPreferredItems(long userId,int count){
  Comparator<Preference<Long,Long>> scoreComparator=new Comparator<Preference<Long,Long>>(){
    @Override public int compare(    Preference<Long,Long> arg0,    Preference<Long,Long> arg1){
      double difference=arg0.getValue().get() - arg1.getValue().get();
      return (int)(100000 * difference);
    }
  }
;
  PriorityQueue<Preference<Long,Long>> queue=new PriorityQueue<Preference<Long,Long>>(count,scoreComparator);
  LinkedList<Preference<Long,Long>> results=new LinkedList<Preference<Long,Long>>();
  if (function == null) {
    Class<?> cls=conf.getClass(OnlineCF.Settings.CONF_ONLINE_UPDATE_FUNCTION,null);
    try {
      function=(OnlineUpdate.Function)(cls.newInstance());
    }
 catch (    Exception e) {
    }
  }
  InputStructure e=new InputStructure();
  e.user=this.modelUserFactorizedValues.get(Long.valueOf(userId));
  e.userFeatureFactorized=this.modelUserFeatureFactorizedValues;
  e.userFeatures=this.modelUserFeatures.get(Long.valueOf(userId));
  e.itemFeatureFactorized=this.modelItemFeatureFactorizedValues;
  if (e.user == null) {
    return null;
  }
  double score=0.0;
  for (  Entry<Long,VectorWritable> item : modelItemFactorizedValues.entrySet()) {
    e.item=item.getValue();
    e.itemFeatures=this.modelItemFeatures.get(item.getKey());
    score=function.predict(e);
    queue.add(new Preference<Long,Long>(userId,item.getKey(),score));
  }
  results.addAll(queue);
  return results;
}

ID 617=========================================================================type: Ignore_Log
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineCF#getMostPreferredItems(long, int)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
OnlineCF
@Override public List<Preference<Long,Long>> getMostPreferredItems(long userId,int count){
  Comparator<Preference<Long,Long>> scoreComparator=new Comparator<Preference<Long,Long>>(){
    @Override public int compare(    Preference<Long,Long> arg0,    Preference<Long,Long> arg1){
      double difference=arg0.getValue().get() - arg1.getValue().get();
      return (int)(100000 * difference);
    }
  }
;
  PriorityQueue<Preference<Long,Long>> queue=new PriorityQueue<Preference<Long,Long>>(count,scoreComparator);
  LinkedList<Preference<Long,Long>> results=new LinkedList<Preference<Long,Long>>();
  if (function == null) {
    Class<?> cls=conf.getClass(OnlineCF.Settings.CONF_ONLINE_UPDATE_FUNCTION,null);
    try {
      function=(OnlineUpdate.Function)(cls.newInstance());
    }
 catch (    Exception e) {
    }
  }
  InputStructure e=new InputStructure();
  e.user=this.modelUserFactorizedValues.get(Long.valueOf(userId));
  e.userFeatureFactorized=this.modelUserFeatureFactorizedValues;
  e.userFeatures=this.modelUserFeatures.get(Long.valueOf(userId));
  e.itemFeatureFactorized=this.modelItemFeatureFactorizedValues;
  if (e.user == null) {
    return null;
  }
  double score=0.0;
  for (  Entry<Long,VectorWritable> item : modelItemFactorizedValues.entrySet()) {
    e.item=item.getValue();
    e.itemFeatures=this.modelItemFeatures.get(item.getKey());
    score=function.predict(e);
    queue.add(new Preference<Long,Long>(userId,item.getKey(),score));
  }
  results.addAll(queue);
  return results;
}

ID 618=========================================================================type: Ignore_Log
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#setup(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
OnlineTrainBSP
@Override public void setup(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  Configuration conf=peer.getConfiguration();
  ITERATION=conf.getInt(OnlineCF.Settings.CONF_ITERATION_COUNT,OnlineCF.Settings.DFLT_ITERATION_COUNT);
  MATRIX_RANK=conf.getInt(OnlineCF.Settings.CONF_MATRIX_RANK,OnlineCF.Settings.DFLT_MATRIX_RANK);
  SKIP_COUNT=conf.getInt(OnlineCF.Settings.CONF_SKIP_COUNT,OnlineCF.Settings.DFLT_SKIP_COUNT);
  inputItemDelim=conf.get(OnlineCF.Settings.CONF_INPUT_ITEM_DELIM,OnlineCF.Settings.DFLT_ITEM_DELIM);
  inputUserDelim=conf.get(OnlineCF.Settings.CONF_INPUT_USER_DELIM,OnlineCF.Settings.DFLT_USER_DELIM);
  inputPreferenceDelim=conf.get(OnlineCF.Settings.CONF_INPUT_PREFERENCES_DELIM,OnlineCF.Settings.DFLT_PREFERENCE_DELIM);
  Class<?> cls=conf.getClass(OnlineCF.Settings.CONF_ONLINE_UPDATE_FUNCTION,null);
  try {
    function=(OnlineUpdate.Function)(cls.newInstance());
  }
 catch (  Exception e) {
  }
}

ID 619=========================================================================type: Ignore_Log
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#setup(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
OnlineTrainBSP
@Override public void setup(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  Configuration conf=peer.getConfiguration();
  ITERATION=conf.getInt(OnlineCF.Settings.CONF_ITERATION_COUNT,OnlineCF.Settings.DFLT_ITERATION_COUNT);
  MATRIX_RANK=conf.getInt(OnlineCF.Settings.CONF_MATRIX_RANK,OnlineCF.Settings.DFLT_MATRIX_RANK);
  SKIP_COUNT=conf.getInt(OnlineCF.Settings.CONF_SKIP_COUNT,OnlineCF.Settings.DFLT_SKIP_COUNT);
  inputItemDelim=conf.get(OnlineCF.Settings.CONF_INPUT_ITEM_DELIM,OnlineCF.Settings.DFLT_ITEM_DELIM);
  inputUserDelim=conf.get(OnlineCF.Settings.CONF_INPUT_USER_DELIM,OnlineCF.Settings.DFLT_USER_DELIM);
  inputPreferenceDelim=conf.get(OnlineCF.Settings.CONF_INPUT_PREFERENCES_DELIM,OnlineCF.Settings.DFLT_PREFERENCE_DELIM);
  Class<?> cls=conf.getClass(OnlineCF.Settings.CONF_ONLINE_UPDATE_FUNCTION,null);
  try {
    function=(OnlineUpdate.Function)(cls.newInstance());
  }
 catch (  Exception e) {
  }
}

ID 620=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#collectInput(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashSet<Text>, HashSet<Text>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 621=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#askForFeatures(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashSet<Text>, HashSet<Text>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 622=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#askForFeatures(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashSet<Text>, HashSet<Text>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 623=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#askForFeatures(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashSet<Text>, HashSet<Text>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 624=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendRequiredFeatures(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 625=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendRequiredFeatures(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 626=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendRequiredFeatures(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 627=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#collectFeatures(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 628=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 629=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: true
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 630=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 631=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 632=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 633=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
@Override public void bsp(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") collecting input data");
  HashSet<Text> requiredUserFeatures=null;
  HashSet<Text> requiredItemFeatures=null;
  collectInput(peer,requiredUserFeatures,requiredItemFeatures);
  askForFeatures(peer,requiredUserFeatures,requiredItemFeatures);
  peer.sync();
  requiredUserFeatures=null;
  requiredItemFeatures=null;
  sendRequiredFeatures(peer);
  peer.sync();
  collectFeatures(peer);
  LOG.info(peer.getPeerName() + ") collected: " + this.usersMatrix.size()+ " users, "+ this.itemsMatrix.size()+ " items, "+ this.preferences.size()+ " preferences");
  for (int i=0; i < ITERATION; i++) {
    computeValues();
    if ((i + 1) % SKIP_COUNT == 0) {
      normalizeWithBroadcastingValues(peer);
    }
  }
  saveModel(peer);
}

ID 634=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  peer.sync();
  normalizeItemFactorizedValues(peer);
  peer.sync();
  if (itemFeatureMatrix != null) {
    normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,true);
    peer.sync();
  }
  if (userFeatureMatrix != null) {
    normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,true);
    peer.sync();
  }
}

ID 635=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  peer.sync();
  normalizeItemFactorizedValues(peer);
  peer.sync();
  if (itemFeatureMatrix != null) {
    normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,true);
    peer.sync();
  }
  if (userFeatureMatrix != null) {
    normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,true);
    peer.sync();
  }
}

ID 636=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  peer.sync();
  normalizeItemFactorizedValues(peer);
  peer.sync();
  if (itemFeatureMatrix != null) {
    normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,true);
    peer.sync();
  }
  if (userFeatureMatrix != null) {
    normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,true);
    peer.sync();
  }
}

ID 637=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeMatrix(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, DoubleMatrix, IntWritable, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  peer.sync();
  normalizeItemFactorizedValues(peer);
  peer.sync();
  if (itemFeatureMatrix != null) {
    normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,true);
    peer.sync();
  }
  if (userFeatureMatrix != null) {
    normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,true);
    peer.sync();
  }
}

ID 638=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeMatrix(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, DoubleMatrix, IntWritable, boolean)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  peer.sync();
  normalizeItemFactorizedValues(peer);
  peer.sync();
  if (itemFeatureMatrix != null) {
    normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,true);
    peer.sync();
  }
  if (userFeatureMatrix != null) {
    normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,true);
    peer.sync();
  }
}

ID 639=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeMatrix(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, DoubleMatrix, IntWritable, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeWithBroadcastingValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  peer.sync();
  normalizeItemFactorizedValues(peer);
  peer.sync();
  if (itemFeatureMatrix != null) {
    normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,true);
    peer.sync();
  }
  if (userFeatureMatrix != null) {
    normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,true);
    peer.sync();
  }
}

ID 640=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  sendTo(peer,senderList,normalizedValues);
  peer.sync();
  receiveSyncedItemFactorizedValues(peer);
}

ID 641=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  sendTo(peer,senderList,normalizedValues);
  peer.sync();
  receiveSyncedItemFactorizedValues(peer);
}

ID 642=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  sendTo(peer,senderList,normalizedValues);
  peer.sync();
  receiveSyncedItemFactorizedValues(peer);
}

ID 643=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#getNormalizedItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashMap<Text,DoubleVector>, HashMap<Text,LinkedList<IntWritable>>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  sendTo(peer,senderList,normalizedValues);
  peer.sync();
  receiveSyncedItemFactorizedValues(peer);
}

ID 644=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendTo(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashMap<Text,LinkedList<IntWritable>>, HashMap<Text,DoubleVector>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  sendTo(peer,senderList,normalizedValues);
  peer.sync();
  receiveSyncedItemFactorizedValues(peer);
}

ID 645=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#receiveSyncedItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void normalizeItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  sendTo(peer,senderList,normalizedValues);
  peer.sync();
  receiveSyncedItemFactorizedValues(peer);
}

ID 646=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 647=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 648=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#sendItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 649=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#getNormalizedItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashMap<Text,DoubleVector>, HashMap<Text,LinkedList<IntWritable>>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 650=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveItemFactorizedValues(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashMap<Text,DoubleVector>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 651=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeMatrix(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, DoubleMatrix, IntWritable, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 652=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeMatrix(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, DoubleMatrix, IntWritable, boolean)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ml.recommendation.cf.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 653=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>)
Rmethod: org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#normalizeMatrix(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, DoubleMatrix, IntWritable, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void saveModel(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  LOG.info(peer.getPeerName() + ") saving " + usersMatrix.size()+ " users");
  for (  Map.Entry<String,VectorWritable> user : usersMatrix.entrySet()) {
    peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()),user.getValue());
  }
  sendItemFactorizedValues(peer);
  peer.sync();
  HashMap<Text,LinkedList<IntWritable>> senderList=new HashMap<Text,LinkedList<IntWritable>>();
  HashMap<Text,DoubleVector> normalizedValues=new HashMap<Text,DoubleVector>();
  getNormalizedItemFactorizedValues(peer,normalizedValues,senderList);
  saveItemFactorizedValues(peer,normalizedValues);
  if (itemFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpItemsFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,itemFeatureMatrix,OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
  if (userFeatureMatrix != null) {
    for (    Map.Entry<String,VectorWritable> feature : inpUsersFeatures.entrySet()) {
      peer.write(new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()),feature.getValue());
    }
    DoubleMatrix res=normalizeMatrix(peer,userFeatureMatrix,OnlineCF.Settings.MSG_USER_FEATURE_MATRIX,false);
    if (res != null) {
      Text key=new Text(OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString());
      peer.write(key,convertMatrixToVector(res));
    }
  }
}

ID 654=========================================================================type: only_throws
package: org.apache.hama.ml.recommendation.cf
Method:org.apache.hama.ml.recommendation.cf.OnlineTrainBSP#collectInput(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable>, HashSet<Text>, HashSet<Text>)
Rmethod: java.lang.Double#parseDouble(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
OnlineTrainBSP
private void collectInput(BSPPeer<Text,VectorWritable,Text,VectorWritable,MapWritable> peer,HashSet<Text> requiredUserFeatures,HashSet<Text> requiredItemFeatures) throws IOException {
  Text key=new Text();
  VectorWritable value=new VectorWritable();
  int counter=0;
  requiredUserFeatures=new HashSet<Text>();
  requiredItemFeatures=new HashSet<Text>();
  while (peer.readNext(key,value)) {
    String firstSymbol=key.toString().substring(0,1);
    String actualId=key.toString().substring(1);
    if (firstSymbol.equals(inputPreferenceDelim)) {
      String itemId=Long.toString((long)value.getVector().get(0));
      String score=Double.toString(value.getVector().get(1));
      if (usersMatrix.containsKey(actualId) == false) {
        DenseDoubleVector vals=new DenseDoubleVector(MATRIX_RANK);
        for (int i=0; i < MATRIX_RANK; i++) {
          vals.set(i,rnd.nextDouble());
        }
        VectorWritable rndValues=new VectorWritable(vals);
        usersMatrix.put(actualId,rndValues);
      }
      if (itemsMatrix.containsKey(itemId) == false) {
        DenseDoubleVector vals=new DenseDoubleVector(MATRIX_RANK);
        for (int i=0; i < MATRIX_RANK; i++) {
          vals.set(i,rnd.nextDouble());
        }
        VectorWritable rndValues=new VectorWritable(vals);
        itemsMatrix.put(itemId,rndValues);
      }
      preferences.add(new Preference<String,String>(actualId,itemId,Double.parseDouble(score)));
      indexes.add(counter);
      requiredUserFeatures.add(new Text(inputUserDelim + actualId));
      requiredItemFeatures.add(new Text(inputItemDelim + itemId));
      counter++;
    }
 else     if (firstSymbol.equals(inputUserDelim)) {
      if (inpUsersFeatures == null) {
        inpUsersFeatures=new HashMap<String,VectorWritable>();
      }
      inpUsersFeatures.put(actualId,value);
    }
 else     if (firstSymbol.equals(inputItemDelim)) {
      if (inpItemsFeatures == null) {
        inpItemsFeatures=new HashMap<String,VectorWritable>();
      }
      inpItemsFeatures.put(actualId,value);
    }
 else {
      continue;
    }
  }
}

ID 655=========================================================================type: only_throws
package: org.apache.hama.graph.example
Method:org.apache.hama.graph.example.PageRank#createJob(java.lang.String[], HamaConfiguration)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PageRank
public static GraphJob createJob(String[] args,HamaConfiguration conf) throws IOException {
  GraphJob pageJob=new GraphJob(conf,PageRank.class);
  pageJob.setJobName("Pagerank");
  pageJob.setVertexClass(PageRankVertex.class);
  pageJob.setInputPath(new Path(args[0]));
  pageJob.setOutputPath(new Path(args[1]));
  pageJob.setMaxIteration(30);
  pageJob.set("hama.pagerank.alpha","0.85");
  pageJob.set("hama.graph.self.ref","true");
  pageJob.set("hama.graph.max.convergence.error","0.001");
  if (args.length == 3) {
    pageJob.setNumBspTask(Integer.parseInt(args[2]));
  }
  pageJob.setAggregatorClass(AverageAggregator.class);
  pageJob.setVertexInputReaderClass(PagerankSeqReader.class);
  pageJob.setVertexIDClass(Text.class);
  pageJob.setVertexValueClass(DoubleWritable.class);
  pageJob.setEdgeValueClass(NullWritable.class);
  pageJob.setInputFormat(SequenceFileInputFormat.class);
  pageJob.setPartitioner(HashPartitioner.class);
  pageJob.setOutputFormat(TextOutputFormat.class);
  pageJob.setOutputKeyClass(Text.class);
  pageJob.setOutputValueClass(DoubleWritable.class);
  return pageJob;
}

ID 656=========================================================================type: only_throws
package: org.apache.hama.graph.example
Method:org.apache.hama.graph.example.PageRank#main(java.lang.String[])
Rmethod: org.apache.hama.graph.example.PageRank#createJob(java.lang.String[], HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PageRank
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length < 2)   printUsage();
  HamaConfiguration conf=new HamaConfiguration(new Configuration());
  GraphJob pageJob=createJob(args,conf);
  long startTime=System.currentTimeMillis();
  if (pageJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 657=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PageRankonYarn#createJob(java.lang.String[], HamaConfiguration, Options)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PageRankonYarn
public static YARNGraphJob createJob(String[] args,HamaConfiguration conf,Options opts) throws IOException, ParseException {
  CommandLine cliParser=new GnuParser().parse(opts,args);
  if (!cliParser.hasOption("i") || !cliParser.hasOption("o")) {
    System.out.println("No input or output path specified for PageRank, exiting.");
  }
  YARNGraphJob pageJob=new YARNGraphJob(conf,PageRankonYarn.class);
  pageJob.setJobName("Pagerank");
  pageJob.setVertexClass(PageRankVertex.class);
  pageJob.setInputPath(new Path(cliParser.getOptionValue("i")));
  pageJob.setOutputPath(new Path(cliParser.getOptionValue("o")));
  pageJob.setMaxIteration(30);
  pageJob.set("hama.pagerank.alpha","0.85");
  pageJob.set("hama.graph.self.ref","true");
  pageJob.set("hama.graph.max.convergence.error","0.001");
  if (cliParser.hasOption("t")) {
    pageJob.setNumBspTask(Integer.parseInt(cliParser.getOptionValue("t")));
  }
  pageJob.setAggregatorClass(AverageAggregator.class);
  if (cliParser.hasOption("f")) {
    if (cliParser.getOptionValue("f").equals("text")) {
      pageJob.setVertexInputReaderClass(PagerankTextReader.class);
    }
 else     if (cliParser.getOptionValue("f").equals("json")) {
      pageJob.setVertexInputReaderClass(PagerankJsonReader.class);
    }
 else {
      System.out.println("File type is not available to run Pagerank... " + "File type set default value, Text.");
      pageJob.setVertexInputReaderClass(PagerankTextReader.class);
    }
  }
 else {
    pageJob.setVertexInputReaderClass(PagerankTextReader.class);
  }
  pageJob.setVertexIDClass(Text.class);
  pageJob.setVertexValueClass(DoubleWritable.class);
  pageJob.setEdgeValueClass(NullWritable.class);
  pageJob.setInputFormat(TextInputFormat.class);
  pageJob.setInputKeyClass(LongWritable.class);
  pageJob.setInputValueClass(Text.class);
  pageJob.setPartitioner(HashPartitioner.class);
  pageJob.setOutputFormat(TextOutputFormat.class);
  pageJob.setOutputKeyClass(Text.class);
  pageJob.setOutputValueClass(DoubleWritable.class);
  return pageJob;
}

ID 658=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PageRankonYarn#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.PageRankonYarn#createJob(java.lang.String[], HamaConfiguration, Options)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PageRankonYarn
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException, ParseException {
  Options opts=new Options();
  opts.addOption("i","input_path",true,"The Location of output path.");
  opts.addOption("o","output_path",true,"The Location of input path.");
  opts.addOption("h","help",false,"Print usage");
  opts.addOption("t","task_num",true,"The number of tasks.");
  opts.addOption("f","file_type",true,"The file type of input data. Input" + "file format which is \"text\" tab delimiter separated or \"json\"." + "Default value - Text");
  if (args.length < 2) {
    new HelpFormatter().printHelp("pagerank -i INPUT_PATH -o OUTPUT_PATH " + "[-t NUM_TASKS] [-f FILE_TYPE]",opts);
    System.exit(-1);
  }
  HamaConfiguration conf=new HamaConfiguration();
  YARNGraphJob pageJob=createJob(args,conf,opts);
  long startTime=System.currentTimeMillis();
  if (pageJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 659=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PageRankonYarn#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.PageRankonYarn#createJob(java.lang.String[], HamaConfiguration, Options)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.ParseException
exception comment: /** 
 * Signals that an error has been reached unexpectedly while parsing.
 * @see java.lang.Exception
 * @see java.text.Format
 * @see java.text.FieldPosition
 * @author      Mark Davis
 */

method comment: null
catch: 
null
block: 
PageRankonYarn
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException, ParseException {
  Options opts=new Options();
  opts.addOption("i","input_path",true,"The Location of output path.");
  opts.addOption("o","output_path",true,"The Location of input path.");
  opts.addOption("h","help",false,"Print usage");
  opts.addOption("t","task_num",true,"The number of tasks.");
  opts.addOption("f","file_type",true,"The file type of input data. Input" + "file format which is \"text\" tab delimiter separated or \"json\"." + "Default value - Text");
  if (args.length < 2) {
    new HelpFormatter().printHelp("pagerank -i INPUT_PATH -o OUTPUT_PATH " + "[-t NUM_TASKS] [-f FILE_TYPE]",opts);
    System.exit(-1);
  }
  HamaConfiguration conf=new HamaConfiguration();
  YARNGraphJob pageJob=createJob(args,conf,opts);
  long startTime=System.currentTimeMillis();
  if (pageJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 660=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.PageRankTest#verifyResult()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PageRankTest
private void verifyResult() throws IOException {
  FileStatus[] globStatus=fs.globStatus(new Path(OUTPUT + "/part-*"));
  double sum=0d;
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      sum+=Double.parseDouble(split[1]);
    }
  }
  System.out.println(sum);
  assertTrue("Sum was: " + sum,sum > 0.9 && sum < 1.1);
}

ID 661=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.PageRankTest#verifyResult()
Rmethod: java.lang.Double#parseDouble(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PageRankTest
private void verifyResult() throws IOException {
  FileStatus[] globStatus=fs.globStatus(new Path(OUTPUT + "/part-*"));
  double sum=0d;
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      sum+=Double.parseDouble(split[1]);
    }
  }
  System.out.println(sum);
  assertTrue("Sum was: " + sum,sum > 0.9 && sum < 1.1);
}

ID 662=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Lexer#next()
Rmethod: java.io.StreamTokenizer#nextToken()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Lexer
Token next() throws IOException {
  int type=tok.nextToken();
switch (type) {
case StreamTokenizer.TT_EOF:
case StreamTokenizer.TT_EOL:
    return null;
case StreamTokenizer.TT_NUMBER:
  return new NumToken(tok.nval);
case StreamTokenizer.TT_WORD:
return new StrToken(TType.IDENT,tok.sval);
case '"':
return new StrToken(TType.QUOT,tok.sval);
default :
switch (type) {
case ',':
return new Token(TType.COMMA);
case '(':
return new Token(TType.LPAREN);
case ')':
return new Token(TType.RPAREN);
default :
throw new IOException("Unexpected: " + type);
}
}
}

ID 663=========================================================================type: Recover
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Node#forIdent(java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: /** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */

catch: 
catch (InstantiationException e) {
  throw (IOException)new IOException().initCause(e);
}

block: 
Node
/** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */
static Node forIdent(String ident) throws IOException {
  try {
    if (!nodeCstrMap.containsKey(ident)) {
      throw new IOException("No nodetype for " + ident);
    }
    return nodeCstrMap.get(ident).newInstance(ident);
  }
 catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InvocationTargetException e) {
    throw (IOException)new IOException().initCause(e);
  }
}

ID 664=========================================================================type: Recover
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Node#forIdent(java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */

catch: 
catch (IllegalAccessException e) {
  throw (IOException)new IOException().initCause(e);
}

block: 
Node
/** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */
static Node forIdent(String ident) throws IOException {
  try {
    if (!nodeCstrMap.containsKey(ident)) {
      throw new IOException("No nodetype for " + ident);
    }
    return nodeCstrMap.get(ident).newInstance(ident);
  }
 catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InvocationTargetException e) {
    throw (IOException)new IOException().initCause(e);
  }
}

ID 665=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Node#forIdent(java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */

catch: 
null
block: 
Node
/** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */
static Node forIdent(String ident) throws IOException {
  try {
    if (!nodeCstrMap.containsKey(ident)) {
      throw new IOException("No nodetype for " + ident);
    }
    return nodeCstrMap.get(ident).newInstance(ident);
  }
 catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InvocationTargetException e) {
    throw (IOException)new IOException().initCause(e);
  }
}

ID 666=========================================================================type: Recover
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Node#forIdent(java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: /** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */

catch: 
catch (InvocationTargetException e) {
  throw (IOException)new IOException().initCause(e);
}

block: 
Node
/** 
 * Return the node type registered for the particular identifier. By default, this is a CNode for any composite node and a WNode for &quot;wrapped&quot; nodes. User nodes will likely be composite nodes.
 * @see #addIdentifier(java.lang.String,java.lang.Class[],java.lang.Class,java.lang.Class)
 * @see CompositeInputFormat#setFormat(org.apache.hama.bsp.BSPJob)
 */
static Node forIdent(String ident) throws IOException {
  try {
    if (!nodeCstrMap.containsKey(ident)) {
      throw new IOException("No nodetype for " + ident);
    }
    return nodeCstrMap.get(ident).newInstance(ident);
  }
 catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InvocationTargetException e) {
    throw (IOException)new IOException().initCause(e);
  }
}

ID 667=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Node#addIdentifier(java.lang.String, Class<?>[], Class<? extends org.apache.hama.bsp.join.Parser.Node>, Class<? extends ComposableRecordReader>)
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: /** 
 * For a given identifier, add a mapping to the nodetype for the parse tree and to the ComposableRecordReader to be created, including the formals required to invoke the constructor. The nodetype and constructor signature should be filled in from the child node.
 */

catch: 
null
block: 
Node
/** 
 * For a given identifier, add a mapping to the nodetype for the parse tree and to the ComposableRecordReader to be created, including the formals required to invoke the constructor. The nodetype and constructor signature should be filled in from the child node.
 */
protected static void addIdentifier(String ident,Class<?>[] mcstrSig,Class<? extends Node> nodetype,Class<? extends ComposableRecordReader> cl) throws NoSuchMethodException {
  Constructor<? extends Node> ncstr=nodetype.getDeclaredConstructor(ncstrSig);
  ncstr.setAccessible(true);
  nodeCstrMap.put(ident,ncstr);
  Constructor<? extends ComposableRecordReader> mcstr=cl.getDeclaredConstructor(mcstrSig);
  mcstr.setAccessible(true);
  rrCstrMap.put(ident,mcstr);
}

ID 668=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Node#addIdentifier(java.lang.String, Class<?>[], Class<? extends org.apache.hama.bsp.join.Parser.Node>, Class<? extends ComposableRecordReader>)
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * For a given identifier, add a mapping to the nodetype for the parse tree and to the ComposableRecordReader to be created, including the formals required to invoke the constructor. The nodetype and constructor signature should be filled in from the child node.
 */

catch: 
null
block: 
Node
/** 
 * For a given identifier, add a mapping to the nodetype for the parse tree and to the ComposableRecordReader to be created, including the formals required to invoke the constructor. The nodetype and constructor signature should be filled in from the child node.
 */
protected static void addIdentifier(String ident,Class<?>[] mcstrSig,Class<? extends Node> nodetype,Class<? extends ComposableRecordReader> cl) throws NoSuchMethodException {
  Constructor<? extends Node> ncstr=nodetype.getDeclaredConstructor(ncstrSig);
  ncstr.setAccessible(true);
  nodeCstrMap.put(ident,ncstr);
  Constructor<? extends ComposableRecordReader> mcstr=cl.getDeclaredConstructor(mcstrSig);
  mcstr.setAccessible(true);
  rrCstrMap.put(ident,mcstr);
}

ID 669=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Node#addIdentifier(java.lang.String, Class<?>[], Class<? extends org.apache.hama.bsp.join.Parser.Node>, Class<? extends ComposableRecordReader>)
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * For a given identifier, add a mapping to the nodetype for the parse tree and to the ComposableRecordReader to be created, including the formals required to invoke the constructor. The nodetype and constructor signature should be filled in from the child node.
 */

catch: 
null
block: 
Node
/** 
 * For a given identifier, add a mapping to the nodetype for the parse tree and to the ComposableRecordReader to be created, including the formals required to invoke the constructor. The nodetype and constructor signature should be filled in from the child node.
 */
protected static void addIdentifier(String ident,Class<?>[] mcstrSig,Class<? extends Node> nodetype,Class<? extends ComposableRecordReader> cl) throws NoSuchMethodException {
  Constructor<? extends Node> ncstr=nodetype.getDeclaredConstructor(ncstrSig);
  ncstr.setAccessible(true);
  nodeCstrMap.put(ident,ncstr);
  Constructor<? extends ComposableRecordReader> mcstr=cl.getDeclaredConstructor(mcstrSig);
  mcstr.setAccessible(true);
  rrCstrMap.put(ident,mcstr);
}

ID 670=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WNode#addIdentifier(java.lang.String, Class<? extends ComposableRecordReader>)
Rmethod: org.apache.hama.bsp.join.Node#addIdentifier(java.lang.String, Class<?>[], Class<? extends org.apache.hama.bsp.join.Parser.Node>, Class<? extends ComposableRecordReader>)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
null
block: 
WNode
static void addIdentifier(String ident,Class<? extends ComposableRecordReader> cl) throws NoSuchMethodException {
  Node.addIdentifier(ident,cstrSig,WNode.class,cl);
}

ID 671=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WNode#parse(List<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
Rmethod: org.apache.hama.bsp.join.Token#getStr()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Let the first actual define the InputFormat and the second define the <tt>bsp.input.dir</tt> property.
 */

catch: 
null
block: 
WNode
/** 
 * Let the first actual define the InputFormat and the second define the <tt>bsp.input.dir</tt> property.
 */
public void parse(List<Token> ll,BSPJob job) throws IOException {
  StringBuilder sb=new StringBuilder();
  Iterator<Token> i=ll.iterator();
  while (i.hasNext()) {
    Token t=i.next();
    if (TType.COMMA.equals(t.getType())) {
      try {
        inf=(InputFormat)ReflectionUtils.newInstance(job.getConfiguration().getClassByName(sb.toString()),job.getConfiguration());
      }
 catch (      ClassNotFoundException e) {
        throw (IOException)new IOException().initCause(e);
      }
catch (      IllegalArgumentException e) {
        throw (IOException)new IOException().initCause(e);
      }
      break;
    }
    sb.append(t.getStr());
  }
  if (!i.hasNext()) {
    throw new IOException("Parse error");
  }
  Token t=i.next();
  if (!TType.QUOT.equals(t.getType())) {
    throw new IOException("Expected quoted string");
  }
  indir=t.getStr();
}

ID 672=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WNode#parse(List<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
Rmethod: org.apache.hama.bsp.join.Token#getStr()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Let the first actual define the InputFormat and the second define the <tt>bsp.input.dir</tt> property.
 */

catch: 
null
block: 
WNode
/** 
 * Let the first actual define the InputFormat and the second define the <tt>bsp.input.dir</tt> property.
 */
public void parse(List<Token> ll,BSPJob job) throws IOException {
  StringBuilder sb=new StringBuilder();
  Iterator<Token> i=ll.iterator();
  while (i.hasNext()) {
    Token t=i.next();
    if (TType.COMMA.equals(t.getType())) {
      try {
        inf=(InputFormat)ReflectionUtils.newInstance(job.getConfiguration().getClassByName(sb.toString()),job.getConfiguration());
      }
 catch (      ClassNotFoundException e) {
        throw (IOException)new IOException().initCause(e);
      }
catch (      IllegalArgumentException e) {
        throw (IOException)new IOException().initCause(e);
      }
      break;
    }
    sb.append(t.getStr());
  }
  if (!i.hasNext()) {
    throw new IOException("Parse error");
  }
  Token t=i.next();
  if (!TType.QUOT.equals(t.getType())) {
    throw new IOException("Expected quoted string");
  }
  indir=t.getStr();
}

ID 673=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WNode#getSplits(BSPJob, int)
Rmethod: org.apache.hama.bsp.join.WNode#getConf(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
WNode
public InputSplit[] getSplits(BSPJob job,int numSplits) throws IOException {
  return inf.getSplits(getConf(job),numSplits);
}

ID 674=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WNode#getRecordReader(InputSplit, BSPJob)
Rmethod: org.apache.hama.bsp.join.WNode#getConf(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
WNode
public ComposableRecordReader getRecordReader(InputSplit split,BSPJob job) throws IOException {
  try {
    if (!rrCstrMap.containsKey(ident)) {
      throw new IOException("No RecordReader for " + ident);
    }
    return rrCstrMap.get(ident).newInstance(id,inf.getRecordReader(split,getConf(job)),cmpcl);
  }
 catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InvocationTargetException e) {
    throw (IOException)new IOException().initCause(e);
  }
}

ID 675=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CNode#addIdentifier(java.lang.String, Class<? extends ComposableRecordReader>)
Rmethod: org.apache.hama.bsp.join.Node#addIdentifier(java.lang.String, Class<?>[], Class<? extends org.apache.hama.bsp.join.Parser.Node>, Class<? extends ComposableRecordReader>)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
null
block: 
CNode
static void addIdentifier(String ident,Class<? extends ComposableRecordReader> cl) throws NoSuchMethodException {
  Node.addIdentifier(ident,cstrSig,CNode.class,cl);
}

ID 676=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.CNode#parse(List<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
Rmethod: org.apache.hama.bsp.join.Token#getNode()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Parse a list of comma-separated nodes.
 */

catch: 
null
block: 
CNode
/** 
 * Parse a list of comma-separated nodes.
 */
public void parse(List<Token> args,BSPJob job) throws IOException {
  ListIterator<Token> i=args.listIterator();
  while (i.hasNext()) {
    Token t=i.next();
    t.getNode().setID(i.previousIndex() >> 1);
    kids.add(t.getNode());
    if (i.hasNext() && !TType.COMMA.equals(i.next().getType())) {
      throw new IOException("Expected ','");
    }
  }
}

ID 677=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Parser#reduce(Stack<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
Rmethod: org.apache.hama.bsp.join.Token#getStr()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Parser
private static Token reduce(Stack<Token> st,BSPJob job) throws IOException {
  LinkedList<Token> args=new LinkedList<Token>();
  while (!st.isEmpty() && !TType.LPAREN.equals(st.peek().getType())) {
    args.addFirst(st.pop());
  }
  if (st.isEmpty()) {
    throw new IOException("Unmatched ')'");
  }
  st.pop();
  if (st.isEmpty() || !TType.IDENT.equals(st.peek().getType())) {
    throw new IOException("Identifier expected");
  }
  Node n=Node.forIdent(st.pop().getStr());
  n.parse(args,job);
  return new NodeToken(n);
}

ID 678=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Parser#reduce(Stack<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
Rmethod: org.apache.hama.bsp.join.Node#forIdent(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Parser
private static Token reduce(Stack<Token> st,BSPJob job) throws IOException {
  LinkedList<Token> args=new LinkedList<Token>();
  while (!st.isEmpty() && !TType.LPAREN.equals(st.peek().getType())) {
    args.addFirst(st.pop());
  }
  if (st.isEmpty()) {
    throw new IOException("Unmatched ')'");
  }
  st.pop();
  if (st.isEmpty() || !TType.IDENT.equals(st.peek().getType())) {
    throw new IOException("Identifier expected");
  }
  Node n=Node.forIdent(st.pop().getStr());
  n.parse(args,job);
  return new NodeToken(n);
}

ID 679=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Parser#reduce(Stack<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
Rmethod: org.apache.hama.bsp.join.Node#parse(List<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Parser
private static Token reduce(Stack<Token> st,BSPJob job) throws IOException {
  LinkedList<Token> args=new LinkedList<Token>();
  while (!st.isEmpty() && !TType.LPAREN.equals(st.peek().getType())) {
    args.addFirst(st.pop());
  }
  if (st.isEmpty()) {
    throw new IOException("Unmatched ')'");
  }
  st.pop();
  if (st.isEmpty() || !TType.IDENT.equals(st.peek().getType())) {
    throw new IOException("Identifier expected");
  }
  Node n=Node.forIdent(st.pop().getStr());
  n.parse(args,job);
  return new NodeToken(n);
}

ID 680=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Parser#parse(java.lang.String, BSPJob)
Rmethod: org.apache.hama.bsp.join.Lexer#next()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Given an expression and an optional comparator, build a tree of InputFormats using the comparator to sort keys.
 */

catch: 
null
block: 
Parser
/** 
 * Given an expression and an optional comparator, build a tree of InputFormats using the comparator to sort keys.
 */
static Node parse(String expr,BSPJob job) throws IOException {
  if (null == expr) {
    throw new IOException("Expression is null");
  }
  Class<? extends WritableComparator> cmpcl=job.getConfiguration().getClass("bsp.join.keycomparator",null,WritableComparator.class);
  Lexer lex=new Lexer(expr);
  Stack<Token> st=new Stack<Token>();
  Token tok;
  while ((tok=lex.next()) != null) {
    if (TType.RPAREN.equals(tok.getType())) {
      st.push(reduce(st,job));
    }
 else {
      st.push(tok);
    }
  }
  if (st.size() == 1 && TType.CIF.equals(st.peek().getType())) {
    Node ret=st.pop().getNode();
    if (cmpcl != null) {
      ret.setKeyComparator(cmpcl);
    }
    return ret;
  }
  throw new IOException("Missing ')'");
}

ID 681=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Parser#parse(java.lang.String, BSPJob)
Rmethod: org.apache.hama.bsp.join.Parser#reduce(Stack<org.apache.hama.bsp.join.Parser.Token>, BSPJob)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Given an expression and an optional comparator, build a tree of InputFormats using the comparator to sort keys.
 */

catch: 
null
block: 
Parser
/** 
 * Given an expression and an optional comparator, build a tree of InputFormats using the comparator to sort keys.
 */
static Node parse(String expr,BSPJob job) throws IOException {
  if (null == expr) {
    throw new IOException("Expression is null");
  }
  Class<? extends WritableComparator> cmpcl=job.getConfiguration().getClass("bsp.join.keycomparator",null,WritableComparator.class);
  Lexer lex=new Lexer(expr);
  Stack<Token> st=new Stack<Token>();
  Token tok;
  while ((tok=lex.next()) != null) {
    if (TType.RPAREN.equals(tok.getType())) {
      st.push(reduce(st,job));
    }
 else {
      st.push(tok);
    }
  }
  if (st.size() == 1 && TType.CIF.equals(st.peek().getType())) {
    Node ret=st.pop().getNode();
    if (cmpcl != null) {
      ret.setKeyComparator(cmpcl);
    }
    return ret;
  }
  throw new IOException("Missing ')'");
}

ID 682=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.Parser#parse(java.lang.String, BSPJob)
Rmethod: org.apache.hama.bsp.join.Token#getNode()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Given an expression and an optional comparator, build a tree of InputFormats using the comparator to sort keys.
 */

catch: 
null
block: 
Parser
/** 
 * Given an expression and an optional comparator, build a tree of InputFormats using the comparator to sort keys.
 */
static Node parse(String expr,BSPJob job) throws IOException {
  if (null == expr) {
    throw new IOException("Expression is null");
  }
  Class<? extends WritableComparator> cmpcl=job.getConfiguration().getClass("bsp.join.keycomparator",null,WritableComparator.class);
  Lexer lex=new Lexer(expr);
  Stack<Token> st=new Stack<Token>();
  Token tok;
  while ((tok=lex.next()) != null) {
    if (TType.RPAREN.equals(tok.getType())) {
      st.push(reduce(st,job));
    }
 else {
      st.push(tok);
    }
  }
  if (st.size() == 1 && TType.CIF.equals(st.peek().getType())) {
    Node ret=st.pop().getNode();
    if (cmpcl != null) {
      ret.setKeyComparator(cmpcl);
    }
    return ret;
  }
  throw new IOException("Missing ')'");
}

ID 683=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PartitioningRunner#bsp(BSPPeer<Writable,Writable,Writable,Writable,MapWritable>)
Rmethod: org.apache.hama.bsp.RecordConverter#convertRecord(KeyValuePair<Writable,Writable>, Configuration)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PartitioningRunner
@Override @SuppressWarnings({"rawtypes"}) public void bsp(BSPPeer<Writable,Writable,Writable,Writable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  Partitioner partitioner=getPartitioner();
  KeyValuePair<Writable,Writable> rawRecord=null;
  KeyValuePair<Writable,Writable> convertedRecord=null;
  Class rawKeyClass=null;
  Class rawValueClass=null;
  MapWritable raw=null;
  while ((rawRecord=peer.readNext()) != null) {
    if (rawKeyClass == null && rawValueClass == null) {
      rawKeyClass=rawRecord.getKey().getClass();
      rawValueClass=rawRecord.getValue().getClass();
    }
    convertedRecord=converter.convertRecord(rawRecord,conf);
    if (convertedRecord == null) {
      throw new IOException("The converted record can't be null.");
    }
    int index=converter.getPartitionId(convertedRecord,partitioner,conf,peer,peer.getNumPeers());
    raw=new MapWritable();
    raw.put(rawRecord.getKey(),rawRecord.getValue());
    peer.send(peer.getPeerName(index),raw);
  }
  peer.sync();
  MapWritable record;
  while ((record=peer.getCurrentMessage()) != null) {
    for (    Map.Entry<Writable,Writable> e : record.entrySet()) {
      peer.write(e.getKey(),e.getValue());
    }
  }
}

ID 684=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PartitioningRunner#getPartitioner()
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(e);
}

block: 
PartitioningRunner
@SuppressWarnings("rawtypes") public Partitioner getPartitioner(){
  Class<? extends Partitioner> partitionerClass=conf.getClass(Constants.RUNTIME_PARTITIONING_CLASS,HashPartitioner.class,Partitioner.class);
  LOG.debug(Constants.RUNTIME_PARTITIONING_CLASS + ": " + partitionerClass.toString());
  Partitioner partitioner=null;
  if (PipesPartitioner.class.equals(partitionerClass)) {
    try {
      Constructor<? extends Partitioner> ctor=partitionerClass.getConstructor(Configuration.class);
      partitioner=ctor.newInstance(conf);
      this.pipesPartitioner=(PipesPartitioner)partitioner;
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
 else {
    partitioner=ReflectionUtils.newInstance(partitionerClass,conf);
  }
  return partitioner;
}

ID 685=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PartitioningRunner#getPartitioner()
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(e);
}

block: 
PartitioningRunner
@SuppressWarnings("rawtypes") public Partitioner getPartitioner(){
  Class<? extends Partitioner> partitionerClass=conf.getClass(Constants.RUNTIME_PARTITIONING_CLASS,HashPartitioner.class,Partitioner.class);
  LOG.debug(Constants.RUNTIME_PARTITIONING_CLASS + ": " + partitionerClass.toString());
  Partitioner partitioner=null;
  if (PipesPartitioner.class.equals(partitionerClass)) {
    try {
      Constructor<? extends Partitioner> ctor=partitionerClass.getConstructor(Configuration.class);
      partitioner=ctor.newInstance(conf);
      this.pipesPartitioner=(PipesPartitioner)partitioner;
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
 else {
    partitioner=ReflectionUtils.newInstance(partitionerClass,conf);
  }
  return partitioner;
}

ID 686=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PartitioningRunner#getPartitioner()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(e);
}

block: 
PartitioningRunner
@SuppressWarnings("rawtypes") public Partitioner getPartitioner(){
  Class<? extends Partitioner> partitionerClass=conf.getClass(Constants.RUNTIME_PARTITIONING_CLASS,HashPartitioner.class,Partitioner.class);
  LOG.debug(Constants.RUNTIME_PARTITIONING_CLASS + ": " + partitionerClass.toString());
  Partitioner partitioner=null;
  if (PipesPartitioner.class.equals(partitionerClass)) {
    try {
      Constructor<? extends Partitioner> ctor=partitionerClass.getConstructor(Configuration.class);
      partitioner=ctor.newInstance(conf);
      this.pipesPartitioner=(PipesPartitioner)partitioner;
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
 else {
    partitioner=ReflectionUtils.newInstance(partitionerClass,conf);
  }
  return partitioner;
}

ID 687=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PartitioningRunner#getPartitioner()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(e);
}

block: 
PartitioningRunner
@SuppressWarnings("rawtypes") public Partitioner getPartitioner(){
  Class<? extends Partitioner> partitionerClass=conf.getClass(Constants.RUNTIME_PARTITIONING_CLASS,HashPartitioner.class,Partitioner.class);
  LOG.debug(Constants.RUNTIME_PARTITIONING_CLASS + ": " + partitionerClass.toString());
  Partitioner partitioner=null;
  if (PipesPartitioner.class.equals(partitionerClass)) {
    try {
      Constructor<? extends Partitioner> ctor=partitionerClass.getConstructor(Configuration.class);
      partitioner=ctor.newInstance(conf);
      this.pipesPartitioner=(PipesPartitioner)partitioner;
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
 else {
    partitioner=ReflectionUtils.newInstance(partitionerClass,conf);
  }
  return partitioner;
}

ID 688=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PartitioningRunner#getPartitioner()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(e);
}

block: 
PartitioningRunner
@SuppressWarnings("rawtypes") public Partitioner getPartitioner(){
  Class<? extends Partitioner> partitionerClass=conf.getClass(Constants.RUNTIME_PARTITIONING_CLASS,HashPartitioner.class,Partitioner.class);
  LOG.debug(Constants.RUNTIME_PARTITIONING_CLASS + ": " + partitionerClass.toString());
  Partitioner partitioner=null;
  if (PipesPartitioner.class.equals(partitionerClass)) {
    try {
      Constructor<? extends Partitioner> ctor=partitionerClass.getConstructor(Configuration.class);
      partitioner=ctor.newInstance(conf);
      this.pipesPartitioner=(PipesPartitioner)partitioner;
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
 else {
    partitioner=ReflectionUtils.newInstance(partitionerClass,conf);
  }
  return partitioner;
}

ID 689=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.PartitioningRunner#getPartitioner()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error(e);
}

block: 
PartitioningRunner
@SuppressWarnings("rawtypes") public Partitioner getPartitioner(){
  Class<? extends Partitioner> partitionerClass=conf.getClass(Constants.RUNTIME_PARTITIONING_CLASS,HashPartitioner.class,Partitioner.class);
  LOG.debug(Constants.RUNTIME_PARTITIONING_CLASS + ": " + partitionerClass.toString());
  Partitioner partitioner=null;
  if (PipesPartitioner.class.equals(partitionerClass)) {
    try {
      Constructor<? extends Partitioner> ctor=partitionerClass.getConstructor(Configuration.class);
      partitioner=ctor.newInstance(conf);
      this.pipesPartitioner=(PipesPartitioner)partitioner;
    }
 catch (    Exception e) {
      LOG.error(e);
    }
  }
 else {
    partitioner=ReflectionUtils.newInstance(partitionerClass,conf);
  }
  return partitioner;
}

ID 690=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.PiEstimator#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PiEstimator
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {
  HamaConfiguration conf=new HamaConfiguration();
  BSPJob bsp=new BSPJob(conf,PiEstimator.class);
  bsp.setJobName("Pi Estimation Example");
  bsp.setBspClass(MyEstimator.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(DoubleWritable.class);
  bsp.setOutputFormat(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,TMP_OUTPUT);
  BSPJobClient jobClient=new BSPJobClient(conf);
  ClusterStatus cluster=jobClient.getClusterStatus(true);
  if (args.length > 0) {
    bsp.setNumBspTask(Integer.parseInt(args[0]));
  }
 else {
    bsp.setNumBspTask(cluster.getMaxTasks());
  }
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    printOutput(conf);
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 691=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.PiEstimator#main(java.lang.String[])
Rmethod: org.apache.hama.examples.PiEstimator#printOutput(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PiEstimator
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {
  HamaConfiguration conf=new HamaConfiguration();
  BSPJob bsp=new BSPJob(conf,PiEstimator.class);
  bsp.setJobName("Pi Estimation Example");
  bsp.setBspClass(MyEstimator.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(DoubleWritable.class);
  bsp.setOutputFormat(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,TMP_OUTPUT);
  BSPJobClient jobClient=new BSPJobClient(conf);
  ClusterStatus cluster=jobClient.getClusterStatus(true);
  if (args.length > 0) {
    bsp.setNumBspTask(Integer.parseInt(args[0]));
  }
 else {
    bsp.setNumBspTask(cluster.getMaxTasks());
  }
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    printOutput(conf);
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 692=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#setupEnvironment(Configuration)
Rmethod: java.net.ServerSocket#ServerSocket(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PipesApplication
public Map<String,String> setupEnvironment(Configuration conf) throws IOException {
  Map<String,String> env=new HashMap<String,String>();
  this.streamingEnabled=conf.getBoolean("hama.streaming.enabled",false);
  if (!this.streamingEnabled) {
    serverSocket=new ServerSocket(0);
    env.put("hama.pipes.command.port",Integer.toString(serverSocket.getLocalPort()));
  }
  env.put("TMPDIR",System.getProperty("java.io.tmpdir"));
  env.put("hama.pipes.logging",conf.getBoolean("hama.pipes.logging",false) ? "1" : "0");
  return env;
}

ID 693=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: org.apache.hama.pipes.PipesApplication#setupEnvironment(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 694=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: org.apache.hama.pipes.PipesApplication#setupCommand(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 695=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: org.apache.hama.pipes.PipesApplication#setupCommand(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 696=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: org.apache.hama.pipes.PipesApplication#runClient(List<java.lang.String>, Map<java.lang.String,java.lang.String>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 697=========================================================================type: Rethrow
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: java.net.ServerSocket#setSoTimeout(int)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
catch (SocketException e) {
  BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
  String inputLine;
  while ((inputLine=br.readLine()) != null) {
    LOG.error("PipesApp Error: " + inputLine);
  }
  br.close();
  throw new SocketException("Timout: Client pipes application did not connect!");
}

block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 698=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: java.net.ServerSocket#accept()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 699=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: java.net.Socket#getOutputStream()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 700=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: java.net.Socket#getInputStream()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 701=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 702=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 703=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(Configuration)
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us. Peer is not available now, start child by using only the configuration! e.g., PipesPartitioner, no peer is available at this time!
 * @param conf task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
public void start(Configuration conf) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(conf);
  List<String> cmd=setupCommand(conf);
  File stdout=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDOUT,"yyyyMMdd'_partitioner_'HHmmss");
  File stderr=TaskLog.getLocalTaskLogFile(TaskLog.LogName.STDERR,"yyyyMMdd'_partitioner_'HHmmss");
  long logLength=TaskLog.getTaskLogLength(conf);
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (!streamingEnabled) {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(conf,clientSocket.getOutputStream(),clientSocket.getInputStream());
      downlink.start();
    }
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 704=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: org.apache.hama.pipes.PipesApplication#setupEnvironment(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 705=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: org.apache.hama.pipes.PipesApplication#setupCommand(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 706=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: org.apache.hama.pipes.PipesApplication#setupCommand(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 707=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: org.apache.hama.pipes.PipesApplication#runClient(List<java.lang.String>, Map<java.lang.String,java.lang.String>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 708=========================================================================type: Rethrow
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.net.ServerSocket#setSoTimeout(int)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
catch (SocketException e) {
  BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
  String inputLine;
  while ((inputLine=br.readLine()) != null) {
    LOG.error("PipesApp Error: " + inputLine);
  }
  br.close();
  throw new SocketException("Timout: Client pipes application did not connect!");
}

block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 709=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.net.ServerSocket#accept()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 710=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.net.Socket#getOutputStream()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 711=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.net.Socket#getInputStream()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 712=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 713=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 714=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#start(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Start the child process to handle the task for us.
 * @param peer the current peer including the task's configuration
 * @throws InterruptedException
 * @throws IOException
 */
@SuppressWarnings({"rawtypes","unchecked"}) public void start(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, InterruptedException {
  Map<String,String> env=setupEnvironment(peer.getConfiguration());
  List<String> cmd=setupCommand(peer.getConfiguration());
  TaskAttemptID taskid=peer.getTaskId();
  File stdout=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDOUT);
  File stderr=TaskLog.getTaskLogFile(taskid,TaskLog.LogName.STDERR);
  long logLength=TaskLog.getTaskLogLength(peer.getConfiguration());
  if (!streamingEnabled) {
    cmd=TaskLog.captureOutAndError(null,cmd,stdout,stderr,logLength);
  }
 else {
    cmd=TaskLog.captureOutAndErrorTee(null,cmd,stdout,stderr,logLength);
  }
  checkParentFile(stdout);
  LOG.debug("STDOUT: " + stdout.getAbsolutePath());
  checkParentFile(stderr);
  LOG.debug("STDERR: " + stderr.getAbsolutePath());
  LOG.debug("DEBUG: cmd: " + cmd);
  process=runClient(cmd,env);
  try {
    if (streamingEnabled) {
      downlink=new StreamingProtocol(peer,process.getOutputStream(),process.getInputStream());
    }
 else {
      LOG.debug("DEBUG: waiting for Client at " + serverSocket.getLocalSocketAddress());
      serverSocket.setSoTimeout(SERVER_SOCKET_TIMEOUT);
      clientSocket=serverSocket.accept();
      LOG.debug("DEBUG: Client connected! - start BinaryProtocol!");
      downlink=new BinaryProtocol<K1,V1,K2,V2,M>(peer,clientSocket.getOutputStream(),clientSocket.getInputStream());
    }
    downlink.start();
  }
 catch (  SocketException e) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(stderr)));
    String inputLine;
    while ((inputLine=br.readLine()) != null) {
      LOG.error("PipesApp Error: " + inputLine);
    }
    br.close();
    throw new SocketException("Timout: Client pipes application did not connect!");
  }
}

ID 715=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#cleanup(boolean)
Rmethod: java.net.ServerSocket#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Clean up the child process and socket if exist.
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Clean up the child process and socket if exist.
 * @throws IOException
 */
public void cleanup(boolean sendClose) throws IOException {
  if (serverSocket != null) {
    serverSocket.close();
  }
  try {
    if ((downlink != null) && (sendClose)) {
      downlink.close();
    }
  }
 catch (  InterruptedException ie) {
    Thread.currentThread().interrupt();
  }
}

ID 716=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesApplication#runClient(List<java.lang.String>, Map<java.lang.String,java.lang.String>)
Rmethod: java.lang.ProcessBuilder#start()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Run a given command in a subprocess, including threads to copy its stdout and stderr to our stdout and stderr.
 * @param command the command and its arguments
 * @param env the environment to run the process in
 * @return a handle on the process
 * @throws IOException
 */

catch: 
null
block: 
PipesApplication
/** 
 * Run a given command in a subprocess, including threads to copy its stdout and stderr to our stdout and stderr.
 * @param command the command and its arguments
 * @param env the environment to run the process in
 * @return a handle on the process
 * @throws IOException
 */
static Process runClient(List<String> command,Map<String,String> env) throws IOException {
  ProcessBuilder builder=new ProcessBuilder(command);
  if (env != null) {
    builder.environment().putAll(env);
  }
  Process result=builder.start();
  return result;
}

ID 717=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.PipesNonJavaInputFormat#getRecordReader(InputSplit, BSPJob)
Rmethod: org.apache.hama.pipes.PipesDummyRecordReader#PipesDummyRecordReader(Configuration, InputSplit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PipesNonJavaInputFormat
@Override public RecordReader<FloatWritable,NullWritable> getRecordReader(InputSplit genericSplit,BSPJob job) throws IOException {
  return new PipesDummyRecordReader(job.getConfiguration(),genericSplit);
}

ID 718=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.PipesVectorWritable#write(java.io.DataOutput)
Rmethod: org.apache.hama.commons.io.PipesVectorWritable#writeVector(DoubleVector, java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PipesVectorWritable
@Override public final void write(DataOutput out) throws IOException {
  writeVector(super.getVector(),out);
}

ID 719=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.PipesVectorWritable#readFields(java.io.DataInput)
Rmethod: org.apache.hama.commons.io.PipesVectorWritable#readVector(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PipesVectorWritable
@Override public final void readFields(DataInput in) throws IOException {
  super.set(readVector(in));
}

ID 720=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.PipesVectorWritable#readVector(java.io.DataInput)
Rmethod: java.lang.Double#parseDouble(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
PipesVectorWritable
public static DoubleVector readVector(DataInput in) throws IOException {
  String str=Text.readString(in);
  String[] values=str.split(",");
  int len=values.length;
  DoubleVector vector=new DenseDoubleVector(len);
  for (int i=0; i < len; i++) {
    vector.set(i,Double.parseDouble(values[i]));
  }
  return vector;
}

ID 721=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDescription#ProgramDescription(Class<?>, java.lang.String)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: /** 
 * Create a description of an example program.
 * @param mainClass the class with the main for the example program
 * @param description a string to display to the user in help messages
 * @throws SecurityException if we can't use reflection
 * @throws NoSuchMethodException if the class doesn't have a main method
 */

catch: 
null
block: 
ProgramDescription
/** 
 * Create a description of an example program.
 * @param mainClass the class with the main for the example program
 * @param description a string to display to the user in help messages
 * @throws SecurityException if we can't use reflection
 * @throws NoSuchMethodException if the class doesn't have a main method
 */
public ProgramDescription(Class<?> mainClass,String description) throws SecurityException, NoSuchMethodException {
  this.main=mainClass.getMethod("main",paramTypes);
  this.description=description;
}

ID 722=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDescription#ProgramDescription(Class<?>, java.lang.String)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * Create a description of an example program.
 * @param mainClass the class with the main for the example program
 * @param description a string to display to the user in help messages
 * @throws SecurityException if we can't use reflection
 * @throws NoSuchMethodException if the class doesn't have a main method
 */

catch: 
null
block: 
ProgramDescription
/** 
 * Create a description of an example program.
 * @param mainClass the class with the main for the example program
 * @param description a string to display to the user in help messages
 * @throws SecurityException if we can't use reflection
 * @throws NoSuchMethodException if the class doesn't have a main method
 */
public ProgramDescription(Class<?> mainClass,String description) throws SecurityException, NoSuchMethodException {
  this.main=mainClass.getMethod("main",paramTypes);
  this.description=description;
}

ID 723=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDescription#invoke(java.lang.String[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * Invoke the example application with the given arguments
 * @param args the arguments for the application
 * @throws Throwable The exception thrown by the invoked method
 */

catch: 
null
block: 
ProgramDescription
/** 
 * Invoke the example application with the given arguments
 * @param args the arguments for the application
 * @throws Throwable The exception thrown by the invoked method
 */
public void invoke(String[] args) throws Throwable {
  try {
    main.invoke(null,new Object[]{args});
  }
 catch (  InvocationTargetException except) {
    throw except.getCause();
  }
}

ID 724=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDescription#invoke(java.lang.String[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Invoke the example application with the given arguments
 * @param args the arguments for the application
 * @throws Throwable The exception thrown by the invoked method
 */

catch: 
null
block: 
ProgramDescription
/** 
 * Invoke the example application with the given arguments
 * @param args the arguments for the application
 * @throws Throwable The exception thrown by the invoked method
 */
public void invoke(String[] args) throws Throwable {
  try {
    main.invoke(null,new Object[]{args});
  }
 catch (  InvocationTargetException except) {
    throw except.getCause();
  }
}

ID 725=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDescription#invoke(java.lang.String[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: /** 
 * Invoke the example application with the given arguments
 * @param args the arguments for the application
 * @throws Throwable The exception thrown by the invoked method
 */

catch: 
catch (InvocationTargetException except) {
  throw except.getCause();
}

block: 
ProgramDescription
/** 
 * Invoke the example application with the given arguments
 * @param args the arguments for the application
 * @throws Throwable The exception thrown by the invoked method
 */
public void invoke(String[] args) throws Throwable {
  try {
    main.invoke(null,new Object[]{args});
  }
 catch (  InvocationTargetException except) {
    throw except.getCause();
  }
}

ID 726=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDriver#addClass(java.lang.String, Class#RAW, java.lang.String)
Rmethod: org.apache.hama.util.ProgramDescription#ProgramDescription(Class<?>, java.lang.String)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * This is the method that adds the classed to the repository
 * @param name The name of the string you want the class instance to be called with
 * @param mainClass The class that you want to add to the repository
 * @param description The description of the class
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 */

catch: 
null
block: 
ProgramDriver
/** 
 * This is the method that adds the classed to the repository
 * @param name The name of the string you want the class instance to be called with
 * @param mainClass The class that you want to add to the repository
 * @param description The description of the class
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 */
@SuppressWarnings("rawtypes") public void addClass(String name,Class mainClass,String description) throws Throwable {
  programs.put(name,new ProgramDescription(mainClass,description));
}

ID 727=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDriver#addClass(java.lang.String, Class#RAW, java.lang.String)
Rmethod: org.apache.hama.util.ProgramDescription#ProgramDescription(Class<?>, java.lang.String)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: /** 
 * This is the method that adds the classed to the repository
 * @param name The name of the string you want the class instance to be called with
 * @param mainClass The class that you want to add to the repository
 * @param description The description of the class
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 */

catch: 
null
block: 
ProgramDriver
/** 
 * This is the method that adds the classed to the repository
 * @param name The name of the string you want the class instance to be called with
 * @param mainClass The class that you want to add to the repository
 * @param description The description of the class
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 */
@SuppressWarnings("rawtypes") public void addClass(String name,Class mainClass,String description) throws Throwable {
  programs.put(name,new ProgramDescription(mainClass,description));
}

ID 728=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ProgramDriver#driver(java.lang.String[])
Rmethod: org.apache.hama.util.ProgramDescription#invoke(java.lang.String[])
hasForStatement: false
parentException: 
thrown: java.lang.Throwable
exception comment: null
method comment: /** 
 * This is a driver for the example programs. It looks at the first command line argument and tries to find an example program with that name. If it is found, it calls the main method in that class with the rest  of the command line arguments.
 * @param args The argument from the user. args[0] is the command to run.
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 * @throws IllegalAccessException 
 * @throws IllegalArgumentException 
 * @throws Throwable Anything thrown by the example program's main
 */

catch: 
null
block: 
ProgramDriver
/** 
 * This is a driver for the example programs. It looks at the first command line argument and tries to find an example program with that name. If it is found, it calls the main method in that class with the rest  of the command line arguments.
 * @param args The argument from the user. args[0] is the command to run.
 * @throws NoSuchMethodException 
 * @throws SecurityException 
 * @throws IllegalAccessException 
 * @throws IllegalArgumentException 
 * @throws Throwable Anything thrown by the example program's main
 */
public void driver(String[] args) throws Throwable {
  if (args.length == 0) {
    System.out.println("An example program must be given as the" + " first argument.");
    printUsage(programs);
    System.exit(-1);
  }
  ProgramDescription pgm=programs.get(args[0]);
  if (pgm == null) {
    System.out.println("Unknown program '" + args[0] + "' chosen.");
    printUsage(programs);
    System.exit(-1);
  }
  String[] new_args=new String[args.length - 1];
  for (int i=1; i < args.length; ++i) {
    new_args[i - 1]=args[i];
  }
  pgm.invoke(new_args);
}

ID 729=========================================================================type: Ignore_Log
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#run(Configuration)
Rmethod: org.apache.hama.zookeeper.QuorumPeer#runZooKeeper(Configuration)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer. This method checks if we are in localmode to prevent zookeeper from starting.
 * @param baseConf Hadoop Configuration.
 */

catch: 
catch (Exception e) {
  LOG.error("Exception during ZooKeeper startup - exiting...",e);
  System.exit(-1);
}

block: 
QuorumPeer
/** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer. This method checks if we are in localmode to prevent zookeeper from starting.
 * @param baseConf Hadoop Configuration.
 */
public static void run(Configuration baseConf){
  Configuration conf=new HamaConfiguration(baseConf);
  if (BSPMaster.getAddress(conf) == null) {
    System.out.println(BSPMaster.localModeMessage);
    LOG.info(BSPMaster.localModeMessage);
    System.exit(0);
  }
  try {
    runZooKeeper(conf);
  }
 catch (  Exception e) {
    LOG.error("Exception during ZooKeeper startup - exiting...",e);
    System.exit(-1);
  }
}

ID 730=========================================================================type: only_throws
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#runZooKeeper(Configuration)
Rmethod: org.apache.hama.zookeeper.QuorumPeer#writeMyID(java.util.Properties)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer.
 * @param conf Hadoop Configuration.
 */

catch: 
null
block: 
QuorumPeer
/** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer.
 * @param conf Hadoop Configuration.
 */
public static void runZooKeeper(Configuration conf) throws Exception {
  Properties zkProperties=makeZKProps(conf);
  writeMyID(zkProperties);
  QuorumPeerConfig zkConfig=new QuorumPeerConfig();
  zkConfig.parseProperties(zkProperties);
  runZKServer(zkConfig);
}

ID 731=========================================================================type: only_throws
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#runZooKeeper(Configuration)
Rmethod: org.apache.hama.zookeeper.QuorumPeer#runZKServer(QuorumPeerConfig)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

method comment: /** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer.
 * @param conf Hadoop Configuration.
 */

catch: 
null
block: 
QuorumPeer
/** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer.
 * @param conf Hadoop Configuration.
 */
public static void runZooKeeper(Configuration conf) throws Exception {
  Properties zkProperties=makeZKProps(conf);
  writeMyID(zkProperties);
  QuorumPeerConfig zkConfig=new QuorumPeerConfig();
  zkConfig.parseProperties(zkProperties);
  runZKServer(zkConfig);
}

ID 732=========================================================================type: only_throws
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#runZooKeeper(Configuration)
Rmethod: org.apache.hama.zookeeper.QuorumPeer#runZKServer(QuorumPeerConfig)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer.
 * @param conf Hadoop Configuration.
 */

catch: 
null
block: 
QuorumPeer
/** 
 * Parse ZooKeeper configuration from Hama XML config and run a QuorumPeer.
 * @param conf Hadoop Configuration.
 */
public static void runZooKeeper(Configuration conf) throws Exception {
  Properties zkProperties=makeZKProps(conf);
  writeMyID(zkProperties);
  QuorumPeerConfig zkConfig=new QuorumPeerConfig();
  zkConfig.parseProperties(zkProperties);
  runZKServer(zkConfig);
}

ID 733=========================================================================type: only_throws
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#runShutdownableZooKeeper(Configuration)
Rmethod: org.apache.hama.zookeeper.QuorumPeer#writeMyID(java.util.Properties)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Runs a shutdownable Zookeeper main server. This does not work with multiple quorums!
 * @param conf the configuration to be used to start ZK
 * @return a <code>ZookeeperTuple</code>
 * @throws Exception
 */

catch: 
null
block: 
QuorumPeer
/** 
 * Runs a shutdownable Zookeeper main server. This does not work with multiple quorums!
 * @param conf the configuration to be used to start ZK
 * @return a <code>ZookeeperTuple</code>
 * @throws Exception
 */
public static ZookeeperTuple runShutdownableZooKeeper(Configuration conf) throws Exception {
  Properties zkProperties=makeZKProps(conf);
  writeMyID(zkProperties);
  QuorumPeerConfig zkConfig=new QuorumPeerConfig();
  zkConfig.parseProperties(zkProperties);
  ShutdownableZooKeeperServerMain zk=new ShutdownableZooKeeperServerMain();
  ServerConfig serverConfig=new ServerConfig();
  serverConfig.readFrom(zkConfig);
  return new ZookeeperTuple(zk,serverConfig);
}

ID 734=========================================================================type: only_throws
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#writeMyID(java.util.Properties)
Rmethod: java.net.NetworkInterface#getNetworkInterfaces()
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
QuorumPeer
private static void writeMyID(Properties properties) throws IOException {
  long myId=-1;
  Configuration conf=new HamaConfiguration();
  String myAddress=DNS.getDefaultHost(conf.get("hama.zookeeper.dns.interface","default"),conf.get("hama.zookeeper.dns.nameserver","default"));
  List<String> ips=new ArrayList<String>();
  ips.add(myAddress.contains(".") ? myAddress : StringUtils.simpleHostname(myAddress));
  Enumeration<?> nics=NetworkInterface.getNetworkInterfaces();
  while (nics.hasMoreElements()) {
    Enumeration<?> rawAdrs=((NetworkInterface)nics.nextElement()).getInetAddresses();
    while (rawAdrs.hasMoreElements()) {
      InetAddress inet=(InetAddress)rawAdrs.nextElement();
      ips.add(StringUtils.simpleHostname(inet.getHostName()));
      ips.add(inet.getHostAddress());
    }
  }
  for (  Entry<Object,Object> entry : properties.entrySet()) {
    String key=entry.getKey().toString().trim();
    String value=entry.getValue().toString().trim();
    if (key.startsWith("server.")) {
      int dot=key.indexOf('.');
      long id=Long.parseLong(key.substring(dot + 1));
      String[] parts=value.split(":");
      String address=parts[0];
      if (addressIsLocalHost(address) || ips.contains(address)) {
        myId=id;
        break;
      }
    }
  }
  if (myId == -1) {
    throw new IOException("Could not find my address: " + myAddress + " in list of ZooKeeper quorum servers");
  }
  String dataDirStr=properties.get("dataDir").toString().trim();
  File dataDir=new File(dataDirStr);
  if (!dataDir.isDirectory()) {
    if (!dataDir.mkdirs()) {
      throw new IOException("Unable to create data dir " + dataDir);
    }
  }
  File myIdFile=new File(dataDir,"myid");
  PrintWriter w=new PrintWriter(myIdFile);
  w.println(myId);
  w.close();
}

ID 735=========================================================================type: only_throws
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#writeMyID(java.util.Properties)
Rmethod: java.lang.Long#parseLong(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
QuorumPeer
private static void writeMyID(Properties properties) throws IOException {
  long myId=-1;
  Configuration conf=new HamaConfiguration();
  String myAddress=DNS.getDefaultHost(conf.get("hama.zookeeper.dns.interface","default"),conf.get("hama.zookeeper.dns.nameserver","default"));
  List<String> ips=new ArrayList<String>();
  ips.add(myAddress.contains(".") ? myAddress : StringUtils.simpleHostname(myAddress));
  Enumeration<?> nics=NetworkInterface.getNetworkInterfaces();
  while (nics.hasMoreElements()) {
    Enumeration<?> rawAdrs=((NetworkInterface)nics.nextElement()).getInetAddresses();
    while (rawAdrs.hasMoreElements()) {
      InetAddress inet=(InetAddress)rawAdrs.nextElement();
      ips.add(StringUtils.simpleHostname(inet.getHostName()));
      ips.add(inet.getHostAddress());
    }
  }
  for (  Entry<Object,Object> entry : properties.entrySet()) {
    String key=entry.getKey().toString().trim();
    String value=entry.getValue().toString().trim();
    if (key.startsWith("server.")) {
      int dot=key.indexOf('.');
      long id=Long.parseLong(key.substring(dot + 1));
      String[] parts=value.split(":");
      String address=parts[0];
      if (addressIsLocalHost(address) || ips.contains(address)) {
        myId=id;
        break;
      }
    }
  }
  if (myId == -1) {
    throw new IOException("Could not find my address: " + myAddress + " in list of ZooKeeper quorum servers");
  }
  String dataDirStr=properties.get("dataDir").toString().trim();
  File dataDir=new File(dataDirStr);
  if (!dataDir.isDirectory()) {
    if (!dataDir.mkdirs()) {
      throw new IOException("Unable to create data dir " + dataDir);
    }
  }
  File myIdFile=new File(dataDir,"myid");
  PrintWriter w=new PrintWriter(myIdFile);
  w.println(myId);
  w.close();
}

ID 736=========================================================================type: only_throws
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#writeMyID(java.util.Properties)
Rmethod: java.io.PrintWriter#PrintWriter(java.io.File)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
QuorumPeer
private static void writeMyID(Properties properties) throws IOException {
  long myId=-1;
  Configuration conf=new HamaConfiguration();
  String myAddress=DNS.getDefaultHost(conf.get("hama.zookeeper.dns.interface","default"),conf.get("hama.zookeeper.dns.nameserver","default"));
  List<String> ips=new ArrayList<String>();
  ips.add(myAddress.contains(".") ? myAddress : StringUtils.simpleHostname(myAddress));
  Enumeration<?> nics=NetworkInterface.getNetworkInterfaces();
  while (nics.hasMoreElements()) {
    Enumeration<?> rawAdrs=((NetworkInterface)nics.nextElement()).getInetAddresses();
    while (rawAdrs.hasMoreElements()) {
      InetAddress inet=(InetAddress)rawAdrs.nextElement();
      ips.add(StringUtils.simpleHostname(inet.getHostName()));
      ips.add(inet.getHostAddress());
    }
  }
  for (  Entry<Object,Object> entry : properties.entrySet()) {
    String key=entry.getKey().toString().trim();
    String value=entry.getValue().toString().trim();
    if (key.startsWith("server.")) {
      int dot=key.indexOf('.');
      long id=Long.parseLong(key.substring(dot + 1));
      String[] parts=value.split(":");
      String address=parts[0];
      if (addressIsLocalHost(address) || ips.contains(address)) {
        myId=id;
        break;
      }
    }
  }
  if (myId == -1) {
    throw new IOException("Could not find my address: " + myAddress + " in list of ZooKeeper quorum servers");
  }
  String dataDirStr=properties.get("dataDir").toString().trim();
  File dataDir=new File(dataDirStr);
  if (!dataDir.isDirectory()) {
    if (!dataDir.mkdirs()) {
      throw new IOException("Unable to create data dir " + dataDir);
    }
  }
  File myIdFile=new File(dataDir,"myid");
  PrintWriter w=new PrintWriter(myIdFile);
  w.println(myId);
  w.close();
}

ID 737=========================================================================type: Ignore_Log
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#makeZKProps(Configuration)
Rmethod: org.apache.hama.zookeeper.QuorumPeer#parseZooCfg(Configuration, java.io.InputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Make a Properties object holding ZooKeeper config equivalent to zoo.cfg. If there is a zoo.cfg in the classpath, simply read it in. Otherwise parse the corresponding config options from the Hama XML configs and generate the appropriate ZooKeeper properties.
 * @param conf Configuration to read from.
 * @return Properties holding mappings representing ZooKeeper zoo.cfg file.
 */

catch: 
catch (IOException e) {
  LOG.warn("Cannot read " + ZOOKEEPER_CONFIG_NAME + ", loading from XML files",e);
}

block: 
QuorumPeer
/** 
 * Make a Properties object holding ZooKeeper config equivalent to zoo.cfg. If there is a zoo.cfg in the classpath, simply read it in. Otherwise parse the corresponding config options from the Hama XML configs and generate the appropriate ZooKeeper properties.
 * @param conf Configuration to read from.
 * @return Properties holding mappings representing ZooKeeper zoo.cfg file.
 */
public static Properties makeZKProps(Configuration conf){
  ClassLoader cl=QuorumPeer.class.getClassLoader();
  InputStream inputStream=cl.getResourceAsStream(ZOOKEEPER_CONFIG_NAME);
  if (inputStream != null) {
    try {
      return parseZooCfg(conf,inputStream);
    }
 catch (    IOException e) {
      LOG.warn("Cannot read " + ZOOKEEPER_CONFIG_NAME + ", loading from XML files",e);
    }
  }
  Properties zkProperties=new Properties();
  zkProperties.setProperty("maxSessionTimeout",conf.get(Constants.ZOOKEEPER_SESSION_TIMEOUT,"1200000"));
  for (  Entry<String,String> entry : conf) {
    String key=entry.getKey();
    if (key.startsWith(ZK_CFG_PROPERTY)) {
      String zkKey=key.substring(ZK_CFG_PROPERTY_SIZE);
      String value=entry.getValue();
      if (value.contains(VARIABLE_START)) {
        value=conf.get(key);
      }
      zkProperties.put(zkKey,value);
    }
  }
  if (zkProperties.getProperty(ZOOKEEPER_CLIENT_PORT) == null) {
    zkProperties.put(ZOOKEEPER_CLIENT_PORT,DEFAULT_ZOOKEEPER_CLIENT_PORT);
  }
  int peerPort=conf.getInt("hama.zookeeper.peerport",2888);
  int leaderPort=conf.getInt("hama.zookeeper.leaderport",3888);
  String[] serverHosts=conf.getStrings(ZOOKEEPER_QUORUM,"localhost");
  for (int i=0; i < serverHosts.length; ++i) {
    String serverHost=serverHosts[i];
    String address=serverHost + ":" + peerPort+ ":"+ leaderPort;
    String key="server." + i;
    zkProperties.put(key,address);
  }
  return zkProperties;
}

ID 738=========================================================================type: Rethrow
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#parseZooCfg(Configuration, java.io.InputStream)
Rmethod: java.util.Properties#load(java.io.InputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Parse ZooKeeper's zoo.cfg, injecting Hama Configuration variables in. This method is used for testing so we can pass our own InputStream.
 * @param conf Configuration to use for injecting variables.
 * @param inputStream InputStream to read from.
 * @return Properties parsed from config stream with variables substituted.
 * @throws IOException if anything goes wrong parsing config
 */

catch: 
catch (IOException e) {
  String msg="fail to read properties from " + ZOOKEEPER_CONFIG_NAME;
  LOG.fatal(msg);
  throw new IOException(msg,e);
}

block: 
QuorumPeer
/** 
 * Parse ZooKeeper's zoo.cfg, injecting Hama Configuration variables in. This method is used for testing so we can pass our own InputStream.
 * @param conf Configuration to use for injecting variables.
 * @param inputStream InputStream to read from.
 * @return Properties parsed from config stream with variables substituted.
 * @throws IOException if anything goes wrong parsing config
 */
public static Properties parseZooCfg(Configuration conf,InputStream inputStream) throws IOException {
  Properties properties=new Properties();
  try {
    properties.load(inputStream);
  }
 catch (  IOException e) {
    String msg="fail to read properties from " + ZOOKEEPER_CONFIG_NAME;
    LOG.fatal(msg);
    throw new IOException(msg,e);
  }
  for (  Entry<Object,Object> entry : properties.entrySet()) {
    String value=entry.getValue().toString().trim();
    String key=entry.getKey().toString().trim();
    StringBuilder newValue=new StringBuilder();
    int varStart=value.indexOf(VARIABLE_START);
    int varEnd=0;
    while (varStart != -1) {
      varEnd=value.indexOf(VARIABLE_END,varStart);
      if (varEnd == -1) {
        String msg="variable at " + varStart + " has no end marker";
        LOG.fatal(msg);
        throw new IOException(msg);
      }
      String variable=value.substring(varStart + VARIABLE_START_LENGTH,varEnd);
      String substituteValue=System.getProperty(variable);
      if (substituteValue == null) {
        substituteValue=conf.get(variable);
      }
      if (substituteValue == null) {
        String msg="variable " + variable + " not set in system property "+ "or hama configs";
        LOG.fatal(msg);
        throw new IOException(msg);
      }
      newValue.append(substituteValue);
      varEnd+=VARIABLE_END_LENGTH;
      varStart=value.indexOf(VARIABLE_START,varEnd);
    }
    if (key.startsWith("server.")) {
      if (conf.get(CLUSTER_DISTRIBUTED).equals(CLUSTER_IS_DISTRIBUTED) && value.startsWith("localhost")) {
        String msg="The server in zoo.cfg cannot be set to localhost " + "in a fully-distributed setup because it won't be reachable. " + "See \"Getting Started\" for more information.";
        LOG.fatal(msg);
        throw new IOException(msg);
      }
    }
    newValue.append(value.substring(varEnd));
    properties.setProperty(key,newValue.toString());
  }
  return properties;
}

ID 739=========================================================================type: Ignore_Log
package: org.apache.hama.zookeeper
Method:org.apache.hama.zookeeper.QuorumPeer#getZKQuorumServersString(java.util.Properties)
Rmethod: java.net.InetAddress#getByName(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

method comment: /** 
 * Return the ZK Quorum servers string given zk properties returned by makeZKProps
 * @param properties the ZK properties
 * @return Quorum servers String
 */

catch: 
catch (UnknownHostException e) {
  LOG.warn(StringUtils.stringifyException(e));
}

block: 
QuorumPeer
/** 
 * Return the ZK Quorum servers string given zk properties returned by makeZKProps
 * @param properties the ZK properties
 * @return Quorum servers String
 */
public static String getZKQuorumServersString(Properties properties){
  String clientPort=null;
  List<String> servers=new ArrayList<String>();
  boolean anyValid=false;
  for (  Entry<Object,Object> property : properties.entrySet()) {
    String key=property.getKey().toString().trim();
    String value=property.getValue().toString().trim();
    if (key.equals("clientPort")) {
      clientPort=value;
    }
 else     if (key.startsWith("server.")) {
      String host=value.substring(0,value.indexOf(':'));
      servers.add(host);
      try {
        InetAddress.getByName(host);
        anyValid=true;
      }
 catch (      UnknownHostException e) {
        LOG.warn(StringUtils.stringifyException(e));
      }
    }
  }
  if (!anyValid) {
    LOG.error("no valid quorum servers found in " + Constants.ZOOKEEPER_CONFIG_NAME);
    return null;
  }
  if (clientPort == null) {
    LOG.error("no clientPort found in " + Constants.ZOOKEEPER_CONFIG_NAME);
    return null;
  }
  if (servers.isEmpty()) {
    LOG.fatal("No server.X lines found in conf/zoo.cfg. Hama must have a " + "ZooKeeper cluster configured for its operation.");
    return null;
  }
  StringBuilder hostPortBuilder=new StringBuilder();
  for (int i=0; i < servers.size(); ++i) {
    String host=servers.get(i);
    if (i > 0) {
      hostPortBuilder.append(',');
    }
    hostPortBuilder.append(host);
    hostPortBuilder.append(':');
    hostPortBuilder.append(clientPort);
  }
  return hostPortBuilder.toString();
}

ID 740=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.RandBench#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RandBench
public static void main(String[] args) throws Exception {
  if (args.length < 3) {
    System.out.println("Usage: <sizeOfMsg> <nCommunications> <nSupersteps>");
    System.exit(-1);
  }
  HamaConfiguration conf=new HamaConfiguration();
  conf.setInt(SIZEOFMSG,Integer.parseInt(args[0]));
  conf.setInt(N_COMMUNICATIONS,Integer.parseInt(args[1]));
  conf.setInt(N_SUPERSTEPS,Integer.parseInt(args[2]));
  BSPJob bsp=new BSPJob(conf,RandBench.class);
  bsp.setJobName("Random Communication Benchmark");
  bsp.setBspClass(RandBSP.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputFormat(NullOutputFormat.class);
  BSPJobClient jobClient=new BSPJobClient(conf);
  ClusterStatus cluster=jobClient.getClusterStatus(false);
  bsp.setNumBspTask(cluster.getMaxTasks());
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 741=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(String className) throws ClassNotFoundException {
  return newInstance((Class<T>)Class.forName(className));
}

ID 742=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>)
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(Class<T> theClass){
  Preconditions.checkNotNull(theClass);
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(new Class[0]);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 743=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>)
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(Class<T> theClass){
  Preconditions.checkNotNull(theClass);
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(new Class[0]);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 744=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>)
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(Class<T> theClass){
  Preconditions.checkNotNull(theClass);
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(new Class[0]);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 745=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(Class<T> theClass){
  Preconditions.checkNotNull(theClass);
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(new Class[0]);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 746=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(Class<T> theClass){
  Preconditions.checkNotNull(theClass);
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(new Class[0]);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 747=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(Class<T> theClass){
  Preconditions.checkNotNull(theClass);
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(new Class[0]);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 748=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: null
catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
@SuppressWarnings("unchecked") public static <T>T newInstance(Class<T> theClass){
  Preconditions.checkNotNull(theClass);
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(new Class[0]);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 749=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(java.lang.String, java.lang.Object[])
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance using class literal name and object values supplied.
 * @param className is the string name of the class to be created.
 * @param values supplied in object array.
 * @exception ClassNotFoundException
 */

catch: 
null
block: 
ReflectionUtils
/** 
 * Create an instance using class literal name and object values supplied.
 * @param className is the string name of the class to be created.
 * @param values supplied in object array.
 * @exception ClassNotFoundException
 */
@SuppressWarnings("unchecked") public static <T>T newInstance(String className,Object[] values) throws ClassNotFoundException {
  return newInstance((Class<T>)Class.forName(className),values);
}

ID 750=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, java.lang.Object[])
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      Class[] parameters=new Class[values.length];
      int idx=0;
      for (      Object value : values) {
        parameters[idx++]=value.getClass();
      }
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 751=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, java.lang.Object[])
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      Class[] parameters=new Class[values.length];
      int idx=0;
      for (      Object value : values) {
        parameters[idx++]=value.getClass();
      }
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 752=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, java.lang.Object[])
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      Class[] parameters=new Class[values.length];
      int idx=0;
      for (      Object value : values) {
        parameters[idx++]=value.getClass();
      }
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 753=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      Class[] parameters=new Class[values.length];
      int idx=0;
      for (      Object value : values) {
        parameters[idx++]=value.getClass();
      }
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 754=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      Class[] parameters=new Class[values.length];
      int idx=0;
      for (      Object value : values) {
        parameters[idx++]=value.getClass();
      }
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 755=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      Class[] parameters=new Class[values.length];
      int idx=0;
      for (      Object value : values) {
        parameters[idx++]=value.getClass();
      }
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 756=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      Class[] parameters=new Class[values.length];
      int idx=0;
      for (      Object value : values) {
        parameters[idx++]=value.getClass();
      }
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 757=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Class[] parameters,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 758=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.Class#getDeclaredConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Class[] parameters,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 759=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Class[] parameters,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 760=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Class[] parameters,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 761=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Class[] parameters,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 762=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Class[] parameters,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 763=========================================================================type: Rethrow
package: org.apache.hama.util
Method:org.apache.hama.util.ReflectionUtils#newInstance(Class<T>, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: /** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */

catch: 
catch (Exception e) {
  throw new RuntimeException(e);
}

block: 
ReflectionUtils
/** 
 * Create an instance with corresponded class and object values supplied. Constructor
 * @param theClass supplies instance to be created.
 * @param parameters are class type of object values supplied.
 * @param values are parameters applied when instance is created.
 */
@SuppressWarnings({"unchecked","rawtypes"}) public static <T>T newInstance(Class<T> theClass,Class[] parameters,Object[] values){
  T result;
  try {
    Constructor<T> meth=(Constructor<T>)CONSTRUCTOR_CACHE.get(theClass);
    if (null == meth) {
      meth=theClass.getDeclaredConstructor(parameters);
      meth.setAccessible(true);
      CONSTRUCTOR_CACHE.put(theClass,meth);
    }
    result=meth.newInstance(values);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return result;
}

ID 764=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#unwrapRemoteException(Class<?>[])
Rmethod: org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * If this remote exception wraps up one of the lookupTypes then return this exception. <p> Unwraps any IOException.
 * @param lookupTypes the desired exception class.
 * @return IOException, which is either the lookupClass exception or this.
 */

catch: 
catch (Exception e) {
  return this;
}

block: 
RemoteException
/** 
 * If this remote exception wraps up one of the lookupTypes then return this exception. <p> Unwraps any IOException.
 * @param lookupTypes the desired exception class.
 * @return IOException, which is either the lookupClass exception or this.
 */
public IOException unwrapRemoteException(Class<?>... lookupTypes){
  if (lookupTypes == null)   return this;
  for (  Class<?> lookupClass : lookupTypes) {
    if (!lookupClass.getName().equals(getClassName()))     continue;
    try {
      return instantiateException(lookupClass.asSubclass(IOException.class));
    }
 catch (    Exception e) {
      return this;
    }
  }
  return this;
}

ID 765=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#unwrapRemoteException()
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * Instantiate and return the exception wrapped up by this remote exception. <p> This unwraps any <code>Throwable</code> that has a constructor taking a <code>String</code> as a parameter. Otherwise it returns this.
 * @return <code>Throwable
 */

catch: 
catch (Exception e) {
}

block: 
RemoteException
/** 
 * Instantiate and return the exception wrapped up by this remote exception. <p> This unwraps any <code>Throwable</code> that has a constructor taking a <code>String</code> as a parameter. Otherwise it returns this.
 * @return <code>Throwable
 */
public IOException unwrapRemoteException(){
  try {
    Class<?> realClass=Class.forName(getClassName());
    return instantiateException(realClass.asSubclass(IOException.class));
  }
 catch (  Exception e) {
  }
  return this;
}

ID 766=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#unwrapRemoteException()
Rmethod: org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * Instantiate and return the exception wrapped up by this remote exception. <p> This unwraps any <code>Throwable</code> that has a constructor taking a <code>String</code> as a parameter. Otherwise it returns this.
 * @return <code>Throwable
 */

catch: 
catch (Exception e) {
}

block: 
RemoteException
/** 
 * Instantiate and return the exception wrapped up by this remote exception. <p> This unwraps any <code>Throwable</code> that has a constructor taking a <code>String</code> as a parameter. Otherwise it returns this.
 * @return <code>Throwable
 */
public IOException unwrapRemoteException(){
  try {
    Class<?> realClass=Class.forName(getClassName());
    return instantiateException(realClass.asSubclass(IOException.class));
  }
 catch (  Exception e) {
  }
  return this;
}

ID 767=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
null
block: 
RemoteException
private IOException instantiateException(Class<? extends IOException> cls) throws Exception {
  Constructor<? extends IOException> cn=cls.getConstructor(String.class);
  cn.setAccessible(true);
  String firstLine=this.getMessage();
  int eol=firstLine.indexOf('\n');
  if (eol >= 0) {
    firstLine=firstLine.substring(0,eol);
  }
  IOException ex=cn.newInstance(firstLine);
  ex.initCause(this);
  return ex;
}

ID 768=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RemoteException
private IOException instantiateException(Class<? extends IOException> cls) throws Exception {
  Constructor<? extends IOException> cn=cls.getConstructor(String.class);
  cn.setAccessible(true);
  String firstLine=this.getMessage();
  int eol=firstLine.indexOf('\n');
  if (eol >= 0) {
    firstLine=firstLine.substring(0,eol);
  }
  IOException ex=cn.newInstance(firstLine);
  ex.initCause(this);
  return ex;
}

ID 769=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RemoteException
private IOException instantiateException(Class<? extends IOException> cls) throws Exception {
  Constructor<? extends IOException> cn=cls.getConstructor(String.class);
  cn.setAccessible(true);
  String firstLine=this.getMessage();
  int eol=firstLine.indexOf('\n');
  if (eol >= 0) {
    firstLine=firstLine.substring(0,eol);
  }
  IOException ex=cn.newInstance(firstLine);
  ex.initCause(this);
  return ex;
}

ID 770=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RemoteException
private IOException instantiateException(Class<? extends IOException> cls) throws Exception {
  Constructor<? extends IOException> cn=cls.getConstructor(String.class);
  cn.setAccessible(true);
  String firstLine=this.getMessage();
  int eol=firstLine.indexOf('\n');
  if (eol >= 0) {
    firstLine=firstLine.substring(0,eol);
  }
  IOException ex=cn.newInstance(firstLine);
  ex.initCause(this);
  return ex;
}

ID 771=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RemoteException
private IOException instantiateException(Class<? extends IOException> cls) throws Exception {
  Constructor<? extends IOException> cn=cls.getConstructor(String.class);
  cn.setAccessible(true);
  String firstLine=this.getMessage();
  int eol=firstLine.indexOf('\n');
  if (eol >= 0) {
    firstLine=firstLine.substring(0,eol);
  }
  IOException ex=cn.newInstance(firstLine);
  ex.initCause(this);
  return ex;
}

ID 772=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RemoteException
private IOException instantiateException(Class<? extends IOException> cls) throws Exception {
  Constructor<? extends IOException> cn=cls.getConstructor(String.class);
  cn.setAccessible(true);
  String firstLine=this.getMessage();
  int eol=firstLine.indexOf('\n');
  if (eol >= 0) {
    firstLine=firstLine.substring(0,eol);
  }
  IOException ex=cn.newInstance(firstLine);
  ex.initCause(this);
  return ex;
}

ID 773=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RemoteException#instantiateException(Class<? extends java.io.IOException>)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: null
catch: 
null
block: 
RemoteException
private IOException instantiateException(Class<? extends IOException> cls) throws Exception {
  Constructor<? extends IOException> cn=cls.getConstructor(String.class);
  cn.setAccessible(true);
  String firstLine=this.getMessage();
  int eol=firstLine.indexOf('\n');
  if (eol >= 0) {
    firstLine=firstLine.substring(0,eol);
  }
  IOException ex=cn.newInstance(firstLine);
  ex.initCause(this);
  return ex;
}

ID 774=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.ResourceManager#getConfigurationOverride(java.lang.Long, java.lang.Long, java.lang.Integer, java.lang.Long)
Rmethod: java.io.OutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  log.warn("Failed to serialize configuration.",e);
  System.exit(1);
}

block: 
ResourceManager
private byte[] getConfigurationOverride(Long groomRPCPort,Long groomPeerPort,Integer maxTasks,Long slotJVMHeap){
  Configuration overrides=new Configuration(conf);
  overrides.set("bsp.groom.rpc.port",groomRPCPort.toString());
  overrides.set("bsp.peer.port",groomPeerPort.toString());
  overrides.set("bsp.tasks.maximum",maxTasks.toString());
  overrides.set("bsp.child.java.opts",conf.get("bsp.child.java.opts") + slotJVMHeap + "m");
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    overrides.write(new DataOutputStream(baos));
    baos.flush();
  }
 catch (  IOException e) {
    log.warn("Failed to serialize configuration.",e);
    System.exit(1);
  }
  return baos.toByteArray();
}

ID 775=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RetryLimited#shouldRetry(java.lang.Exception, int)
Rmethod: java.util.concurrent.TimeUnit#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
}

block: 
RetryLimited
@Override public boolean shouldRetry(Exception e,int retries) throws Exception {
  if (retries >= maxRetries) {
    throw e;
  }
  try {
    timeUnit.sleep(calculateSleepTime(retries));
  }
 catch (  InterruptedException ie) {
  }
  return true;
}

ID 776=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.MultipleLinearRandomRetry#shouldRetry(java.lang.Exception, int)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
MultipleLinearRandomRetry
@Override public boolean shouldRetry(Exception e,int curRetry) throws Exception {
  final Pair p=searchPair(curRetry);
  if (p == null) {
    throw e;
  }
  final double ratio=RANDOM.get().nextDouble() + 0.5;
  Thread.sleep(Math.round(p.sleepMillis * ratio));
  return true;
}

ID 777=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.MultipleLinearRandomRetry#parsePositiveInt(java.lang.String[], int, java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Parse the i-th element as an integer.
 * @return -1 if the parsing fails or the parsed value <= 0;otherwise, return the parsed value.
 */

catch: 
catch (NumberFormatException nfe) {
  LOG.warn("Failed to parse \"" + s + "\", which is the index "+ i+ " element in \""+ originalString+ "\"",nfe);
  return -1;
}

block: 
MultipleLinearRandomRetry
/** 
 * Parse the i-th element as an integer.
 * @return -1 if the parsing fails or the parsed value <= 0;otherwise, return the parsed value.
 */
private static int parsePositiveInt(final String[] elements,final int i,final String originalString){
  final String s=elements[i].trim();
  final int n;
  try {
    n=Integer.parseInt(s);
  }
 catch (  NumberFormatException nfe) {
    LOG.warn("Failed to parse \"" + s + "\", which is the index "+ i+ " element in \""+ originalString+ "\"",nfe);
    return -1;
  }
  if (n <= 0) {
    LOG.warn("The value " + n + " <= 0: it is parsed from the string \""+ s+ "\" which is the index "+ i+ " element in \""+ originalString+ "\"");
    return -1;
  }
  return n;
}

ID 778=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Invocation#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Invocation
public void readFields(DataInput in) throws IOException {
  methodName=Text.readString(in);
  parameters=new Object[in.readInt()];
  parameterClasses=new Class[parameters.length];
  ObjectWritable objectWritable=new ObjectWritable();
  for (int i=0; i < parameters.length; i++) {
    parameters[i]=ObjectWritable.readObject(in,objectWritable,this.conf);
    parameterClasses[i]=objectWritable.getDeclaredClass();
  }
}

ID 779=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Invocation#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Invocation
public void write(DataOutput out) throws IOException {
  Text.writeString(out,methodName);
  out.writeInt(parameterClasses.length);
  for (int i=0; i < parameterClasses.length; i++) {
    ObjectWritable.writeObject(out,parameters[i],parameterClasses[i],conf);
  }
}

ID 780=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration)
Rmethod: org.apache.hama.ipc.RPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RPC
public static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf) throws IOException {
  return waitForProxy(protocol,clientVersion,addr,conf,0,Long.MAX_VALUE);
}

ID 781=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, long)
Rmethod: org.apache.hama.ipc.RPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */

catch: 
null
block: 
RPC
/** 
 * Get a proxy connection to a remote server
 * @param protocol protocol class
 * @param clientVersion client version
 * @param addr remote address
 * @param conf configuration to use
 * @param connTimeout time in milliseconds before giving up
 * @return the proxy
 * @throws IOException if the far end through a RemoteException
 */
static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,long connTimeout) throws IOException {
  return waitForProxy(protocol,clientVersion,addr,conf,0,connTimeout);
}

ID 782=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
Rmethod: org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RPC
static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,int rpcTimeout,long connTimeout) throws IOException {
  long startTime=System.currentTimeMillis();
  IOException ioe;
  while (true) {
    try {
      return getProxy(protocol,clientVersion,addr,conf,rpcTimeout);
    }
 catch (    ConnectException se) {
      LOG.info("Server at " + addr + " not available yet, Zzzzz...");
      ioe=se;
    }
catch (    SocketTimeoutException te) {
      LOG.info("Problem connecting to server: " + addr);
      ioe=te;
    }
    if (System.currentTimeMillis() - connTimeout >= startTime) {
      throw ioe;
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ie) {
    }
  }
}

ID 783=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#waitForProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int, long)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
}

block: 
RPC
static VersionedProtocol waitForProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,int rpcTimeout,long connTimeout) throws IOException {
  long startTime=System.currentTimeMillis();
  IOException ioe;
  while (true) {
    try {
      return getProxy(protocol,clientVersion,addr,conf,rpcTimeout);
    }
 catch (    ConnectException se) {
      LOG.info("Server at " + addr + " not available yet, Zzzzz...");
      ioe=se;
    }
catch (    SocketTimeoutException te) {
      LOG.info("Problem connecting to server: " + addr);
      ioe=te;
    }
    if (System.currentTimeMillis() - connTimeout >= startTime) {
      throw ioe;
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ie) {
    }
  }
}

ID 784=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory)
Rmethod: org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,SocketFactory factory) throws IOException {
  UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
  return getProxy(protocol,clientVersion,addr,ugi,conf,factory,0);
}

ID 785=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory, int)
Rmethod: org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,SocketFactory factory,int rpcTimeout) throws IOException {
  UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
  return getProxy(protocol,clientVersion,addr,ugi,conf,factory,rpcTimeout);
}

ID 786=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory)
Rmethod: org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory) throws IOException {
  return getProxy(protocol,clientVersion,addr,ticket,conf,factory,0);
}

ID 787=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int)
Rmethod: org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout) throws IOException {
  return getProxy(protocol,clientVersion,addr,ticket,conf,factory,rpcTimeout,null,true);
}

ID 788=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
Rmethod: org.apache.hama.ipc.Invoker#Invoker(Class<? extends VersionedProtocol>, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout,RetryPolicy connectionRetryPolicy,boolean checkVersion) throws IOException {
  if (UserGroupInformation.isSecurityEnabled()) {
    SaslRpcServer.init(conf);
  }
  final Invoker invoker=new Invoker(protocol,addr,ticket,conf,factory,rpcTimeout,connectionRetryPolicy);
  VersionedProtocol proxy=(VersionedProtocol)Proxy.newProxyInstance(protocol.getClassLoader(),new Class[]{protocol},invoker);
  if (checkVersion) {
    checkVersion(protocol,clientVersion,proxy);
  }
  return proxy;
}

ID 789=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
Rmethod: java.lang.reflect.Proxy#newProxyInstance(java.lang.ClassLoader, Class<?>[], java.lang.reflect.InvocationHandler)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout,RetryPolicy connectionRetryPolicy,boolean checkVersion) throws IOException {
  if (UserGroupInformation.isSecurityEnabled()) {
    SaslRpcServer.init(conf);
  }
  final Invoker invoker=new Invoker(protocol,addr,ticket,conf,factory,rpcTimeout,connectionRetryPolicy);
  VersionedProtocol proxy=(VersionedProtocol)Proxy.newProxyInstance(protocol.getClassLoader(),new Class[]{protocol},invoker);
  if (checkVersion) {
    checkVersion(protocol,clientVersion,proxy);
  }
  return proxy;
}

ID 790=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, UserGroupInformation, Configuration, javax.net.SocketFactory, int, RetryPolicy, boolean)
Rmethod: org.apache.hama.ipc.RPC#checkVersion(Class<? extends VersionedProtocol>, long, VersionedProtocol)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object that implements the named protocol, talking to a server at the named address.
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,UserGroupInformation ticket,Configuration conf,SocketFactory factory,int rpcTimeout,RetryPolicy connectionRetryPolicy,boolean checkVersion) throws IOException {
  if (UserGroupInformation.isSecurityEnabled()) {
    SaslRpcServer.init(conf);
  }
  final Invoker invoker=new Invoker(protocol,addr,ticket,conf,factory,rpcTimeout,connectionRetryPolicy);
  VersionedProtocol proxy=(VersionedProtocol)Proxy.newProxyInstance(protocol.getClassLoader(),new Class[]{protocol},invoker);
  if (checkVersion) {
    checkVersion(protocol,clientVersion,proxy);
  }
  return proxy;
}

ID 791=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration)
Rmethod: org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a client-side proxy object with the default SocketFactory
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @return a proxy instance
 * @throws IOException
 */

catch: 
null
block: 
RPC
/** 
 * Construct a client-side proxy object with the default SocketFactory
 * @param protocol
 * @param clientVersion
 * @param addr
 * @param conf
 * @return a proxy instance
 * @throws IOException
 */
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf) throws IOException {
  return getProxy(protocol,clientVersion,addr,conf,BSPNetUtils.getDefaultSocketFactory(conf),0);
}

ID 792=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, int)
Rmethod: org.apache.hama.ipc.RPC#getProxy(Class<? extends VersionedProtocol>, long, java.net.InetSocketAddress, Configuration, javax.net.SocketFactory, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
RPC
public static VersionedProtocol getProxy(Class<? extends VersionedProtocol> protocol,long clientVersion,InetSocketAddress addr,Configuration conf,int rpcTimeout) throws IOException {
  return getProxy(protocol,clientVersion,addr,conf,BSPNetUtils.getDefaultSocketFactory(conf),rpcTimeout);
}

ID 793=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], Configuration)
Rmethod: org.apache.hama.ipc.RPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], UserGroupInformation, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @deprecated Use{@link #call(Method,Object[][],InetSocketAddress[],UserGroupInformation,Configuration)}instead
 */

catch: 
null
block: 
RPC
/** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @deprecated Use{@link #call(Method,Object[][],InetSocketAddress[],UserGroupInformation,Configuration)}instead
 */
public static Object[] call(Method method,Object[][] params,InetSocketAddress[] addrs,Configuration conf) throws IOException, InterruptedException {
  return call(method,params,addrs,null,conf);
}

ID 794=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], Configuration)
Rmethod: org.apache.hama.ipc.RPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], UserGroupInformation, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @deprecated Use{@link #call(Method,Object[][],InetSocketAddress[],UserGroupInformation,Configuration)}instead
 */

catch: 
null
block: 
RPC
/** 
 * Expert: Make multiple, parallel calls to a set of servers.
 * @deprecated Use{@link #call(Method,Object[][],InetSocketAddress[],UserGroupInformation,Configuration)}instead
 */
public static Object[] call(Method method,Object[][] params,InetSocketAddress[] addrs,Configuration conf) throws IOException, InterruptedException {
  return call(method,params,addrs,null,conf);
}

ID 795=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], UserGroupInformation, Configuration)
Rmethod: java.lang.reflect.Array#newInstance(Class<?>, int[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Expert: Make multiple, parallel calls to a set of servers. 
 */

catch: 
null
block: 
RPC
/** 
 * Expert: Make multiple, parallel calls to a set of servers. 
 */
public static Object[] call(Method method,Object[][] params,InetSocketAddress[] addrs,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  Invocation[] invocations=new Invocation[params.length];
  for (int i=0; i < params.length; i++)   invocations[i]=new Invocation(method,params[i]);
  Client client=CLIENTS.getClient(conf);
  try {
    Writable[] wrappedValues=client.call(invocations,addrs,method.getDeclaringClass(),ticket,conf);
    if (method.getReturnType() == Void.TYPE) {
      return null;
    }
    Object[] values=(Object[])Array.newInstance(method.getReturnType(),wrappedValues.length);
    for (int i=0; i < values.length; i++)     if (wrappedValues[i] != null)     values[i]=((ObjectWritable)wrappedValues[i]).get();
    return values;
  }
  finally {
    CLIENTS.stopClient(client);
  }
}

ID 796=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#call(java.lang.reflect.Method, java.lang.Object[][], java.net.InetSocketAddress[], UserGroupInformation, Configuration)
Rmethod: java.lang.reflect.Array#newInstance(Class<?>, int[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.NegativeArraySizeException
exception comment: /** 
 * Thrown if an application tries to create an array with negative size.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Expert: Make multiple, parallel calls to a set of servers. 
 */

catch: 
null
block: 
RPC
/** 
 * Expert: Make multiple, parallel calls to a set of servers. 
 */
public static Object[] call(Method method,Object[][] params,InetSocketAddress[] addrs,UserGroupInformation ticket,Configuration conf) throws IOException, InterruptedException {
  Invocation[] invocations=new Invocation[params.length];
  for (int i=0; i < params.length; i++)   invocations[i]=new Invocation(method,params[i]);
  Client client=CLIENTS.getClient(conf);
  try {
    Writable[] wrappedValues=client.call(invocations,addrs,method.getDeclaringClass(),ticket,conf);
    if (method.getReturnType() == Void.TYPE) {
      return null;
    }
    Object[] values=(Object[])Array.newInstance(method.getReturnType(),wrappedValues.length);
    for (int i=0; i < values.length; i++)     if (wrappedValues[i] != null)     values[i]=((ObjectWritable)wrappedValues[i]).get();
    return values;
  }
  finally {
    CLIENTS.stopClient(client);
  }
}

ID 797=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getServer(java.lang.Object, java.lang.String, int, Configuration)
Rmethod: org.apache.hama.ipc.RPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 */
public static Server getServer(final Object instance,final String bindAddress,final int port,Configuration conf) throws IOException {
  return getServer(instance,bindAddress,port,1,false,conf);
}

ID 798=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration)
Rmethod: org.apache.hama.ipc.RPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration, SecretManager<? extends TokenIdentifier>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a server for a protocol implementation instance listening on a port and address.
 */
public static Server getServer(final Object instance,final String bindAddress,final int port,final int numHandlers,final boolean verbose,Configuration conf) throws IOException {
  return getServer(instance,bindAddress,port,numHandlers,verbose,conf,null);
}

ID 799=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.RPC#getServer(java.lang.Object, java.lang.String, int, int, boolean, Configuration, SecretManager<? extends TokenIdentifier>)
Rmethod: org.apache.hama.ipc.Server#Server(java.lang.Object, Configuration, java.lang.String, int, int, boolean, SecretManager<? extends TokenIdentifier>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Construct a server for a protocol implementation instance listening on a port and address, with a secret manager.
 */

catch: 
null
block: 
RPC
/** 
 * Construct a server for a protocol implementation instance listening on a port and address, with a secret manager.
 */
public static Server getServer(final Object instance,final String bindAddress,final int port,final int numHandlers,final boolean verbose,Configuration conf,SecretManager<? extends TokenIdentifier> secretManager) throws IOException {
  return new Server(instance,conf,bindAddress,port,numHandlers,verbose,secretManager);
}

ID 800=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
Server
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 801=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
Server
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 802=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
Server
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 803=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
Server
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 804=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
Server
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 805=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: null
catch: 
catch (Throwable e) {
  if (!(e instanceof IOException)) {
    LOG.error("Unexpected throwable object ",e);
  }
  IOException ioe=new IOException(e.toString());
  ioe.setStackTrace(e.getStackTrace());
  throw ioe;
}

block: 
Server
public Writable call(Class<?> protocol,Writable param,long receivedTime) throws IOException {
  try {
    Invocation call=(Invocation)param;
    if (verbose)     log("Call: " + call);
    Method method=protocol.getMethod(call.getMethodName(),call.getParameterClasses());
    method.setAccessible(true);
    long startTime=System.currentTimeMillis();
    Object value=method.invoke(instance,call.getParameters());
    int processingTime=(int)(System.currentTimeMillis() - startTime);
    int qTime=(int)(startTime - receivedTime);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Served: " + call.getMethodName() + " queueTime= "+ qTime+ " procesingTime= "+ processingTime);
    }
    if (verbose)     log("Return: " + value);
    return new ObjectWritable(method.getReturnType(),value);
  }
 catch (  InvocationTargetException e) {
    Throwable target=e.getTargetException();
    if (target instanceof IOException) {
      throw (IOException)target;
    }
 else {
      IOException ioe=new IOException(target.toString());
      ioe.setStackTrace(target.getStackTrace());
      throw ioe;
    }
  }
catch (  Throwable e) {
    if (!(e instanceof IOException)) {
      LOG.error("Unexpected throwable object ",e);
    }
    IOException ioe=new IOException(e.toString());
    ioe.setStackTrace(e.getStackTrace());
    throw ioe;
  }
}

ID 806=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.util.jar.JarFile#JarFile(java.io.File)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 807=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.util.jar.JarFile#getInputStream(java.util.zip.ZipEntry)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 808=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 809=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.io.InputStream#read(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 810=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.io.OutputStream#write(byte[], int, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 811=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.io.OutputStream#close()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 812=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.io.InputStream#close()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 813=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
Rmethod: java.util.zip.ZipFile#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Unpack a jar file into a directory. 
 */

catch: 
null
block: 
RunJar
/** 
 * Unpack a jar file into a directory. 
 */
public static void unJar(File jarFile,File toDir) throws IOException {
  JarFile jar=new JarFile(jarFile);
  try {
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      if (!entry.isDirectory()) {
        InputStream in=jar.getInputStream(entry);
        try {
          File file=new File(toDir,entry.getName());
          file.getParentFile().mkdirs();
          OutputStream out=new FileOutputStream(file);
          try {
            byte[] buffer=new byte[8192];
            int i;
            while ((i=in.read(buffer)) != -1) {
              out.write(buffer,0,i);
            }
          }
  finally {
            out.close();
          }
        }
  finally {
          in.close();
        }
      }
    }
  }
  finally {
    jar.close();
  }
}

ID 814=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.util.jar.JarFile#JarFile(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 815=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.util.jar.JarFile#getManifest()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 816=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.util.zip.ZipFile#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 817=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.io.File#createTempFile(java.lang.String, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 818=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: org.apache.hama.util.RunJar#unJar(java.io.File, java.io.File)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 819=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.net.URI#toURL()
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 820=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 821=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.lang.reflect.Array#newInstance(Class<?>, int)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.NegativeArraySizeException
exception comment: /** 
 * Thrown if an application tries to create an array with negative size.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 822=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 823=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 824=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 825=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
null
block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 826=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.RunJar#main(java.lang.String[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.reflect.InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

method comment: /** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */

catch: 
catch (InvocationTargetException e) {
  throw e.getTargetException();
}

block: 
RunJar
/** 
 * Run a Hama job jar. If the main class is not in the jar's manifest, then it must be provided on the command line.
 */
public static void main(String[] args) throws Throwable {
  String usage="Usage: hama jar <jar> [mainClass] args...";
  if (args.length < 1) {
    System.err.println(usage);
    System.exit(-1);
  }
  int firstArg=0;
  String fileName=args[firstArg++];
  File file=new File(fileName);
  String mainClassName=null;
  JarFile jarFile=new JarFile(fileName);
  Manifest manifest=jarFile.getManifest();
  if (manifest != null) {
    mainClassName=manifest.getMainAttributes().getValue("Main-Class");
  }
  jarFile.close();
  if (mainClassName == null) {
    if (args.length < 2) {
      System.err.println(usage);
      System.exit(-1);
    }
    mainClassName=args[firstArg++];
  }
  mainClassName=mainClassName.replaceAll("/",".");
  final File workDir=File.createTempFile("hama-unjar","");
  workDir.delete();
  workDir.mkdirs();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      try {
        FileUtil.fullyDelete(workDir);
      }
 catch (      Exception e) {
      }
    }
  }
);
  unJar(file,workDir);
  List<URL> classPath=new ArrayList<URL>();
  classPath.add(new File(workDir + "/").toURI().toURL());
  classPath.add(file.toURI().toURL());
  classPath.add(new File(workDir,"classes/").toURI().toURL());
  File[] libs=new File(workDir,"lib").listFiles();
  if (libs != null) {
    for (    File lib : libs) {
      classPath.add(lib.toURI().toURL());
    }
  }
  ClassLoader loader=new URLClassLoader(classPath.toArray(new URL[classPath.size()]));
  Thread.currentThread().setContextClassLoader(loader);
  Class<?> mainClass=loader.loadClass(mainClassName);
  Method main=mainClass.getMethod("main",new Class[]{Array.newInstance(String.class,0).getClass()});
  List<String> var=Arrays.asList(args).subList(firstArg,args.length);
  String[] newArgs=var.toArray(new String[var.size()]);
  try {
    main.invoke(null,new Object[]{newArgs});
  }
 catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}

ID 827=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterDetails#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterDetails
@Override public void readFields(DataInput in) throws IOException {
  this.semiClusterId=in.readUTF();
  this.semiClusterScore=in.readDouble();
}

ID 828=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterDetails#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readDouble()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterDetails
@Override public void readFields(DataInput in) throws IOException {
  this.semiClusterId=in.readUTF();
  this.semiClusterScore=in.readDouble();
}

ID 829=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterDetails#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterDetails
@Override public void write(DataOutput out) throws IOException {
  out.writeUTF(semiClusterId);
  out.writeDouble(semiClusterScore);
}

ID 830=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterDetails#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeDouble(double)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterDetails
@Override public void write(DataOutput out) throws IOException {
  out.writeUTF(semiClusterId);
  out.writeDouble(semiClusterScore);
}

ID 831=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusteringVertex#compute(Iterable<SemiClusterMessage>)
Rmethod: org.apache.hama.ml.semiclustering.SemiClusteringVertex#initClusters()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The user overrides the Compute() method, which will be executed at each active vertex in every superstep
 */

catch: 
null
block: 
SemiClusteringVertex
/** 
 * The user overrides the Compute() method, which will be executed at each active vertex in every superstep
 */
@Override public void compute(Iterable<SemiClusterMessage> messages) throws IOException {
  if (this.getSuperstepCount() == 0) {
    initClusters();
  }
  if (this.getSuperstepCount() >= 1) {
    TreeSet<SemiClusterMessage> candidates=new TreeSet<SemiClusterMessage>();
    for (    SemiClusterMessage msg : messages) {
      candidates.add(msg);
      if (!msg.contains(this.getVertexID()) && msg.size() == semiClusterMaximumVertexCount) {
        SemiClusterMessage msgNew=WritableUtils.clone(msg,this.getConf());
        msgNew.addVertex(this);
        msgNew.setSemiClusterId("C" + createNewSemiClusterName(msgNew.getVertexList()));
        msgNew.setScore(semiClusterScoreCalcuation(msgNew));
        candidates.add(msgNew);
      }
    }
    Iterator<SemiClusterMessage> bestCandidates=candidates.descendingIterator();
    int count=0;
    while (bestCandidates.hasNext() && count < graphJobMessageSentCount) {
      SemiClusterMessage candidate=bestCandidates.next();
      sendMessageToNeighbors(candidate);
      count++;
    }
    SemiClusterMessage value=this.getValue();
    Set<SemiClusterDetails> clusters=value.getSemiClusterContainThis();
    for (    SemiClusterMessage msg : candidates) {
      if (clusters.size() > graphJobVertexMaxClusterCount) {
        break;
      }
 else {
        clusters.add(new SemiClusterDetails(msg.getSemiClusterId(),msg.getScore()));
      }
    }
    value.setClusters(clusters,graphJobVertexMaxClusterCount);
    this.setValue(value);
  }
}

ID 832=========================================================================type: Rethrow
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterJobDriver#parseArgs(HamaConfiguration, java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Function parses command line in standart form.
 */

catch: 
catch (NumberFormatException e) {
  printUsage();
  throw new IllegalArgumentException("The format of job maximum iteration count is int. Can not parse value: " + args[2]);
}

block: 
SemiClusterJobDriver
/** 
 * Function parses command line in standart form.
 */
private static void parseArgs(HamaConfiguration conf,String[] args){
  if (args.length < 2) {
    printUsage();
    System.exit(-1);
  }
  conf.set(inputPathString,args[0]);
  Path path=new Path(args[1]);
  conf.set(outputPathString,path.toString());
  if (args.length >= 3) {
    try {
      int taskCount=Integer.parseInt(args[2]);
      if (taskCount < 0) {
        printUsage();
        throw new IllegalArgumentException("The number of requested job maximum iteration count can't be negative. Actual value: " + String.valueOf(taskCount));
      }
      conf.setInt(requestedGraphJobMaxIterationString,taskCount);
      if (args.length >= 4) {
        int maximumVertexCount=Integer.parseInt(args[3]);
        if (maximumVertexCount < 0) {
          printUsage();
          throw new IllegalArgumentException("The number of  maximum vertex  count can't be negative. Actual value: " + String.valueOf(maximumVertexCount));
        }
        conf.setInt(semiClusterMaximumVertexCount,maximumVertexCount);
        if (args.length >= 5) {
          int messageSentCount=Integer.parseInt(args[4]);
          if (messageSentCount < 0) {
            printUsage();
            throw new IllegalArgumentException("The number of  maximum message sent count can't be negative. Actual value: " + String.valueOf(messageSentCount));
          }
          conf.setInt(graphJobMessageSentCount,messageSentCount);
          if (args.length == 6) {
            int vertexClusterCount=Integer.parseInt(args[5]);
            if (vertexClusterCount < 0) {
              printUsage();
              throw new IllegalArgumentException("The maximum number of clusters in which a vertex can be containted can't be negative. Actual value: " + String.valueOf(vertexClusterCount));
            }
            conf.setInt(graphJobVertexMaxClusterCount,vertexClusterCount);
          }
        }
      }
    }
 catch (    NumberFormatException e) {
      printUsage();
      throw new IllegalArgumentException("The format of job maximum iteration count is int. Can not parse value: " + args[2]);
    }
  }
}

ID 833=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterJobDriver#main(java.lang.String[])
Rmethod: org.apache.hama.examples.SemiClusterJobDriver#startTask(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterJobDriver
public static void main(String[] args) throws Exception {
  HamaConfiguration conf=new HamaConfiguration();
  parseArgs(conf,args);
  startTask(conf);
}

ID 834=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterJobDriver#main(java.lang.String[])
Rmethod: org.apache.hama.examples.SemiClusterJobDriver#startTask(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterJobDriver
public static void main(String[] args) throws Exception {
  HamaConfiguration conf=new HamaConfiguration();
  parseArgs(conf,args);
  startTask(conf);
}

ID 835=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterJobDriver#main(java.lang.String[])
Rmethod: org.apache.hama.examples.SemiClusterJobDriver#startTask(HamaConfiguration)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterJobDriver
public static void main(String[] args) throws Exception {
  HamaConfiguration conf=new HamaConfiguration();
  parseArgs(conf,args);
  startTask(conf);
}

ID 836=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterMatchingTest#inputGraphLoader()
Rmethod: java.io.FileReader#FileReader(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMatchingTest
public static Map<String,List<String>> inputGraphLoader() throws IOException {
  BufferedReader br=new BufferedReader(new FileReader(INPUT));
  String line, firstVal;
  Map<String,List<String>> mp=new HashMap<String,List<String>>();
  while ((line=br.readLine()) != null) {
    List<String> tm=new ArrayList<String>();
    StringTokenizer st1=new StringTokenizer(line,"\t");
    firstVal=st1.nextToken();
    StringTokenizer st2=new StringTokenizer(st1.nextToken(),",");
    while (st2.hasMoreTokens()) {
      tm.add(st2.nextToken().split("-")[0]);
    }
    mp.put(firstVal,tm);
  }
  br.close();
  return mp;
}

ID 837=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterMatchingTest#inputGraphLoader()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMatchingTest
public static Map<String,List<String>> inputGraphLoader() throws IOException {
  BufferedReader br=new BufferedReader(new FileReader(INPUT));
  String line, firstVal;
  Map<String,List<String>> mp=new HashMap<String,List<String>>();
  while ((line=br.readLine()) != null) {
    List<String> tm=new ArrayList<String>();
    StringTokenizer st1=new StringTokenizer(line,"\t");
    firstVal=st1.nextToken();
    StringTokenizer st2=new StringTokenizer(st1.nextToken(),",");
    while (st2.hasMoreTokens()) {
      tm.add(st2.nextToken().split("-")[0]);
    }
    mp.put(firstVal,tm);
  }
  br.close();
  return mp;
}

ID 838=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterMatchingTest#inputGraphLoader()
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMatchingTest
public static Map<String,List<String>> inputGraphLoader() throws IOException {
  BufferedReader br=new BufferedReader(new FileReader(INPUT));
  String line, firstVal;
  Map<String,List<String>> mp=new HashMap<String,List<String>>();
  while ((line=br.readLine()) != null) {
    List<String> tm=new ArrayList<String>();
    StringTokenizer st1=new StringTokenizer(line,"\t");
    firstVal=st1.nextToken();
    StringTokenizer st2=new StringTokenizer(st1.nextToken(),",");
    while (st2.hasMoreTokens()) {
      tm.add(st2.nextToken().split("-")[0]);
    }
    mp.put(firstVal,tm);
  }
  br.close();
  return mp;
}

ID 839=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterMatchingTest#outputClusterLoader()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMatchingTest
@SuppressWarnings({"unchecked","rawtypes"}) public static Map<String,List<String>> outputClusterLoader() throws IOException {
  FileStatus[] files=fs.globStatus(new Path(OUTPUT + "/part-*"));
  String line, vertexId, clusterId, clusterList;
  List<String> tm;
  Map<String,List<String>> mp=new HashMap<String,List<String>>();
  for (  FileStatus file : files) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(file.getPath())));
    while ((line=reader.readLine()) != null) {
      StringTokenizer st1=new StringTokenizer(line,"\t");
      vertexId=st1.nextToken();
      clusterList=st1.nextToken().toString().replaceAll("[\\[\\] ]","");
      StringTokenizer st2=new StringTokenizer(clusterList,",");
      while (st2.hasMoreTokens()) {
        clusterId=st2.nextToken();
        if (!mp.containsKey(clusterId)) {
          tm=new ArrayList<String>();
          mp.put(clusterId,tm);
        }
 else         tm=mp.get(clusterId);
        tm.add(vertexId);
        mp.put(clusterId,tm);
      }
    }
    reader.close();
  }
  Iterator it=mp.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry pairs=(Map.Entry)it.next();
    List<String> ls=(List<String>)pairs.getValue();
    if (ls.size() == 1) {
      it.remove();
    }
  }
  return mp;
}

ID 840=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterMatchingTest#outputClusterLoader()
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMatchingTest
@SuppressWarnings({"unchecked","rawtypes"}) public static Map<String,List<String>> outputClusterLoader() throws IOException {
  FileStatus[] files=fs.globStatus(new Path(OUTPUT + "/part-*"));
  String line, vertexId, clusterId, clusterList;
  List<String> tm;
  Map<String,List<String>> mp=new HashMap<String,List<String>>();
  for (  FileStatus file : files) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(file.getPath())));
    while ((line=reader.readLine()) != null) {
      StringTokenizer st1=new StringTokenizer(line,"\t");
      vertexId=st1.nextToken();
      clusterList=st1.nextToken().toString().replaceAll("[\\[\\] ]","");
      StringTokenizer st2=new StringTokenizer(clusterList,",");
      while (st2.hasMoreTokens()) {
        clusterId=st2.nextToken();
        if (!mp.containsKey(clusterId)) {
          tm=new ArrayList<String>();
          mp.put(clusterId,tm);
        }
 else         tm=mp.get(clusterId);
        tm.add(vertexId);
        mp.put(clusterId,tm);
      }
    }
    reader.close();
  }
  Iterator it=mp.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry pairs=(Map.Entry)it.next();
    List<String> ls=(List<String>)pairs.getValue();
    if (ls.size() == 1) {
      it.remove();
    }
  }
  return mp;
}

ID 841=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterMatchingTest#semiClusterOutputChecker()
Rmethod: org.apache.hama.examples.SemiClusterMatchingTest#inputGraphLoader()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMatchingTest
@SuppressWarnings({"rawtypes","unchecked"}) public static void semiClusterOutputChecker() throws IOException {
  int count=0;
  boolean flag;
  Map<String,List<String>> mp=inputGraphLoader();
  Map<String,List<String>> mpOutPutCluser=outputClusterLoader();
  Iterator it=mpOutPutCluser.entrySet().iterator();
  while (it.hasNext()) {
    flag=true;
    Map.Entry<String,List<String>> pairs=(Map.Entry<String,List<String>>)it.next();
    System.out.println(pairs.getKey() + " = " + pairs.getValue());
    List<String> valFromMap=new ArrayList<String>();
    List<String> val2=(List<String>)pairs.getValue();
    int size=val2.size();
    for (int i=0; i < size; i++) {
      valFromMap=mp.get(val2.get(0));
      val2.remove(0);
      if (!valFromMap.containsAll(val2)) {
        flag=false;
      }
    }
    if (flag == true) {
      count++;
    }
  }
  assertEquals("Semi Cluster Test Successful",10,count);
}

ID 842=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SemiClusterMatchingTest#semiClusterOutputChecker()
Rmethod: org.apache.hama.examples.SemiClusterMatchingTest#outputClusterLoader()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMatchingTest
@SuppressWarnings({"rawtypes","unchecked"}) public static void semiClusterOutputChecker() throws IOException {
  int count=0;
  boolean flag;
  Map<String,List<String>> mp=inputGraphLoader();
  Map<String,List<String>> mpOutPutCluser=outputClusterLoader();
  Iterator it=mpOutPutCluser.entrySet().iterator();
  while (it.hasNext()) {
    flag=true;
    Map.Entry<String,List<String>> pairs=(Map.Entry<String,List<String>>)it.next();
    System.out.println(pairs.getKey() + " = " + pairs.getValue());
    List<String> valFromMap=new ArrayList<String>();
    List<String> val2=(List<String>)pairs.getValue();
    int size=val2.size();
    for (int i=0; i < size; i++) {
      valFromMap=mp.get(val2.get(0));
      val2.remove(0);
      if (!valFromMap.containsAll(val2)) {
        flag=false;
      }
    }
    if (flag == true) {
      count++;
    }
  }
  assertEquals("Semi Cluster Test Successful",10,count);
}

ID 843=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    this.semiClusterId=in.readUTF();
  }
  this.semiClusterScore=in.readDouble();
  if (in.readBoolean()) {
    int len=in.readInt();
    if (len > 0) {
      for (int i=0; i < len; i++) {
        SemiClusteringVertex v=new SemiClusteringVertex();
        v.readFields(in);
        semiClusterVertexList.add(v);
      }
    }
  }
  int len=in.readInt();
  if (len > 0) {
    for (int i=0; i < len; i++) {
      SemiClusterDetails sd=new SemiClusterDetails();
      sd.readFields(in);
      semiClusterContainThis.add(sd);
    }
  }
}

ID 844=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    this.semiClusterId=in.readUTF();
  }
  this.semiClusterScore=in.readDouble();
  if (in.readBoolean()) {
    int len=in.readInt();
    if (len > 0) {
      for (int i=0; i < len; i++) {
        SemiClusteringVertex v=new SemiClusteringVertex();
        v.readFields(in);
        semiClusterVertexList.add(v);
      }
    }
  }
  int len=in.readInt();
  if (len > 0) {
    for (int i=0; i < len; i++) {
      SemiClusterDetails sd=new SemiClusterDetails();
      sd.readFields(in);
      semiClusterContainThis.add(sd);
    }
  }
}

ID 845=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readDouble()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    this.semiClusterId=in.readUTF();
  }
  this.semiClusterScore=in.readDouble();
  if (in.readBoolean()) {
    int len=in.readInt();
    if (len > 0) {
      for (int i=0; i < len; i++) {
        SemiClusteringVertex v=new SemiClusteringVertex();
        v.readFields(in);
        semiClusterVertexList.add(v);
      }
    }
  }
  int len=in.readInt();
  if (len > 0) {
    for (int i=0; i < len; i++) {
      SemiClusterDetails sd=new SemiClusterDetails();
      sd.readFields(in);
      semiClusterContainThis.add(sd);
    }
  }
}

ID 846=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    this.semiClusterId=in.readUTF();
  }
  this.semiClusterScore=in.readDouble();
  if (in.readBoolean()) {
    int len=in.readInt();
    if (len > 0) {
      for (int i=0; i < len; i++) {
        SemiClusteringVertex v=new SemiClusteringVertex();
        v.readFields(in);
        semiClusterVertexList.add(v);
      }
    }
  }
  int len=in.readInt();
  if (len > 0) {
    for (int i=0; i < len; i++) {
      SemiClusterDetails sd=new SemiClusterDetails();
      sd.readFields(in);
      semiClusterContainThis.add(sd);
    }
  }
}

ID 847=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void write(DataOutput out) throws IOException {
  if (this.semiClusterId == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeUTF(semiClusterId);
  }
  out.writeDouble(semiClusterScore);
  if (this.semiClusterVertexList == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(semiClusterVertexList.size());
    for (    Vertex<Text,DoubleWritable,SemiClusterMessage> v : semiClusterVertexList) {
      v.write(out);
    }
  }
  out.writeInt(semiClusterContainThis.size());
  for (  SemiClusterDetails semiClusterContainThi : semiClusterContainThis)   semiClusterContainThi.write(out);
}

ID 848=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void write(DataOutput out) throws IOException {
  if (this.semiClusterId == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeUTF(semiClusterId);
  }
  out.writeDouble(semiClusterScore);
  if (this.semiClusterVertexList == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(semiClusterVertexList.size());
    for (    Vertex<Text,DoubleWritable,SemiClusterMessage> v : semiClusterVertexList) {
      v.write(out);
    }
  }
  out.writeInt(semiClusterContainThis.size());
  for (  SemiClusterDetails semiClusterContainThi : semiClusterContainThis)   semiClusterContainThi.write(out);
}

ID 849=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeDouble(double)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void write(DataOutput out) throws IOException {
  if (this.semiClusterId == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeUTF(semiClusterId);
  }
  out.writeDouble(semiClusterScore);
  if (this.semiClusterVertexList == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(semiClusterVertexList.size());
    for (    Vertex<Text,DoubleWritable,SemiClusterMessage> v : semiClusterVertexList) {
      v.write(out);
    }
  }
  out.writeInt(semiClusterContainThis.size());
  for (  SemiClusterDetails semiClusterContainThi : semiClusterContainThis)   semiClusterContainThi.write(out);
}

ID 850=========================================================================type: only_throws
package: org.apache.hama.ml.semiclustering
Method:org.apache.hama.ml.semiclustering.SemiClusterMessage#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SemiClusterMessage
public void write(DataOutput out) throws IOException {
  if (this.semiClusterId == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeUTF(semiClusterId);
  }
  out.writeDouble(semiClusterScore);
  if (this.semiClusterVertexList == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(semiClusterVertexList.size());
    for (    Vertex<Text,DoubleWritable,SemiClusterMessage> v : semiClusterVertexList) {
      v.write(out);
    }
  }
  out.writeInt(semiClusterContainThis.size());
  for (  SemiClusterDetails semiClusterContainThi : semiClusterContainThis)   semiClusterContainThi.write(out);
}

ID 851=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.io.FileWriter#FileWriter(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 852=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.io.Writer#append(java.lang.CharSequence)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 853=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 854=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.io.Writer#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 855=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.io.Writer#append(java.lang.CharSequence)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 856=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.io.Writer#write(java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 857=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.io.Writer#flush()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 858=========================================================================type: only_throws
package: org.apache.hama.pipes.util
Method:org.apache.hama.pipes.util.SequenceFileDumper#main(java.lang.String[])
Rmethod: java.io.Writer#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileDumper
public static void main(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return;
  }
  cli.addOption("file",false,"The Sequence File containing the Clusters","path");
  cli.addOption("output",false,"The output file.  If not specified, dumps to the console","path");
  cli.addOption("substring",false,"The number of chars of the FormatString() to print","number");
  cli.addOption("count",false,"Report the count only","number");
  Parser parser=cli.createParser();
  try {
    HamaConfiguration conf=new HamaConfiguration();
    CommandLine cmdLine=parser.parse(cli.options,args);
    if (cmdLine.hasOption("file")) {
      Path path=new Path(cmdLine.getOptionValue("file"));
      FileSystem fs=FileSystem.get(path.toUri(),conf);
      if (!fs.isFile(path)) {
        System.out.println("File does not exist: " + path.toString());
        return;
      }
      SequenceFile.Reader reader=new SequenceFile.Reader(fs,path,conf);
      Writer writer;
      if (cmdLine.hasOption("output")) {
        writer=new FileWriter(cmdLine.getOptionValue("output"));
      }
 else {
        writer=new OutputStreamWriter(System.out);
      }
      writer.append("Input Path: ").append(String.valueOf(path)).append(LINE_SEP);
      int sub=Integer.MAX_VALUE;
      if (cmdLine.hasOption("substring")) {
        sub=Integer.parseInt(cmdLine.getOptionValue("substring"));
      }
      Writable key;
      if (reader.getKeyClass() != NullWritable.class) {
        key=(Writable)reader.getKeyClass().newInstance();
      }
 else {
        key=NullWritable.get();
      }
      Writable value;
      if (reader.getValueClass() != NullWritable.class) {
        value=(Writable)reader.getValueClass().newInstance();
      }
 else {
        value=NullWritable.get();
      }
      writer.append("Key class: ").append(String.valueOf(reader.getKeyClass())).append(" Value Class: ").append(String.valueOf(value.getClass())).append(LINE_SEP);
      writer.flush();
      long count=0;
      boolean countOnly=cmdLine.hasOption("count");
      if (countOnly == false) {
        while (reader.next(key,value)) {
          writer.append("Key: ").append(String.valueOf(key));
          String str=value.toString();
          writer.append(": Value: ").append(str.length() > sub ? str.substring(0,sub) : str);
          writer.write(LINE_SEP);
          writer.flush();
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
 else {
        while (reader.next(key,value)) {
          count++;
        }
        writer.append("Count: ").append(String.valueOf(count)).append(LINE_SEP);
      }
      writer.flush();
      if (cmdLine.hasOption("output")) {
        writer.close();
      }
      reader.close();
    }
 else {
      cli.printUsage();
    }
  }
 catch (  ParseException e) {
    LOG.error(e.getMessage());
    cli.printUsage();
    return;
  }
}

ID 859=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.SequenceFileRecordReader#next(K, V)
Rmethod: org.apache.hama.bsp.SequenceFileRecordReader#getCurrentValue(V)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SequenceFileRecordReader
@Override public synchronized boolean next(K key,V value) throws IOException {
  if (!more)   return false;
  long pos=in.getPosition();
  boolean remaining=(in.next(key) != null);
  if (remaining) {
    getCurrentValue(value);
  }
  if (pos >= end && in.syncSeen()) {
    more=false;
  }
 else {
    more=remaining;
  }
  return more;
}

ID 860=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#bind(java.net.ServerSocket, java.net.InetSocketAddress, int)
Rmethod: java.net.ServerSocket#bind(java.net.SocketAddress, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * A convenience method to bind to a given address and report better exceptions if the address is not a valid host.
 * @param socket the socket to bind
 * @param address the address to bind to
 * @param backlog the number of connections allowed in the queue
 * @throws BindException if the address can't be bound
 * @throws UnknownHostException if the address isn't a valid host name
 * @throws IOException other random errors from bind
 */

catch: 
null
block: 
Server
/** 
 * A convenience method to bind to a given address and report better exceptions if the address is not a valid host.
 * @param socket the socket to bind
 * @param address the address to bind to
 * @param backlog the number of connections allowed in the queue
 * @throws BindException if the address can't be bound
 * @throws UnknownHostException if the address isn't a valid host name
 * @throws IOException other random errors from bind
 */
public static void bind(ServerSocket socket,InetSocketAddress address,int backlog) throws IOException {
  try {
    socket.bind(address,backlog);
  }
 catch (  BindException e) {
    BindException bindException=new BindException("Problem binding to " + address + " : "+ e.getMessage());
    bindException.initCause(e);
    throw bindException;
  }
catch (  SocketException e) {
    if ("Unresolved address".equals(e.getMessage())) {
      throw new UnknownHostException("Invalid hostname for server: " + address.getHostName());
    }
 else {
      throw e;
    }
  }
}

ID 861=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#Listener()
Rmethod: java.nio.channels.ServerSocketChannel#open()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
public Listener() throws IOException {
  address=new InetSocketAddress(bindAddress,port);
  acceptChannel=ServerSocketChannel.open();
  acceptChannel.configureBlocking(false);
  bind(acceptChannel.socket(),address,backlogLength);
  port=acceptChannel.socket().getLocalPort();
  selector=Selector.open();
  readers=new Reader[readThreads];
  for (int i=0; i < readThreads; i++) {
    Selector readSelector=Selector.open();
    Reader reader=new Reader("Socket Reader #" + (i + 1) + " for port "+ port,readSelector);
    readers[i]=reader;
    reader.start();
  }
  acceptChannel.register(selector,SelectionKey.OP_ACCEPT);
  this.setName("IPC Server listener on " + port);
  this.setDaemon(true);
}

ID 862=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#Listener()
Rmethod: java.nio.channels.spi.AbstractSelectableChannel#configureBlocking(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
public Listener() throws IOException {
  address=new InetSocketAddress(bindAddress,port);
  acceptChannel=ServerSocketChannel.open();
  acceptChannel.configureBlocking(false);
  bind(acceptChannel.socket(),address,backlogLength);
  port=acceptChannel.socket().getLocalPort();
  selector=Selector.open();
  readers=new Reader[readThreads];
  for (int i=0; i < readThreads; i++) {
    Selector readSelector=Selector.open();
    Reader reader=new Reader("Socket Reader #" + (i + 1) + " for port "+ port,readSelector);
    readers[i]=reader;
    reader.start();
  }
  acceptChannel.register(selector,SelectionKey.OP_ACCEPT);
  this.setName("IPC Server listener on " + port);
  this.setDaemon(true);
}

ID 863=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#Listener()
Rmethod: org.apache.hama.ipc.Server#bind(java.net.ServerSocket, java.net.InetSocketAddress, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
public Listener() throws IOException {
  address=new InetSocketAddress(bindAddress,port);
  acceptChannel=ServerSocketChannel.open();
  acceptChannel.configureBlocking(false);
  bind(acceptChannel.socket(),address,backlogLength);
  port=acceptChannel.socket().getLocalPort();
  selector=Selector.open();
  readers=new Reader[readThreads];
  for (int i=0; i < readThreads; i++) {
    Selector readSelector=Selector.open();
    Reader reader=new Reader("Socket Reader #" + (i + 1) + " for port "+ port,readSelector);
    readers[i]=reader;
    reader.start();
  }
  acceptChannel.register(selector,SelectionKey.OP_ACCEPT);
  this.setName("IPC Server listener on " + port);
  this.setDaemon(true);
}

ID 864=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#Listener()
Rmethod: java.nio.channels.Selector#open()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
public Listener() throws IOException {
  address=new InetSocketAddress(bindAddress,port);
  acceptChannel=ServerSocketChannel.open();
  acceptChannel.configureBlocking(false);
  bind(acceptChannel.socket(),address,backlogLength);
  port=acceptChannel.socket().getLocalPort();
  selector=Selector.open();
  readers=new Reader[readThreads];
  for (int i=0; i < readThreads; i++) {
    Selector readSelector=Selector.open();
    Reader reader=new Reader("Socket Reader #" + (i + 1) + " for port "+ port,readSelector);
    readers[i]=reader;
    reader.start();
  }
  acceptChannel.register(selector,SelectionKey.OP_ACCEPT);
  this.setName("IPC Server listener on " + port);
  this.setDaemon(true);
}

ID 865=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#Listener()
Rmethod: java.nio.channels.Selector#open()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
public Listener() throws IOException {
  address=new InetSocketAddress(bindAddress,port);
  acceptChannel=ServerSocketChannel.open();
  acceptChannel.configureBlocking(false);
  bind(acceptChannel.socket(),address,backlogLength);
  port=acceptChannel.socket().getLocalPort();
  selector=Selector.open();
  readers=new Reader[readThreads];
  for (int i=0; i < readThreads; i++) {
    Selector readSelector=Selector.open();
    Reader reader=new Reader("Socket Reader #" + (i + 1) + " for port "+ port,readSelector);
    readers[i]=reader;
    reader.start();
  }
  acceptChannel.register(selector,SelectionKey.OP_ACCEPT);
  this.setName("IPC Server listener on " + port);
  this.setDaemon(true);
}

ID 866=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#Listener()
Rmethod: java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.nio.channels.ClosedChannelException
exception comment: /** 
 * Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.  That this exception is thrown does not necessarily imply that the channel is completely closed.  A socket channel whose write half has been shut down, for example, may still be open for reading.
 * @since 1.4
 */

method comment: null
catch: 
null
block: 
Listener
public Listener() throws IOException {
  address=new InetSocketAddress(bindAddress,port);
  acceptChannel=ServerSocketChannel.open();
  acceptChannel.configureBlocking(false);
  bind(acceptChannel.socket(),address,backlogLength);
  port=acceptChannel.socket().getLocalPort();
  selector=Selector.open();
  readers=new Reader[readThreads];
  for (int i=0; i < readThreads; i++) {
    Selector readSelector=Selector.open();
    Reader reader=new Reader("Socket Reader #" + (i + 1) + " for port "+ port,readSelector);
    readers[i]=reader;
    reader.start();
  }
  acceptChannel.register(selector,SelectionKey.OP_ACCEPT);
  this.setName("IPC Server listener on " + port);
  this.setDaemon(true);
}

ID 867=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Reader#run()
Rmethod: java.nio.channels.Selector#select()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ex) {
  LOG.error("Error in Reader",ex);
}

block: 
Reader
public void run(){
  LOG.info("Starting " + getName());
synchronized (this) {
    while (running) {
      SelectionKey key=null;
      try {
        readSelector.select();
        while (adding) {
          this.wait(1000);
        }
        Iterator<SelectionKey> iter=readSelector.selectedKeys().iterator();
        while (iter.hasNext()) {
          key=iter.next();
          iter.remove();
          if (key.isValid()) {
            if (key.isReadable()) {
              doRead(key);
            }
          }
          key=null;
        }
      }
 catch (      InterruptedException e) {
        if (running) {
          LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
        }
      }
catch (      IOException ex) {
        LOG.error("Error in Reader",ex);
      }
    }
  }
}

ID 868=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Reader#run()
Rmethod: java.lang.Object#wait(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  if (running) {
    LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
  }
}

block: 
Reader
public void run(){
  LOG.info("Starting " + getName());
synchronized (this) {
    while (running) {
      SelectionKey key=null;
      try {
        readSelector.select();
        while (adding) {
          this.wait(1000);
        }
        Iterator<SelectionKey> iter=readSelector.selectedKeys().iterator();
        while (iter.hasNext()) {
          key=iter.next();
          iter.remove();
          if (key.isValid()) {
            if (key.isReadable()) {
              doRead(key);
            }
          }
          key=null;
        }
      }
 catch (      InterruptedException e) {
        if (running) {
          LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
        }
      }
catch (      IOException ex) {
        LOG.error("Error in Reader",ex);
      }
    }
  }
}

ID 869=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Reader#run()
Rmethod: org.apache.hama.ipc.Listener#doRead(java.nio.channels.SelectionKey)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  if (running) {
    LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
  }
}

block: 
Reader
public void run(){
  LOG.info("Starting " + getName());
synchronized (this) {
    while (running) {
      SelectionKey key=null;
      try {
        readSelector.select();
        while (adding) {
          this.wait(1000);
        }
        Iterator<SelectionKey> iter=readSelector.selectedKeys().iterator();
        while (iter.hasNext()) {
          key=iter.next();
          iter.remove();
          if (key.isValid()) {
            if (key.isReadable()) {
              doRead(key);
            }
          }
          key=null;
        }
      }
 catch (      InterruptedException e) {
        if (running) {
          LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
        }
      }
catch (      IOException ex) {
        LOG.error("Error in Reader",ex);
      }
    }
  }
}

ID 870=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Reader#registerChannel(java.nio.channels.SocketChannel)
Rmethod: java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.nio.channels.ClosedChannelException
exception comment: /** 
 * Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.  That this exception is thrown does not necessarily imply that the channel is completely closed.  A socket channel whose write half has been shut down, for example, may still be open for reading.
 * @since 1.4
 */

method comment: null
catch: 
null
block: 
Reader
public synchronized SelectionKey registerChannel(SocketChannel channel) throws IOException {
  return channel.register(readSelector,SelectionKey.OP_READ);
}

ID 871=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Reader#shutdown()
Rmethod: java.lang.Thread#join()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  Thread.currentThread().interrupt();
}

block: 
Reader
void shutdown(){
  assert !running;
  readSelector.wakeup();
  try {
    join();
  }
 catch (  InterruptedException ie) {
    Thread.currentThread().interrupt();
  }
}

ID 872=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#run()
Rmethod: java.nio.channels.Selector#select()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  closeCurrentConnection(key,e);
}

block: 
Listener
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  while (running) {
    SelectionKey key=null;
    try {
      selector.select();
      Iterator<SelectionKey> iter=selector.selectedKeys().iterator();
      while (iter.hasNext()) {
        key=iter.next();
        iter.remove();
        try {
          if (key.isValid()) {
            if (key.isAcceptable())             doAccept(key);
          }
        }
 catch (        IOException e) {
        }
        key=null;
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      closeCurrentConnection(key,e);
      cleanupConnections(true);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      closeCurrentConnection(key,e);
    }
    cleanupConnections(false);
  }
  LOG.info("Stopping " + this.getName());
synchronized (this) {
    try {
      acceptChannel.close();
      selector.close();
    }
 catch (    IOException e) {
    }
    selector=null;
    acceptChannel=null;
    while (!connectionList.isEmpty()) {
      closeConnection(connectionList.remove(0));
    }
  }
}

ID 873=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#run()
Rmethod: org.apache.hama.ipc.Listener#doAccept(java.nio.channels.SelectionKey)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
}

block: 
Listener
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  while (running) {
    SelectionKey key=null;
    try {
      selector.select();
      Iterator<SelectionKey> iter=selector.selectedKeys().iterator();
      while (iter.hasNext()) {
        key=iter.next();
        iter.remove();
        try {
          if (key.isValid()) {
            if (key.isAcceptable())             doAccept(key);
          }
        }
 catch (        IOException e) {
        }
        key=null;
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      closeCurrentConnection(key,e);
      cleanupConnections(true);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      closeCurrentConnection(key,e);
    }
    cleanupConnections(false);
  }
  LOG.info("Stopping " + this.getName());
synchronized (this) {
    try {
      acceptChannel.close();
      selector.close();
    }
 catch (    IOException e) {
    }
    selector=null;
    acceptChannel=null;
    while (!connectionList.isEmpty()) {
      closeConnection(connectionList.remove(0));
    }
  }
}

ID 874=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#run()
Rmethod: org.apache.hama.ipc.Listener#doAccept(java.nio.channels.SelectionKey)
hasForStatement: true
parentException: VirtualMachineError Error Throwable 
thrown: java.lang.OutOfMemoryError
exception comment: null
method comment: null
catch: 
null
block: 
Listener
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  while (running) {
    SelectionKey key=null;
    try {
      selector.select();
      Iterator<SelectionKey> iter=selector.selectedKeys().iterator();
      while (iter.hasNext()) {
        key=iter.next();
        iter.remove();
        try {
          if (key.isValid()) {
            if (key.isAcceptable())             doAccept(key);
          }
        }
 catch (        IOException e) {
        }
        key=null;
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      closeCurrentConnection(key,e);
      cleanupConnections(true);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      closeCurrentConnection(key,e);
    }
    cleanupConnections(false);
  }
  LOG.info("Stopping " + this.getName());
synchronized (this) {
    try {
      acceptChannel.close();
      selector.close();
    }
 catch (    IOException e) {
    }
    selector=null;
    acceptChannel=null;
    while (!connectionList.isEmpty()) {
      closeConnection(connectionList.remove(0));
    }
  }
}

ID 875=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#run()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception ie) {
}

block: 
Listener
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  while (running) {
    SelectionKey key=null;
    try {
      selector.select();
      Iterator<SelectionKey> iter=selector.selectedKeys().iterator();
      while (iter.hasNext()) {
        key=iter.next();
        iter.remove();
        try {
          if (key.isValid()) {
            if (key.isAcceptable())             doAccept(key);
          }
        }
 catch (        IOException e) {
        }
        key=null;
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      closeCurrentConnection(key,e);
      cleanupConnections(true);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      closeCurrentConnection(key,e);
    }
    cleanupConnections(false);
  }
  LOG.info("Stopping " + this.getName());
synchronized (this) {
    try {
      acceptChannel.close();
      selector.close();
    }
 catch (    IOException e) {
    }
    selector=null;
    acceptChannel=null;
    while (!connectionList.isEmpty()) {
      closeConnection(connectionList.remove(0));
    }
  }
}

ID 876=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#run()
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
}

block: 
Listener
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  while (running) {
    SelectionKey key=null;
    try {
      selector.select();
      Iterator<SelectionKey> iter=selector.selectedKeys().iterator();
      while (iter.hasNext()) {
        key=iter.next();
        iter.remove();
        try {
          if (key.isValid()) {
            if (key.isAcceptable())             doAccept(key);
          }
        }
 catch (        IOException e) {
        }
        key=null;
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      closeCurrentConnection(key,e);
      cleanupConnections(true);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      closeCurrentConnection(key,e);
    }
    cleanupConnections(false);
  }
  LOG.info("Stopping " + this.getName());
synchronized (this) {
    try {
      acceptChannel.close();
      selector.close();
    }
 catch (    IOException e) {
    }
    selector=null;
    acceptChannel=null;
    while (!connectionList.isEmpty()) {
      closeConnection(connectionList.remove(0));
    }
  }
}

ID 877=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#run()
Rmethod: java.nio.channels.Selector#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
}

block: 
Listener
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  while (running) {
    SelectionKey key=null;
    try {
      selector.select();
      Iterator<SelectionKey> iter=selector.selectedKeys().iterator();
      while (iter.hasNext()) {
        key=iter.next();
        iter.remove();
        try {
          if (key.isValid()) {
            if (key.isAcceptable())             doAccept(key);
          }
        }
 catch (        IOException e) {
        }
        key=null;
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      closeCurrentConnection(key,e);
      cleanupConnections(true);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      closeCurrentConnection(key,e);
    }
    cleanupConnections(false);
  }
  LOG.info("Stopping " + this.getName());
synchronized (this) {
    try {
      acceptChannel.close();
      selector.close();
    }
 catch (    IOException e) {
    }
    selector=null;
    acceptChannel=null;
    while (!connectionList.isEmpty()) {
      closeConnection(connectionList.remove(0));
    }
  }
}

ID 878=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#doAccept(java.nio.channels.SelectionKey)
Rmethod: java.nio.channels.ServerSocketChannel#accept()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
void doAccept(SelectionKey key) throws IOException, OutOfMemoryError {
  Connection c=null;
  ServerSocketChannel server=(ServerSocketChannel)key.channel();
  SocketChannel channel;
  while ((channel=server.accept()) != null) {
    channel.configureBlocking(false);
    channel.socket().setTcpNoDelay(tcpNoDelay);
    Reader reader=getReader();
    try {
      reader.startAdd();
      SelectionKey readKey=reader.registerChannel(channel);
      c=new Connection(readKey,channel,System.currentTimeMillis());
      readKey.attach(c);
synchronized (connectionList) {
        connectionList.add(numConnections,c);
        numConnections++;
      }
      if (LOG.isDebugEnabled())       LOG.debug("Server connection from " + c.toString() + "; # active connections: "+ numConnections+ "; # queued calls: "+ callQueue.size());
    }
  finally {
      reader.finishAdd();
    }
  }
}

ID 879=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#doAccept(java.nio.channels.SelectionKey)
Rmethod: java.nio.channels.spi.AbstractSelectableChannel#configureBlocking(boolean)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
void doAccept(SelectionKey key) throws IOException, OutOfMemoryError {
  Connection c=null;
  ServerSocketChannel server=(ServerSocketChannel)key.channel();
  SocketChannel channel;
  while ((channel=server.accept()) != null) {
    channel.configureBlocking(false);
    channel.socket().setTcpNoDelay(tcpNoDelay);
    Reader reader=getReader();
    try {
      reader.startAdd();
      SelectionKey readKey=reader.registerChannel(channel);
      c=new Connection(readKey,channel,System.currentTimeMillis());
      readKey.attach(c);
synchronized (connectionList) {
        connectionList.add(numConnections,c);
        numConnections++;
      }
      if (LOG.isDebugEnabled())       LOG.debug("Server connection from " + c.toString() + "; # active connections: "+ numConnections+ "; # queued calls: "+ callQueue.size());
    }
  finally {
      reader.finishAdd();
    }
  }
}

ID 880=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#doAccept(java.nio.channels.SelectionKey)
Rmethod: java.net.Socket#setTcpNoDelay(boolean)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
void doAccept(SelectionKey key) throws IOException, OutOfMemoryError {
  Connection c=null;
  ServerSocketChannel server=(ServerSocketChannel)key.channel();
  SocketChannel channel;
  while ((channel=server.accept()) != null) {
    channel.configureBlocking(false);
    channel.socket().setTcpNoDelay(tcpNoDelay);
    Reader reader=getReader();
    try {
      reader.startAdd();
      SelectionKey readKey=reader.registerChannel(channel);
      c=new Connection(readKey,channel,System.currentTimeMillis());
      readKey.attach(c);
synchronized (connectionList) {
        connectionList.add(numConnections,c);
        numConnections++;
      }
      if (LOG.isDebugEnabled())       LOG.debug("Server connection from " + c.toString() + "; # active connections: "+ numConnections+ "; # queued calls: "+ callQueue.size());
    }
  finally {
      reader.finishAdd();
    }
  }
}

ID 881=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#doAccept(java.nio.channels.SelectionKey)
Rmethod: org.apache.hama.ipc.Reader#registerChannel(java.nio.channels.SocketChannel)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Listener
void doAccept(SelectionKey key) throws IOException, OutOfMemoryError {
  Connection c=null;
  ServerSocketChannel server=(ServerSocketChannel)key.channel();
  SocketChannel channel;
  while ((channel=server.accept()) != null) {
    channel.configureBlocking(false);
    channel.socket().setTcpNoDelay(tcpNoDelay);
    Reader reader=getReader();
    try {
      reader.startAdd();
      SelectionKey readKey=reader.registerChannel(channel);
      c=new Connection(readKey,channel,System.currentTimeMillis());
      readKey.attach(c);
synchronized (connectionList) {
        connectionList.add(numConnections,c);
        numConnections++;
      }
      if (LOG.isDebugEnabled())       LOG.debug("Server connection from " + c.toString() + "; # active connections: "+ numConnections+ "; # queued calls: "+ callQueue.size());
    }
  finally {
      reader.finishAdd();
    }
  }
}

ID 882=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#doRead(java.nio.channels.SelectionKey)
Rmethod: org.apache.hama.ipc.Connection#readAndProcess()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.info(getName() + ": readAndProcess threw exception " + e+ ". Count of bytes read: "+ count,e);
  count=-1;
}

block: 
Listener
void doRead(SelectionKey key) throws InterruptedException {
  int count=0;
  Connection c=(Connection)key.attachment();
  if (c == null) {
    return;
  }
  c.setLastContact(System.currentTimeMillis());
  try {
    count=c.readAndProcess();
  }
 catch (  InterruptedException ieo) {
    LOG.info(getName() + ": readAndProcess caught InterruptedException",ieo);
    throw ieo;
  }
catch (  Exception e) {
    LOG.info(getName() + ": readAndProcess threw exception " + e+ ". Count of bytes read: "+ count,e);
    count=-1;
  }
  if (count < 0) {
    if (LOG.isDebugEnabled())     LOG.debug(getName() + ": disconnecting client " + c+ ". Number of active connections: "+ numConnections);
    closeConnection(c);
    c=null;
  }
 else {
    c.setLastContact(System.currentTimeMillis());
  }
}

ID 883=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#doRead(java.nio.channels.SelectionKey)
Rmethod: org.apache.hama.ipc.Connection#readAndProcess()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.info(getName() + ": readAndProcess threw exception " + e+ ". Count of bytes read: "+ count,e);
  count=-1;
}

block: 
Listener
void doRead(SelectionKey key) throws InterruptedException {
  int count=0;
  Connection c=(Connection)key.attachment();
  if (c == null) {
    return;
  }
  c.setLastContact(System.currentTimeMillis());
  try {
    count=c.readAndProcess();
  }
 catch (  InterruptedException ieo) {
    LOG.info(getName() + ": readAndProcess caught InterruptedException",ieo);
    throw ieo;
  }
catch (  Exception e) {
    LOG.info(getName() + ": readAndProcess threw exception " + e+ ". Count of bytes read: "+ count,e);
    count=-1;
  }
  if (count < 0) {
    if (LOG.isDebugEnabled())     LOG.debug(getName() + ": disconnecting client " + c+ ". Number of active connections: "+ numConnections);
    closeConnection(c);
    c=null;
  }
 else {
    c.setLastContact(System.currentTimeMillis());
  }
}

ID 884=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Listener#doStop()
Rmethod: java.net.ServerSocket#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.info(getName() + ":Exception in closing listener socket. " + e);
}

block: 
Listener
synchronized void doStop(){
  if (selector != null) {
    selector.wakeup();
    Thread.yield();
  }
  if (acceptChannel != null) {
    try {
      acceptChannel.socket().close();
    }
 catch (    IOException e) {
      LOG.info(getName() + ":Exception in closing listener socket. " + e);
    }
  }
  for (  Reader r : readers) {
    r.shutdown();
  }
}

ID 885=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#Responder()
Rmethod: java.nio.channels.Selector#open()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Responder
Responder() throws IOException {
  this.setName("IPC Server Responder");
  this.setDaemon(true);
  writeSelector=Selector.open();
  pending=0;
}

ID 886=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#run()
Rmethod: org.apache.hama.ipc.Responder#waitPending()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
}

block: 
Responder
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  long lastPurgeTime=0;
  while (running) {
    try {
      waitPending();
      writeSelector.select(PURGE_INTERVAL);
      Iterator<SelectionKey> iter=writeSelector.selectedKeys().iterator();
      while (iter.hasNext()) {
        SelectionKey key=iter.next();
        iter.remove();
        try {
          if (key.isValid() && key.isWritable()) {
            doAsyncWrite(key);
          }
        }
 catch (        IOException e) {
          LOG.info(getName() + ": doAsyncWrite threw exception " + e);
        }
      }
      long now=System.currentTimeMillis();
      if (now < lastPurgeTime + PURGE_INTERVAL) {
        continue;
      }
      lastPurgeTime=now;
      LOG.debug("Checking for old call responses.");
      ArrayList<Call> calls;
synchronized (writeSelector.keys()) {
        calls=new ArrayList<Call>(writeSelector.keys().size());
        iter=writeSelector.keys().iterator();
        while (iter.hasNext()) {
          SelectionKey key=iter.next();
          Call call=(Call)key.attachment();
          if (call != null && key.channel() == call.connection.channel) {
            calls.add(call);
          }
        }
      }
      for (      Call call : calls) {
        try {
          doPurge(call,now);
        }
 catch (        IOException e) {
          LOG.warn("Error in purging old calls " + e);
        }
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
    }
  }
  LOG.info("Stopping " + this.getName());
}

ID 887=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#run()
Rmethod: java.nio.channels.Selector#select(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
}

block: 
Responder
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  long lastPurgeTime=0;
  while (running) {
    try {
      waitPending();
      writeSelector.select(PURGE_INTERVAL);
      Iterator<SelectionKey> iter=writeSelector.selectedKeys().iterator();
      while (iter.hasNext()) {
        SelectionKey key=iter.next();
        iter.remove();
        try {
          if (key.isValid() && key.isWritable()) {
            doAsyncWrite(key);
          }
        }
 catch (        IOException e) {
          LOG.info(getName() + ": doAsyncWrite threw exception " + e);
        }
      }
      long now=System.currentTimeMillis();
      if (now < lastPurgeTime + PURGE_INTERVAL) {
        continue;
      }
      lastPurgeTime=now;
      LOG.debug("Checking for old call responses.");
      ArrayList<Call> calls;
synchronized (writeSelector.keys()) {
        calls=new ArrayList<Call>(writeSelector.keys().size());
        iter=writeSelector.keys().iterator();
        while (iter.hasNext()) {
          SelectionKey key=iter.next();
          Call call=(Call)key.attachment();
          if (call != null && key.channel() == call.connection.channel) {
            calls.add(call);
          }
        }
      }
      for (      Call call : calls) {
        try {
          doPurge(call,now);
        }
 catch (        IOException e) {
          LOG.warn("Error in purging old calls " + e);
        }
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
    }
  }
  LOG.info("Stopping " + this.getName());
}

ID 888=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#run()
Rmethod: org.apache.hama.ipc.Responder#doAsyncWrite(java.nio.channels.SelectionKey)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.info(getName() + ": doAsyncWrite threw exception " + e);
}

block: 
Responder
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  long lastPurgeTime=0;
  while (running) {
    try {
      waitPending();
      writeSelector.select(PURGE_INTERVAL);
      Iterator<SelectionKey> iter=writeSelector.selectedKeys().iterator();
      while (iter.hasNext()) {
        SelectionKey key=iter.next();
        iter.remove();
        try {
          if (key.isValid() && key.isWritable()) {
            doAsyncWrite(key);
          }
        }
 catch (        IOException e) {
          LOG.info(getName() + ": doAsyncWrite threw exception " + e);
        }
      }
      long now=System.currentTimeMillis();
      if (now < lastPurgeTime + PURGE_INTERVAL) {
        continue;
      }
      lastPurgeTime=now;
      LOG.debug("Checking for old call responses.");
      ArrayList<Call> calls;
synchronized (writeSelector.keys()) {
        calls=new ArrayList<Call>(writeSelector.keys().size());
        iter=writeSelector.keys().iterator();
        while (iter.hasNext()) {
          SelectionKey key=iter.next();
          Call call=(Call)key.attachment();
          if (call != null && key.channel() == call.connection.channel) {
            calls.add(call);
          }
        }
      }
      for (      Call call : calls) {
        try {
          doPurge(call,now);
        }
 catch (        IOException e) {
          LOG.warn("Error in purging old calls " + e);
        }
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
    }
  }
  LOG.info("Stopping " + this.getName());
}

ID 889=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#run()
Rmethod: org.apache.hama.ipc.Responder#doPurge(org.apache.hama.ipc.Server.Call, long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.warn("Error in purging old calls " + e);
}

block: 
Responder
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  long lastPurgeTime=0;
  while (running) {
    try {
      waitPending();
      writeSelector.select(PURGE_INTERVAL);
      Iterator<SelectionKey> iter=writeSelector.selectedKeys().iterator();
      while (iter.hasNext()) {
        SelectionKey key=iter.next();
        iter.remove();
        try {
          if (key.isValid() && key.isWritable()) {
            doAsyncWrite(key);
          }
        }
 catch (        IOException e) {
          LOG.info(getName() + ": doAsyncWrite threw exception " + e);
        }
      }
      long now=System.currentTimeMillis();
      if (now < lastPurgeTime + PURGE_INTERVAL) {
        continue;
      }
      lastPurgeTime=now;
      LOG.debug("Checking for old call responses.");
      ArrayList<Call> calls;
synchronized (writeSelector.keys()) {
        calls=new ArrayList<Call>(writeSelector.keys().size());
        iter=writeSelector.keys().iterator();
        while (iter.hasNext()) {
          SelectionKey key=iter.next();
          Call call=(Call)key.attachment();
          if (call != null && key.channel() == call.connection.channel) {
            calls.add(call);
          }
        }
      }
      for (      Call call : calls) {
        try {
          doPurge(call,now);
        }
 catch (        IOException e) {
          LOG.warn("Error in purging old calls " + e);
        }
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
    }
  }
  LOG.info("Stopping " + this.getName());
}

ID 890=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#run()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception ie) {
}

block: 
Responder
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  long lastPurgeTime=0;
  while (running) {
    try {
      waitPending();
      writeSelector.select(PURGE_INTERVAL);
      Iterator<SelectionKey> iter=writeSelector.selectedKeys().iterator();
      while (iter.hasNext()) {
        SelectionKey key=iter.next();
        iter.remove();
        try {
          if (key.isValid() && key.isWritable()) {
            doAsyncWrite(key);
          }
        }
 catch (        IOException e) {
          LOG.info(getName() + ": doAsyncWrite threw exception " + e);
        }
      }
      long now=System.currentTimeMillis();
      if (now < lastPurgeTime + PURGE_INTERVAL) {
        continue;
      }
      lastPurgeTime=now;
      LOG.debug("Checking for old call responses.");
      ArrayList<Call> calls;
synchronized (writeSelector.keys()) {
        calls=new ArrayList<Call>(writeSelector.keys().size());
        iter=writeSelector.keys().iterator();
        while (iter.hasNext()) {
          SelectionKey key=iter.next();
          Call call=(Call)key.attachment();
          if (call != null && key.channel() == call.connection.channel) {
            calls.add(call);
          }
        }
      }
      for (      Call call : calls) {
        try {
          doPurge(call,now);
        }
 catch (        IOException e) {
          LOG.warn("Error in purging old calls " + e);
        }
      }
    }
 catch (    OutOfMemoryError e) {
      LOG.warn("Out of Memory in server select",e);
      try {
        Thread.sleep(60000);
      }
 catch (      Exception ie) {
      }
    }
catch (    Exception e) {
      LOG.warn("Exception in Responder " + StringUtils.stringifyException(e));
    }
  }
  LOG.info("Stopping " + this.getName());
}

ID 891=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#doAsyncWrite(java.nio.channels.SelectionKey)
Rmethod: org.apache.hama.ipc.Responder#processResponse(LinkedList<org.apache.hama.ipc.Server.Call>, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Responder
private void doAsyncWrite(SelectionKey key) throws IOException {
  Call call=(Call)key.attachment();
  if (call == null) {
    return;
  }
  if (key.channel() != call.connection.channel) {
    throw new IOException("doAsyncWrite: bad channel");
  }
synchronized (call.connection.responseQueue) {
    if (processResponse(call.connection.responseQueue,false)) {
      try {
        key.interestOps(0);
      }
 catch (      CancelledKeyException e) {
        LOG.warn("Exception while changing ops : " + e);
      }
    }
  }
}

ID 892=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#processResponse(LinkedList<org.apache.hama.ipc.Server.Call>, boolean)
Rmethod: org.apache.hama.ipc.Server#channelWrite(java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Responder
private boolean processResponse(LinkedList<Call> responseQueue,boolean inHandler) throws IOException {
  boolean error=true;
  boolean done=false;
  int numElements=0;
  Call call=null;
  try {
synchronized (responseQueue) {
      numElements=responseQueue.size();
      if (numElements == 0) {
        error=false;
        return true;
      }
      call=responseQueue.removeFirst();
      SocketChannel channel=call.connection.channel;
      if (LOG.isDebugEnabled()) {
        LOG.debug(getName() + ": responding to #" + call.id+ " from "+ call.connection);
      }
      int numBytes=channelWrite(channel,call.response);
      if (numBytes < 0) {
        return true;
      }
      if (!call.response.hasRemaining()) {
        call.connection.decRpcCount();
        if (numElements == 1) {
          done=true;
        }
 else {
          done=false;
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug(getName() + ": responding to #" + call.id+ " from "+ call.connection+ " Wrote "+ numBytes+ " bytes.");
        }
      }
 else {
        call.connection.responseQueue.addFirst(call);
        if (inHandler) {
          call.timestamp=System.currentTimeMillis();
          incPending();
          try {
            writeSelector.wakeup();
            channel.register(writeSelector,SelectionKey.OP_WRITE,call);
          }
 catch (          ClosedChannelException e) {
            done=true;
          }
 finally {
            decPending();
          }
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug(getName() + ": responding to #" + call.id+ " from "+ call.connection+ " Wrote partial "+ numBytes+ " bytes.");
        }
      }
      error=false;
    }
  }
  finally {
    if (error && call != null) {
      LOG.warn(getName() + ", call " + call+ ": output error");
      done=true;
      closeConnection(call.connection);
    }
  }
  return done;
}

ID 893=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#processResponse(LinkedList<org.apache.hama.ipc.Server.Call>, boolean)
Rmethod: java.nio.channels.spi.AbstractSelectableChannel#register(java.nio.channels.Selector, int, java.lang.Object)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.nio.channels.ClosedChannelException
exception comment: /** 
 * Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.  That this exception is thrown does not necessarily imply that the channel is completely closed.  A socket channel whose write half has been shut down, for example, may still be open for reading.
 * @since 1.4
 */

method comment: null
catch: 
catch (ClosedChannelException e) {
  done=true;
}

block: 
Responder
private boolean processResponse(LinkedList<Call> responseQueue,boolean inHandler) throws IOException {
  boolean error=true;
  boolean done=false;
  int numElements=0;
  Call call=null;
  try {
synchronized (responseQueue) {
      numElements=responseQueue.size();
      if (numElements == 0) {
        error=false;
        return true;
      }
      call=responseQueue.removeFirst();
      SocketChannel channel=call.connection.channel;
      if (LOG.isDebugEnabled()) {
        LOG.debug(getName() + ": responding to #" + call.id+ " from "+ call.connection);
      }
      int numBytes=channelWrite(channel,call.response);
      if (numBytes < 0) {
        return true;
      }
      if (!call.response.hasRemaining()) {
        call.connection.decRpcCount();
        if (numElements == 1) {
          done=true;
        }
 else {
          done=false;
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug(getName() + ": responding to #" + call.id+ " from "+ call.connection+ " Wrote "+ numBytes+ " bytes.");
        }
      }
 else {
        call.connection.responseQueue.addFirst(call);
        if (inHandler) {
          call.timestamp=System.currentTimeMillis();
          incPending();
          try {
            writeSelector.wakeup();
            channel.register(writeSelector,SelectionKey.OP_WRITE,call);
          }
 catch (          ClosedChannelException e) {
            done=true;
          }
 finally {
            decPending();
          }
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug(getName() + ": responding to #" + call.id+ " from "+ call.connection+ " Wrote partial "+ numBytes+ " bytes.");
        }
      }
      error=false;
    }
  }
  finally {
    if (error && call != null) {
      LOG.warn(getName() + ", call " + call+ ": output error");
      done=true;
      closeConnection(call.connection);
    }
  }
  return done;
}

ID 894=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#doRespond(org.apache.hama.ipc.Server.Call)
Rmethod: org.apache.hama.ipc.Responder#processResponse(LinkedList<org.apache.hama.ipc.Server.Call>, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Responder
void doRespond(Call call) throws IOException {
synchronized (call.connection.responseQueue) {
    call.connection.responseQueue.addLast(call);
    if (call.connection.responseQueue.size() == 1) {
      processResponse(call.connection.responseQueue,true);
    }
  }
}

ID 895=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Responder#waitPending()
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Responder
private synchronized void waitPending() throws InterruptedException {
  while (pending > 0) {
    wait();
  }
}

ID 896=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#Connection(java.nio.channels.SelectionKey, java.nio.channels.SocketChannel, long)
Rmethod: java.net.Socket#setSendBufferSize(int)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.warn("Connection: unable to set socket send buffer size to " + socketSendBufferSize);
}

block: 
Connection
public Connection(SelectionKey key,SocketChannel channel,long lastContact){
  this.channel=channel;
  this.lastContact=lastContact;
  this.data=null;
  this.dataLengthBuffer=ByteBuffer.allocate(4);
  this.socket=channel.socket();
  this.addr=socket.getInetAddress();
  if (addr == null) {
    this.hostAddress="*Unknown*";
  }
 else {
    this.hostAddress=addr.getHostAddress();
  }
  this.remotePort=socket.getPort();
  this.responseQueue=new LinkedList<Call>();
  if (socketSendBufferSize != 0) {
    try {
      socket.setSendBufferSize(socketSendBufferSize);
    }
 catch (    IOException e) {
      LOG.warn("Connection: unable to set socket send buffer size to " + socketSendBufferSize);
    }
  }
}

ID 897=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#readAndProcess()
Rmethod: org.apache.hama.ipc.Server#channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
public int readAndProcess() throws IOException, InterruptedException {
  while (true) {
    int count=-1;
    if (dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,dataLengthBuffer);
      if (count < 0 || dataLengthBuffer.remaining() > 0)       return count;
    }
    if (!rpcHeaderRead) {
      if (rpcHeaderBuffer == null) {
        rpcHeaderBuffer=ByteBuffer.allocate(2);
      }
      count=channelRead(channel,rpcHeaderBuffer);
      if (count < 0 || rpcHeaderBuffer.remaining() > 0) {
        return count;
      }
      int version=rpcHeaderBuffer.get(0);
      byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
      authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
      dataLengthBuffer.flip();
      if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
        LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":"+ remotePort+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
        return -1;
      }
      dataLengthBuffer.clear();
      if (authMethod == null) {
        throw new IOException("Unable to read authentication method");
      }
      if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {
        AccessControlException ae=new AccessControlException("Authorization (" + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION + ") is enabled but authentication ("+ CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION+ ") is configured as simple. Please configure another method "+ "like kerberos or digest.");
        setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
        responder.doRespond(authFailedCall);
        throw ae;
      }
      if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {
        authMethod=AuthMethod.SIMPLE;
        skipInitialSaslHandshake=true;
      }
      rpcHeaderBuffer=null;
      rpcHeaderRead=true;
      continue;
    }
    if (data == null) {
      dataLengthBuffer.flip();
      dataLength=dataLengthBuffer.getInt();
      if (dataLength == Client.PING_CALL_ID) {
        if (!useWrap) {
          dataLengthBuffer.clear();
          return 0;
        }
      }
      if (dataLength < 0) {
        LOG.warn("Unexpected data length " + dataLength + "!! from "+ getHostAddress());
      }
      data=ByteBuffer.allocate(dataLength);
    }
    count=channelRead(channel,data);
    if (data.remaining() == 0) {
      dataLengthBuffer.clear();
      data.flip();
      if (skipInitialSaslHandshake) {
        data=null;
        skipInitialSaslHandshake=false;
        continue;
      }
      boolean isHeaderRead=headerRead;
      processOneRpc(data.array());
      data=null;
      if (!isHeaderRead) {
        continue;
      }
    }
    return count;
  }
}

ID 898=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#readAndProcess()
Rmethod: org.apache.hama.ipc.Server#setupResponse(java.io.ByteArrayOutputStream, org.apache.hama.ipc.Server.Call, Status, Writable, java.lang.String, java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
public int readAndProcess() throws IOException, InterruptedException {
  while (true) {
    int count=-1;
    if (dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,dataLengthBuffer);
      if (count < 0 || dataLengthBuffer.remaining() > 0)       return count;
    }
    if (!rpcHeaderRead) {
      if (rpcHeaderBuffer == null) {
        rpcHeaderBuffer=ByteBuffer.allocate(2);
      }
      count=channelRead(channel,rpcHeaderBuffer);
      if (count < 0 || rpcHeaderBuffer.remaining() > 0) {
        return count;
      }
      int version=rpcHeaderBuffer.get(0);
      byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
      authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
      dataLengthBuffer.flip();
      if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
        LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":"+ remotePort+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
        return -1;
      }
      dataLengthBuffer.clear();
      if (authMethod == null) {
        throw new IOException("Unable to read authentication method");
      }
      if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {
        AccessControlException ae=new AccessControlException("Authorization (" + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION + ") is enabled but authentication ("+ CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION+ ") is configured as simple. Please configure another method "+ "like kerberos or digest.");
        setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
        responder.doRespond(authFailedCall);
        throw ae;
      }
      if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {
        authMethod=AuthMethod.SIMPLE;
        skipInitialSaslHandshake=true;
      }
      rpcHeaderBuffer=null;
      rpcHeaderRead=true;
      continue;
    }
    if (data == null) {
      dataLengthBuffer.flip();
      dataLength=dataLengthBuffer.getInt();
      if (dataLength == Client.PING_CALL_ID) {
        if (!useWrap) {
          dataLengthBuffer.clear();
          return 0;
        }
      }
      if (dataLength < 0) {
        LOG.warn("Unexpected data length " + dataLength + "!! from "+ getHostAddress());
      }
      data=ByteBuffer.allocate(dataLength);
    }
    count=channelRead(channel,data);
    if (data.remaining() == 0) {
      dataLengthBuffer.clear();
      data.flip();
      if (skipInitialSaslHandshake) {
        data=null;
        skipInitialSaslHandshake=false;
        continue;
      }
      boolean isHeaderRead=headerRead;
      processOneRpc(data.array());
      data=null;
      if (!isHeaderRead) {
        continue;
      }
    }
    return count;
  }
}

ID 899=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#readAndProcess()
Rmethod: org.apache.hama.ipc.Responder#doRespond(org.apache.hama.ipc.Server.Call)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
public int readAndProcess() throws IOException, InterruptedException {
  while (true) {
    int count=-1;
    if (dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,dataLengthBuffer);
      if (count < 0 || dataLengthBuffer.remaining() > 0)       return count;
    }
    if (!rpcHeaderRead) {
      if (rpcHeaderBuffer == null) {
        rpcHeaderBuffer=ByteBuffer.allocate(2);
      }
      count=channelRead(channel,rpcHeaderBuffer);
      if (count < 0 || rpcHeaderBuffer.remaining() > 0) {
        return count;
      }
      int version=rpcHeaderBuffer.get(0);
      byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
      authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
      dataLengthBuffer.flip();
      if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
        LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":"+ remotePort+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
        return -1;
      }
      dataLengthBuffer.clear();
      if (authMethod == null) {
        throw new IOException("Unable to read authentication method");
      }
      if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {
        AccessControlException ae=new AccessControlException("Authorization (" + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION + ") is enabled but authentication ("+ CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION+ ") is configured as simple. Please configure another method "+ "like kerberos or digest.");
        setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
        responder.doRespond(authFailedCall);
        throw ae;
      }
      if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {
        authMethod=AuthMethod.SIMPLE;
        skipInitialSaslHandshake=true;
      }
      rpcHeaderBuffer=null;
      rpcHeaderRead=true;
      continue;
    }
    if (data == null) {
      dataLengthBuffer.flip();
      dataLength=dataLengthBuffer.getInt();
      if (dataLength == Client.PING_CALL_ID) {
        if (!useWrap) {
          dataLengthBuffer.clear();
          return 0;
        }
      }
      if (dataLength < 0) {
        LOG.warn("Unexpected data length " + dataLength + "!! from "+ getHostAddress());
      }
      data=ByteBuffer.allocate(dataLength);
    }
    count=channelRead(channel,data);
    if (data.remaining() == 0) {
      dataLengthBuffer.clear();
      data.flip();
      if (skipInitialSaslHandshake) {
        data=null;
        skipInitialSaslHandshake=false;
        continue;
      }
      boolean isHeaderRead=headerRead;
      processOneRpc(data.array());
      data=null;
      if (!isHeaderRead) {
        continue;
      }
    }
    return count;
  }
}

ID 900=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#readAndProcess()
Rmethod: org.apache.hama.ipc.Connection#processOneRpc(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
public int readAndProcess() throws IOException, InterruptedException {
  while (true) {
    int count=-1;
    if (dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,dataLengthBuffer);
      if (count < 0 || dataLengthBuffer.remaining() > 0)       return count;
    }
    if (!rpcHeaderRead) {
      if (rpcHeaderBuffer == null) {
        rpcHeaderBuffer=ByteBuffer.allocate(2);
      }
      count=channelRead(channel,rpcHeaderBuffer);
      if (count < 0 || rpcHeaderBuffer.remaining() > 0) {
        return count;
      }
      int version=rpcHeaderBuffer.get(0);
      byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
      authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
      dataLengthBuffer.flip();
      if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
        LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":"+ remotePort+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
        return -1;
      }
      dataLengthBuffer.clear();
      if (authMethod == null) {
        throw new IOException("Unable to read authentication method");
      }
      if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {
        AccessControlException ae=new AccessControlException("Authorization (" + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION + ") is enabled but authentication ("+ CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION+ ") is configured as simple. Please configure another method "+ "like kerberos or digest.");
        setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
        responder.doRespond(authFailedCall);
        throw ae;
      }
      if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {
        authMethod=AuthMethod.SIMPLE;
        skipInitialSaslHandshake=true;
      }
      rpcHeaderBuffer=null;
      rpcHeaderRead=true;
      continue;
    }
    if (data == null) {
      dataLengthBuffer.flip();
      dataLength=dataLengthBuffer.getInt();
      if (dataLength == Client.PING_CALL_ID) {
        if (!useWrap) {
          dataLengthBuffer.clear();
          return 0;
        }
      }
      if (dataLength < 0) {
        LOG.warn("Unexpected data length " + dataLength + "!! from "+ getHostAddress());
      }
      data=ByteBuffer.allocate(dataLength);
    }
    count=channelRead(channel,data);
    if (data.remaining() == 0) {
      dataLengthBuffer.clear();
      data.flip();
      if (skipInitialSaslHandshake) {
        data=null;
        skipInitialSaslHandshake=false;
        continue;
      }
      boolean isHeaderRead=headerRead;
      processOneRpc(data.array());
      data=null;
      if (!isHeaderRead) {
        continue;
      }
    }
    return count;
  }
}

ID 901=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#readAndProcess()
Rmethod: org.apache.hama.ipc.Connection#processOneRpc(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
public int readAndProcess() throws IOException, InterruptedException {
  while (true) {
    int count=-1;
    if (dataLengthBuffer.remaining() > 0) {
      count=channelRead(channel,dataLengthBuffer);
      if (count < 0 || dataLengthBuffer.remaining() > 0)       return count;
    }
    if (!rpcHeaderRead) {
      if (rpcHeaderBuffer == null) {
        rpcHeaderBuffer=ByteBuffer.allocate(2);
      }
      count=channelRead(channel,rpcHeaderBuffer);
      if (count < 0 || rpcHeaderBuffer.remaining() > 0) {
        return count;
      }
      int version=rpcHeaderBuffer.get(0);
      byte[] method=new byte[]{rpcHeaderBuffer.get(1)};
      authMethod=AuthMethod.read(new DataInputStream(new ByteArrayInputStream(method)));
      dataLengthBuffer.flip();
      if (!HEADER.equals(dataLengthBuffer) || version != CURRENT_VERSION) {
        LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":"+ remotePort+ " got version "+ version+ " expected version "+ CURRENT_VERSION);
        return -1;
      }
      dataLengthBuffer.clear();
      if (authMethod == null) {
        throw new IOException("Unable to read authentication method");
      }
      if (isSecurityEnabled && authMethod == AuthMethod.SIMPLE) {
        AccessControlException ae=new AccessControlException("Authorization (" + CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION + ") is enabled but authentication ("+ CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION+ ") is configured as simple. Please configure another method "+ "like kerberos or digest.");
        setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
        responder.doRespond(authFailedCall);
        throw ae;
      }
      if (!isSecurityEnabled && authMethod != AuthMethod.SIMPLE) {
        authMethod=AuthMethod.SIMPLE;
        skipInitialSaslHandshake=true;
      }
      rpcHeaderBuffer=null;
      rpcHeaderRead=true;
      continue;
    }
    if (data == null) {
      dataLengthBuffer.flip();
      dataLength=dataLengthBuffer.getInt();
      if (dataLength == Client.PING_CALL_ID) {
        if (!useWrap) {
          dataLengthBuffer.clear();
          return 0;
        }
      }
      if (dataLength < 0) {
        LOG.warn("Unexpected data length " + dataLength + "!! from "+ getHostAddress());
      }
      data=ByteBuffer.allocate(dataLength);
    }
    count=channelRead(channel,data);
    if (data.remaining() == 0) {
      dataLengthBuffer.clear();
      data.flip();
      if (skipInitialSaslHandshake) {
        data=null;
        skipInitialSaslHandshake=false;
        continue;
      }
      boolean isHeaderRead=headerRead;
      processOneRpc(data.array());
      data=null;
      if (!isHeaderRead) {
        continue;
      }
    }
    return count;
  }
}

ID 902=========================================================================type: Rethrow
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#processHeader(byte[])
Rmethod: org.apache.hama.ipc.Server#getProtocolClass(java.lang.String, Configuration)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (ClassNotFoundException cnfe) {
  throw new IOException("Unknown protocol: " + header.getProtocol());
}

block: 
Connection
private void processHeader(byte[] buf) throws IOException {
  DataInputStream in=new DataInputStream(new ByteArrayInputStream(buf));
  header.readFields(in);
  try {
    String protocolClassName=header.getProtocol();
    if (protocolClassName != null) {
      protocol=getProtocolClass(header.getProtocol(),conf);
    }
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException("Unknown protocol: " + header.getProtocol());
  }
  UserGroupInformation protocolUser=header.getUgi();
  user=protocolUser;
}

ID 903=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#processOneRpc(byte[])
Rmethod: org.apache.hama.ipc.Connection#processData(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void processOneRpc(byte[] buf) throws IOException, InterruptedException {
  if (headerRead) {
    processData(buf);
  }
 else {
    processHeader(buf);
    headerRead=true;
    if (!authorizeConnection()) {
      throw new AccessControlException("Connection from " + this + " for protocol "+ header.getProtocol()+ " is unauthorized for user "+ user);
    }
  }
}

ID 904=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#processOneRpc(byte[])
Rmethod: org.apache.hama.ipc.Connection#processData(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void processOneRpc(byte[] buf) throws IOException, InterruptedException {
  if (headerRead) {
    processData(buf);
  }
 else {
    processHeader(buf);
    headerRead=true;
    if (!authorizeConnection()) {
      throw new AccessControlException("Connection from " + this + " for protocol "+ header.getProtocol()+ " is unauthorized for user "+ user);
    }
  }
}

ID 905=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#processOneRpc(byte[])
Rmethod: org.apache.hama.ipc.Connection#processHeader(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void processOneRpc(byte[] buf) throws IOException, InterruptedException {
  if (headerRead) {
    processData(buf);
  }
 else {
    processHeader(buf);
    headerRead=true;
    if (!authorizeConnection()) {
      throw new AccessControlException("Connection from " + this + " for protocol "+ header.getProtocol()+ " is unauthorized for user "+ user);
    }
  }
}

ID 906=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#processOneRpc(byte[])
Rmethod: org.apache.hama.ipc.Connection#authorizeConnection()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void processOneRpc(byte[] buf) throws IOException, InterruptedException {
  if (headerRead) {
    processData(buf);
  }
 else {
    processHeader(buf);
    headerRead=true;
    if (!authorizeConnection()) {
      throw new AccessControlException("Connection from " + this + " for protocol "+ header.getProtocol()+ " is unauthorized for user "+ user);
    }
  }
}

ID 907=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#processData(byte[])
Rmethod: java.io.DataInputStream#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void processData(byte[] buf) throws IOException, InterruptedException {
  DataInputStream dis=new DataInputStream(new ByteArrayInputStream(buf));
  int id=dis.readInt();
  if (LOG.isDebugEnabled())   LOG.debug(" got #" + id);
  Writable param=ReflectionUtils.newInstance(paramClass,conf);
  param.readFields(dis);
  Call call=new Call(id,param,this);
  callQueue.put(call);
  incRpcCount();
}

ID 908=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#processData(byte[])
Rmethod: java.util.concurrent.BlockingQueue#put(E)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private void processData(byte[] buf) throws IOException, InterruptedException {
  DataInputStream dis=new DataInputStream(new ByteArrayInputStream(buf));
  int id=dis.readInt();
  if (LOG.isDebugEnabled())   LOG.debug(" got #" + id);
  Writable param=ReflectionUtils.newInstance(paramClass,conf);
  param.readFields(dis);
  Call call=new Call(id,param,this);
  callQueue.put(call);
  incRpcCount();
}

ID 909=========================================================================type: Recover
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#authorizeConnection()
Rmethod: org.apache.hama.ipc.Server#authorize(UserGroupInformation, ConnectionHeader, java.net.InetAddress)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.ipc.AuthorizationException
exception comment: null
method comment: null
catch: 
catch (AuthorizationException ae) {
  setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
  responder.doRespond(authFailedCall);
  return false;
}

block: 
Connection
private boolean authorizeConnection() throws IOException {
  try {
    if (user != null && user.getRealUser() != null && (authMethod != AuthMethod.DIGEST)) {
      ProxyUsers.authorize(user,this.getHostAddress(),conf);
    }
    authorize(user,header,getHostInetAddress());
    if (LOG.isDebugEnabled()) {
      LOG.debug("Successfully authorized " + header);
    }
  }
 catch (  AuthorizationException ae) {
    setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
    responder.doRespond(authFailedCall);
    return false;
  }
  return true;
}

ID 910=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#authorizeConnection()
Rmethod: org.apache.hama.ipc.Server#setupResponse(java.io.ByteArrayOutputStream, org.apache.hama.ipc.Server.Call, Status, Writable, java.lang.String, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private boolean authorizeConnection() throws IOException {
  try {
    if (user != null && user.getRealUser() != null && (authMethod != AuthMethod.DIGEST)) {
      ProxyUsers.authorize(user,this.getHostAddress(),conf);
    }
    authorize(user,header,getHostInetAddress());
    if (LOG.isDebugEnabled()) {
      LOG.debug("Successfully authorized " + header);
    }
  }
 catch (  AuthorizationException ae) {
    setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
    responder.doRespond(authFailedCall);
    return false;
  }
  return true;
}

ID 911=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#authorizeConnection()
Rmethod: org.apache.hama.ipc.Responder#doRespond(org.apache.hama.ipc.Server.Call)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Connection
private boolean authorizeConnection() throws IOException {
  try {
    if (user != null && user.getRealUser() != null && (authMethod != AuthMethod.DIGEST)) {
      ProxyUsers.authorize(user,this.getHostAddress(),conf);
    }
    authorize(user,header,getHostInetAddress());
    if (LOG.isDebugEnabled()) {
      LOG.debug("Successfully authorized " + header);
    }
  }
 catch (  AuthorizationException ae) {
    setupResponse(authFailedResponse,authFailedCall,Status.FATAL,null,ae.getClass().getName(),ae.getMessage());
    responder.doRespond(authFailedCall);
    return false;
  }
  return true;
}

ID 912=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#close()
Rmethod: java.net.Socket#shutdownOutput()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
Connection
private synchronized void close() throws IOException {
  data=null;
  dataLengthBuffer=null;
  if (!channel.isOpen())   return;
  try {
    socket.shutdownOutput();
  }
 catch (  Exception e) {
  }
  if (channel.isOpen()) {
    try {
      channel.close();
    }
 catch (    Exception e) {
    }
  }
  try {
    socket.close();
  }
 catch (  Exception e) {
  }
}

ID 913=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#close()
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
Connection
private synchronized void close() throws IOException {
  data=null;
  dataLengthBuffer=null;
  if (!channel.isOpen())   return;
  try {
    socket.shutdownOutput();
  }
 catch (  Exception e) {
  }
  if (channel.isOpen()) {
    try {
      channel.close();
    }
 catch (    Exception e) {
    }
  }
  try {
    socket.close();
  }
 catch (  Exception e) {
  }
}

ID 914=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Connection#close()
Rmethod: java.net.Socket#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
Connection
private synchronized void close() throws IOException {
  data=null;
  dataLengthBuffer=null;
  if (!channel.isOpen())   return;
  try {
    socket.shutdownOutput();
  }
 catch (  Exception e) {
  }
  if (channel.isOpen()) {
    try {
      channel.close();
    }
 catch (    Exception e) {
    }
  }
  try {
    socket.close();
  }
 catch (  Exception e) {
  }
}

ID 915=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Handler#run()
Rmethod: java.util.concurrent.BlockingQueue#take()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
}

block: 
Handler
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  while (running) {
    try {
      final Call call=callQueue.take();
      if (LOG.isDebugEnabled())       LOG.debug(getName() + ": has #" + call.id+ " from "+ call.connection);
      String errorClass=null;
      String error=null;
      Writable value=null;
      CurCall.set(call);
      try {
        if (call.connection.user == null) {
          value=call(call.connection.protocol,call.param,call.timestamp);
        }
 else {
          value=call.connection.user.doAs(new PrivilegedExceptionAction<Writable>(){
            @Override public Writable run() throws Exception {
              return call(call.connection.protocol,call.param,call.timestamp);
            }
          }
);
        }
      }
 catch (      Throwable e) {
        String logMsg=getName() + ", call " + call+ ": error: "+ e;
        if (e instanceof RuntimeException || e instanceof Error) {
          LOG.warn(logMsg,e);
        }
 else         if (exceptionsHandler.isTerse(e.getClass())) {
          LOG.info(logMsg);
        }
 else {
          LOG.info(logMsg,e);
        }
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
      }
      CurCall.set(null);
synchronized (call.connection.responseQueue) {
        setupResponse(buf,call,(error == null) ? Status.SUCCESS : Status.ERROR,value,errorClass,error);
        if (buf.size() > maxRespSize) {
          LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
          buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
        }
        responder.doRespond(call);
      }
    }
 catch (    InterruptedException e) {
      if (running) {
        LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
      }
    }
catch (    Exception e) {
      LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
    }
  }
  LOG.info(getName() + ": exiting");
}

ID 916=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Handler#run()
Rmethod: org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  String logMsg=getName() + ", call " + call+ ": error: "+ e;
  if (e instanceof RuntimeException || e instanceof Error) {
    LOG.warn(logMsg,e);
  }
 else   if (exceptionsHandler.isTerse(e.getClass())) {
    LOG.info(logMsg);
  }
 else {
    LOG.info(logMsg,e);
  }
  errorClass=e.getClass().getName();
  error=StringUtils.stringifyException(e);
}

block: 
Handler
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  while (running) {
    try {
      final Call call=callQueue.take();
      if (LOG.isDebugEnabled())       LOG.debug(getName() + ": has #" + call.id+ " from "+ call.connection);
      String errorClass=null;
      String error=null;
      Writable value=null;
      CurCall.set(call);
      try {
        if (call.connection.user == null) {
          value=call(call.connection.protocol,call.param,call.timestamp);
        }
 else {
          value=call.connection.user.doAs(new PrivilegedExceptionAction<Writable>(){
            @Override public Writable run() throws Exception {
              return call(call.connection.protocol,call.param,call.timestamp);
            }
          }
);
        }
      }
 catch (      Throwable e) {
        String logMsg=getName() + ", call " + call+ ": error: "+ e;
        if (e instanceof RuntimeException || e instanceof Error) {
          LOG.warn(logMsg,e);
        }
 else         if (exceptionsHandler.isTerse(e.getClass())) {
          LOG.info(logMsg);
        }
 else {
          LOG.info(logMsg,e);
        }
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
      }
      CurCall.set(null);
synchronized (call.connection.responseQueue) {
        setupResponse(buf,call,(error == null) ? Status.SUCCESS : Status.ERROR,value,errorClass,error);
        if (buf.size() > maxRespSize) {
          LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
          buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
        }
        responder.doRespond(call);
      }
    }
 catch (    InterruptedException e) {
      if (running) {
        LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
      }
    }
catch (    Exception e) {
      LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
    }
  }
  LOG.info(getName() + ": exiting");
}

ID 917=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Handler#run()
Rmethod: org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Handler
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  while (running) {
    try {
      final Call call=callQueue.take();
      if (LOG.isDebugEnabled())       LOG.debug(getName() + ": has #" + call.id+ " from "+ call.connection);
      String errorClass=null;
      String error=null;
      Writable value=null;
      CurCall.set(call);
      try {
        if (call.connection.user == null) {
          value=call(call.connection.protocol,call.param,call.timestamp);
        }
 else {
          value=call.connection.user.doAs(new PrivilegedExceptionAction<Writable>(){
            @Override public Writable run() throws Exception {
              return call(call.connection.protocol,call.param,call.timestamp);
            }
          }
);
        }
      }
 catch (      Throwable e) {
        String logMsg=getName() + ", call " + call+ ": error: "+ e;
        if (e instanceof RuntimeException || e instanceof Error) {
          LOG.warn(logMsg,e);
        }
 else         if (exceptionsHandler.isTerse(e.getClass())) {
          LOG.info(logMsg);
        }
 else {
          LOG.info(logMsg,e);
        }
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
      }
      CurCall.set(null);
synchronized (call.connection.responseQueue) {
        setupResponse(buf,call,(error == null) ? Status.SUCCESS : Status.ERROR,value,errorClass,error);
        if (buf.size() > maxRespSize) {
          LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
          buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
        }
        responder.doRespond(call);
      }
    }
 catch (    InterruptedException e) {
      if (running) {
        LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
      }
    }
catch (    Exception e) {
      LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
    }
  }
  LOG.info(getName() + ": exiting");
}

ID 918=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Handler#run()
Rmethod: org.apache.hama.ipc.Server#setupResponse(java.io.ByteArrayOutputStream, org.apache.hama.ipc.Server.Call, Status, Writable, java.lang.String, java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
}

block: 
Handler
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  while (running) {
    try {
      final Call call=callQueue.take();
      if (LOG.isDebugEnabled())       LOG.debug(getName() + ": has #" + call.id+ " from "+ call.connection);
      String errorClass=null;
      String error=null;
      Writable value=null;
      CurCall.set(call);
      try {
        if (call.connection.user == null) {
          value=call(call.connection.protocol,call.param,call.timestamp);
        }
 else {
          value=call.connection.user.doAs(new PrivilegedExceptionAction<Writable>(){
            @Override public Writable run() throws Exception {
              return call(call.connection.protocol,call.param,call.timestamp);
            }
          }
);
        }
      }
 catch (      Throwable e) {
        String logMsg=getName() + ", call " + call+ ": error: "+ e;
        if (e instanceof RuntimeException || e instanceof Error) {
          LOG.warn(logMsg,e);
        }
 else         if (exceptionsHandler.isTerse(e.getClass())) {
          LOG.info(logMsg);
        }
 else {
          LOG.info(logMsg,e);
        }
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
      }
      CurCall.set(null);
synchronized (call.connection.responseQueue) {
        setupResponse(buf,call,(error == null) ? Status.SUCCESS : Status.ERROR,value,errorClass,error);
        if (buf.size() > maxRespSize) {
          LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
          buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
        }
        responder.doRespond(call);
      }
    }
 catch (    InterruptedException e) {
      if (running) {
        LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
      }
    }
catch (    Exception e) {
      LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
    }
  }
  LOG.info(getName() + ": exiting");
}

ID 919=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Handler#run()
Rmethod: org.apache.hama.ipc.Responder#doRespond(org.apache.hama.ipc.Server.Call)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
}

block: 
Handler
@Override public void run(){
  LOG.info(getName() + ": starting");
  SERVER.set(Server.this);
  ByteArrayOutputStream buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
  while (running) {
    try {
      final Call call=callQueue.take();
      if (LOG.isDebugEnabled())       LOG.debug(getName() + ": has #" + call.id+ " from "+ call.connection);
      String errorClass=null;
      String error=null;
      Writable value=null;
      CurCall.set(call);
      try {
        if (call.connection.user == null) {
          value=call(call.connection.protocol,call.param,call.timestamp);
        }
 else {
          value=call.connection.user.doAs(new PrivilegedExceptionAction<Writable>(){
            @Override public Writable run() throws Exception {
              return call(call.connection.protocol,call.param,call.timestamp);
            }
          }
);
        }
      }
 catch (      Throwable e) {
        String logMsg=getName() + ", call " + call+ ": error: "+ e;
        if (e instanceof RuntimeException || e instanceof Error) {
          LOG.warn(logMsg,e);
        }
 else         if (exceptionsHandler.isTerse(e.getClass())) {
          LOG.info(logMsg);
        }
 else {
          LOG.info(logMsg,e);
        }
        errorClass=e.getClass().getName();
        error=StringUtils.stringifyException(e);
      }
      CurCall.set(null);
synchronized (call.connection.responseQueue) {
        setupResponse(buf,call,(error == null) ? Status.SUCCESS : Status.ERROR,value,errorClass,error);
        if (buf.size() > maxRespSize) {
          LOG.warn("Large response size " + buf.size() + " for call "+ call.toString());
          buf=new ByteArrayOutputStream(INITIAL_RESP_BUF_SIZE);
        }
        responder.doRespond(call);
      }
    }
 catch (    InterruptedException e) {
      if (running) {
        LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
      }
    }
catch (    Exception e) {
      LOG.info(getName() + " caught: " + StringUtils.stringifyException(e));
    }
  }
  LOG.info(getName() + ": exiting");
}

ID 920=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc#run()
Rmethod: org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 

@Override public Writable run() throws Exception {
  return call(call.connection.protocol,call.param,call.timestamp);
}

ID 921=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#Server(java.lang.String, int, Class<? extends Writable>, int, Configuration, java.lang.String, SecretManager<? extends TokenIdentifier>)
Rmethod: org.apache.hama.ipc.Listener#Listener()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Constructs a server listening on the named port and address. Parameters passed must be of the named class. The <code>handlerCount</handlerCount> determines the number of handler threads that will be used to process calls.
 */

catch: 
null
block: 
Server
/** 
 * Constructs a server listening on the named port and address. Parameters passed must be of the named class. The <code>handlerCount</handlerCount> determines the number of handler threads that will be used to process calls.
 */
protected Server(String bindAddress,int port,Class<? extends Writable> paramClass,int handlerCount,Configuration conf,String serverName,SecretManager<? extends TokenIdentifier> secretManager) throws IOException {
  this.bindAddress=bindAddress;
  this.conf=conf;
  this.port=port;
  this.paramClass=paramClass;
  this.handlerCount=handlerCount;
  this.socketSendBufferSize=0;
  this.maxQueueSize=handlerCount * conf.getInt(IPC_SERVER_HANDLER_QUEUE_SIZE_KEY,IPC_SERVER_HANDLER_QUEUE_SIZE_DEFAULT);
  this.maxRespSize=conf.getInt(IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY,IPC_SERVER_RPC_MAX_RESPONSE_SIZE_DEFAULT);
  this.readThreads=conf.getInt(IPC_SERVER_RPC_READ_THREADS_KEY,IPC_SERVER_RPC_READ_THREADS_DEFAULT);
  this.callQueue=new LinkedBlockingQueue<Call>(maxQueueSize);
  this.maxIdleTime=2 * conf.getInt("ipc.client.connection.maxidletime",1000);
  this.maxConnectionsToNuke=conf.getInt("ipc.client.kill.max",10);
  this.thresholdIdleConnections=conf.getInt("ipc.client.idlethreshold",4000);
  this.authorize=conf.getBoolean(HADOOP_SECURITY_AUTHORIZATION,false);
  this.isSecurityEnabled=UserGroupInformation.isSecurityEnabled();
  listener=new Listener();
  this.port=listener.getAddress().getPort();
  this.tcpNoDelay=conf.getBoolean("ipc.server.tcpnodelay",false);
  responder=new Responder();
}

ID 922=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#Server(java.lang.String, int, Class<? extends Writable>, int, Configuration, java.lang.String, SecretManager<? extends TokenIdentifier>)
Rmethod: org.apache.hama.ipc.Responder#Responder()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Constructs a server listening on the named port and address. Parameters passed must be of the named class. The <code>handlerCount</handlerCount> determines the number of handler threads that will be used to process calls.
 */

catch: 
null
block: 
Server
/** 
 * Constructs a server listening on the named port and address. Parameters passed must be of the named class. The <code>handlerCount</handlerCount> determines the number of handler threads that will be used to process calls.
 */
protected Server(String bindAddress,int port,Class<? extends Writable> paramClass,int handlerCount,Configuration conf,String serverName,SecretManager<? extends TokenIdentifier> secretManager) throws IOException {
  this.bindAddress=bindAddress;
  this.conf=conf;
  this.port=port;
  this.paramClass=paramClass;
  this.handlerCount=handlerCount;
  this.socketSendBufferSize=0;
  this.maxQueueSize=handlerCount * conf.getInt(IPC_SERVER_HANDLER_QUEUE_SIZE_KEY,IPC_SERVER_HANDLER_QUEUE_SIZE_DEFAULT);
  this.maxRespSize=conf.getInt(IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY,IPC_SERVER_RPC_MAX_RESPONSE_SIZE_DEFAULT);
  this.readThreads=conf.getInt(IPC_SERVER_RPC_READ_THREADS_KEY,IPC_SERVER_RPC_READ_THREADS_DEFAULT);
  this.callQueue=new LinkedBlockingQueue<Call>(maxQueueSize);
  this.maxIdleTime=2 * conf.getInt("ipc.client.connection.maxidletime",1000);
  this.maxConnectionsToNuke=conf.getInt("ipc.client.kill.max",10);
  this.thresholdIdleConnections=conf.getInt("ipc.client.idlethreshold",4000);
  this.authorize=conf.getBoolean(HADOOP_SECURITY_AUTHORIZATION,false);
  this.isSecurityEnabled=UserGroupInformation.isSecurityEnabled();
  listener=new Listener();
  this.port=listener.getAddress().getPort();
  this.tcpNoDelay=conf.getBoolean("ipc.server.tcpnodelay",false);
  responder=new Responder();
}

ID 923=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#closeConnection(org.apache.hama.ipc.Server.Connection)
Rmethod: org.apache.hama.ipc.Connection#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
}

block: 
Server
private void closeConnection(Connection connection){
synchronized (connectionList) {
    if (connectionList.remove(connection))     numConnections--;
  }
  try {
    connection.close();
  }
 catch (  IOException e) {
  }
}

ID 924=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#setupResponse(java.io.ByteArrayOutputStream, org.apache.hama.ipc.Server.Call, Status, Writable, java.lang.String, java.lang.String)
Rmethod: java.io.DataOutputStream#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Setup response for the IPC Call.
 * @param response buffer to serialize the response into
 * @param call {@link Call} to which we are setting up the response
 * @param status {@link Status} of the IPC call
 * @param rv return value for the IPC Call, if the call was successful
 * @param errorClass error class, if the the call failed
 * @param error error message, if the call failed
 * @throws IOException
 */

catch: 
null
block: 
Server
/** 
 * Setup response for the IPC Call.
 * @param response buffer to serialize the response into
 * @param call {@link Call} to which we are setting up the response
 * @param status {@link Status} of the IPC call
 * @param rv return value for the IPC Call, if the call was successful
 * @param errorClass error class, if the the call failed
 * @param error error message, if the call failed
 * @throws IOException
 */
private void setupResponse(ByteArrayOutputStream response,Call call,Status status,Writable rv,String errorClass,String error) throws IOException {
  response.reset();
  DataOutputStream out=new DataOutputStream(response);
  out.writeInt(call.id);
  out.writeInt(status.state);
  if (status == Status.SUCCESS) {
    rv.write(out);
  }
 else {
    WritableUtils.writeString(out,errorClass);
    WritableUtils.writeString(out,error);
  }
  call.setResponse(ByteBuffer.wrap(response.toByteArray()));
}

ID 925=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#join()
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Wait for the server to be stopped. Does not wait for all subthreads to finish. See  {@link #stop()}.
 */

catch: 
null
block: 
Server
/** 
 * Wait for the server to be stopped. Does not wait for all subthreads to finish. See  {@link #stop()}.
 */
public synchronized void join() throws InterruptedException {
  while (running) {
    wait();
  }
}

ID 926=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#call(Writable, long)
Rmethod: org.apache.hama.ipc.Server#call(Class<?>, Writable, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Called for each call.
 * @deprecated Use {@link #call(Class,Writable,long)} instead
 */

catch: 
null
block: 
Server
/** 
 * Called for each call.
 * @deprecated Use {@link #call(Class,Writable,long)} instead
 */
@Deprecated public Writable call(Writable param,long receiveTime) throws IOException {
  return call(null,param,receiveTime);
}

ID 927=========================================================================type: Rethrow
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#authorize(UserGroupInformation, ConnectionHeader, java.net.InetAddress)
Rmethod: org.apache.hama.ipc.Server#getProtocolClass(java.lang.String, Configuration)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * Authorize the incoming client connection.
 * @param user client user
 * @param connection incoming connection
 * @param addr InetAddress of incoming connection
 * @throws AuthorizationException when the client isn't authorized to talk theprotocol
 */

catch: 
catch (ClassNotFoundException cfne) {
  throw new AuthorizationException("Unknown protocol: " + connection.getProtocol());
}

block: 
Server
/** 
 * Authorize the incoming client connection.
 * @param user client user
 * @param connection incoming connection
 * @param addr InetAddress of incoming connection
 * @throws AuthorizationException when the client isn't authorized to talk theprotocol
 */
@SuppressWarnings("static-access") public void authorize(UserGroupInformation user,ConnectionHeader connection,InetAddress addr) throws AuthorizationException {
  if (authorize) {
    Class<?> protocol=null;
    try {
      protocol=getProtocolClass(connection.getProtocol(),getConf());
    }
 catch (    ClassNotFoundException cfne) {
      throw new AuthorizationException("Unknown protocol: " + connection.getProtocol());
    }
    ServiceAuthorizationManager authManager=new ServiceAuthorizationManager();
    authManager.authorize(user,protocol,getConf(),addr);
  }
}

ID 928=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#channelWrite(java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)
Rmethod: java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * This is a wrapper around  {@link WritableByteChannel#write(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of buffer increases. This also minimizes extra copies in NIO layer as a result of multiple write operations required to write a large buffer.
 * @see WritableByteChannel#write(ByteBuffer)
 */

catch: 
null
block: 
Server
/** 
 * This is a wrapper around  {@link WritableByteChannel#write(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of buffer increases. This also minimizes extra copies in NIO layer as a result of multiple write operations required to write a large buffer.
 * @see WritableByteChannel#write(ByteBuffer)
 */
private int channelWrite(WritableByteChannel channel,ByteBuffer buffer) throws IOException {
  int count=(buffer.remaining() <= NIO_BUFFER_LIMIT) ? channel.write(buffer) : channelIO(null,channel,buffer);
  return count;
}

ID 929=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#channelWrite(java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)
Rmethod: org.apache.hama.ipc.Server#channelIO(java.nio.channels.ReadableByteChannel, java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * This is a wrapper around  {@link WritableByteChannel#write(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of buffer increases. This also minimizes extra copies in NIO layer as a result of multiple write operations required to write a large buffer.
 * @see WritableByteChannel#write(ByteBuffer)
 */

catch: 
null
block: 
Server
/** 
 * This is a wrapper around  {@link WritableByteChannel#write(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of buffer increases. This also minimizes extra copies in NIO layer as a result of multiple write operations required to write a large buffer.
 * @see WritableByteChannel#write(ByteBuffer)
 */
private int channelWrite(WritableByteChannel channel,ByteBuffer buffer) throws IOException {
  int count=(buffer.remaining() <= NIO_BUFFER_LIMIT) ? channel.write(buffer) : channelIO(null,channel,buffer);
  return count;
}

ID 930=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)
Rmethod: java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * This is a wrapper around  {@link ReadableByteChannel#read(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of ByteBuffer increases. There should not be any performance degredation.
 * @see ReadableByteChannel#read(ByteBuffer)
 */

catch: 
null
block: 
Server
/** 
 * This is a wrapper around  {@link ReadableByteChannel#read(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of ByteBuffer increases. There should not be any performance degredation.
 * @see ReadableByteChannel#read(ByteBuffer)
 */
private int channelRead(ReadableByteChannel channel,ByteBuffer buffer) throws IOException {
  int count=(buffer.remaining() <= NIO_BUFFER_LIMIT) ? channel.read(buffer) : channelIO(channel,null,buffer);
  return count;
}

ID 931=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)
Rmethod: org.apache.hama.ipc.Server#channelIO(java.nio.channels.ReadableByteChannel, java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * This is a wrapper around  {@link ReadableByteChannel#read(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of ByteBuffer increases. There should not be any performance degredation.
 * @see ReadableByteChannel#read(ByteBuffer)
 */

catch: 
null
block: 
Server
/** 
 * This is a wrapper around  {@link ReadableByteChannel#read(ByteBuffer)}. If the amount of data is large, it writes to channel in smaller chunks. This is to avoid jdk from creating many direct buffers as the size of ByteBuffer increases. There should not be any performance degredation.
 * @see ReadableByteChannel#read(ByteBuffer)
 */
private int channelRead(ReadableByteChannel channel,ByteBuffer buffer) throws IOException {
  int count=(buffer.remaining() <= NIO_BUFFER_LIMIT) ? channel.read(buffer) : channelIO(channel,null,buffer);
  return count;
}

ID 932=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#channelIO(java.nio.channels.ReadableByteChannel, java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)
Rmethod: java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Helper for  {@link #channelRead(ReadableByteChannel,ByteBuffer)} and{@link #channelWrite(WritableByteChannel,ByteBuffer)}. Only one of readCh or writeCh should be non-null.
 * @see #channelRead(ReadableByteChannel,ByteBuffer)
 * @see #channelWrite(WritableByteChannel,ByteBuffer)
 */

catch: 
null
block: 
Server
/** 
 * Helper for  {@link #channelRead(ReadableByteChannel,ByteBuffer)} and{@link #channelWrite(WritableByteChannel,ByteBuffer)}. Only one of readCh or writeCh should be non-null.
 * @see #channelRead(ReadableByteChannel,ByteBuffer)
 * @see #channelWrite(WritableByteChannel,ByteBuffer)
 */
private static int channelIO(ReadableByteChannel readCh,WritableByteChannel writeCh,ByteBuffer buf) throws IOException {
  int originalLimit=buf.limit();
  int initialRemaining=buf.remaining();
  int ret=0;
  while (buf.remaining() > 0) {
    try {
      int ioSize=Math.min(buf.remaining(),NIO_BUFFER_LIMIT);
      buf.limit(buf.position() + ioSize);
      ret=(readCh == null) ? writeCh.write(buf) : readCh.read(buf);
      if (ret < ioSize) {
        break;
      }
    }
  finally {
      buf.limit(originalLimit);
    }
  }
  int nBytes=initialRemaining - buf.remaining();
  return (nBytes > 0) ? nBytes : ret;
}

ID 933=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.Server#channelIO(java.nio.channels.ReadableByteChannel, java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)
Rmethod: java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Helper for  {@link #channelRead(ReadableByteChannel,ByteBuffer)} and{@link #channelWrite(WritableByteChannel,ByteBuffer)}. Only one of readCh or writeCh should be non-null.
 * @see #channelRead(ReadableByteChannel,ByteBuffer)
 * @see #channelWrite(WritableByteChannel,ByteBuffer)
 */

catch: 
null
block: 
Server
/** 
 * Helper for  {@link #channelRead(ReadableByteChannel,ByteBuffer)} and{@link #channelWrite(WritableByteChannel,ByteBuffer)}. Only one of readCh or writeCh should be non-null.
 * @see #channelRead(ReadableByteChannel,ByteBuffer)
 * @see #channelWrite(WritableByteChannel,ByteBuffer)
 */
private static int channelIO(ReadableByteChannel readCh,WritableByteChannel writeCh,ByteBuffer buf) throws IOException {
  int originalLimit=buf.limit();
  int initialRemaining=buf.remaining();
  int ret=0;
  while (buf.remaining() > 0) {
    try {
      int ioSize=Math.min(buf.remaining(),NIO_BUFFER_LIMIT);
      buf.limit(buf.position() + ioSize);
      ret=(readCh == null) ? writeCh.write(buf) : readCh.read(buf);
      if (ret < ioSize) {
        break;
      }
    }
  finally {
      buf.limit(originalLimit);
    }
  }
  int nBytes=initialRemaining - buf.remaining();
  return (nBytes > 0) ? nBytes : ret;
}

ID 934=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JobProcessor#schedule(JobInProgress)
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Schedule job to designated GroomServer(s) immediately.
 * @param Targeted GroomServer(s).
 * @param Job to be scheduled.
 */

catch: 
catch (InterruptedException e) {
  jobResult=Boolean.FALSE;
  LOG.error("Error submitting job",e);
}

block: 
JobProcessor
/** 
 * Schedule job to designated GroomServer(s) immediately.
 * @param Targeted GroomServer(s).
 * @param Job to be scheduled.
 */
@Override public void schedule(JobInProgress job){
  Future<Boolean> jobScheduleResult=sched.submit(taskWorkerManager.spawnWorker(job));
  Boolean jobResult=Boolean.FALSE;
  try {
    jobResult=jobScheduleResult.get();
  }
 catch (  InterruptedException e) {
    jobResult=Boolean.FALSE;
    LOG.error("Error submitting job",e);
  }
catch (  ExecutionException e) {
    jobResult=Boolean.FALSE;
    LOG.error("Error submitting job",e);
  }
  if (Boolean.FALSE.equals(jobResult)) {
    LOG.error(new StringBuffer(512).append("Scheduling of job ").append(job.getJobName()).append(" could not be done successfully. Killing it!").toString());
    job.kill();
  }
}

ID 935=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JobProcessor#schedule(JobInProgress)
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: /** 
 * Schedule job to designated GroomServer(s) immediately.
 * @param Targeted GroomServer(s).
 * @param Job to be scheduled.
 */

catch: 
catch (ExecutionException e) {
  jobResult=Boolean.FALSE;
  LOG.error("Error submitting job",e);
}

block: 
JobProcessor
/** 
 * Schedule job to designated GroomServer(s) immediately.
 * @param Targeted GroomServer(s).
 * @param Job to be scheduled.
 */
@Override public void schedule(JobInProgress job){
  Future<Boolean> jobScheduleResult=sched.submit(taskWorkerManager.spawnWorker(job));
  Boolean jobResult=Boolean.FALSE;
  try {
    jobResult=jobScheduleResult.get();
  }
 catch (  InterruptedException e) {
    jobResult=Boolean.FALSE;
    LOG.error("Error submitting job",e);
  }
catch (  ExecutionException e) {
    jobResult=Boolean.FALSE;
    LOG.error("Error submitting job",e);
  }
  if (Boolean.FALSE.equals(jobResult)) {
    LOG.error(new StringBuffer(512).append("Scheduling of job ").append(job.getJobName()).append(" could not be done successfully. Killing it!").toString());
    job.kill();
  }
}

ID 936=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JvmCollector#run()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.warn(ie);
  Thread.currentThread().interrupt();
}

block: 
JvmCollector
@Override public void run(){
  for (  GroomServerStatus status : groomServerManager.get().groomServerStatusKeySet()) {
    final String groom=status.getGroomName();
    final String jvmPath=Monitor.MONITOR_ROOT_PATH + groom + "/metrics/jvm";
    final Act act=new Act(new ZKCollector(zk,"jvm","Jvm metrics.",jvmPath),new CollectorHandler(){
      @Override public void handle(      @SuppressWarnings("rawtypes") Future future){
        try {
          MetricsRecord record=(MetricsRecord)future.get();
          if (null != record) {
            if (LOG.isDebugEnabled()) {
              for (              @SuppressWarnings("rawtypes") Metric metric : record.metrics()) {
                LOG.debug("Metric name:" + metric.name() + " metric value:"+ metric.value());
              }
            }
            repository.put(groom,record);
          }
        }
 catch (        InterruptedException ie) {
          LOG.warn(ie);
          Thread.currentThread().interrupt();
        }
catch (        ExecutionException ee) {
          LOG.warn(ee.getCause());
        }
      }
    }
);
    this.federator.register(act);
  }
}

ID 937=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.JvmCollector#run()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException ee) {
  LOG.warn(ee.getCause());
}

block: 
JvmCollector
@Override public void run(){
  for (  GroomServerStatus status : groomServerManager.get().groomServerStatusKeySet()) {
    final String groom=status.getGroomName();
    final String jvmPath=Monitor.MONITOR_ROOT_PATH + groom + "/metrics/jvm";
    final Act act=new Act(new ZKCollector(zk,"jvm","Jvm metrics.",jvmPath),new CollectorHandler(){
      @Override public void handle(      @SuppressWarnings("rawtypes") Future future){
        try {
          MetricsRecord record=(MetricsRecord)future.get();
          if (null != record) {
            if (LOG.isDebugEnabled()) {
              for (              @SuppressWarnings("rawtypes") Metric metric : record.metrics()) {
                LOG.debug("Metric name:" + metric.name() + " metric value:"+ metric.value());
              }
            }
            repository.put(groom,record);
          }
        }
 catch (        InterruptedException ie) {
          LOG.warn(ie);
          Thread.currentThread().interrupt();
        }
catch (        ExecutionException ee) {
          LOG.warn(ee.getCause());
        }
      }
    }
);
    this.federator.register(act);
  }
}

ID 938=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp#handle(Future#RAW)
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.warn(ie);
  Thread.currentThread().interrupt();
}

block: 

@Override public void handle(@SuppressWarnings("rawtypes") Future future){
  try {
    MetricsRecord record=(MetricsRecord)future.get();
    if (null != record) {
      if (LOG.isDebugEnabled()) {
        for (        @SuppressWarnings("rawtypes") Metric metric : record.metrics()) {
          LOG.debug("Metric name:" + metric.name() + " metric value:"+ metric.value());
        }
      }
      repository.put(groom,record);
    }
  }
 catch (  InterruptedException ie) {
    LOG.warn(ie);
    Thread.currentThread().interrupt();
  }
catch (  ExecutionException ee) {
    LOG.warn(ee.getCause());
  }
}

ID 939=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp#handle(Future#RAW)
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException ee) {
  LOG.warn(ee.getCause());
}

block: 

@Override public void handle(@SuppressWarnings("rawtypes") Future future){
  try {
    MetricsRecord record=(MetricsRecord)future.get();
    if (null != record) {
      if (LOG.isDebugEnabled()) {
        for (        @SuppressWarnings("rawtypes") Metric metric : record.metrics()) {
          LOG.debug("Metric name:" + metric.name() + " metric value:"+ metric.value());
        }
      }
      repository.put(groom,record);
    }
  }
 catch (  InterruptedException ie) {
    LOG.warn(ie);
    Thread.currentThread().interrupt();
  }
catch (  ExecutionException ee) {
    LOG.warn(ee.getCause());
  }
}

ID 940=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.Reader#performIO(java.nio.ByteBuffer)
Rmethod: java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Reader
int performIO(ByteBuffer buf) throws IOException {
  return channel.read(buf);
}

ID 941=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketInputStream#SocketInputStream(java.nio.channels.ReadableByteChannel, long)
Rmethod: org.apache.hama.util.Reader#Reader(java.nio.channels.ReadableByteChannel, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a new input stream with the given timeout. If the timeout is zero, it will be treated as infinite timeout. The socket's channel will be configured to be non-blocking.
 * @param channel Channel for reading, should also be a{@link SelectableChannel}. The channel will be configured to be non-blocking.
 * @param timeout timeout in milliseconds. must not be negative.
 * @throws IOException
 */

catch: 
null
block: 
SocketInputStream
/** 
 * Create a new input stream with the given timeout. If the timeout is zero, it will be treated as infinite timeout. The socket's channel will be configured to be non-blocking.
 * @param channel Channel for reading, should also be a{@link SelectableChannel}. The channel will be configured to be non-blocking.
 * @param timeout timeout in milliseconds. must not be negative.
 * @throws IOException
 */
public SocketInputStream(ReadableByteChannel channel,long timeout) throws IOException {
  SocketIOWithTimeout.checkChannelValidity(channel);
  reader=new Reader(channel,timeout);
}

ID 942=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketInputStream#SocketInputStream(java.net.Socket)
Rmethod: java.net.Socket#getSoTimeout()
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * Same as SocketInputStream(socket.getChannel(), socket.getSoTimeout()) :<br> <br> Create a new input stream with the given timeout. If the timeout is zero, it will be treated as infinite timeout. The socket's channel will be configured to be non-blocking.
 * @see SocketInputStream#SocketInputStream(ReadableByteChannel,long)
 * @param socket should have a channel associated with it.
 * @throws IOException
 */

catch: 
null
block: 
SocketInputStream
/** 
 * Same as SocketInputStream(socket.getChannel(), socket.getSoTimeout()) :<br> <br> Create a new input stream with the given timeout. If the timeout is zero, it will be treated as infinite timeout. The socket's channel will be configured to be non-blocking.
 * @see SocketInputStream#SocketInputStream(ReadableByteChannel,long)
 * @param socket should have a channel associated with it.
 * @throws IOException
 */
public SocketInputStream(Socket socket) throws IOException {
  this(socket.getChannel(),socket.getSoTimeout());
}

ID 943=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketInputStream#read()
Rmethod: org.apache.hama.util.SocketInputStream#read(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SocketInputStream
@Override public int read() throws IOException {
  byte[] buf=new byte[1];
  int ret=read(buf,0,1);
  if (ret > 0) {
    return (byte)buf[0];
  }
  if (ret != -1) {
    throw new IOException("Could not read from stream");
  }
  return ret;
}

ID 944=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketInputStream#read(byte[], int, int)
Rmethod: org.apache.hama.util.SocketInputStream#read(java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SocketInputStream
public int read(byte[] b,int off,int len) throws IOException {
  return read(ByteBuffer.wrap(b,off,len));
}

ID 945=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketInputStream#close()
Rmethod: java.nio.channels.Channel#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SocketInputStream
public synchronized void close() throws IOException {
  reader.channel.close();
  reader.close();
}

ID 946=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#SocketIOWithTimeout(java.nio.channels.SelectableChannel, long)
Rmethod: org.apache.hama.util.SocketIOWithTimeout#checkChannelValidity(java.lang.Object)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SocketIOWithTimeout
SocketIOWithTimeout(SelectableChannel channel,long timeout) throws IOException {
  checkChannelValidity(channel);
  this.channel=channel;
  this.timeout=timeout;
  channel.configureBlocking(false);
}

ID 947=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#SocketIOWithTimeout(java.nio.channels.SelectableChannel, long)
Rmethod: java.nio.channels.SelectableChannel#configureBlocking(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SocketIOWithTimeout
SocketIOWithTimeout(SelectableChannel channel,long timeout) throws IOException {
  checkChannelValidity(channel);
  this.channel=channel;
  this.timeout=timeout;
  channel.configureBlocking(false);
}

ID 948=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#doIO(java.nio.ByteBuffer, int)
Rmethod: org.apache.hama.util.SocketIOWithTimeout#performIO(java.nio.ByteBuffer)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Performs one IO and returns number of bytes read or written. It waits up to the specified timeout. If the channel is not read before the timeout, SocketTimeoutException is thrown.
 * @param buf buffer for IO
 * @param ops Selection Ops used for waiting. Suggested values:SelectionKey.OP_READ while reading and SelectionKey.OP_WRITE while writing.
 * @return number of bytes read or written. negative implies end of stream.
 * @throws IOException
 */

catch: 
catch (IOException e) {
  if (!channel.isOpen()) {
    closed=true;
  }
  throw e;
}

block: 
SocketIOWithTimeout
/** 
 * Performs one IO and returns number of bytes read or written. It waits up to the specified timeout. If the channel is not read before the timeout, SocketTimeoutException is thrown.
 * @param buf buffer for IO
 * @param ops Selection Ops used for waiting. Suggested values:SelectionKey.OP_READ while reading and SelectionKey.OP_WRITE while writing.
 * @return number of bytes read or written. negative implies end of stream.
 * @throws IOException
 */
int doIO(ByteBuffer buf,int ops) throws IOException {
  if (!buf.hasRemaining()) {
    throw new IllegalArgumentException("Buffer has no data left.");
  }
  while (buf.hasRemaining()) {
    if (closed) {
      return -1;
    }
    try {
      int n=performIO(buf);
      if (n != 0) {
        return n;
      }
    }
 catch (    IOException e) {
      if (!channel.isOpen()) {
        closed=true;
      }
      throw e;
    }
    int count=0;
    try {
      count=selector.select(channel,ops,timeout);
    }
 catch (    IOException e) {
      closed=true;
      throw e;
    }
    if (count == 0) {
      throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,ops));
    }
  }
  return 0;
}

ID 949=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#doIO(java.nio.ByteBuffer, int)
Rmethod: org.apache.hama.util.SelectorPool#select(java.nio.channels.SelectableChannel, int, long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Performs one IO and returns number of bytes read or written. It waits up to the specified timeout. If the channel is not read before the timeout, SocketTimeoutException is thrown.
 * @param buf buffer for IO
 * @param ops Selection Ops used for waiting. Suggested values:SelectionKey.OP_READ while reading and SelectionKey.OP_WRITE while writing.
 * @return number of bytes read or written. negative implies end of stream.
 * @throws IOException
 */

catch: 
catch (IOException e) {
  closed=true;
  throw e;
}

block: 
SocketIOWithTimeout
/** 
 * Performs one IO and returns number of bytes read or written. It waits up to the specified timeout. If the channel is not read before the timeout, SocketTimeoutException is thrown.
 * @param buf buffer for IO
 * @param ops Selection Ops used for waiting. Suggested values:SelectionKey.OP_READ while reading and SelectionKey.OP_WRITE while writing.
 * @return number of bytes read or written. negative implies end of stream.
 * @throws IOException
 */
int doIO(ByteBuffer buf,int ops) throws IOException {
  if (!buf.hasRemaining()) {
    throw new IllegalArgumentException("Buffer has no data left.");
  }
  while (buf.hasRemaining()) {
    if (closed) {
      return -1;
    }
    try {
      int n=performIO(buf);
      if (n != 0) {
        return n;
      }
    }
 catch (    IOException e) {
      if (!channel.isOpen()) {
        closed=true;
      }
      throw e;
    }
    int count=0;
    try {
      count=selector.select(channel,ops,timeout);
    }
 catch (    IOException e) {
      closed=true;
      throw e;
    }
    if (count == 0) {
      throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,ops));
    }
  }
  return 0;
}

ID 950=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#connect(java.nio.channels.SocketChannel, java.net.SocketAddress, int)
Rmethod: java.nio.channels.spi.AbstractSelectableChannel#configureBlocking(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */

catch: 
null
block: 
SocketIOWithTimeout
/** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */
static void connect(SocketChannel channel,SocketAddress endpoint,int timeout) throws IOException {
  boolean blockingOn=channel.isBlocking();
  if (blockingOn) {
    channel.configureBlocking(false);
  }
  try {
    if (channel.connect(endpoint)) {
      return;
    }
    long timeoutLeft=timeout;
    long endTime=(timeout > 0) ? (System.currentTimeMillis() + timeout) : 0;
    while (true) {
      int ret=selector.select((SelectableChannel)channel,SelectionKey.OP_CONNECT,timeoutLeft);
      if (ret > 0 && channel.finishConnect()) {
        return;
      }
      if (ret == 0 || (timeout > 0 && (timeoutLeft=(endTime - System.currentTimeMillis())) <= 0)) {
        throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,SelectionKey.OP_CONNECT));
      }
    }
  }
 catch (  IOException e) {
    try {
      channel.close();
    }
 catch (    IOException ignored) {
    }
    throw e;
  }
 finally {
    if (blockingOn && channel.isOpen()) {
      channel.configureBlocking(true);
    }
  }
}

ID 951=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#connect(java.nio.channels.SocketChannel, java.net.SocketAddress, int)
Rmethod: java.nio.channels.SocketChannel#connect(java.net.SocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */

catch: 
catch (IOException e) {
  try {
    channel.close();
  }
 catch (  IOException ignored) {
  }
  throw e;
}

block: 
SocketIOWithTimeout
/** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */
static void connect(SocketChannel channel,SocketAddress endpoint,int timeout) throws IOException {
  boolean blockingOn=channel.isBlocking();
  if (blockingOn) {
    channel.configureBlocking(false);
  }
  try {
    if (channel.connect(endpoint)) {
      return;
    }
    long timeoutLeft=timeout;
    long endTime=(timeout > 0) ? (System.currentTimeMillis() + timeout) : 0;
    while (true) {
      int ret=selector.select((SelectableChannel)channel,SelectionKey.OP_CONNECT,timeoutLeft);
      if (ret > 0 && channel.finishConnect()) {
        return;
      }
      if (ret == 0 || (timeout > 0 && (timeoutLeft=(endTime - System.currentTimeMillis())) <= 0)) {
        throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,SelectionKey.OP_CONNECT));
      }
    }
  }
 catch (  IOException e) {
    try {
      channel.close();
    }
 catch (    IOException ignored) {
    }
    throw e;
  }
 finally {
    if (blockingOn && channel.isOpen()) {
      channel.configureBlocking(true);
    }
  }
}

ID 952=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#connect(java.nio.channels.SocketChannel, java.net.SocketAddress, int)
Rmethod: org.apache.hama.util.SelectorPool#select(java.nio.channels.SelectableChannel, int, long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */

catch: 
catch (IOException e) {
  try {
    channel.close();
  }
 catch (  IOException ignored) {
  }
  throw e;
}

block: 
SocketIOWithTimeout
/** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */
static void connect(SocketChannel channel,SocketAddress endpoint,int timeout) throws IOException {
  boolean blockingOn=channel.isBlocking();
  if (blockingOn) {
    channel.configureBlocking(false);
  }
  try {
    if (channel.connect(endpoint)) {
      return;
    }
    long timeoutLeft=timeout;
    long endTime=(timeout > 0) ? (System.currentTimeMillis() + timeout) : 0;
    while (true) {
      int ret=selector.select((SelectableChannel)channel,SelectionKey.OP_CONNECT,timeoutLeft);
      if (ret > 0 && channel.finishConnect()) {
        return;
      }
      if (ret == 0 || (timeout > 0 && (timeoutLeft=(endTime - System.currentTimeMillis())) <= 0)) {
        throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,SelectionKey.OP_CONNECT));
      }
    }
  }
 catch (  IOException e) {
    try {
      channel.close();
    }
 catch (    IOException ignored) {
    }
    throw e;
  }
 finally {
    if (blockingOn && channel.isOpen()) {
      channel.configureBlocking(true);
    }
  }
}

ID 953=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#connect(java.nio.channels.SocketChannel, java.net.SocketAddress, int)
Rmethod: java.nio.channels.SocketChannel#finishConnect()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */

catch: 
catch (IOException e) {
  try {
    channel.close();
  }
 catch (  IOException ignored) {
  }
  throw e;
}

block: 
SocketIOWithTimeout
/** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */
static void connect(SocketChannel channel,SocketAddress endpoint,int timeout) throws IOException {
  boolean blockingOn=channel.isBlocking();
  if (blockingOn) {
    channel.configureBlocking(false);
  }
  try {
    if (channel.connect(endpoint)) {
      return;
    }
    long timeoutLeft=timeout;
    long endTime=(timeout > 0) ? (System.currentTimeMillis() + timeout) : 0;
    while (true) {
      int ret=selector.select((SelectableChannel)channel,SelectionKey.OP_CONNECT,timeoutLeft);
      if (ret > 0 && channel.finishConnect()) {
        return;
      }
      if (ret == 0 || (timeout > 0 && (timeoutLeft=(endTime - System.currentTimeMillis())) <= 0)) {
        throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,SelectionKey.OP_CONNECT));
      }
    }
  }
 catch (  IOException e) {
    try {
      channel.close();
    }
 catch (    IOException ignored) {
    }
    throw e;
  }
 finally {
    if (blockingOn && channel.isOpen()) {
      channel.configureBlocking(true);
    }
  }
}

ID 954=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#connect(java.nio.channels.SocketChannel, java.net.SocketAddress, int)
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */

catch: 
catch (IOException ignored) {
}

block: 
SocketIOWithTimeout
/** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */
static void connect(SocketChannel channel,SocketAddress endpoint,int timeout) throws IOException {
  boolean blockingOn=channel.isBlocking();
  if (blockingOn) {
    channel.configureBlocking(false);
  }
  try {
    if (channel.connect(endpoint)) {
      return;
    }
    long timeoutLeft=timeout;
    long endTime=(timeout > 0) ? (System.currentTimeMillis() + timeout) : 0;
    while (true) {
      int ret=selector.select((SelectableChannel)channel,SelectionKey.OP_CONNECT,timeoutLeft);
      if (ret > 0 && channel.finishConnect()) {
        return;
      }
      if (ret == 0 || (timeout > 0 && (timeoutLeft=(endTime - System.currentTimeMillis())) <= 0)) {
        throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,SelectionKey.OP_CONNECT));
      }
    }
  }
 catch (  IOException e) {
    try {
      channel.close();
    }
 catch (    IOException ignored) {
    }
    throw e;
  }
 finally {
    if (blockingOn && channel.isOpen()) {
      channel.configureBlocking(true);
    }
  }
}

ID 955=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#connect(java.nio.channels.SocketChannel, java.net.SocketAddress, int)
Rmethod: java.nio.channels.spi.AbstractSelectableChannel#configureBlocking(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */

catch: 
catch (IOException e) {
  try {
    channel.close();
  }
 catch (  IOException ignored) {
  }
  throw e;
}

block: 
SocketIOWithTimeout
/** 
 * The contract is similar to  {@link SocketChannel#connect(SocketAddress)}with a timeout.
 * @see SocketChannel#connect(SocketAddress)
 * @param channel - this should be a {@link SelectableChannel}
 * @param endpoint
 * @throws IOException
 */
static void connect(SocketChannel channel,SocketAddress endpoint,int timeout) throws IOException {
  boolean blockingOn=channel.isBlocking();
  if (blockingOn) {
    channel.configureBlocking(false);
  }
  try {
    if (channel.connect(endpoint)) {
      return;
    }
    long timeoutLeft=timeout;
    long endTime=(timeout > 0) ? (System.currentTimeMillis() + timeout) : 0;
    while (true) {
      int ret=selector.select((SelectableChannel)channel,SelectionKey.OP_CONNECT,timeoutLeft);
      if (ret > 0 && channel.finishConnect()) {
        return;
      }
      if (ret == 0 || (timeout > 0 && (timeoutLeft=(endTime - System.currentTimeMillis())) <= 0)) {
        throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,SelectionKey.OP_CONNECT));
      }
    }
  }
 catch (  IOException e) {
    try {
      channel.close();
    }
 catch (    IOException ignored) {
    }
    throw e;
  }
 finally {
    if (blockingOn && channel.isOpen()) {
      channel.configureBlocking(true);
    }
  }
}

ID 956=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketIOWithTimeout#waitForIO(int)
Rmethod: org.apache.hama.util.SelectorPool#select(java.nio.channels.SelectableChannel, int, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * This is similar to  {@link #doIO(ByteBuffer,int)} except that it does notperform any I/O. It just waits for the channel to be ready for I/O as specified in ops.
 * @param ops Selection Ops used for waiting
 * @throws SocketTimeoutException if select on the channel times out.
 * @throws IOException if any other I/O error occurs.
 */

catch: 
null
block: 
SocketIOWithTimeout
/** 
 * This is similar to  {@link #doIO(ByteBuffer,int)} except that it does notperform any I/O. It just waits for the channel to be ready for I/O as specified in ops.
 * @param ops Selection Ops used for waiting
 * @throws SocketTimeoutException if select on the channel times out.
 * @throws IOException if any other I/O error occurs.
 */
void waitForIO(int ops) throws IOException {
  if (selector.select(channel,ops,timeout) == 0) {
    throw new SocketTimeoutException(timeoutExceptionString(channel,timeout,ops));
  }
}

ID 957=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.SelectorInfo#close()
Rmethod: java.nio.channels.Selector#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.warn("Unexpected exception while closing selector : " + StringUtils.stringifyException(e));
}

block: 
SelectorInfo
void close(){
  if (selector != null) {
    try {
      selector.close();
    }
 catch (    IOException e) {
      LOG.warn("Unexpected exception while closing selector : " + StringUtils.stringifyException(e));
    }
  }
}

ID 958=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SelectorPool#select(java.nio.channels.SelectableChannel, int, long)
Rmethod: org.apache.hama.util.SelectorPool#get(java.nio.channels.SelectableChannel)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */

catch: 
null
block: 
SelectorPool
/** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */
int select(SelectableChannel channel,int ops,long timeout) throws IOException {
  SelectorInfo info=get(channel);
  SelectionKey key=null;
  int ret=0;
  try {
    while (true) {
      long start=(timeout == 0) ? 0 : System.currentTimeMillis();
      key=channel.register(info.selector,ops);
      ret=info.selector.select(timeout);
      if (ret != 0) {
        return ret;
      }
      if (timeout > 0) {
        timeout-=System.currentTimeMillis() - start;
        if (timeout <= 0) {
          return 0;
        }
      }
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedIOException("Interruped while waiting for " + "IO on channel " + channel + ". "+ timeout+ " millis timeout left.");
      }
    }
  }
  finally {
    if (key != null) {
      key.cancel();
    }
    try {
      info.selector.selectNow();
    }
 catch (    IOException e) {
      LOG.info("Unexpected Exception while clearing selector : " + StringUtils.stringifyException(e));
      info.close();
      return ret;
    }
    release(info);
  }
}

ID 959=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SelectorPool#select(java.nio.channels.SelectableChannel, int, long)
Rmethod: java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)
hasForStatement: true
parentException: IOException Exception Throwable 
thrown: java.nio.channels.ClosedChannelException
exception comment: /** 
 * Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.  That this exception is thrown does not necessarily imply that the channel is completely closed.  A socket channel whose write half has been shut down, for example, may still be open for reading.
 * @since 1.4
 */

method comment: /** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */

catch: 
null
block: 
SelectorPool
/** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */
int select(SelectableChannel channel,int ops,long timeout) throws IOException {
  SelectorInfo info=get(channel);
  SelectionKey key=null;
  int ret=0;
  try {
    while (true) {
      long start=(timeout == 0) ? 0 : System.currentTimeMillis();
      key=channel.register(info.selector,ops);
      ret=info.selector.select(timeout);
      if (ret != 0) {
        return ret;
      }
      if (timeout > 0) {
        timeout-=System.currentTimeMillis() - start;
        if (timeout <= 0) {
          return 0;
        }
      }
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedIOException("Interruped while waiting for " + "IO on channel " + channel + ". "+ timeout+ " millis timeout left.");
      }
    }
  }
  finally {
    if (key != null) {
      key.cancel();
    }
    try {
      info.selector.selectNow();
    }
 catch (    IOException e) {
      LOG.info("Unexpected Exception while clearing selector : " + StringUtils.stringifyException(e));
      info.close();
      return ret;
    }
    release(info);
  }
}

ID 960=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SelectorPool#select(java.nio.channels.SelectableChannel, int, long)
Rmethod: java.nio.channels.Selector#select(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */

catch: 
null
block: 
SelectorPool
/** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */
int select(SelectableChannel channel,int ops,long timeout) throws IOException {
  SelectorInfo info=get(channel);
  SelectionKey key=null;
  int ret=0;
  try {
    while (true) {
      long start=(timeout == 0) ? 0 : System.currentTimeMillis();
      key=channel.register(info.selector,ops);
      ret=info.selector.select(timeout);
      if (ret != 0) {
        return ret;
      }
      if (timeout > 0) {
        timeout-=System.currentTimeMillis() - start;
        if (timeout <= 0) {
          return 0;
        }
      }
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedIOException("Interruped while waiting for " + "IO on channel " + channel + ". "+ timeout+ " millis timeout left.");
      }
    }
  }
  finally {
    if (key != null) {
      key.cancel();
    }
    try {
      info.selector.selectNow();
    }
 catch (    IOException e) {
      LOG.info("Unexpected Exception while clearing selector : " + StringUtils.stringifyException(e));
      info.close();
      return ret;
    }
    release(info);
  }
}

ID 961=========================================================================type: Ignore_Log
package: org.apache.hama.util
Method:org.apache.hama.util.SelectorPool#select(java.nio.channels.SelectableChannel, int, long)
Rmethod: java.nio.channels.Selector#selectNow()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */

catch: 
catch (IOException e) {
  LOG.info("Unexpected Exception while clearing selector : " + StringUtils.stringifyException(e));
  info.close();
  return ret;
}

block: 
SelectorPool
/** 
 * Waits on the channel with the given timeout using one of the cached selectors. It also removes any cached selectors that are idle for a few seconds.
 * @param channel
 * @param ops
 * @param timeout
 * @return
 * @throws IOException
 */
int select(SelectableChannel channel,int ops,long timeout) throws IOException {
  SelectorInfo info=get(channel);
  SelectionKey key=null;
  int ret=0;
  try {
    while (true) {
      long start=(timeout == 0) ? 0 : System.currentTimeMillis();
      key=channel.register(info.selector,ops);
      ret=info.selector.select(timeout);
      if (ret != 0) {
        return ret;
      }
      if (timeout > 0) {
        timeout-=System.currentTimeMillis() - start;
        if (timeout <= 0) {
          return 0;
        }
      }
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedIOException("Interruped while waiting for " + "IO on channel " + channel + ". "+ timeout+ " millis timeout left.");
      }
    }
  }
  finally {
    if (key != null) {
      key.cancel();
    }
    try {
      info.selector.selectNow();
    }
 catch (    IOException e) {
      LOG.info("Unexpected Exception while clearing selector : " + StringUtils.stringifyException(e));
      info.close();
      return ret;
    }
    release(info);
  }
}

ID 962=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SelectorPool#get(java.nio.channels.SelectableChannel)
Rmethod: java.nio.channels.spi.SelectorProvider#openSelector()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Takes one selector from end of LRU list of free selectors. If there are no selectors awailable, it creates a new selector. Also invokes trimIdleSelectors().
 * @param channel
 * @return
 * @throws IOException
 */

catch: 
null
block: 
SelectorPool
/** 
 * Takes one selector from end of LRU list of free selectors. If there are no selectors awailable, it creates a new selector. Also invokes trimIdleSelectors().
 * @param channel
 * @return
 * @throws IOException
 */
private synchronized SelectorInfo get(SelectableChannel channel) throws IOException {
  SelectorInfo selInfo=null;
  SelectorProvider provider=channel.provider();
  ProviderInfo pList=providerList;
  while (pList != null && pList.provider != provider) {
    pList=pList.next;
  }
  if (pList == null) {
    pList=new ProviderInfo();
    pList.provider=provider;
    pList.queue=new LinkedList<SelectorInfo>();
    pList.next=providerList;
    providerList=pList;
  }
  LinkedList<SelectorInfo> queue=pList.queue;
  if (queue.isEmpty()) {
    Selector selector=provider.openSelector();
    selInfo=new SelectorInfo();
    selInfo.selector=selector;
    selInfo.queue=queue;
  }
 else {
    selInfo=queue.removeLast();
  }
  trimIdleSelectors(System.currentTimeMillis());
  return selInfo;
}

ID 963=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.Writer#performIO(java.nio.ByteBuffer)
Rmethod: java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Writer
int performIO(ByteBuffer buf) throws IOException {
  return channel.write(buf);
}

ID 964=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketOutputStream#SocketOutputStream(java.nio.channels.WritableByteChannel, long)
Rmethod: org.apache.hama.util.Writer#Writer(java.nio.channels.WritableByteChannel, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Create a new ouput stream with the given timeout. If the timeout is zero, it will be treated as infinite timeout. The socket's channel will be configured to be non-blocking.
 * @param channel Channel for writing, should also be a{@link SelectableChannel}. The channel will be configured to be non-blocking.
 * @param timeout timeout in milliseconds. must not be negative.
 * @throws IOException
 */

catch: 
null
block: 
SocketOutputStream
/** 
 * Create a new ouput stream with the given timeout. If the timeout is zero, it will be treated as infinite timeout. The socket's channel will be configured to be non-blocking.
 * @param channel Channel for writing, should also be a{@link SelectableChannel}. The channel will be configured to be non-blocking.
 * @param timeout timeout in milliseconds. must not be negative.
 * @throws IOException
 */
public SocketOutputStream(WritableByteChannel channel,long timeout) throws IOException {
  SocketIOWithTimeout.checkChannelValidity(channel);
  writer=new Writer(channel,timeout);
}

ID 965=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketOutputStream#write(int)
Rmethod: org.apache.hama.util.SocketOutputStream#write(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SocketOutputStream
public void write(int b) throws IOException {
  byte[] buf=new byte[1];
  buf[0]=(byte)b;
  write(buf,0,1);
}

ID 966=========================================================================type: Recover
package: org.apache.hama.util
Method:org.apache.hama.util.SocketOutputStream#write(byte[], int, int)
Rmethod: org.apache.hama.util.SocketOutputStream#write(java.nio.ByteBuffer)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  if (buf.capacity() > buf.remaining()) {
    writer.close();
  }
  throw e;
}

block: 
SocketOutputStream
public void write(byte[] b,int off,int len) throws IOException {
  ByteBuffer buf=ByteBuffer.wrap(b,off,len);
  while (buf.hasRemaining()) {
    try {
      if (write(buf) < 0) {
        throw new IOException("The stream is closed");
      }
    }
 catch (    IOException e) {
      if (buf.capacity() > buf.remaining()) {
        writer.close();
      }
      throw e;
    }
  }
}

ID 967=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketOutputStream#close()
Rmethod: java.nio.channels.Channel#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SocketOutputStream
public synchronized void close() throws IOException {
  writer.channel.close();
  writer.close();
}

ID 968=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketOutputStream#transferToFully(java.nio.channels.FileChannel, long, int)
Rmethod: org.apache.hama.util.SocketOutputStream#waitForWritable()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Transfers data from FileChannel using {@link FileChannel#transferTo(long,long,WritableByteChannel)}. Similar to readFully(), this waits till requested amount of data is transfered.
 * @param fileCh FileChannel to transfer data from.
 * @param position position within the channel where the transfer begins
 * @param count number of bytes to transfer.
 * @throws EOFException If end of input file is reached before requestednumber of bytes are transfered.
 * @throws SocketTimeoutException If this channel blocks transfer longer thantimeout for this stream.
 * @throws IOException Includes any exception thrown by{@link FileChannel#transferTo(long,long,WritableByteChannel)}.
 */

catch: 
null
block: 
SocketOutputStream
/** 
 * Transfers data from FileChannel using {@link FileChannel#transferTo(long,long,WritableByteChannel)}. Similar to readFully(), this waits till requested amount of data is transfered.
 * @param fileCh FileChannel to transfer data from.
 * @param position position within the channel where the transfer begins
 * @param count number of bytes to transfer.
 * @throws EOFException If end of input file is reached before requestednumber of bytes are transfered.
 * @throws SocketTimeoutException If this channel blocks transfer longer thantimeout for this stream.
 * @throws IOException Includes any exception thrown by{@link FileChannel#transferTo(long,long,WritableByteChannel)}.
 */
public void transferToFully(FileChannel fileCh,long position,int count) throws IOException {
  while (count > 0) {
    waitForWritable();
    int nTransfered=(int)fileCh.transferTo(position,count,getChannel());
    if (nTransfered == 0) {
      if (position >= fileCh.size()) {
        throw new EOFException("EOF Reached. file size is " + fileCh.size() + " and "+ count+ " more bytes left to be "+ "transfered.");
      }
    }
 else     if (nTransfered < 0) {
      throw new IOException("Unexpected return of " + nTransfered + " from transferTo()");
    }
 else {
      position+=nTransfered;
      count-=nTransfered;
    }
  }
}

ID 969=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketOutputStream#transferToFully(java.nio.channels.FileChannel, long, int)
Rmethod: java.nio.channels.FileChannel#transferTo(long, long, java.nio.channels.WritableByteChannel)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Transfers data from FileChannel using {@link FileChannel#transferTo(long,long,WritableByteChannel)}. Similar to readFully(), this waits till requested amount of data is transfered.
 * @param fileCh FileChannel to transfer data from.
 * @param position position within the channel where the transfer begins
 * @param count number of bytes to transfer.
 * @throws EOFException If end of input file is reached before requestednumber of bytes are transfered.
 * @throws SocketTimeoutException If this channel blocks transfer longer thantimeout for this stream.
 * @throws IOException Includes any exception thrown by{@link FileChannel#transferTo(long,long,WritableByteChannel)}.
 */

catch: 
null
block: 
SocketOutputStream
/** 
 * Transfers data from FileChannel using {@link FileChannel#transferTo(long,long,WritableByteChannel)}. Similar to readFully(), this waits till requested amount of data is transfered.
 * @param fileCh FileChannel to transfer data from.
 * @param position position within the channel where the transfer begins
 * @param count number of bytes to transfer.
 * @throws EOFException If end of input file is reached before requestednumber of bytes are transfered.
 * @throws SocketTimeoutException If this channel blocks transfer longer thantimeout for this stream.
 * @throws IOException Includes any exception thrown by{@link FileChannel#transferTo(long,long,WritableByteChannel)}.
 */
public void transferToFully(FileChannel fileCh,long position,int count) throws IOException {
  while (count > 0) {
    waitForWritable();
    int nTransfered=(int)fileCh.transferTo(position,count,getChannel());
    if (nTransfered == 0) {
      if (position >= fileCh.size()) {
        throw new EOFException("EOF Reached. file size is " + fileCh.size() + " and "+ count+ " more bytes left to be "+ "transfered.");
      }
    }
 else     if (nTransfered < 0) {
      throw new IOException("Unexpected return of " + nTransfered + " from transferTo()");
    }
 else {
      position+=nTransfered;
      count-=nTransfered;
    }
  }
}

ID 970=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.SocketOutputStream#transferToFully(java.nio.channels.FileChannel, long, int)
Rmethod: java.nio.channels.FileChannel#size()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Transfers data from FileChannel using {@link FileChannel#transferTo(long,long,WritableByteChannel)}. Similar to readFully(), this waits till requested amount of data is transfered.
 * @param fileCh FileChannel to transfer data from.
 * @param position position within the channel where the transfer begins
 * @param count number of bytes to transfer.
 * @throws EOFException If end of input file is reached before requestednumber of bytes are transfered.
 * @throws SocketTimeoutException If this channel blocks transfer longer thantimeout for this stream.
 * @throws IOException Includes any exception thrown by{@link FileChannel#transferTo(long,long,WritableByteChannel)}.
 */

catch: 
null
block: 
SocketOutputStream
/** 
 * Transfers data from FileChannel using {@link FileChannel#transferTo(long,long,WritableByteChannel)}. Similar to readFully(), this waits till requested amount of data is transfered.
 * @param fileCh FileChannel to transfer data from.
 * @param position position within the channel where the transfer begins
 * @param count number of bytes to transfer.
 * @throws EOFException If end of input file is reached before requestednumber of bytes are transfered.
 * @throws SocketTimeoutException If this channel blocks transfer longer thantimeout for this stream.
 * @throws IOException Includes any exception thrown by{@link FileChannel#transferTo(long,long,WritableByteChannel)}.
 */
public void transferToFully(FileChannel fileCh,long position,int count) throws IOException {
  while (count > 0) {
    waitForWritable();
    int nTransfered=(int)fileCh.transferTo(position,count,getChannel());
    if (nTransfered == 0) {
      if (position >= fileCh.size()) {
        throw new EOFException("EOF Reached. file size is " + fileCh.size() + " and "+ count+ " more bytes left to be "+ "transfered.");
      }
    }
 else     if (nTransfered < 0) {
      throw new IOException("Unexpected return of " + nTransfered + " from transferTo()");
    }
 else {
      position+=nTransfered;
      count-=nTransfered;
    }
  }
}

ID 971=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.SparseVectorWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SparseVectorWritable
@Override public void readFields(DataInput in) throws IOException {
  clear();
  int size=in.readInt();
  int len=in.readInt();
  setSize(size);
  for (int i=0; i < len; i++) {
    int index=in.readInt();
    double value=in.readDouble();
    this.addCell(index,value);
  }
}

ID 972=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.SparseVectorWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SparseVectorWritable
@Override public void readFields(DataInput in) throws IOException {
  clear();
  int size=in.readInt();
  int len=in.readInt();
  setSize(size);
  for (int i=0; i < len; i++) {
    int index=in.readInt();
    double value=in.readDouble();
    this.addCell(index,value);
  }
}

ID 973=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.SparseVectorWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readDouble()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SparseVectorWritable
@Override public void readFields(DataInput in) throws IOException {
  clear();
  int size=in.readInt();
  int len=in.readInt();
  setSize(size);
  for (int i=0; i < len; i++) {
    int index=in.readInt();
    double value=in.readDouble();
    this.addCell(index,value);
  }
}

ID 974=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.SparseVectorWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SparseVectorWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(getSize());
  out.writeInt(indeces.size());
  for (int i=0; i < indeces.size(); i++) {
    out.writeInt(indeces.get(i));
    out.writeDouble(values.get(i));
  }
}

ID 975=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.SparseVectorWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SparseVectorWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(getSize());
  out.writeInt(indeces.size());
  for (int i=0; i < indeces.size(); i++) {
    out.writeInt(indeces.get(i));
    out.writeDouble(values.get(i));
  }
}

ID 976=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.SparseVectorWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeDouble(double)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SparseVectorWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(getSize());
  out.writeInt(indeces.size());
  for (int i=0; i < indeces.size(); i++) {
    out.writeInt(indeces.get(i));
    out.writeDouble(values.get(i));
  }
}

ID 977=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMV#convertToDenseVector(HamaConfiguration)
Rmethod: org.apache.hama.examples.SpMV#convertSpMVOutputToDenseVector(java.lang.String, HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * IMPORTANT: This can be a bottle neck. Problem can be here {@core WritableUtil.convertSpMVOutputToDenseVector()}
 */

catch: 
null
block: 
SpMV
/** 
 * IMPORTANT: This can be a bottle neck. Problem can be here {@core WritableUtil.convertSpMVOutputToDenseVector()}
 */
private static void convertToDenseVector(HamaConfiguration conf) throws IOException {
  String resultPath=convertSpMVOutputToDenseVector(conf.get(outputPathString),conf);
  setResultPath(resultPath);
}

ID 978=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMVBSP#setup(BSPPeer<IntWritable,SparseVectorWritable,IntWritable,DoubleWritable,NullWritable>)
Rmethod: org.apache.hama.examples.SpMV#readFromFile(java.lang.String, Writable, HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Each peer reads input dense vector.
 */

catch: 
null
block: 
SpMVBSP
/** 
 * Each peer reads input dense vector.
 */
@Override public void setup(BSPPeer<IntWritable,SparseVectorWritable,IntWritable,DoubleWritable,NullWritable> peer) throws IOException, SyncException, InterruptedException {
  HamaConfiguration conf=(HamaConfiguration)peer.getConfiguration();
  v=new DenseVectorWritable();
  readFromFile(conf.get(inputVectorPathString),v,conf);
  peer.sync();
}

ID 979=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMV#startTask(HamaConfiguration)
Rmethod: org.apache.hama.examples.SpMV#convertToDenseVector(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Method which actually starts SpMV.
 */

catch: 
null
block: 
SpMV
/** 
 * Method which actually starts SpMV.
 */
private static void startTask(HamaConfiguration conf) throws IOException, InterruptedException, ClassNotFoundException {
  BSPJob bsp=new BSPJob(conf,SpMV.class);
  bsp.setJobName("Sparse matrix vector multiplication");
  bsp.setBspClass(SpMVBSP.class);
  bsp.setInputFormat(SequenceFileInputFormat.class);
  bsp.setInputKeyClass(IntWritable.class);
  bsp.setInputValueClass(SparseVectorWritable.class);
  bsp.setOutputKeyClass(IntWritable.class);
  bsp.setOutputValueClass(DoubleWritable.class);
  bsp.setOutputFormat(SequenceFileOutputFormat.class);
  bsp.setInputPath(new Path(conf.get(inputMatrixPathString)));
  FileOutputFormat.setOutputPath(bsp,new Path(conf.get(outputPathString)));
  BSPJobClient jobClient=new BSPJobClient(conf);
  ClusterStatus cluster=jobClient.getClusterStatus(true);
  int requestedTasks=conf.getInt(requestedBspTasksString,-1);
  if (requestedTasks != -1) {
    bsp.setNumBspTask(requestedTasks);
  }
 else {
    bsp.setNumBspTask(cluster.getMaxTasks());
  }
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    LOG.info("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds.");
    convertToDenseVector(conf);
    LOG.info("Result is in " + getResultPath());
  }
 else {
    setResultPath(null);
  }
}

ID 980=========================================================================type: Rethrow
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMV#parseArgs(HamaConfiguration, java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Function parses command line in standart form.
 */

catch: 
catch (NumberFormatException e) {
  printUsage();
  throw new IllegalArgumentException("The format of requested task count is int. Can not parse value: " + args[3]);
}

block: 
SpMV
/** 
 * Function parses command line in standart form.
 */
private static void parseArgs(HamaConfiguration conf,String[] args){
  if (args.length < 3) {
    printUsage();
    System.exit(-1);
  }
  conf.set(inputMatrixPathString,args[0]);
  conf.set(inputVectorPathString,args[1]);
  Path path=new Path(args[2]);
  path=path.suffix(intermediate);
  conf.set(outputPathString,path.toString());
  if (args.length == 4) {
    try {
      int taskCount=Integer.parseInt(args[3]);
      if (taskCount < 0) {
        printUsage();
        throw new IllegalArgumentException("The number of requested tasks can't be negative. Actual value: " + String.valueOf(taskCount));
      }
      conf.setInt(requestedBspTasksString,taskCount);
    }
 catch (    NumberFormatException e) {
      printUsage();
      throw new IllegalArgumentException("The format of requested task count is int. Can not parse value: " + args[3]);
    }
  }
}

ID 981=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMV#convertSpMVOutputToDenseVector(java.lang.String, HamaConfiguration)
Rmethod: org.apache.hama.examples.SpMV#writeToFile(java.lang.String, Writable, HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * SpMV produces a file, which contains result dense vector in format of pairs of integer and double. The aim of this method is to convert SpMV output to format usable in subsequent computation - dense vector. It can be usable for iterative solvers. IMPORTANT: currently it is used in SpMV. It can be a bottle neck, because all input needs to be stored in memory.
 * @param SpMVoutputPathString output path, which represents directory withpart files.
 * @param conf configuration
 * @return path to output vector.
 * @throws IOException
 */

catch: 
null
block: 
SpMV
/** 
 * SpMV produces a file, which contains result dense vector in format of pairs of integer and double. The aim of this method is to convert SpMV output to format usable in subsequent computation - dense vector. It can be usable for iterative solvers. IMPORTANT: currently it is used in SpMV. It can be a bottle neck, because all input needs to be stored in memory.
 * @param SpMVoutputPathString output path, which represents directory withpart files.
 * @param conf configuration
 * @return path to output vector.
 * @throws IOException
 */
public static String convertSpMVOutputToDenseVector(String SpMVoutputPathString,HamaConfiguration conf) throws IOException {
  List<Integer> indeces=new ArrayList<Integer>();
  List<Double> values=new ArrayList<Double>();
  FileSystem fs=FileSystem.get(conf);
  Path SpMVOutputPath=new Path(SpMVoutputPathString);
  Path resultOutputPath=SpMVOutputPath.getParent().suffix("/result");
  FileStatus[] stats=fs.listStatus(SpMVOutputPath);
  for (  FileStatus stat : stats) {
    String filePath=stat.getPath().toUri().getPath();
    SequenceFile.Reader reader=null;
    fs.open(new Path(filePath));
    try {
      reader=new SequenceFile.Reader(fs,new Path(filePath),conf);
      IntWritable key=new IntWritable();
      DoubleWritable value=new DoubleWritable();
      while (reader.next(key,value)) {
        indeces.add(key.get());
        values.add(value.get());
      }
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
 finally {
      if (reader != null)       reader.close();
    }
  }
  DenseVectorWritable result=new DenseVectorWritable();
  result.setSize(indeces.size());
  for (int i=0; i < indeces.size(); i++)   result.addCell(indeces.get(i),values.get(i));
  writeToFile(resultOutputPath.toString(),result,conf);
  return resultOutputPath.toString();
}

ID 982=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMV#main(java.lang.String[])
Rmethod: org.apache.hama.examples.SpMV#startTask(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SpMV
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  HamaConfiguration conf=new HamaConfiguration();
  parseArgs(conf,args);
  startTask(conf);
}

ID 983=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMV#main(java.lang.String[])
Rmethod: org.apache.hama.examples.SpMV#startTask(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SpMV
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  HamaConfiguration conf=new HamaConfiguration();
  parseArgs(conf,args);
  startTask(conf);
}

ID 984=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SpMV#main(java.lang.String[])
Rmethod: org.apache.hama.examples.SpMV#startTask(HamaConfiguration)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SpMV
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  HamaConfiguration conf=new HamaConfiguration();
  parseArgs(conf,args);
  startTask(conf);
}

ID 985=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SSSPTextReader#parseVertex(LongWritable, Text, Vertex<Text,IntWritable,IntWritable>)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * The text file essentially should look like: <br/> VERTEX_ID\t(n-tab separated VERTEX_ID:VERTEX_VALUE pairs)<br/> E.G:<br/> 1\t2:25\t3:32\t4:21<br/> 2\t3:222\t1:922<br/> etc.
 */

catch: 
null
block: 
SSSPTextReader
/** 
 * The text file essentially should look like: <br/> VERTEX_ID\t(n-tab separated VERTEX_ID:VERTEX_VALUE pairs)<br/> E.G:<br/> 1\t2:25\t3:32\t4:21<br/> 2\t3:222\t1:922<br/> etc.
 */
@Override public boolean parseVertex(LongWritable key,Text value,Vertex<Text,IntWritable,IntWritable> vertex) throws Exception {
  String[] split=value.toString().split("\t");
  for (int i=0; i < split.length; i++) {
    if (i == 0) {
      vertex.setVertexID(new Text(split[i]));
    }
 else {
      String[] split2=split[i].split(":");
      vertex.addEdge(new Edge<Text,IntWritable>(new Text(split2[0]),new IntWritable(Integer.parseInt(split2[1]))));
    }
  }
  return true;
}

ID 986=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SSSP#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SSSP
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  if (args.length < 3)   printUsage();
  HamaConfiguration conf=new HamaConfiguration();
  GraphJob ssspJob=new GraphJob(conf,SSSP.class);
  ssspJob.setJobName("Single Source Shortest Path");
  conf.set(START_VERTEX,args[0]);
  ssspJob.setInputPath(new Path(args[1]));
  ssspJob.setOutputPath(new Path(args[2]));
  if (args.length == 4) {
    ssspJob.setNumBspTask(Integer.parseInt(args[3]));
  }
  ssspJob.setVertexClass(ShortestPathVertex.class);
  ssspJob.setCombinerClass(MinIntCombiner.class);
  ssspJob.setInputFormat(TextInputFormat.class);
  ssspJob.setInputKeyClass(LongWritable.class);
  ssspJob.setInputValueClass(Text.class);
  ssspJob.setPartitioner(HashPartitioner.class);
  ssspJob.setOutputFormat(TextOutputFormat.class);
  ssspJob.setVertexInputReaderClass(SSSPTextReader.class);
  ssspJob.setOutputKeyClass(Text.class);
  ssspJob.setOutputValueClass(IntWritable.class);
  ssspJob.setMaxIteration(Integer.MAX_VALUE);
  ssspJob.setVertexIDClass(Text.class);
  ssspJob.setVertexValueClass(IntWritable.class);
  ssspJob.setEdgeValueClass(IntWritable.class);
  long startTime=System.currentTimeMillis();
  if (ssspJob.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 987=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SSSPTest#verifyResult()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SSSPTest
private void verifyResult() throws IOException {
  Map<String,Integer> rs=new HashMap<String,Integer>();
  rs.put("6",403);
  rs.put("1",85);
  rs.put("3",503);
  rs.put("4",173);
  rs.put("7",320);
  rs.put("8",415);
  rs.put("0",0);
  rs.put("9",487);
  rs.put("2",217);
  rs.put("5",165);
  FileStatus[] globStatus=fs.globStatus(new Path(OUTPUT + "/part-*"));
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line=null;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      System.out.println(split[1] + " = " + rs.get(split[0]));
      assertEquals(Integer.parseInt(split[1]),(int)rs.get(split[0]));
    }
  }
}

ID 988=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SSSPTest#verifyResult()
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SSSPTest
private void verifyResult() throws IOException {
  Map<String,Integer> rs=new HashMap<String,Integer>();
  rs.put("6",403);
  rs.put("1",85);
  rs.put("3",503);
  rs.put("4",173);
  rs.put("7",320);
  rs.put("8",415);
  rs.put("0",0);
  rs.put("9",487);
  rs.put("2",217);
  rs.put("5",165);
  FileStatus[] globStatus=fs.globStatus(new Path(OUTPUT + "/part-*"));
  for (  FileStatus fts : globStatus) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(fts.getPath())));
    String line=null;
    while ((line=reader.readLine()) != null) {
      String[] split=line.split("\t");
      System.out.println(split[1] + " = " + rs.get(split[0]));
      assertEquals(Integer.parseInt(split[1]),(int)rs.get(split[0]));
    }
  }
}

ID 989=========================================================================type: Recover
package: org.apache.hama.examples
Method:org.apache.hama.examples.SSSPTest#generateTestData()
Rmethod: java.io.FileWriter#FileWriter(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
SSSPTest
private void generateTestData(){
  BufferedWriter bw=null;
  try {
    bw=new BufferedWriter(new FileWriter(INPUT));
    int index=0;
    for (    String s : input) {
      bw.write((index++) + "\t" + s+ "\n");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    if (bw != null) {
      try {
        bw.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}

ID 990=========================================================================type: Recover
package: org.apache.hama.examples
Method:org.apache.hama.examples.SSSPTest#generateTestData()
Rmethod: java.io.Writer#write(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
SSSPTest
private void generateTestData(){
  BufferedWriter bw=null;
  try {
    bw=new BufferedWriter(new FileWriter(INPUT));
    int index=0;
    for (    String s : input) {
      bw.write((index++) + "\t" + s+ "\n");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    if (bw != null) {
      try {
        bw.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}

ID 991=========================================================================type: Recover
package: org.apache.hama.examples
Method:org.apache.hama.examples.SSSPTest#generateTestData()
Rmethod: java.io.BufferedWriter#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
SSSPTest
private void generateTestData(){
  BufferedWriter bw=null;
  try {
    bw=new BufferedWriter(new FileWriter(INPUT));
    int index=0;
    for (    String s : input) {
      bw.write((index++) + "\t" + s+ "\n");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    if (bw != null) {
      try {
        bw.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}

ID 992=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.StreamBackedIterator#close()
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamBackedIterator
public void close() throws IOException {
  if (null != infbuf)   infbuf.close();
  if (null != outfbuf)   outfbuf.close();
}

ID 993=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.StreamBackedIterator#close()
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamBackedIterator
public void close() throws IOException {
  if (null != infbuf)   infbuf.close();
  if (null != outfbuf)   outfbuf.close();
}

ID 994=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#getUplinkReader(BSPPeer<K1,V1,Text,Text,BytesWritable>, java.io.InputStream)
Rmethod: org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#StreamingUplinkReaderThread(BinaryProtocol<K1,V1,Text,Text,BytesWritable>, BSPPeer<K1,V1,Text,Text,BytesWritable>, java.io.InputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public UplinkReader<K1,V1,Text,Text,BytesWritable> getUplinkReader(BSPPeer<K1,V1,Text,Text,BytesWritable> peer,InputStream in) throws IOException {
  return new StreamingUplinkReaderThread(this,peer,in);
}

ID 995=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#sendMessage()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void sendMessage() throws IOException {
  String peerLine=reader.readLine();
  String msgLine=reader.readLine();
  peer.send(peerLine,new BytesWritable(msgLine.getBytes()));
}

ID 996=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getMessage()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getMessage() throws IOException {
  BytesWritable currentMessage=peer.getCurrentMessage();
  if (currentMessage != null)   writeLine(new String(currentMessage.getBytes()));
 else   writeLine("%%-1%%");
}

ID 997=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getMessageCount()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getMessageCount() throws IOException {
  writeLine("" + peer.getNumCurrentMessages());
}

ID 998=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getSuperstepCount()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getSuperstepCount() throws IOException {
  writeLine("" + peer.getSuperstepCount());
}

ID 999=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getPeerName()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getPeerName() throws IOException {
  int id=Integer.parseInt(reader.readLine());
  if (id == -1)   writeLine(peer.getPeerName());
 else   writeLine(peer.getPeerName(id));
}

ID 1000=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getPeerName()
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getPeerName() throws IOException {
  int id=Integer.parseInt(reader.readLine());
  if (id == -1)   writeLine(peer.getPeerName());
 else   writeLine(peer.getPeerName(id));
}

ID 1001=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getPeerName()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getPeerName() throws IOException {
  int id=Integer.parseInt(reader.readLine());
  if (id == -1)   writeLine(peer.getPeerName());
 else   writeLine(peer.getPeerName(id));
}

ID 1002=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getPeerIndex()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getPeerIndex() throws IOException {
  writeLine("" + peer.getPeerIndex());
}

ID 1003=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getAllPeerNames()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getAllPeerNames() throws IOException {
  writeLine("" + peer.getAllPeerNames().length);
  for (  String s : peer.getAllPeerNames()) {
    writeLine(s);
  }
}

ID 1004=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#getPeerCount()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void getPeerCount() throws IOException {
  writeLine("" + peer.getAllPeerNames().length);
}

ID 1005=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#sync()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void sync() throws IOException, SyncException, InterruptedException {
  peer.sync();
  writeLine(getProtocolString(MessageType.SYNC) + "_SUCCESS");
}

ID 1006=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#writeKeyValue()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void writeKeyValue() throws IOException {
  String key=reader.readLine();
  String value=reader.readLine();
  peer.write(new Text(key),new Text(value));
}

ID 1007=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#readKeyValue()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override public void readKeyValue() throws IOException {
  KeyValuePair<K1,V1> readNext=peer.readNext();
  if (readNext == null) {
    writeLine("%%-1%%");
    writeLine("%%-1%%");
  }
 else {
    writeLine(readNext.getKey() + "");
    writeLine(readNext.getValue() + "");
  }
}

ID 1008=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#readCommand()
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingUplinkReaderThread
@Override protected int readCommand() throws IOException {
  String readLine=reader.readLine();
  if (readLine != null && !readLine.isEmpty()) {
    String[] split=PROTOCOL_STRING_PATTERN.split(readLine,2);
    split[0]=split[0].replace("%","");
    if (checkAcks(split))     return -1;
    try {
      int parseInt=Integer.parseInt(split[0]);
      if (parseInt == MessageType.LOG.code) {
        LOG.info(split[1]);
        return -1;
      }
      return parseInt;
    }
 catch (    NumberFormatException e) {
      e.printStackTrace();
    }
  }
 else {
    return -1;
  }
  return -2;
}

ID 1009=========================================================================type: Recover
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#readCommand()
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (NumberFormatException e) {
  e.printStackTrace();
}

block: 
StreamingUplinkReaderThread
@Override protected int readCommand() throws IOException {
  String readLine=reader.readLine();
  if (readLine != null && !readLine.isEmpty()) {
    String[] split=PROTOCOL_STRING_PATTERN.split(readLine,2);
    split[0]=split[0].replace("%","");
    if (checkAcks(split))     return -1;
    try {
      int parseInt=Integer.parseInt(split[0]);
      if (parseInt == MessageType.LOG.code) {
        LOG.info(split[1]);
        return -1;
      }
      return parseInt;
    }
 catch (    NumberFormatException e) {
      e.printStackTrace();
    }
  }
 else {
    return -1;
  }
  return -2;
}

ID 1010=========================================================================type: Recover
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#checkAcks(java.lang.String[])
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  e.printStackTrace();
}

block: 
StreamingUplinkReaderThread
private boolean checkAcks(String[] readLine){
  if (readLine[0].startsWith("ACK_")) {
    try {
      ackBarrier.await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
catch (    BrokenBarrierException e) {
      e.printStackTrace();
    }
    return true;
  }
  return false;
}

ID 1011=========================================================================type: Recover
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingUplinkReaderThread#checkAcks(java.lang.String[])
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.BrokenBarrierException
exception comment: /** 
 * Exception thrown when a thread tries to wait upon a barrier that is in a broken state, or which enters the broken state while the thread is waiting.
 * @see CyclicBarrier
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (BrokenBarrierException e) {
  e.printStackTrace();
}

block: 
StreamingUplinkReaderThread
private boolean checkAcks(String[] readLine){
  if (readLine[0].startsWith("ACK_")) {
    try {
      ackBarrier.await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
catch (    BrokenBarrierException e) {
      e.printStackTrace();
    }
    return true;
  }
  return false;
}

ID 1012=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#start()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(MessageType, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void start() throws IOException {
  writeLine(MessageType.START,null);
  writeLine("" + CURRENT_PROTOCOL_VERSION);
  setBSPJobConf(peer.getConfiguration());
  try {
    ackBarrier.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  BrokenBarrierException e) {
    e.printStackTrace();
  }
}

ID 1013=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#start()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void start() throws IOException {
  writeLine(MessageType.START,null);
  writeLine("" + CURRENT_PROTOCOL_VERSION);
  setBSPJobConf(peer.getConfiguration());
  try {
    ackBarrier.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  BrokenBarrierException e) {
    e.printStackTrace();
  }
}

ID 1014=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#start()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#setBSPJobConf(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void start() throws IOException {
  writeLine(MessageType.START,null);
  writeLine("" + CURRENT_PROTOCOL_VERSION);
  setBSPJobConf(peer.getConfiguration());
  try {
    ackBarrier.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  BrokenBarrierException e) {
    e.printStackTrace();
  }
}

ID 1015=========================================================================type: Recover
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#start()
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  e.printStackTrace();
}

block: 
StreamingProtocol
@Override public void start() throws IOException {
  writeLine(MessageType.START,null);
  writeLine("" + CURRENT_PROTOCOL_VERSION);
  setBSPJobConf(peer.getConfiguration());
  try {
    ackBarrier.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  BrokenBarrierException e) {
    e.printStackTrace();
  }
}

ID 1016=========================================================================type: Recover
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#start()
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.BrokenBarrierException
exception comment: /** 
 * Exception thrown when a thread tries to wait upon a barrier that is in a broken state, or which enters the broken state while the thread is waiting.
 * @see CyclicBarrier
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (BrokenBarrierException e) {
  e.printStackTrace();
}

block: 
StreamingProtocol
@Override public void start() throws IOException {
  writeLine(MessageType.START,null);
  writeLine("" + CURRENT_PROTOCOL_VERSION);
  setBSPJobConf(peer.getConfiguration());
  try {
    ackBarrier.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  BrokenBarrierException e) {
    e.printStackTrace();
  }
}

ID 1017=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#setBSPJobConf(Configuration)
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(MessageType, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void setBSPJobConf(Configuration conf) throws IOException {
  writeLine(MessageType.SET_BSPJOB_CONF,null);
  List<String> list=new ArrayList<String>();
  for (  Map.Entry<String,String> itm : conf) {
    list.add(itm.getKey());
    list.add(itm.getValue());
  }
  writeLine(list.size());
  for (  String entry : list) {
    writeLine(entry);
  }
  flush();
}

ID 1018=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#setBSPJobConf(Configuration)
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void setBSPJobConf(Configuration conf) throws IOException {
  writeLine(MessageType.SET_BSPJOB_CONF,null);
  List<String> list=new ArrayList<String>();
  for (  Map.Entry<String,String> itm : conf) {
    list.add(itm.getKey());
    list.add(itm.getValue());
  }
  writeLine(list.size());
  for (  String entry : list) {
    writeLine(entry);
  }
  flush();
}

ID 1019=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#setBSPJobConf(Configuration)
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void setBSPJobConf(Configuration conf) throws IOException {
  writeLine(MessageType.SET_BSPJOB_CONF,null);
  List<String> list=new ArrayList<String>();
  for (  Map.Entry<String,String> itm : conf) {
    list.add(itm.getKey());
    list.add(itm.getValue());
  }
  writeLine(list.size());
  for (  String entry : list) {
    writeLine(entry);
  }
  flush();
}

ID 1020=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#runSetup()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(MessageType, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void runSetup() throws IOException {
  writeLine(MessageType.RUN_SETUP,null);
  waitOnAck();
}

ID 1021=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#runBsp()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(MessageType, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void runBsp() throws IOException {
  writeLine(MessageType.RUN_BSP,null);
  waitOnAck();
}

ID 1022=========================================================================type: Recover
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#waitOnAck()
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  e.printStackTrace();
}

block: 
StreamingProtocol
public void waitOnAck(){
  try {
    if (!brokenBarrier)     ackBarrier.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  BrokenBarrierException e) {
    e.printStackTrace();
  }
}

ID 1023=========================================================================type: Recover
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#waitOnAck()
Rmethod: java.util.concurrent.CyclicBarrier#await()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.BrokenBarrierException
exception comment: /** 
 * Exception thrown when a thread tries to wait upon a barrier that is in a broken state, or which enters the broken state while the thread is waiting.
 * @see CyclicBarrier
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (BrokenBarrierException e) {
  e.printStackTrace();
}

block: 
StreamingProtocol
public void waitOnAck(){
  try {
    if (!brokenBarrier)     ackBarrier.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  BrokenBarrierException e) {
    e.printStackTrace();
  }
}

ID 1024=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#runCleanup()
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(MessageType, java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
@Override public void runCleanup() throws IOException {
  writeLine(MessageType.RUN_CLEANUP,null);
  waitOnAck();
}

ID 1025=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(int)
Rmethod: org.apache.hama.pipes.protocol.StreamingProtocol#writeLine(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StreamingProtocol
public void writeLine(int msg) throws IOException {
  writeLine("" + msg);
}

ID 1026=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.StringArrayWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StringArrayWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(array.length);
  for (  String s : array) {
    out.writeUTF(s);
  }
}

ID 1027=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.StringArrayWritable#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StringArrayWritable
@Override public void write(DataOutput out) throws IOException {
  out.writeInt(array.length);
  for (  String s : array) {
    out.writeUTF(s);
  }
}

ID 1028=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.StringArrayWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StringArrayWritable
@Override public void readFields(DataInput in) throws IOException {
  array=new String[in.readInt()];
  for (int i=0; i < array.length; i++) {
    array[i]=in.readUTF();
  }
}

ID 1029=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.StringArrayWritable#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
StringArrayWritable
@Override public void readFields(DataInput in) throws IOException {
  array=new String[in.readInt()];
  for (int i=0; i < array.length; i++) {
    array[i]=in.readUTF();
  }
}

ID 1030=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.Submitter#runJob(BSPJob)
Rmethod: org.apache.hama.pipes.Submitter#setupPipesJob(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Submit a job to the cluster. All of the necessary modifications to the job to run under pipes are made to the configuration.
 * @param job to submit to the cluster
 * @throws IOException
 */

catch: 
null
block: 
Submitter
/** 
 * Submit a job to the cluster. All of the necessary modifications to the job to run under pipes are made to the configuration.
 * @param job to submit to the cluster
 * @throws IOException
 */
public static void runJob(BSPJob job) throws IOException {
  setupPipesJob(job);
  BSPJobClient.runJob(job);
}

ID 1031=========================================================================type: Recover
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.Submitter#setupPipesJob(BSPJob)
Rmethod: java.net.URI#URI(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.net.URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

method comment: null
catch: 
catch (URISyntaxException e) {
  IOException ie=new IOException("Problem parsing executable URI " + exec);
  ie.initCause(e);
  throw ie;
}

block: 
Submitter
private static void setupPipesJob(BSPJob job) throws IOException {
  job.setBspClass(PipesBSP.class);
  job.setJarByClass(PipesBSP.class);
  String textClassname=Text.class.getName();
  setIfUnset(job.getConfiguration(),"bsp.input.key.class",textClassname);
  setIfUnset(job.getConfiguration(),"bsp.input.value.class",textClassname);
  setIfUnset(job.getConfiguration(),"bsp.output.key.class",textClassname);
  setIfUnset(job.getConfiguration(),"bsp.output.value.class",textClassname);
  setIfUnset(job.getConfiguration(),Constants.MESSAGE_CLASS,BytesWritable.class.getName());
  setIfUnset(job.getConfiguration(),"bsp.job.name","Hama Pipes Job");
  LOG.debug("BspClass: " + job.getBspClass().getName());
  LOG.debug("InputFormat: " + job.getInputFormat());
  LOG.debug("InputKeyClass: " + job.getInputKeyClass().getName());
  LOG.debug("InputValueClass: " + job.getInputValueClass().getName());
  LOG.debug("InputFormat: " + job.getOutputFormat());
  LOG.debug("OutputKeyClass: " + job.getOutputKeyClass().getName());
  LOG.debug("OutputValueClass: " + job.getOutputValueClass().getName());
  LOG.debug("MessageClass: " + job.get(Constants.MESSAGE_CLASS));
  LOG.debug("bsp.master.address: " + job.getConfiguration().get("bsp.master.address"));
  LOG.debug("bsp.local.tasks.maximum: " + job.getConfiguration().get("bsp.local.tasks.maximum"));
  LOG.debug("NumBspTask: " + job.getNumBspTask());
  LOG.debug("fs.default.name: " + job.getConfiguration().get("fs.default.name"));
  String exec=getExecutable(job.getConfiguration());
  if (exec == null) {
    throw new IllegalArgumentException("No application defined. (Set property hama.pipes.executable)");
  }
  URI[] fileCache=DistributedCache.getCacheFiles(job.getConfiguration());
  if (fileCache == null) {
    fileCache=new URI[1];
  }
 else {
    URI[] tmp=new URI[fileCache.length + 1];
    System.arraycopy(fileCache,0,tmp,1,fileCache.length);
    fileCache=tmp;
  }
  try {
    fileCache[0]=new URI(exec);
  }
 catch (  URISyntaxException e) {
    IOException ie=new IOException("Problem parsing executable URI " + exec);
    ie.initCause(e);
    throw ie;
  }
  DistributedCache.setCacheFiles(fileCache,job.getConfiguration());
  String tmpjars=job.getConfiguration().get("tmpjars");
  LOG.debug("conf.get(tmpjars): " + tmpjars);
  if (tmpjars != null) {
    String hdfsFileUrls=DistributedCacheUtil.addFilesToHDFS(job.getConfiguration(),job.getConfiguration().get("tmpjars"));
    job.getConfiguration().set("tmpjars",hdfsFileUrls);
    LOG.info("conf.get(tmpjars): " + job.getConfiguration().get("tmpjars"));
  }
}

ID 1032=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.Submitter#run(java.lang.String[])
Rmethod: org.apache.hama.pipes.Submitter#getClass(CommandLine, java.lang.String, HamaConfiguration, Class<InterfaceType>)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Submitter
@Override public int run(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return 1;
  }
  LOG.debug("Hama pipes Submitter started!");
  cli.addOption("input",false,"input path for bsp","path");
  cli.addOption("output",false,"output path from bsp","path");
  cli.addOption("jar",false,"job jar file","path");
  cli.addOption("inputformat",false,"java classname of InputFormat","class");
  cli.addOption("partitioner",false,"java classname of Partitioner","class");
  cli.addOption("outputformat",false,"java classname of OutputFormat","class");
  cli.addOption("cachefiles",false,"additional cache files to add","space delimited paths");
  cli.addOption("interpreter",false,"interpreter, like python or bash","executable");
  cli.addOption("jobname",false,"the jobname","name");
  cli.addOption("programArgs",false,"program arguments","arguments");
  cli.addOption("bspTasks",false,"how many bsp tasks to launch","number");
  cli.addOption("streaming",false,"if supplied, streaming is used instead of pipes","");
  cli.addOption("jobconf",false,"\"n1=v1,n2=v2,..\" (Deprecated) Optional. Add or override a JobConf property.","key=val");
  cli.addOption("program",false,"URI to application executable","class");
  Parser parser=cli.createParser();
  try {
    GenericOptionsParser genericParser=new GenericOptionsParser(getConf(),args);
    CommandLine results=parser.parse(cli.options,genericParser.getRemainingArgs());
    BSPJob job=new BSPJob(getConf());
    if (results.hasOption("input")) {
      FileInputFormat.setInputPaths(job,results.getOptionValue("input"));
    }
    if (results.hasOption("output")) {
      FileOutputFormat.setOutputPath(job,new Path(results.getOptionValue("output")));
    }
    if (results.hasOption("jar")) {
      job.setJar(results.getOptionValue("jar"));
    }
    if (results.hasOption("jobname")) {
      job.setJobName(results.getOptionValue("jobname"));
    }
    if (results.hasOption("inputformat")) {
      job.setInputFormat(getClass(results,"inputformat",conf,InputFormat.class));
    }
    if (results.hasOption("partitioner")) {
      job.setPartitioner(getClass(results,"partitioner",conf,Partitioner.class));
    }
    if (results.hasOption("outputformat")) {
      job.setOutputFormat(getClass(results,"outputformat",conf,OutputFormat.class));
    }
    if (results.hasOption("streaming")) {
      LOG.info("Streaming enabled!");
      job.set("hama.streaming.enabled","true");
    }
    if (results.hasOption("jobconf")) {
      LOG.warn("-jobconf option is deprecated, please use -D instead.");
      String options=results.getOptionValue("jobconf");
      StringTokenizer tokenizer=new StringTokenizer(options,",");
      while (tokenizer.hasMoreTokens()) {
        String keyVal=tokenizer.nextToken().trim();
        String[] keyValSplit=keyVal.split("=",2);
        job.set(keyValSplit[0],keyValSplit[1]);
      }
    }
    if (results.hasOption("bspTasks")) {
      int optionValue=Integer.parseInt(results.getOptionValue("bspTasks"));
      conf.setInt("bsp.local.tasks.maximum",optionValue);
      conf.setInt("bsp.peers.num",optionValue);
    }
    if (results.hasOption("program")) {
      String executablePath=results.getOptionValue("program");
      setExecutable(job.getConfiguration(),executablePath);
      DistributedCache.addCacheFile(new Path(executablePath).toUri(),conf);
    }
    if (results.hasOption("interpreter")) {
      job.getConfiguration().set("hama.pipes.executable.interpretor",results.getOptionValue("interpreter"));
    }
    if (results.hasOption("programArgs")) {
      job.getConfiguration().set("hama.pipes.executable.args",Joiner.on(" ").join(results.getOptionValues("programArgs")));
    }
    if (results.hasOption("cachefiles")) {
      FileSystem fs=FileSystem.get(getConf());
      String[] optionValues=results.getOptionValues("cachefiles");
      for (      String s : optionValues) {
        Path path=new Path(s);
        FileStatus[] globStatus=fs.globStatus(path);
        for (        FileStatus f : globStatus) {
          if (!f.isDir()) {
            DistributedCache.addCacheFile(f.getPath().toUri(),job.getConfiguration());
          }
 else {
            LOG.info("Ignoring directory " + f.getPath() + " while globbing.");
          }
        }
      }
    }
    String jarFile=job.getJar();
    if (jarFile != null) {
      @SuppressWarnings("deprecation") final URL[] urls=new URL[]{FileSystem.getLocal(conf).pathToFile(new Path(jarFile)).toURL()};
      ClassLoader loader=AccessController.doPrivileged(new PrivilegedAction<ClassLoader>(){
        @Override public ClassLoader run(){
          return new URLClassLoader(urls);
        }
      }
);
      conf.setClassLoader(loader);
    }
    runJob(job);
    return 0;
  }
 catch (  ParseException pe) {
    LOG.info("Error : " + pe);
    cli.printUsage();
    return 1;
  }
}

ID 1033=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.Submitter#run(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Submitter
@Override public int run(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return 1;
  }
  LOG.debug("Hama pipes Submitter started!");
  cli.addOption("input",false,"input path for bsp","path");
  cli.addOption("output",false,"output path from bsp","path");
  cli.addOption("jar",false,"job jar file","path");
  cli.addOption("inputformat",false,"java classname of InputFormat","class");
  cli.addOption("partitioner",false,"java classname of Partitioner","class");
  cli.addOption("outputformat",false,"java classname of OutputFormat","class");
  cli.addOption("cachefiles",false,"additional cache files to add","space delimited paths");
  cli.addOption("interpreter",false,"interpreter, like python or bash","executable");
  cli.addOption("jobname",false,"the jobname","name");
  cli.addOption("programArgs",false,"program arguments","arguments");
  cli.addOption("bspTasks",false,"how many bsp tasks to launch","number");
  cli.addOption("streaming",false,"if supplied, streaming is used instead of pipes","");
  cli.addOption("jobconf",false,"\"n1=v1,n2=v2,..\" (Deprecated) Optional. Add or override a JobConf property.","key=val");
  cli.addOption("program",false,"URI to application executable","class");
  Parser parser=cli.createParser();
  try {
    GenericOptionsParser genericParser=new GenericOptionsParser(getConf(),args);
    CommandLine results=parser.parse(cli.options,genericParser.getRemainingArgs());
    BSPJob job=new BSPJob(getConf());
    if (results.hasOption("input")) {
      FileInputFormat.setInputPaths(job,results.getOptionValue("input"));
    }
    if (results.hasOption("output")) {
      FileOutputFormat.setOutputPath(job,new Path(results.getOptionValue("output")));
    }
    if (results.hasOption("jar")) {
      job.setJar(results.getOptionValue("jar"));
    }
    if (results.hasOption("jobname")) {
      job.setJobName(results.getOptionValue("jobname"));
    }
    if (results.hasOption("inputformat")) {
      job.setInputFormat(getClass(results,"inputformat",conf,InputFormat.class));
    }
    if (results.hasOption("partitioner")) {
      job.setPartitioner(getClass(results,"partitioner",conf,Partitioner.class));
    }
    if (results.hasOption("outputformat")) {
      job.setOutputFormat(getClass(results,"outputformat",conf,OutputFormat.class));
    }
    if (results.hasOption("streaming")) {
      LOG.info("Streaming enabled!");
      job.set("hama.streaming.enabled","true");
    }
    if (results.hasOption("jobconf")) {
      LOG.warn("-jobconf option is deprecated, please use -D instead.");
      String options=results.getOptionValue("jobconf");
      StringTokenizer tokenizer=new StringTokenizer(options,",");
      while (tokenizer.hasMoreTokens()) {
        String keyVal=tokenizer.nextToken().trim();
        String[] keyValSplit=keyVal.split("=",2);
        job.set(keyValSplit[0],keyValSplit[1]);
      }
    }
    if (results.hasOption("bspTasks")) {
      int optionValue=Integer.parseInt(results.getOptionValue("bspTasks"));
      conf.setInt("bsp.local.tasks.maximum",optionValue);
      conf.setInt("bsp.peers.num",optionValue);
    }
    if (results.hasOption("program")) {
      String executablePath=results.getOptionValue("program");
      setExecutable(job.getConfiguration(),executablePath);
      DistributedCache.addCacheFile(new Path(executablePath).toUri(),conf);
    }
    if (results.hasOption("interpreter")) {
      job.getConfiguration().set("hama.pipes.executable.interpretor",results.getOptionValue("interpreter"));
    }
    if (results.hasOption("programArgs")) {
      job.getConfiguration().set("hama.pipes.executable.args",Joiner.on(" ").join(results.getOptionValues("programArgs")));
    }
    if (results.hasOption("cachefiles")) {
      FileSystem fs=FileSystem.get(getConf());
      String[] optionValues=results.getOptionValues("cachefiles");
      for (      String s : optionValues) {
        Path path=new Path(s);
        FileStatus[] globStatus=fs.globStatus(path);
        for (        FileStatus f : globStatus) {
          if (!f.isDir()) {
            DistributedCache.addCacheFile(f.getPath().toUri(),job.getConfiguration());
          }
 else {
            LOG.info("Ignoring directory " + f.getPath() + " while globbing.");
          }
        }
      }
    }
    String jarFile=job.getJar();
    if (jarFile != null) {
      @SuppressWarnings("deprecation") final URL[] urls=new URL[]{FileSystem.getLocal(conf).pathToFile(new Path(jarFile)).toURL()};
      ClassLoader loader=AccessController.doPrivileged(new PrivilegedAction<ClassLoader>(){
        @Override public ClassLoader run(){
          return new URLClassLoader(urls);
        }
      }
);
      conf.setClassLoader(loader);
    }
    runJob(job);
    return 0;
  }
 catch (  ParseException pe) {
    LOG.info("Error : " + pe);
    cli.printUsage();
    return 1;
  }
}

ID 1034=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.Submitter#run(java.lang.String[])
Rmethod: org.apache.hama.pipes.Submitter#runJob(BSPJob)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Submitter
@Override public int run(String[] args) throws Exception {
  CommandLineParser cli=new CommandLineParser();
  if (args.length == 0) {
    cli.printUsage();
    return 1;
  }
  LOG.debug("Hama pipes Submitter started!");
  cli.addOption("input",false,"input path for bsp","path");
  cli.addOption("output",false,"output path from bsp","path");
  cli.addOption("jar",false,"job jar file","path");
  cli.addOption("inputformat",false,"java classname of InputFormat","class");
  cli.addOption("partitioner",false,"java classname of Partitioner","class");
  cli.addOption("outputformat",false,"java classname of OutputFormat","class");
  cli.addOption("cachefiles",false,"additional cache files to add","space delimited paths");
  cli.addOption("interpreter",false,"interpreter, like python or bash","executable");
  cli.addOption("jobname",false,"the jobname","name");
  cli.addOption("programArgs",false,"program arguments","arguments");
  cli.addOption("bspTasks",false,"how many bsp tasks to launch","number");
  cli.addOption("streaming",false,"if supplied, streaming is used instead of pipes","");
  cli.addOption("jobconf",false,"\"n1=v1,n2=v2,..\" (Deprecated) Optional. Add or override a JobConf property.","key=val");
  cli.addOption("program",false,"URI to application executable","class");
  Parser parser=cli.createParser();
  try {
    GenericOptionsParser genericParser=new GenericOptionsParser(getConf(),args);
    CommandLine results=parser.parse(cli.options,genericParser.getRemainingArgs());
    BSPJob job=new BSPJob(getConf());
    if (results.hasOption("input")) {
      FileInputFormat.setInputPaths(job,results.getOptionValue("input"));
    }
    if (results.hasOption("output")) {
      FileOutputFormat.setOutputPath(job,new Path(results.getOptionValue("output")));
    }
    if (results.hasOption("jar")) {
      job.setJar(results.getOptionValue("jar"));
    }
    if (results.hasOption("jobname")) {
      job.setJobName(results.getOptionValue("jobname"));
    }
    if (results.hasOption("inputformat")) {
      job.setInputFormat(getClass(results,"inputformat",conf,InputFormat.class));
    }
    if (results.hasOption("partitioner")) {
      job.setPartitioner(getClass(results,"partitioner",conf,Partitioner.class));
    }
    if (results.hasOption("outputformat")) {
      job.setOutputFormat(getClass(results,"outputformat",conf,OutputFormat.class));
    }
    if (results.hasOption("streaming")) {
      LOG.info("Streaming enabled!");
      job.set("hama.streaming.enabled","true");
    }
    if (results.hasOption("jobconf")) {
      LOG.warn("-jobconf option is deprecated, please use -D instead.");
      String options=results.getOptionValue("jobconf");
      StringTokenizer tokenizer=new StringTokenizer(options,",");
      while (tokenizer.hasMoreTokens()) {
        String keyVal=tokenizer.nextToken().trim();
        String[] keyValSplit=keyVal.split("=",2);
        job.set(keyValSplit[0],keyValSplit[1]);
      }
    }
    if (results.hasOption("bspTasks")) {
      int optionValue=Integer.parseInt(results.getOptionValue("bspTasks"));
      conf.setInt("bsp.local.tasks.maximum",optionValue);
      conf.setInt("bsp.peers.num",optionValue);
    }
    if (results.hasOption("program")) {
      String executablePath=results.getOptionValue("program");
      setExecutable(job.getConfiguration(),executablePath);
      DistributedCache.addCacheFile(new Path(executablePath).toUri(),conf);
    }
    if (results.hasOption("interpreter")) {
      job.getConfiguration().set("hama.pipes.executable.interpretor",results.getOptionValue("interpreter"));
    }
    if (results.hasOption("programArgs")) {
      job.getConfiguration().set("hama.pipes.executable.args",Joiner.on(" ").join(results.getOptionValues("programArgs")));
    }
    if (results.hasOption("cachefiles")) {
      FileSystem fs=FileSystem.get(getConf());
      String[] optionValues=results.getOptionValues("cachefiles");
      for (      String s : optionValues) {
        Path path=new Path(s);
        FileStatus[] globStatus=fs.globStatus(path);
        for (        FileStatus f : globStatus) {
          if (!f.isDir()) {
            DistributedCache.addCacheFile(f.getPath().toUri(),job.getConfiguration());
          }
 else {
            LOG.info("Ignoring directory " + f.getPath() + " while globbing.");
          }
        }
      }
    }
    String jarFile=job.getJar();
    if (jarFile != null) {
      @SuppressWarnings("deprecation") final URL[] urls=new URL[]{FileSystem.getLocal(conf).pathToFile(new Path(jarFile)).toURL()};
      ClassLoader loader=AccessController.doPrivileged(new PrivilegedAction<ClassLoader>(){
        @Override public ClassLoader run(){
          return new URLClassLoader(urls);
        }
      }
);
      conf.setClassLoader(loader);
    }
    runJob(job);
    return 0;
  }
 catch (  ParseException pe) {
    LOG.info("Error : " + pe);
    cli.printUsage();
    return 1;
  }
}

ID 1035=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.Submitter#main(java.lang.String[])
Rmethod: org.apache.hama.pipes.Submitter#run(java.lang.String[])
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: /** 
 * Submit a pipes job based on the command line arguments.
 */

catch: 
null
block: 
Submitter
/** 
 * Submit a pipes job based on the command line arguments.
 */
public static void main(String[] args) throws Exception {
  int exitCode=new Submitter().run(args);
  System.exit(exitCode);
}

ID 1036=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.SuperstepBSP#setup(BSPPeer<K1,V1,K2,V2,M>)
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: true
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (ClassNotFoundException e) {
  LOG.error((new StringBuffer("Could not instantiate a Superstep class ").append(classNames[i])).toString(),e);
  throw new IOException(e);
}

block: 
SuperstepBSP
@SuppressWarnings("unchecked") @Override public void setup(BSPPeer<K1,V1,K2,V2,M> peer) throws IOException, SyncException, InterruptedException {
  String classList=peer.getConfiguration().get("hama.supersteps.class");
  String[] classNames=classList.split(",");
  LOG.debug("Size of classes = " + classNames.length);
  supersteps=new Superstep[classNames.length];
  Superstep<K1,V1,K2,V2,M> newInstance;
  for (int i=0; i < classNames.length; i++) {
    try {
      newInstance=(Superstep<K1,V1,K2,V2,M>)ReflectionUtils.newInstance(Class.forName(classNames[i]),peer.getConfiguration());
    }
 catch (    ClassNotFoundException e) {
      LOG.error((new StringBuffer("Could not instantiate a Superstep class ").append(classNames[i])).toString(),e);
      throw new IOException(e);
    }
    newInstance.setup(peer);
    supersteps[i]=newInstance;
  }
  startSuperstep=peer.getConfiguration().getInt("attempt.superstep",0);
}

ID 1037=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SuperstepPiEstimator#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SuperstepPiEstimator
@SuppressWarnings("unchecked") public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {
  HamaConfiguration conf=new HamaConfiguration();
  BSPJob bsp=new BSPJob(conf,SuperstepBSP.class);
  bsp.setJobName("Fault Tolerant Pi Estimation Example");
  bsp.setSupersteps(SuperstepPiEstimator.PiEstimatorCalculator.class,SuperstepPiEstimator.PiEstimatorAggregator.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(DoubleWritable.class);
  bsp.setOutputFormat(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,TMP_OUTPUT);
  BSPJobClient jobClient=new BSPJobClient(conf);
  ClusterStatus cluster=jobClient.getClusterStatus(true);
  if (args.length > 0) {
    bsp.setNumBspTask(Integer.parseInt(args[0]));
  }
 else {
    bsp.setNumBspTask(cluster.getMaxTasks());
  }
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    printOutput(conf);
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 1038=========================================================================type: only_throws
package: org.apache.hama.examples
Method:org.apache.hama.examples.SuperstepPiEstimator#main(java.lang.String[])
Rmethod: org.apache.hama.examples.SuperstepPiEstimator#printOutput(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SuperstepPiEstimator
@SuppressWarnings("unchecked") public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {
  HamaConfiguration conf=new HamaConfiguration();
  BSPJob bsp=new BSPJob(conf,SuperstepBSP.class);
  bsp.setJobName("Fault Tolerant Pi Estimation Example");
  bsp.setSupersteps(SuperstepPiEstimator.PiEstimatorCalculator.class,SuperstepPiEstimator.PiEstimatorAggregator.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(DoubleWritable.class);
  bsp.setOutputFormat(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,TMP_OUTPUT);
  BSPJobClient jobClient=new BSPJobClient(conf);
  ClusterStatus cluster=jobClient.getClusterStatus(true);
  if (args.length > 0) {
    bsp.setNumBspTask(Integer.parseInt(args[0]));
  }
 else {
    bsp.setNumBspTask(cluster.getMaxTasks());
  }
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    printOutput(conf);
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 1039=========================================================================type: only_throws
package: org.apache.hama.examples.util
Method:org.apache.hama.examples.util.SymmetricMatrixGenBSP#bsp(BSPPeer<NullWritable,NullWritable,Text,TextArrayWritable,Text>)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SymmetricMatrixGenBSP
@Override public void bsp(BSPPeer<NullWritable,NullWritable,Text,TextArrayWritable,Text> peer) throws IOException, SyncException, InterruptedException {
  int interval=sizeN / peer.getNumPeers();
  int startID=peer.getPeerIndex() * interval;
  int endID;
  if (peer.getPeerIndex() == peer.getNumPeers() - 1)   endID=sizeN;
 else   endID=startID + interval;
  for (int i=startID; i < endID; i++) {
    HashSet<Integer> edges=new HashSet<Integer>();
    for (int j=0; j <= i; j++) {
      boolean nonZero=new Random().nextInt(density) == 0;
      if (nonZero && !edges.contains(j) && i != j) {
        edges.add(j);
        int peerIndex=j / interval;
        if (peerIndex == peer.getNumPeers())         peerIndex=peerIndex - 1;
        peer.send(peer.getPeerName(peerIndex),new Text(j + "," + i));
      }
    }
    list.put(i,edges);
  }
  peer.sync();
  Text received;
  while ((received=peer.getCurrentMessage()) != null) {
    String[] kv=received.toString().split(",");
    HashSet<Integer> nList=list.get(Integer.parseInt(kv[0]));
    nList.add(Integer.parseInt(kv[1]));
    list.put(Integer.parseInt(kv[0]),nList);
  }
}

ID 1040=========================================================================type: only_throws
package: org.apache.hama.examples.util
Method:org.apache.hama.examples.util.SymmetricMatrixGen#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
SymmetricMatrixGen
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {
  if (args.length < 4) {
    System.out.println("Usage: <size n> <1/x density> <output path> <number of tasks>");
    System.exit(1);
  }
  HamaConfiguration conf=new HamaConfiguration();
  conf.setInt(SIZE_OF_MATRIX,Integer.parseInt(args[0]));
  conf.setInt(DENSITY,Integer.parseInt(args[1]));
  BSPJob bsp=new BSPJob(conf,CombineExample.class);
  bsp.setJobName("Random Symmetric Matrix Generator");
  bsp.setBspClass(SymmetricMatrixGenBSP.class);
  bsp.setInputFormat(NullInputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(TextArrayWritable.class);
  bsp.setOutputFormat(SequenceFileOutputFormat.class);
  FileOutputFormat.setOutputPath(bsp,new Path(args[2]));
  bsp.setNumBspTask(Integer.parseInt(args[3]));
  long startTime=System.currentTimeMillis();
  if (bsp.waitForCompletion(true)) {
    System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
  }
}

ID 1041=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Task#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Task
@Override public void write(DataOutput out) throws IOException {
  jobId.write(out);
  Text.writeString(out,jobFile);
  taskId.write(out);
  out.writeInt(partition);
}

ID 1042=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Task#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Task
@Override public void readFields(DataInput in) throws IOException {
  jobId.readFields(in);
  jobFile=Text.readString(in);
  taskId.readFields(in);
  partition=in.readInt();
}

ID 1043=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskAttemptID#forName(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception ex) {
}

block: 
TaskAttemptID
public static TaskAttemptID forName(String str) throws IllegalArgumentException {
  if (str == null)   return null;
  try {
    String[] parts=str.split(Character.toString(SEPARATOR));
    if (parts.length == 5) {
      if (parts[0].equals(ATTEMPT)) {
        return new TaskAttemptID(parts[1],Integer.parseInt(parts[2]),Integer.parseInt(parts[3]),Integer.parseInt(parts[4]));
      }
    }
  }
 catch (  Exception ex) {
  }
  throw new IllegalArgumentException("TaskAttemptId string : " + str + " is not properly formed");
}

ID 1044=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskID#forName(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception ex) {
}

block: 
TaskID
public static TaskID forName(String str) throws IllegalArgumentException {
  if (str == null)   return null;
  try {
    String[] parts=str.split("_");
    if (parts.length == 5) {
      if (parts[0].equals(TASK)) {
        return new TaskID(parts[1],Integer.parseInt(parts[2]),Integer.parseInt(parts[4]));
      }
    }
  }
 catch (  Exception ex) {
  }
  throw new IllegalArgumentException("TaskId string : " + str + " is not properly formed");
}

ID 1045=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Reader#Reader(TaskAttemptID, org.apache.hama.bsp.TaskLog.LogName, long, long)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * Read a log file from start to end positions. The offsets may be negative, in which case they are relative to the end of the file. For example, Reader(taskid, kind, 0, -1) is the entire file and Reader(taskid, kind, -4197, -1) is the last 4196 bytes.
 * @param taskid the id of the task to read the log file for
 * @param kind the kind of log to read
 * @param pStart the offset to read from (negative is relative to tail)
 * @param pEnd the offset to read upto (negative is relative to tail)
 * @throws IOException
 */

catch: 
null
block: 
Reader
/** 
 * Read a log file from start to end positions. The offsets may be negative, in which case they are relative to the end of the file. For example, Reader(taskid, kind, 0, -1) is the entire file and Reader(taskid, kind, -4197, -1) is the last 4196 bytes.
 * @param taskid the id of the task to read the log file for
 * @param kind the kind of log to read
 * @param pStart the offset to read from (negative is relative to tail)
 * @param pEnd the offset to read upto (negative is relative to tail)
 * @throws IOException
 */
public Reader(TaskAttemptID taskid,LogName kind,long pStart,long pEnd) throws IOException {
  long start=pStart;
  long end=pEnd;
  File filename=getTaskLogFile(taskid,kind);
  long size=filename.length();
  if (start < 0) {
    start+=size + 1;
  }
  if (end < 0) {
    end+=size + 1;
  }
  start=Math.max(0,Math.min(start,size));
  end=Math.max(0,Math.min(end,size));
  bytesRemaining=end - start;
  file=new FileInputStream(filename);
  long pos=0;
  while (pos < start) {
    long result=file.skip(start - pos);
    if (result < 0) {
      bytesRemaining=0;
      break;
    }
    pos+=result;
  }
}

ID 1046=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Reader#Reader(TaskAttemptID, org.apache.hama.bsp.TaskLog.LogName, long, long)
Rmethod: java.io.FileInputStream#skip(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read a log file from start to end positions. The offsets may be negative, in which case they are relative to the end of the file. For example, Reader(taskid, kind, 0, -1) is the entire file and Reader(taskid, kind, -4197, -1) is the last 4196 bytes.
 * @param taskid the id of the task to read the log file for
 * @param kind the kind of log to read
 * @param pStart the offset to read from (negative is relative to tail)
 * @param pEnd the offset to read upto (negative is relative to tail)
 * @throws IOException
 */

catch: 
null
block: 
Reader
/** 
 * Read a log file from start to end positions. The offsets may be negative, in which case they are relative to the end of the file. For example, Reader(taskid, kind, 0, -1) is the entire file and Reader(taskid, kind, -4197, -1) is the last 4196 bytes.
 * @param taskid the id of the task to read the log file for
 * @param kind the kind of log to read
 * @param pStart the offset to read from (negative is relative to tail)
 * @param pEnd the offset to read upto (negative is relative to tail)
 * @throws IOException
 */
public Reader(TaskAttemptID taskid,LogName kind,long pStart,long pEnd) throws IOException {
  long start=pStart;
  long end=pEnd;
  File filename=getTaskLogFile(taskid,kind);
  long size=filename.length();
  if (start < 0) {
    start+=size + 1;
  }
  if (end < 0) {
    end+=size + 1;
  }
  start=Math.max(0,Math.min(start,size));
  end=Math.max(0,Math.min(end,size));
  bytesRemaining=end - start;
  file=new FileInputStream(filename);
  long pos=0;
  while (pos < start) {
    long result=file.skip(start - pos);
    if (result < 0) {
      bytesRemaining=0;
      break;
    }
    pos+=result;
  }
}

ID 1047=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Reader#read()
Rmethod: java.io.FileInputStream#read()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Reader
@Override public int read() throws IOException {
  int result=-1;
  if (bytesRemaining > 0) {
    bytesRemaining-=1;
    result=file.read();
  }
  return result;
}

ID 1048=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Reader#read(byte[], int, int)
Rmethod: java.io.FileInputStream#read(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Reader
@Override public int read(byte[] buffer,int offset,int pLength) throws IOException {
  int length=(int)Math.min(pLength,bytesRemaining);
  int bytes=file.read(buffer,offset,length);
  if (bytes > 0) {
    bytesRemaining-=bytes;
  }
  return bytes;
}

ID 1049=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Reader#available()
Rmethod: java.io.FileInputStream#available()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Reader
@Override public int available() throws IOException {
  return (int)Math.min(bytesRemaining,file.available());
}

ID 1050=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.Reader#close()
Rmethod: java.io.FileInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Reader
@Override public void close() throws IOException {
  file.close();
}

ID 1051=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLog#captureOutAndError(List<java.lang.String>, java.io.File, java.io.File, long)
Rmethod: org.apache.hama.bsp.TaskLog#captureOutAndError(List<java.lang.String>, List<java.lang.String>, java.io.File, java.io.File, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Wrap a command in a shell to capture stdout and stderr to files. If the tailLength is 0, the entire output will be saved.
 * @param cmd The command and the arguments that should be run
 * @param stdoutFilename The filename that stdout should be saved to
 * @param stderrFilename The filename that stderr should be saved to
 * @param tailLength The length of the tail to be saved.
 * @return the modified command that should be run
 */

catch: 
null
block: 
TaskLog
/** 
 * Wrap a command in a shell to capture stdout and stderr to files. If the tailLength is 0, the entire output will be saved.
 * @param cmd The command and the arguments that should be run
 * @param stdoutFilename The filename that stdout should be saved to
 * @param stderrFilename The filename that stderr should be saved to
 * @param tailLength The length of the tail to be saved.
 * @return the modified command that should be run
 */
public static List<String> captureOutAndError(List<String> cmd,File stdoutFilename,File stderrFilename,long tailLength) throws IOException {
  return captureOutAndError(null,cmd,stdoutFilename,stderrFilename,tailLength);
}

ID 1052=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLog#captureOutAndError(List<java.lang.String>, List<java.lang.String>, java.io.File, java.io.File, long)
Rmethod: org.apache.hama.bsp.TaskLog#addCommand(List<java.lang.String>, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Wrap a command in a shell to capture stdout and stderr to files. Setup commands such as setting memory limit can be passed which will be executed before exec. If the tailLength is 0, the entire output will be saved.
 * @param setup The setup commands for the execed process.
 * @param cmd The command and the arguments that should be run
 * @param stdoutFilename The filename that stdout should be saved to
 * @param stderrFilename The filename that stderr should be saved to
 * @param tailLength The length of the tail to be saved.
 * @return the modified command that should be run
 */

catch: 
null
block: 
TaskLog
/** 
 * Wrap a command in a shell to capture stdout and stderr to files. Setup commands such as setting memory limit can be passed which will be executed before exec. If the tailLength is 0, the entire output will be saved.
 * @param setup The setup commands for the execed process.
 * @param cmd The command and the arguments that should be run
 * @param stdoutFilename The filename that stdout should be saved to
 * @param stderrFilename The filename that stderr should be saved to
 * @param tailLength The length of the tail to be saved.
 * @return the modified command that should be run
 */
public static List<String> captureOutAndError(List<String> setup,List<String> cmd,File stdoutFilename,File stderrFilename,long tailLength) throws IOException {
  String stdout=FileUtil.makeShellPath(stdoutFilename);
  String stderr=FileUtil.makeShellPath(stderrFilename);
  List<String> result=new ArrayList<String>(3);
  result.add(bashCommand);
  result.add("-c");
  StringBuffer mergedCmd=new StringBuffer();
  if (setup != null && setup.size() > 0) {
    mergedCmd.append(addCommand(setup,false));
    mergedCmd.append(";");
  }
  if (tailLength > 0) {
    mergedCmd.append("(");
  }
 else {
    mergedCmd.append("exec ");
  }
  mergedCmd.append(addCommand(cmd,true));
  mergedCmd.append(" < /dev/null ");
  if (tailLength > 0) {
    mergedCmd.append(" | ");
    mergedCmd.append(tailCommand);
    mergedCmd.append(" -c ");
    mergedCmd.append(tailLength);
    mergedCmd.append(" > ");
    mergedCmd.append(stdout);
    mergedCmd.append(" ; exit $PIPESTATUS ) 2>&1 | ");
    mergedCmd.append(tailCommand);
    mergedCmd.append(" -c ");
    mergedCmd.append(tailLength);
    mergedCmd.append(" > ");
    mergedCmd.append(stderr);
    mergedCmd.append(" ; exit $PIPESTATUS");
  }
 else {
    mergedCmd.append(" 1> ");
    mergedCmd.append(stdout);
    mergedCmd.append(" 2> ");
    mergedCmd.append(stderr);
  }
  result.add(mergedCmd.toString());
  return result;
}

ID 1053=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLog#captureOutAndErrorTee(List<java.lang.String>, List<java.lang.String>, java.io.File, java.io.File, long)
Rmethod: org.apache.hama.bsp.TaskLog#addCommand(List<java.lang.String>, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskLog
public static List<String> captureOutAndErrorTee(List<String> setup,List<String> cmd,File stdoutFilename,File stderrFilename,long tailLength) throws IOException {
  String stdout=FileUtil.makeShellPath(stdoutFilename);
  List<String> result=new ArrayList<String>(3);
  result.add(bashCommand);
  result.add("-c");
  StringBuilder mergedCmd=new StringBuilder();
  mergedCmd.append(addCommand(cmd,true));
  mergedCmd.append(" 2>&1 | tee ").append(stdout);
  result.add(mergedCmd.toString());
  return result;
}

ID 1054=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#quotedWrite(java.io.OutputStream, byte[], int, int)
Rmethod: java.io.OutputStream#write(byte[], int, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskLogServlet
private static void quotedWrite(OutputStream out,byte[] data,int pOffset,int length) throws IOException {
  int offset=pOffset;
  int end=offset + length;
  while (offset < end) {
    int next=findFirstQuotable(data,offset,end);
    out.write(data,offset,next - offset);
    offset=next;
    if (offset < end) {
switch (data[offset]) {
case '<':
        out.write("&lt;".getBytes());
      break;
case '>':
    out.write("&gt;".getBytes());
  break;
case '&':
out.write("&amp;".getBytes());
break;
default :
out.write(data[offset]);
break;
}
offset+=1;
}
}
}

ID 1055=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#quotedWrite(java.io.OutputStream, byte[], int, int)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskLogServlet
private static void quotedWrite(OutputStream out,byte[] data,int pOffset,int length) throws IOException {
  int offset=pOffset;
  int end=offset + length;
  while (offset < end) {
    int next=findFirstQuotable(data,offset,end);
    out.write(data,offset,next - offset);
    offset=next;
    if (offset < end) {
switch (data[offset]) {
case '<':
        out.write("&lt;".getBytes());
      break;
case '>':
    out.write("&gt;".getBytes());
  break;
case '&':
out.write("&amp;".getBytes());
break;
default :
out.write(data[offset]);
break;
}
offset+=1;
}
}
}

ID 1056=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#quotedWrite(java.io.OutputStream, byte[], int, int)
Rmethod: java.io.OutputStream#write(int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskLogServlet
private static void quotedWrite(OutputStream out,byte[] data,int pOffset,int length) throws IOException {
  int offset=pOffset;
  int end=offset + length;
  while (offset < end) {
    int next=findFirstQuotable(data,offset,end);
    out.write(data,offset,next - offset);
    offset=next;
    if (offset < end) {
switch (data[offset]) {
case '<':
        out.write("&lt;".getBytes());
      break;
case '>':
    out.write("&gt;".getBytes());
  break;
case '&':
out.write("&amp;".getBytes());
break;
default :
out.write(data[offset]);
break;
}
offset+=1;
}
}
}

ID 1057=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#printTaskLog(HttpServletResponse, java.io.OutputStream, TaskAttemptID, long, long, boolean, TaskLog.LogName, boolean)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskLogServlet
private static void printTaskLog(HttpServletResponse response,OutputStream out,TaskAttemptID taskId,long start,long end,boolean plainText,TaskLog.LogName filter,boolean isCleanup) throws IOException {
  if (!plainText) {
    out.write(("<br><b><u>" + filter + " logs</u></b><br>\n"+ "<pre>\n").getBytes());
  }
  try {
    InputStream taskLogReader=new TaskLog.Reader(taskId,filter,start,end);
    byte[] b=new byte[65536];
    int result;
    while (true) {
      result=taskLogReader.read(b);
      if (result > 0) {
        if (plainText) {
          out.write(b,0,result);
        }
 else {
          quotedWrite(out,b,0,result);
        }
      }
 else {
        break;
      }
    }
    taskLogReader.close();
    if (!plainText) {
      out.write("</pre></td></tr></table><hr><br>\n".getBytes());
    }
  }
 catch (  IOException ioe) {
    if (filter == TaskLog.LogName.DEBUGOUT) {
      if (!plainText) {
        out.write("</pre><hr><br>\n".getBytes());
      }
    }
 else {
      response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
      out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
    }
  }
}

ID 1058=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#printTaskLog(HttpServletResponse, java.io.OutputStream, TaskAttemptID, long, long, boolean, TaskLog.LogName, boolean)
Rmethod: java.io.InputStream#read(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  if (filter == TaskLog.LogName.DEBUGOUT) {
    if (!plainText) {
      out.write("</pre><hr><br>\n".getBytes());
    }
  }
 else {
    response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
    out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
  }
}

block: 
TaskLogServlet
private static void printTaskLog(HttpServletResponse response,OutputStream out,TaskAttemptID taskId,long start,long end,boolean plainText,TaskLog.LogName filter,boolean isCleanup) throws IOException {
  if (!plainText) {
    out.write(("<br><b><u>" + filter + " logs</u></b><br>\n"+ "<pre>\n").getBytes());
  }
  try {
    InputStream taskLogReader=new TaskLog.Reader(taskId,filter,start,end);
    byte[] b=new byte[65536];
    int result;
    while (true) {
      result=taskLogReader.read(b);
      if (result > 0) {
        if (plainText) {
          out.write(b,0,result);
        }
 else {
          quotedWrite(out,b,0,result);
        }
      }
 else {
        break;
      }
    }
    taskLogReader.close();
    if (!plainText) {
      out.write("</pre></td></tr></table><hr><br>\n".getBytes());
    }
  }
 catch (  IOException ioe) {
    if (filter == TaskLog.LogName.DEBUGOUT) {
      if (!plainText) {
        out.write("</pre><hr><br>\n".getBytes());
      }
    }
 else {
      response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
      out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
    }
  }
}

ID 1059=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#printTaskLog(HttpServletResponse, java.io.OutputStream, TaskAttemptID, long, long, boolean, TaskLog.LogName, boolean)
Rmethod: java.io.OutputStream#write(byte[], int, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  if (filter == TaskLog.LogName.DEBUGOUT) {
    if (!plainText) {
      out.write("</pre><hr><br>\n".getBytes());
    }
  }
 else {
    response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
    out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
  }
}

block: 
TaskLogServlet
private static void printTaskLog(HttpServletResponse response,OutputStream out,TaskAttemptID taskId,long start,long end,boolean plainText,TaskLog.LogName filter,boolean isCleanup) throws IOException {
  if (!plainText) {
    out.write(("<br><b><u>" + filter + " logs</u></b><br>\n"+ "<pre>\n").getBytes());
  }
  try {
    InputStream taskLogReader=new TaskLog.Reader(taskId,filter,start,end);
    byte[] b=new byte[65536];
    int result;
    while (true) {
      result=taskLogReader.read(b);
      if (result > 0) {
        if (plainText) {
          out.write(b,0,result);
        }
 else {
          quotedWrite(out,b,0,result);
        }
      }
 else {
        break;
      }
    }
    taskLogReader.close();
    if (!plainText) {
      out.write("</pre></td></tr></table><hr><br>\n".getBytes());
    }
  }
 catch (  IOException ioe) {
    if (filter == TaskLog.LogName.DEBUGOUT) {
      if (!plainText) {
        out.write("</pre><hr><br>\n".getBytes());
      }
    }
 else {
      response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
      out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
    }
  }
}

ID 1060=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#printTaskLog(HttpServletResponse, java.io.OutputStream, TaskAttemptID, long, long, boolean, TaskLog.LogName, boolean)
Rmethod: org.apache.hama.bsp.TaskLogServlet#quotedWrite(java.io.OutputStream, byte[], int, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  if (filter == TaskLog.LogName.DEBUGOUT) {
    if (!plainText) {
      out.write("</pre><hr><br>\n".getBytes());
    }
  }
 else {
    response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
    out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
  }
}

block: 
TaskLogServlet
private static void printTaskLog(HttpServletResponse response,OutputStream out,TaskAttemptID taskId,long start,long end,boolean plainText,TaskLog.LogName filter,boolean isCleanup) throws IOException {
  if (!plainText) {
    out.write(("<br><b><u>" + filter + " logs</u></b><br>\n"+ "<pre>\n").getBytes());
  }
  try {
    InputStream taskLogReader=new TaskLog.Reader(taskId,filter,start,end);
    byte[] b=new byte[65536];
    int result;
    while (true) {
      result=taskLogReader.read(b);
      if (result > 0) {
        if (plainText) {
          out.write(b,0,result);
        }
 else {
          quotedWrite(out,b,0,result);
        }
      }
 else {
        break;
      }
    }
    taskLogReader.close();
    if (!plainText) {
      out.write("</pre></td></tr></table><hr><br>\n".getBytes());
    }
  }
 catch (  IOException ioe) {
    if (filter == TaskLog.LogName.DEBUGOUT) {
      if (!plainText) {
        out.write("</pre><hr><br>\n".getBytes());
      }
    }
 else {
      response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
      out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
    }
  }
}

ID 1061=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#printTaskLog(HttpServletResponse, java.io.OutputStream, TaskAttemptID, long, long, boolean, TaskLog.LogName, boolean)
Rmethod: java.io.InputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  if (filter == TaskLog.LogName.DEBUGOUT) {
    if (!plainText) {
      out.write("</pre><hr><br>\n".getBytes());
    }
  }
 else {
    response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
    out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
  }
}

block: 
TaskLogServlet
private static void printTaskLog(HttpServletResponse response,OutputStream out,TaskAttemptID taskId,long start,long end,boolean plainText,TaskLog.LogName filter,boolean isCleanup) throws IOException {
  if (!plainText) {
    out.write(("<br><b><u>" + filter + " logs</u></b><br>\n"+ "<pre>\n").getBytes());
  }
  try {
    InputStream taskLogReader=new TaskLog.Reader(taskId,filter,start,end);
    byte[] b=new byte[65536];
    int result;
    while (true) {
      result=taskLogReader.read(b);
      if (result > 0) {
        if (plainText) {
          out.write(b,0,result);
        }
 else {
          quotedWrite(out,b,0,result);
        }
      }
 else {
        break;
      }
    }
    taskLogReader.close();
    if (!plainText) {
      out.write("</pre></td></tr></table><hr><br>\n".getBytes());
    }
  }
 catch (  IOException ioe) {
    if (filter == TaskLog.LogName.DEBUGOUT) {
      if (!plainText) {
        out.write("</pre><hr><br>\n".getBytes());
      }
    }
 else {
      response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
      out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
    }
  }
}

ID 1062=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#printTaskLog(HttpServletResponse, java.io.OutputStream, TaskAttemptID, long, long, boolean, TaskLog.LogName, boolean)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  if (filter == TaskLog.LogName.DEBUGOUT) {
    if (!plainText) {
      out.write("</pre><hr><br>\n".getBytes());
    }
  }
 else {
    response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
    out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
  }
}

block: 
TaskLogServlet
private static void printTaskLog(HttpServletResponse response,OutputStream out,TaskAttemptID taskId,long start,long end,boolean plainText,TaskLog.LogName filter,boolean isCleanup) throws IOException {
  if (!plainText) {
    out.write(("<br><b><u>" + filter + " logs</u></b><br>\n"+ "<pre>\n").getBytes());
  }
  try {
    InputStream taskLogReader=new TaskLog.Reader(taskId,filter,start,end);
    byte[] b=new byte[65536];
    int result;
    while (true) {
      result=taskLogReader.read(b);
      if (result > 0) {
        if (plainText) {
          out.write(b,0,result);
        }
 else {
          quotedWrite(out,b,0,result);
        }
      }
 else {
        break;
      }
    }
    taskLogReader.close();
    if (!plainText) {
      out.write("</pre></td></tr></table><hr><br>\n".getBytes());
    }
  }
 catch (  IOException ioe) {
    if (filter == TaskLog.LogName.DEBUGOUT) {
      if (!plainText) {
        out.write("</pre><hr><br>\n".getBytes());
      }
    }
 else {
      response.sendError(HttpServletResponse.SC_GONE,"Failed to retrieve " + filter + " log for task: "+ taskId);
      out.write(("TaskLogServlet exception:\n" + StringUtils.stringifyException(ioe) + "\n").getBytes());
    }
  }
}

ID 1063=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.lang.Long#valueOf(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Get the logs via http.
 */

catch: 
null
block: 
TaskLogServlet
/** 
 * Get the logs via http.
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  long start=0;
  long end=-1;
  boolean plainText=false;
  TaskLog.LogName filter=null;
  boolean isCleanup=false;
  String taskIdStr=request.getParameter("taskid");
  if (taskIdStr == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Argument taskid is required");
    return;
  }
  TaskAttemptID taskId=TaskAttemptID.forName(taskIdStr);
  String logFilter=request.getParameter("filter");
  if (logFilter != null) {
    try {
      filter=Enum.valueOf(TaskLog.LogName.class,logFilter.toUpperCase());
    }
 catch (    IllegalArgumentException iae) {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Illegal value for filter: " + logFilter);
      return;
    }
  }
  String sLogOff=request.getParameter("start");
  if (sLogOff != null) {
    start=Long.valueOf(sLogOff);
  }
  String sLogEnd=request.getParameter("end");
  if (sLogEnd != null) {
    end=Long.valueOf(sLogEnd);
  }
  String sPlainText=request.getParameter("plaintext");
  if (sPlainText != null) {
    plainText=Boolean.valueOf(sPlainText);
  }
  String sCleanup=request.getParameter("cleanup");
  if (sCleanup != null) {
    isCleanup=Boolean.valueOf(sCleanup);
  }
  OutputStream out=response.getOutputStream();
  if (!plainText) {
    out.write(("<html>\n" + "<title>Task Logs: '" + taskId + "'</title>\n"+ "<body>\n"+ "<h1>Task Logs: '"+ taskId+ "'</h1><br>\n").getBytes());
    if (filter == null) {
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDOUT,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDERR,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.SYSLOG,isCleanup);
      if (haveTaskLog(taskId,TaskLog.LogName.DEBUGOUT)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.DEBUGOUT,isCleanup);
      }
      if (haveTaskLog(taskId,TaskLog.LogName.PROFILE)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.PROFILE,isCleanup);
      }
    }
 else {
      printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
    }
    out.write("</body></html>\n".getBytes());
    out.close();
  }
 else   if (filter == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"You must supply a value for `filter' (STDOUT, STDERR, or SYSLOG) if you set plainText = true");
  }
 else {
    printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
  }
}

ID 1064=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.io.OutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get the logs via http.
 */

catch: 
null
block: 
TaskLogServlet
/** 
 * Get the logs via http.
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  long start=0;
  long end=-1;
  boolean plainText=false;
  TaskLog.LogName filter=null;
  boolean isCleanup=false;
  String taskIdStr=request.getParameter("taskid");
  if (taskIdStr == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Argument taskid is required");
    return;
  }
  TaskAttemptID taskId=TaskAttemptID.forName(taskIdStr);
  String logFilter=request.getParameter("filter");
  if (logFilter != null) {
    try {
      filter=Enum.valueOf(TaskLog.LogName.class,logFilter.toUpperCase());
    }
 catch (    IllegalArgumentException iae) {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Illegal value for filter: " + logFilter);
      return;
    }
  }
  String sLogOff=request.getParameter("start");
  if (sLogOff != null) {
    start=Long.valueOf(sLogOff);
  }
  String sLogEnd=request.getParameter("end");
  if (sLogEnd != null) {
    end=Long.valueOf(sLogEnd);
  }
  String sPlainText=request.getParameter("plaintext");
  if (sPlainText != null) {
    plainText=Boolean.valueOf(sPlainText);
  }
  String sCleanup=request.getParameter("cleanup");
  if (sCleanup != null) {
    isCleanup=Boolean.valueOf(sCleanup);
  }
  OutputStream out=response.getOutputStream();
  if (!plainText) {
    out.write(("<html>\n" + "<title>Task Logs: '" + taskId + "'</title>\n"+ "<body>\n"+ "<h1>Task Logs: '"+ taskId+ "'</h1><br>\n").getBytes());
    if (filter == null) {
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDOUT,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDERR,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.SYSLOG,isCleanup);
      if (haveTaskLog(taskId,TaskLog.LogName.DEBUGOUT)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.DEBUGOUT,isCleanup);
      }
      if (haveTaskLog(taskId,TaskLog.LogName.PROFILE)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.PROFILE,isCleanup);
      }
    }
 else {
      printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
    }
    out.write("</body></html>\n".getBytes());
    out.close();
  }
 else   if (filter == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"You must supply a value for `filter' (STDOUT, STDERR, or SYSLOG) if you set plainText = true");
  }
 else {
    printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
  }
}

ID 1065=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: org.apache.hama.bsp.TaskLogServlet#printTaskLog(HttpServletResponse, java.io.OutputStream, TaskAttemptID, long, long, boolean, TaskLog.LogName, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get the logs via http.
 */

catch: 
null
block: 
TaskLogServlet
/** 
 * Get the logs via http.
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  long start=0;
  long end=-1;
  boolean plainText=false;
  TaskLog.LogName filter=null;
  boolean isCleanup=false;
  String taskIdStr=request.getParameter("taskid");
  if (taskIdStr == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Argument taskid is required");
    return;
  }
  TaskAttemptID taskId=TaskAttemptID.forName(taskIdStr);
  String logFilter=request.getParameter("filter");
  if (logFilter != null) {
    try {
      filter=Enum.valueOf(TaskLog.LogName.class,logFilter.toUpperCase());
    }
 catch (    IllegalArgumentException iae) {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Illegal value for filter: " + logFilter);
      return;
    }
  }
  String sLogOff=request.getParameter("start");
  if (sLogOff != null) {
    start=Long.valueOf(sLogOff);
  }
  String sLogEnd=request.getParameter("end");
  if (sLogEnd != null) {
    end=Long.valueOf(sLogEnd);
  }
  String sPlainText=request.getParameter("plaintext");
  if (sPlainText != null) {
    plainText=Boolean.valueOf(sPlainText);
  }
  String sCleanup=request.getParameter("cleanup");
  if (sCleanup != null) {
    isCleanup=Boolean.valueOf(sCleanup);
  }
  OutputStream out=response.getOutputStream();
  if (!plainText) {
    out.write(("<html>\n" + "<title>Task Logs: '" + taskId + "'</title>\n"+ "<body>\n"+ "<h1>Task Logs: '"+ taskId+ "'</h1><br>\n").getBytes());
    if (filter == null) {
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDOUT,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDERR,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.SYSLOG,isCleanup);
      if (haveTaskLog(taskId,TaskLog.LogName.DEBUGOUT)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.DEBUGOUT,isCleanup);
      }
      if (haveTaskLog(taskId,TaskLog.LogName.PROFILE)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.PROFILE,isCleanup);
      }
    }
 else {
      printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
    }
    out.write("</body></html>\n".getBytes());
    out.close();
  }
 else   if (filter == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"You must supply a value for `filter' (STDOUT, STDERR, or SYSLOG) if you set plainText = true");
  }
 else {
    printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
  }
}

ID 1066=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskLogServlet#doGet(HttpServletRequest, HttpServletResponse)
Rmethod: java.io.OutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Get the logs via http.
 */

catch: 
null
block: 
TaskLogServlet
/** 
 * Get the logs via http.
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  long start=0;
  long end=-1;
  boolean plainText=false;
  TaskLog.LogName filter=null;
  boolean isCleanup=false;
  String taskIdStr=request.getParameter("taskid");
  if (taskIdStr == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Argument taskid is required");
    return;
  }
  TaskAttemptID taskId=TaskAttemptID.forName(taskIdStr);
  String logFilter=request.getParameter("filter");
  if (logFilter != null) {
    try {
      filter=Enum.valueOf(TaskLog.LogName.class,logFilter.toUpperCase());
    }
 catch (    IllegalArgumentException iae) {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST,"Illegal value for filter: " + logFilter);
      return;
    }
  }
  String sLogOff=request.getParameter("start");
  if (sLogOff != null) {
    start=Long.valueOf(sLogOff);
  }
  String sLogEnd=request.getParameter("end");
  if (sLogEnd != null) {
    end=Long.valueOf(sLogEnd);
  }
  String sPlainText=request.getParameter("plaintext");
  if (sPlainText != null) {
    plainText=Boolean.valueOf(sPlainText);
  }
  String sCleanup=request.getParameter("cleanup");
  if (sCleanup != null) {
    isCleanup=Boolean.valueOf(sCleanup);
  }
  OutputStream out=response.getOutputStream();
  if (!plainText) {
    out.write(("<html>\n" + "<title>Task Logs: '" + taskId + "'</title>\n"+ "<body>\n"+ "<h1>Task Logs: '"+ taskId+ "'</h1><br>\n").getBytes());
    if (filter == null) {
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDOUT,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.STDERR,isCleanup);
      printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.SYSLOG,isCleanup);
      if (haveTaskLog(taskId,TaskLog.LogName.DEBUGOUT)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.DEBUGOUT,isCleanup);
      }
      if (haveTaskLog(taskId,TaskLog.LogName.PROFILE)) {
        printTaskLog(response,out,taskId,start,end,plainText,TaskLog.LogName.PROFILE,isCleanup);
      }
    }
 else {
      printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
    }
    out.write("</body></html>\n".getBytes());
    out.close();
  }
 else   if (filter == null) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST,"You must supply a value for `filter' (STDOUT, STDERR, or SYSLOG) if you set plainText = true");
  }
 else {
    printTaskLog(response,out,taskId,start,end,plainText,filter,isCleanup);
  }
}

ID 1067=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BspChildRunner#join()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
BspChildRunner
void join() throws InterruptedException, ExecutionException {
  this.future.get().get();
}

ID 1068=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BspChildRunner#join()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
null
block: 
BspChildRunner
void join() throws InterruptedException, ExecutionException {
  this.future.get().get();
}

ID 1069=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BspChildRunner#call()
Rmethod: java.lang.ProcessBuilder#start()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Error when executing BSPPeer process.",ioe);
}

block: 
BspChildRunner
@Override public Object call() throws Exception {
  final boolean consoleRedirect=bspJob.getConfiguration().getBoolean("hama.child.redirect.log.console",false);
  ProcessBuilder builder=new ProcessBuilder(commands);
  builder.directory(workDir);
  try {
    bspProcess=builder.start();
    errorLog=new Thread(){
      @Override public void run(){
        logStream(bspProcess.getErrorStream(),consoleRedirect ? LogType.CONSOLE : LogType.ERROR);
      }
    }
;
    errorLog.start();
    infoLog=new Thread(){
      @Override public void run(){
        logStream(bspProcess.getInputStream(),consoleRedirect ? LogType.CONSOLE : LogType.STDOUT);
      }
    }
;
    infoLog.start();
    int exit_code=bspProcess.waitFor();
    if (!bspKilled && exit_code != 0) {
      throw new IOException("BSP task process exit with nonzero status of " + exit_code + ". command = "+ commands);
    }
  }
 catch (  InterruptedException e) {
    LOG.warn("Thread is interrupted when execeuting BSP process.",e);
  }
catch (  IOException ioe) {
    LOG.error("Error when executing BSPPeer process.",ioe);
  }
 finally {
    killBsp();
  }
  return null;
}

ID 1070=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.BspChildRunner#call()
Rmethod: java.lang.Process#waitFor()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.warn("Thread is interrupted when execeuting BSP process.",e);
}

block: 
BspChildRunner
@Override public Object call() throws Exception {
  final boolean consoleRedirect=bspJob.getConfiguration().getBoolean("hama.child.redirect.log.console",false);
  ProcessBuilder builder=new ProcessBuilder(commands);
  builder.directory(workDir);
  try {
    bspProcess=builder.start();
    errorLog=new Thread(){
      @Override public void run(){
        logStream(bspProcess.getErrorStream(),consoleRedirect ? LogType.CONSOLE : LogType.ERROR);
      }
    }
;
    errorLog.start();
    infoLog=new Thread(){
      @Override public void run(){
        logStream(bspProcess.getInputStream(),consoleRedirect ? LogType.CONSOLE : LogType.STDOUT);
      }
    }
;
    infoLog.start();
    int exit_code=bspProcess.waitFor();
    if (!bspKilled && exit_code != 0) {
      throw new IOException("BSP task process exit with nonzero status of " + exit_code + ". command = "+ commands);
    }
  }
 catch (  InterruptedException e) {
    LOG.warn("Thread is interrupted when execeuting BSP process.",e);
  }
catch (  IOException ioe) {
    LOG.error("Error when executing BSPPeer process.",ioe);
  }
 finally {
    killBsp();
  }
  return null;
}

ID 1071=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#run()
Rmethod: org.apache.hama.bsp.BspChildRunner#join()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Build working environment and launch BSPPeer processes.
 */

catch: 
catch (InterruptedException ie) {
  LOG.error("BSPPeer child process is interrupted.",ie);
}

block: 
TaskRunner
/** 
 * Build working environment and launch BSPPeer processes.
 */
@Override public void run(){
  File workDir=createWorkDirectory();
  logDir=createLogDirectory();
  String classPath=assembleClasspath(bspJob,workDir);
  LOG.debug("Spawned child's classpath " + classPath);
  List<String> bspArgs=buildJvmArgs(bspJob,classPath,GroomServer.BSPPeerChild.class);
  BspChildRunner bspPeer=new BspChildRunner(bspArgs,workDir);
  bspPeer.start();
  try {
    bspPeer.join();
  }
 catch (  InterruptedException ie) {
    LOG.error("BSPPeer child process is interrupted.",ie);
  }
catch (  ExecutionException ee) {
    LOG.error("Failure occurs when retrieving tasks result.",ee);
  }
 finally {
    killBsp();
  }
  LOG.debug("Finishes executing BSPPeer child process.");
}

ID 1072=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#run()
Rmethod: org.apache.hama.bsp.BspChildRunner#join()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: /** 
 * Build working environment and launch BSPPeer processes.
 */

catch: 
catch (ExecutionException ee) {
  LOG.error("Failure occurs when retrieving tasks result.",ee);
}

block: 
TaskRunner
/** 
 * Build working environment and launch BSPPeer processes.
 */
@Override public void run(){
  File workDir=createWorkDirectory();
  logDir=createLogDirectory();
  String classPath=assembleClasspath(bspJob,workDir);
  LOG.debug("Spawned child's classpath " + classPath);
  List<String> bspArgs=buildJvmArgs(bspJob,classPath,GroomServer.BSPPeerChild.class);
  BspChildRunner bspPeer=new BspChildRunner(bspArgs,workDir);
  bspPeer.start();
  try {
    bspPeer.join();
  }
 catch (  InterruptedException ie) {
    LOG.error("BSPPeer child process is interrupted.",ie);
  }
catch (  ExecutionException ee) {
    LOG.error("Failure occurs when retrieving tasks result.",ee);
  }
 finally {
    killBsp();
  }
  LOG.debug("Finishes executing BSPPeer child process.");
}

ID 1073=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#logStream(java.io.InputStream, org.apache.hama.bsp.TaskRunner.LogType)
Rmethod: java.io.FileWriter#FileWriter(java.io.File)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */

catch: 
catch (IOException e) {
  if (!bspKilled) {
    LOG.warn(task.getTaskID() + " Error reading child output",e);
  }
}

block: 
TaskRunner
/** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */
private void logStream(InputStream input,LogType type){
  if (type == LogType.CONSOLE) {
    try {
      IOUtils.copyBytes(input,System.out,bspJob.getConfiguration());
    }
 catch (    IOException e) {
    }
    return;
  }
  File taskLogFile=new File(logDir,task.getTaskAttemptId() + getFileEndingForType(type));
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(taskLogFile));
    BufferedReader in=new BufferedReader(new InputStreamReader(input));
    String line;
    while ((line=in.readLine()) != null) {
      writer.write(line);
      writer.newLine();
    }
  }
 catch (  IOException e) {
    if (!bspKilled) {
      LOG.warn(task.getTaskID() + " Error reading child output",e);
    }
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing child output",e);
    }
    try {
      writer.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing log file",e);
    }
  }
}

ID 1074=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#logStream(java.io.InputStream, org.apache.hama.bsp.TaskRunner.LogType)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */

catch: 
catch (IOException e) {
  if (!bspKilled) {
    LOG.warn(task.getTaskID() + " Error reading child output",e);
  }
}

block: 
TaskRunner
/** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */
private void logStream(InputStream input,LogType type){
  if (type == LogType.CONSOLE) {
    try {
      IOUtils.copyBytes(input,System.out,bspJob.getConfiguration());
    }
 catch (    IOException e) {
    }
    return;
  }
  File taskLogFile=new File(logDir,task.getTaskAttemptId() + getFileEndingForType(type));
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(taskLogFile));
    BufferedReader in=new BufferedReader(new InputStreamReader(input));
    String line;
    while ((line=in.readLine()) != null) {
      writer.write(line);
      writer.newLine();
    }
  }
 catch (  IOException e) {
    if (!bspKilled) {
      LOG.warn(task.getTaskID() + " Error reading child output",e);
    }
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing child output",e);
    }
    try {
      writer.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing log file",e);
    }
  }
}

ID 1075=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#logStream(java.io.InputStream, org.apache.hama.bsp.TaskRunner.LogType)
Rmethod: java.io.Writer#write(java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */

catch: 
catch (IOException e) {
  if (!bspKilled) {
    LOG.warn(task.getTaskID() + " Error reading child output",e);
  }
}

block: 
TaskRunner
/** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */
private void logStream(InputStream input,LogType type){
  if (type == LogType.CONSOLE) {
    try {
      IOUtils.copyBytes(input,System.out,bspJob.getConfiguration());
    }
 catch (    IOException e) {
    }
    return;
  }
  File taskLogFile=new File(logDir,task.getTaskAttemptId() + getFileEndingForType(type));
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(taskLogFile));
    BufferedReader in=new BufferedReader(new InputStreamReader(input));
    String line;
    while ((line=in.readLine()) != null) {
      writer.write(line);
      writer.newLine();
    }
  }
 catch (  IOException e) {
    if (!bspKilled) {
      LOG.warn(task.getTaskID() + " Error reading child output",e);
    }
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing child output",e);
    }
    try {
      writer.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing log file",e);
    }
  }
}

ID 1076=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#logStream(java.io.InputStream, org.apache.hama.bsp.TaskRunner.LogType)
Rmethod: java.io.BufferedWriter#newLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */

catch: 
catch (IOException e) {
  if (!bspKilled) {
    LOG.warn(task.getTaskID() + " Error reading child output",e);
  }
}

block: 
TaskRunner
/** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */
private void logStream(InputStream input,LogType type){
  if (type == LogType.CONSOLE) {
    try {
      IOUtils.copyBytes(input,System.out,bspJob.getConfiguration());
    }
 catch (    IOException e) {
    }
    return;
  }
  File taskLogFile=new File(logDir,task.getTaskAttemptId() + getFileEndingForType(type));
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(taskLogFile));
    BufferedReader in=new BufferedReader(new InputStreamReader(input));
    String line;
    while ((line=in.readLine()) != null) {
      writer.write(line);
      writer.newLine();
    }
  }
 catch (  IOException e) {
    if (!bspKilled) {
      LOG.warn(task.getTaskID() + " Error reading child output",e);
    }
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing child output",e);
    }
    try {
      writer.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing log file",e);
    }
  }
}

ID 1077=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#logStream(java.io.InputStream, org.apache.hama.bsp.TaskRunner.LogType)
Rmethod: java.io.InputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */

catch: 
catch (IOException e) {
  LOG.warn(task.getTaskID() + " Error closing child output",e);
}

block: 
TaskRunner
/** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */
private void logStream(InputStream input,LogType type){
  if (type == LogType.CONSOLE) {
    try {
      IOUtils.copyBytes(input,System.out,bspJob.getConfiguration());
    }
 catch (    IOException e) {
    }
    return;
  }
  File taskLogFile=new File(logDir,task.getTaskAttemptId() + getFileEndingForType(type));
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(taskLogFile));
    BufferedReader in=new BufferedReader(new InputStreamReader(input));
    String line;
    while ((line=in.readLine()) != null) {
      writer.write(line);
      writer.newLine();
    }
  }
 catch (  IOException e) {
    if (!bspKilled) {
      LOG.warn(task.getTaskID() + " Error reading child output",e);
    }
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing child output",e);
    }
    try {
      writer.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing log file",e);
    }
  }
}

ID 1078=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskRunner#logStream(java.io.InputStream, org.apache.hama.bsp.TaskRunner.LogType)
Rmethod: java.io.BufferedWriter#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */

catch: 
catch (IOException e) {
  LOG.warn(task.getTaskID() + " Error closing log file",e);
}

block: 
TaskRunner
/** 
 * Log process's stream.
 * @param input stream to be logged.
 * @param stdout type of the log
 */
private void logStream(InputStream input,LogType type){
  if (type == LogType.CONSOLE) {
    try {
      IOUtils.copyBytes(input,System.out,bspJob.getConfiguration());
    }
 catch (    IOException e) {
    }
    return;
  }
  File taskLogFile=new File(logDir,task.getTaskAttemptId() + getFileEndingForType(type));
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(taskLogFile));
    BufferedReader in=new BufferedReader(new InputStreamReader(input));
    String line;
    while ((line=in.readLine()) != null) {
      writer.write(line);
      writer.newLine();
    }
  }
 catch (  IOException e) {
    if (!bspKilled) {
      LOG.warn(task.getTaskID() + " Error reading child output",e);
    }
  }
 finally {
    try {
      input.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing child output",e);
    }
    try {
      writer.close();
    }
 catch (    IOException e) {
      LOG.warn(task.getTaskID() + " Error closing log file",e);
    }
  }
}

ID 1079=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readFloat()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskStatus
@Override public void readFields(DataInput in) throws IOException {
  this.jobId.readFields(in);
  this.taskId.readFields(in);
  this.progress=in.readFloat();
  this.runState=WritableUtils.readEnum(in,State.class);
  this.stateString=Text.readString(in);
  this.phase=WritableUtils.readEnum(in,Phase.class);
  this.startTime=in.readLong();
  this.finishTime=in.readLong();
  counters=new Counters();
  this.counters.readFields(in);
}

ID 1080=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskStatus#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskStatus
@Override public void readFields(DataInput in) throws IOException {
  this.jobId.readFields(in);
  this.taskId.readFields(in);
  this.progress=in.readFloat();
  this.runState=WritableUtils.readEnum(in,State.class);
  this.stateString=Text.readString(in);
  this.phase=WritableUtils.readEnum(in,Phase.class);
  this.startTime=in.readLong();
  this.finishTime=in.readLong();
  counters=new Counters();
  this.counters.readFields(in);
}

ID 1081=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeFloat(float)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskStatus
@Override public void write(DataOutput out) throws IOException {
  jobId.write(out);
  taskId.write(out);
  out.writeFloat(progress);
  WritableUtils.writeEnum(out,runState);
  Text.writeString(out,stateString);
  WritableUtils.writeEnum(out,phase);
  out.writeLong(startTime);
  out.writeLong(finishTime);
  counters.write(out);
}

ID 1082=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TaskStatus#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TaskStatus
@Override public void write(DataOutput out) throws IOException {
  jobId.write(out);
  taskId.write(out);
  out.writeFloat(progress);
  WritableUtils.writeEnum(out,runState);
  Text.writeString(out,stateString);
  WritableUtils.writeEnum(out,phase);
  out.writeLong(startTime);
  out.writeLong(finishTime);
  counters.write(out);
}

ID 1083=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestServer#call(Class<?>, Writable, long)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
}

block: 
TestServer
@Override public Writable call(Class<?> protocol,Writable param,long receiveTime) throws IOException {
  if (sleep) {
    try {
      Thread.sleep(RANDOM.nextInt(2 * PING_INTERVAL));
    }
 catch (    InterruptedException e) {
    }
  }
  return param;
}

ID 1084=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncIPC#testSerial()
Rmethod: org.apache.hama.ipc.TestAsyncIPC#testSerial(int, boolean, int, int, int)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncIPC
public void testSerial() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  testSerial(3,false,2,5,100);
}

ID 1085=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncIPC#testSerial(int, boolean, int, int, int)
Rmethod: org.apache.hama.ipc.TestServer#TestServer(int, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncIPC
public void testSerial(int handlerCount,boolean handlerSleep,int clientCount,int callerCount,int callCount) throws Exception {
  AsyncServer server=new TestServer(handlerCount,handlerSleep);
  InetSocketAddress addr=server.getAddress();
  server.start();
  AsyncClient[] clients=new AsyncClient[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new AsyncClient(LongWritable.class,conf);
  }
  SerialCaller[] callers=new SerialCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new SerialCaller(clients[i % clientCount],addr,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  server.stop();
}

ID 1086=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncIPC#testSerial(int, boolean, int, int, int)
Rmethod: java.lang.Thread#join()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncIPC
public void testSerial(int handlerCount,boolean handlerSleep,int clientCount,int callerCount,int callCount) throws Exception {
  AsyncServer server=new TestServer(handlerCount,handlerSleep);
  InetSocketAddress addr=server.getAddress();
  server.start();
  AsyncClient[] clients=new AsyncClient[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new AsyncClient(LongWritable.class,conf);
  }
  SerialCaller[] callers=new SerialCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new SerialCaller(clients[i % clientCount],addr,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  server.stop();
}

ID 1087=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncIPC#testParallel()
Rmethod: org.apache.hama.ipc.TestAsyncIPC#testParallel(int, boolean, int, int, int, int, int)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncIPC
public void testParallel() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  testParallel(10,false,2,4,2,4,100);
}

ID 1088=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncIPC#testParallel(int, boolean, int, int, int, int, int)
Rmethod: org.apache.hama.ipc.TestServer#TestServer(int, boolean)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncIPC
public void testParallel(int handlerCount,boolean handlerSleep,int serverCount,int addressCount,int clientCount,int callerCount,int callCount) throws Exception {
  AsyncServer[] servers=new AsyncServer[serverCount];
  for (int i=0; i < serverCount; i++) {
    servers[i]=new TestServer(handlerCount,handlerSleep);
    servers[i].start();
  }
  InetSocketAddress[] addresses=new InetSocketAddress[addressCount];
  for (int i=0; i < addressCount; i++) {
    addresses[i]=servers[i % serverCount].address;
  }
  AsyncClient[] clients=new AsyncClient[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new AsyncClient(LongWritable.class,conf);
  }
  ParallelCaller[] callers=new ParallelCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new ParallelCaller(clients[i % clientCount],addresses,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  for (int i=0; i < serverCount; i++) {
    servers[i].stop();
  }
}

ID 1089=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncIPC#testParallel(int, boolean, int, int, int, int, int)
Rmethod: java.lang.Thread#join()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncIPC
public void testParallel(int handlerCount,boolean handlerSleep,int serverCount,int addressCount,int clientCount,int callerCount,int callCount) throws Exception {
  AsyncServer[] servers=new AsyncServer[serverCount];
  for (int i=0; i < serverCount; i++) {
    servers[i]=new TestServer(handlerCount,handlerSleep);
    servers[i].start();
  }
  InetSocketAddress[] addresses=new InetSocketAddress[addressCount];
  for (int i=0; i < addressCount; i++) {
    addresses[i]=servers[i % serverCount].address;
  }
  AsyncClient[] clients=new AsyncClient[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new AsyncClient(LongWritable.class,conf);
  }
  ParallelCaller[] callers=new ParallelCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new ParallelCaller(clients[i % clientCount],addresses,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  for (int i=0; i < serverCount; i++) {
    servers[i].stop();
  }
}

ID 1090=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#ping()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1091=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#echo(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1092=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#echo(java.lang.String[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1093=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#add(int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1094=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#add(int[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1095=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#error()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.debug("Caught " + e);
  caught=true;
}

block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1096=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#testServerGet()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1097=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1098=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#testCalls()
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public void testCalls() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  AsyncServer server=AsyncRPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)AsyncRPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  Exception e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])AsyncRPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=AsyncRPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1099=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestAsyncRPC#main(java.lang.String[])
Rmethod: org.apache.hama.ipc.TestAsyncRPC#testCalls()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestAsyncRPC
public static void main(String[] args) throws Exception {
  new TestAsyncRPC("test").testCalls();
}

ID 1100=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPMasterGroomServer#testSubmitJob()
Rmethod: org.apache.hama.bsp.TestBSPMasterGroomServer#checkOutput(FileSystem, Configuration, int)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPMasterGroomServer
public void testSubmitJob() throws Exception {
  BSPJob bsp=new BSPJob(configuration,org.apache.hama.examples.ClassSerializePrinting.class);
  bsp.setJobName("Test Serialize Printing");
  bsp.setBspClass(org.apache.hama.examples.ClassSerializePrinting.class);
  bsp.setOutputFormat(SequenceFileOutputFormat.class);
  bsp.setOutputKeyClass(IntWritable.class);
  bsp.setOutputValueClass(Text.class);
  bsp.setOutputPath(OUTPUT_PATH);
  bsp.setCompressionCodec(Bzip2Compressor.class);
  BSPJobClient jobClient=new BSPJobClient(configuration);
  configuration.setInt(Constants.ZOOKEEPER_SESSION_TIMEOUT,6000);
  ClusterStatus cluster=jobClient.getClusterStatus(false);
  assertEquals(this.numOfGroom,cluster.getGroomServers());
  bsp.setNumBspTask(2);
  FileSystem fileSys=FileSystem.get(configuration);
  if (bsp.waitForCompletion(true)) {
    checkOutput(fileSys,configuration,2);
  }
 else {
    fail();
  }
  LOG.info("Client finishes execution job.");
}

ID 1101=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPMessageBundle#testEmpty()
Rmethod: java.io.ByteArrayOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPMessageBundle
public void testEmpty() throws IOException {
  BSPMessageBundle<BytesWritable> bundle=new BSPMessageBundle<BytesWritable>();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  bundle.write(new DataOutputStream(baos));
  baos.close();
  BSPMessageBundle<BytesWritable> readBundle=new BSPMessageBundle<BytesWritable>();
  readBundle.readFields(new DataInputStream(new ByteArrayInputStream(baos.toByteArray())));
  assertEquals(0,readBundle.size());
}

ID 1102=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPMessageBundle#testSerializationDeserialization()
Rmethod: java.io.ByteArrayOutputStream#close()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPMessageBundle
public void testSerializationDeserialization() throws IOException {
  BSPMessageBundle<BytesWritable> bundle=new BSPMessageBundle<BytesWritable>();
  BytesWritable[] testMessages=new BytesWritable[16];
  for (int i=0; i < testMessages.length; ++i) {
    byte[] tag=new byte[1];
    tag[0]=(byte)i;
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    baos.write(i);
    baos.close();
    byte[] data=baos.toByteArray();
    BytesWritable msg=new BytesWritable();
    msg.set(data,0,data.length);
    testMessages[i]=msg;
    bundle.addMessage(testMessages[i]);
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  bundle.write(new DataOutputStream(baos));
  baos.close();
  BSPMessageBundle<BytesWritable> readBundle=new BSPMessageBundle<BytesWritable>();
  readBundle.readFields(new DataInputStream(new ByteArrayInputStream(baos.toByteArray())));
  int messageNumber=0;
  Iterator<BytesWritable> it=readBundle.iterator();
  while (it.hasNext()) {
    BytesWritable byteMessage=it.next();
    assertTrue(Arrays.equals(testMessages[messageNumber].getBytes(),byteMessage.getBytes()));
    ++messageNumber;
  }
  assertEquals(testMessages.length,messageNumber);
}

ID 1103=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPMessageBundle#testSerializationDeserialization()
Rmethod: java.io.ByteArrayOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPMessageBundle
public void testSerializationDeserialization() throws IOException {
  BSPMessageBundle<BytesWritable> bundle=new BSPMessageBundle<BytesWritable>();
  BytesWritable[] testMessages=new BytesWritable[16];
  for (int i=0; i < testMessages.length; ++i) {
    byte[] tag=new byte[1];
    tag[0]=(byte)i;
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    baos.write(i);
    baos.close();
    byte[] data=baos.toByteArray();
    BytesWritable msg=new BytesWritable();
    msg.set(data,0,data.length);
    testMessages[i]=msg;
    bundle.addMessage(testMessages[i]);
  }
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  bundle.write(new DataOutputStream(baos));
  baos.close();
  BSPMessageBundle<BytesWritable> readBundle=new BSPMessageBundle<BytesWritable>();
  readBundle.readFields(new DataInputStream(new ByteArrayInputStream(baos.toByteArray())));
  int messageNumber=0;
  Iterator<BytesWritable> it=readBundle.iterator();
  while (it.hasNext()) {
    BytesWritable byteMessage=it.next();
    assertTrue(Arrays.equals(testMessages[messageNumber].getBytes(),byteMessage.getBytes()));
    ++messageNumber;
  }
  assertEquals(testMessages.length,messageNumber);
}

ID 1104=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPProcessRunner#readStream(java.io.InputStream)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPProcessRunner
private static void readStream(InputStream input) throws IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(input));
  String line;
  while ((line=reader.readLine()) != null) {
    LOG.info(line);
  }
}

ID 1105=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPProcessRunner#getBSPExitCode()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error("Error while fetching exit status from BSPTask",e);
}

block: 
TestBSPProcessRunner
public int getBSPExitCode(){
  try {
    return this.future.get().get();
  }
 catch (  Exception e) {
    LOG.error("Error while fetching exit status from BSPTask",e);
  }
 finally {
  }
  return -1;
}

ID 1106=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPProcessRunner#getBSPExitCode()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error("Error while fetching exit status from BSPTask",e);
}

block: 
TestBSPProcessRunner
public int getBSPExitCode(){
  try {
    return this.future.get().get();
  }
 catch (  Exception e) {
    LOG.error("Error while fetching exit status from BSPTask",e);
  }
 finally {
  }
  return -1;
}

ID 1107=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPProcessRunner#call()
Rmethod: java.lang.ProcessBuilder#start()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error("Error getting exit code of child process",e);
}

block: 
TestBSPProcessRunner
@Override public Integer call() throws Exception {
  String SYSTEM_PATH_SEPARATOR=System.getProperty("path.separator");
  List<String> commands=new ArrayList<String>();
  String workDir=new File(".").getAbsolutePath();
  File jvm=new File(new File(System.getProperty("java.home"),"bin"),"java");
  commands.add(jvm.toString());
  StringBuffer classPath=new StringBuffer();
  classPath.append(System.getProperty("java.class.path"));
  classPath.append(SYSTEM_PATH_SEPARATOR);
  classPath.append(new File(workDir,"core/target/test-classes"));
  classPath.append(SYSTEM_PATH_SEPARATOR);
  classPath.append(workDir);
  commands.add("-classpath");
  commands.add(classPath.toString());
  commands.add(TestBSPProcessRunner.class.getName());
  LOG.info("starting process for failure case - " + testPoint);
  commands.add("" + testPoint);
  commands.add("" + testPort);
  LOG.info(commands.toString());
  ProcessBuilder builder=new ProcessBuilder(commands);
  try {
    bspTaskProcess=builder.start();
    errorLog=new Thread(){
      @Override public void run(){
        try {
          readStream(bspTaskProcess.getErrorStream());
        }
 catch (        Exception e) {
        }
      }
    }
;
    errorLog.start();
    infoLog=new Thread(){
      @Override public void run(){
        try {
          readStream(bspTaskProcess.getInputStream());
        }
 catch (        Exception e) {
        }
      }
    }
;
    infoLog.start();
    int exit_code=bspTaskProcess.waitFor();
    return exit_code;
  }
 catch (  Exception e) {
    LOG.error("Error getting exit code of child process",e);
  }
  return -1;
}

ID 1108=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPProcessRunner#call()
Rmethod: org.apache.hama.bsp.TestBSPProcessRunner#readStream(java.io.InputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 
TestBSPProcessRunner
@Override public Integer call() throws Exception {
  String SYSTEM_PATH_SEPARATOR=System.getProperty("path.separator");
  List<String> commands=new ArrayList<String>();
  String workDir=new File(".").getAbsolutePath();
  File jvm=new File(new File(System.getProperty("java.home"),"bin"),"java");
  commands.add(jvm.toString());
  StringBuffer classPath=new StringBuffer();
  classPath.append(System.getProperty("java.class.path"));
  classPath.append(SYSTEM_PATH_SEPARATOR);
  classPath.append(new File(workDir,"core/target/test-classes"));
  classPath.append(SYSTEM_PATH_SEPARATOR);
  classPath.append(workDir);
  commands.add("-classpath");
  commands.add(classPath.toString());
  commands.add(TestBSPProcessRunner.class.getName());
  LOG.info("starting process for failure case - " + testPoint);
  commands.add("" + testPoint);
  commands.add("" + testPort);
  LOG.info(commands.toString());
  ProcessBuilder builder=new ProcessBuilder(commands);
  try {
    bspTaskProcess=builder.start();
    errorLog=new Thread(){
      @Override public void run(){
        try {
          readStream(bspTaskProcess.getErrorStream());
        }
 catch (        Exception e) {
        }
      }
    }
;
    errorLog.start();
    infoLog=new Thread(){
      @Override public void run(){
        try {
          readStream(bspTaskProcess.getInputStream());
        }
 catch (        Exception e) {
        }
      }
    }
;
    infoLog.start();
    int exit_code=bspTaskProcess.waitFor();
    return exit_code;
  }
 catch (  Exception e) {
    LOG.error("Error getting exit code of child process",e);
  }
  return -1;
}

ID 1109=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPProcessRunner#call()
Rmethod: java.lang.Process#waitFor()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error("Error getting exit code of child process",e);
}

block: 
TestBSPProcessRunner
@Override public Integer call() throws Exception {
  String SYSTEM_PATH_SEPARATOR=System.getProperty("path.separator");
  List<String> commands=new ArrayList<String>();
  String workDir=new File(".").getAbsolutePath();
  File jvm=new File(new File(System.getProperty("java.home"),"bin"),"java");
  commands.add(jvm.toString());
  StringBuffer classPath=new StringBuffer();
  classPath.append(System.getProperty("java.class.path"));
  classPath.append(SYSTEM_PATH_SEPARATOR);
  classPath.append(new File(workDir,"core/target/test-classes"));
  classPath.append(SYSTEM_PATH_SEPARATOR);
  classPath.append(workDir);
  commands.add("-classpath");
  commands.add(classPath.toString());
  commands.add(TestBSPProcessRunner.class.getName());
  LOG.info("starting process for failure case - " + testPoint);
  commands.add("" + testPoint);
  commands.add("" + testPort);
  LOG.info(commands.toString());
  ProcessBuilder builder=new ProcessBuilder(commands);
  try {
    bspTaskProcess=builder.start();
    errorLog=new Thread(){
      @Override public void run(){
        try {
          readStream(bspTaskProcess.getErrorStream());
        }
 catch (        Exception e) {
        }
      }
    }
;
    errorLog.start();
    infoLog=new Thread(){
      @Override public void run(){
        try {
          readStream(bspTaskProcess.getInputStream());
        }
 catch (        Exception e) {
        }
      }
    }
;
    infoLog.start();
    int exit_code=bspTaskProcess.waitFor();
    return exit_code;
  }
 catch (  Exception e) {
    LOG.error("Error getting exit code of child process",e);
  }
  return -1;
}

ID 1110=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp#run()
Rmethod: org.apache.hama.bsp.TestBSPProcessRunner#readStream(java.io.InputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 

@Override public void run(){
  try {
    readStream(bspTaskProcess.getErrorStream());
  }
 catch (  Exception e) {
  }
}

ID 1111=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp#run()
Rmethod: org.apache.hama.bsp.TestBSPProcessRunner#readStream(java.io.InputStream)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
}

block: 

@Override public void run(){
  try {
    readStream(bspTaskProcess.getInputStream());
  }
 catch (  Exception e) {
  }
}

ID 1112=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPProcessRunner#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPProcessRunner
public static void main(String[] args){
  HamaConfiguration hamaConf=new HamaConfiguration();
  hamaConf.setInt(Constants.GROOM_PING_PERIOD,200);
  hamaConf.setClass("bsp.work.class",FaulTestBSP.class,BSP.class);
  hamaConf.setClass(SyncServiceFactory.SYNC_CLIENT_CLASS,LocalBSPRunner.LocalSyncClient.class,SyncClient.class);
  hamaConf.setInt("bsp.master.port",610002);
  TaskAttemptID tid=new TaskAttemptID(new TaskID(new BSPJobID("job_201110102255",1),1),1);
  hamaConf.setInt(TEST_POINT,Integer.parseInt(args[0]));
  int port=Integer.parseInt(args[1]);
  try {
    BSPJob job=new BSPJob(hamaConf);
    job.setInputFormat(NullInputFormat.class);
    job.setOutputFormat(NullOutputFormat.class);
    final BSPPeerProtocol proto=(BSPPeerProtocol)RPC.getProxy(BSPPeerProtocol.class,HamaRPCProtocolVersion.versionID,new InetSocketAddress("127.0.0.1",port),hamaConf);
    BSPTask task=new BSPTask();
    task.setConf(job);
    LOG.info("Testing failure case in process - " + hamaConf.getInt(TEST_POINT,0));
    Runtime.getRuntime().addShutdownHook(new Thread(){
      @Override public void run(){
        try {
          proto.close();
        }
 catch (        Exception e) {
        }
      }
    }
);
    @SuppressWarnings("rawtypes") BSPPeerImpl<?,?,?,?,?> bspPeer=new BSPPeerImpl(job,hamaConf,tid,proto,0,null,null,new Counters());
    task.run(job,bspPeer,proto);
  }
 catch (  Exception e) {
    LOG.error("Error in bsp child process.",e);
  }
}

ID 1113=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.FaulTestBSP#setup(BSPPeer<NullWritable,NullWritable,NullWritable,NullWritable,NullWritable>)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FaulTestBSP
@Override public void setup(BSPPeer<NullWritable,NullWritable,NullWritable,NullWritable,NullWritable> peer) throws IOException, SyncException, InterruptedException {
  if (peer.getConfiguration().getInt(TEST_POINT,0) == 1) {
    throw new RuntimeException("Error injected in setup");
  }
  Thread.sleep(500);
  super.setup(peer);
  LOG.info("Succesfully completed setup for bsp.");
}

ID 1114=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.FaulTestBSP#cleanup(BSPPeer<NullWritable,NullWritable,NullWritable,NullWritable,NullWritable>)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error("Interrupted BSP thread.",e);
}

block: 
FaulTestBSP
@Override public void cleanup(BSPPeer<NullWritable,NullWritable,NullWritable,NullWritable,NullWritable> peer) throws IOException {
  if (peer.getConfiguration().getInt(TEST_POINT,0) == 3) {
    throw new RuntimeException("Error injected in cleanup");
  }
  try {
    Thread.sleep(500);
  }
 catch (  Exception e) {
    LOG.error("Interrupted BSP thread.",e);
  }
  super.cleanup(peer);
  LOG.info("Succesfully cleaned up after bsp.");
}

ID 1115=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.FaulTestBSP#bsp(BSPPeer<NullWritable,NullWritable,NullWritable,NullWritable,NullWritable>)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
FaulTestBSP
@Override public void bsp(BSPPeer<NullWritable,NullWritable,NullWritable,NullWritable,NullWritable> peer) throws IOException, SyncException, InterruptedException {
  if (peer.getConfiguration().getInt(TEST_POINT,0) == 2) {
    throw new RuntimeException("Error injected in bsp function");
  }
  Thread.sleep(500);
  LOG.info("Succesfully completed bsp.");
}

ID 1116=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#setUp()
Rmethod: org.apache.hama.bsp.MinimalGroomServer#MinimalGroomServer(Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPTaskFaults
@Override protected void setUp() throws Exception {
  super.setUp();
  conf=new HamaConfiguration();
  conf.setInt(Constants.GROOM_PING_PERIOD,200);
  conf.setClass("bsp.work.class",FaulTestBSP.class,BSP.class);
  conf.setClass(SyncServiceFactory.SYNC_CLIENT_CLASS,LocalBSPRunner.LocalSyncClient.class,SyncClient.class);
  int port=BSPNetUtils.getFreePort(4321 + incrementTestNumber());
  try {
    InetSocketAddress inetAddress=new InetSocketAddress(port);
    groom=new MinimalGroomServer(conf);
    workerServer=RPC.getServer(groom,inetAddress.getHostName(),inetAddress.getPort(),conf);
    workerServer.start();
    LOG.info("Started RPC server");
    conf.setInt("bsp.groom.rpc.port",inetAddress.getPort());
    umbilical=(BSPPeerProtocol)RPC.getProxy(BSPPeerProtocol.class,HamaRPCProtocolVersion.versionID,inetAddress,conf);
    LOG.info("Started the proxy connections");
    this.testBSPTaskService=Executors.newScheduledThreadPool(1);
  }
 catch (  BindException be) {
    LOG.info(be);
  }
}

ID 1117=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPing()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e1) {
  LOG.error("Interrupted Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPing(){
  conf.setInt(TEST_POINT,0);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(0,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1118=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPing()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException e1) {
  LOG.error("ExecutionException Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPing(){
  conf.setInt(TEST_POINT,0);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(0,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1119=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPing()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (TimeoutException e) {
  LOG.error("TimeoutException Exception.",e);
}

block: 
TestBSPTaskFaults
public void testPing(){
  conf.setInt(TEST_POINT,0);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(0,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1120=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskSetupFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e1) {
  LOG.error("Interrupted Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskSetupFailure(){
  LOG.info("Testing ping failure case - 1");
  conf.setInt(TEST_POINT,1);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(1,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1121=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskSetupFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException e1) {
  LOG.error("ExecutionException Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskSetupFailure(){
  LOG.info("Testing ping failure case - 1");
  conf.setInt(TEST_POINT,1);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(1,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1122=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskSetupFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (TimeoutException e) {
  LOG.error("TimeoutException Exception.",e);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskSetupFailure(){
  LOG.info("Testing ping failure case - 1");
  conf.setInt(TEST_POINT,1);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(1,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1123=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskExecFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e1) {
  LOG.error("Interrupted Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskExecFailure(){
  LOG.info("Testing ping failure case - 2");
  conf.setInt(TEST_POINT,2);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(2,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1124=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskExecFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException e1) {
  LOG.error("ExecutionException Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskExecFailure(){
  LOG.info("Testing ping failure case - 2");
  conf.setInt(TEST_POINT,2);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(2,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1125=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskExecFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (TimeoutException e) {
  LOG.error("TimeoutException Exception.",e);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskExecFailure(){
  LOG.info("Testing ping failure case - 2");
  conf.setInt(TEST_POINT,2);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(2,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1126=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskCleanupFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e1) {
  LOG.error("Interrupted Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskCleanupFailure(){
  LOG.info("Testing ping failure case - 3");
  conf.setInt(TEST_POINT,3);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(3,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1127=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskCleanupFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException e1) {
  LOG.error("ExecutionException Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskCleanupFailure(){
  LOG.info("Testing ping failure case - 3");
  conf.setInt(TEST_POINT,3);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(3,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1128=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testPingOnTaskCleanupFailure()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (TimeoutException e) {
  LOG.error("TimeoutException Exception.",e);
}

block: 
TestBSPTaskFaults
public void testPingOnTaskCleanupFailure(){
  LOG.info("Testing ping failure case - 3");
  conf.setInt(TEST_POINT,3);
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(3,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  checkIfPingTestPassed();
  groom.setPingCount(0);
  this.testBSPTaskService.shutdownNow();
  runner.destroyProcess();
}

ID 1129=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testBSPTaskSelfDestroy()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.error("Interrupted the timer for 1 sec.",e);
}

block: 
TestBSPTaskFaults
public void testBSPTaskSelfDestroy(){
  LOG.info("Testing self kill on lost contact.");
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(0,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    while (groom.pingCount == 0) {
      Thread.sleep(100);
    }
  }
 catch (  Exception e) {
    LOG.error("Interrupted the timer for 1 sec.",e);
  }
  workerServer.stop();
  umbilical=null;
  workerServer=null;
  Integer exitValue=-1;
  try {
    exitValue=future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  assertEquals(69,exitValue.intValue());
  runner.destroyProcess();
}

ID 1130=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testBSPTaskSelfDestroy()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e1) {
  LOG.error("Interrupted Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testBSPTaskSelfDestroy(){
  LOG.info("Testing self kill on lost contact.");
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(0,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    while (groom.pingCount == 0) {
      Thread.sleep(100);
    }
  }
 catch (  Exception e) {
    LOG.error("Interrupted the timer for 1 sec.",e);
  }
  workerServer.stop();
  umbilical=null;
  workerServer=null;
  Integer exitValue=-1;
  try {
    exitValue=future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  assertEquals(69,exitValue.intValue());
  runner.destroyProcess();
}

ID 1131=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testBSPTaskSelfDestroy()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException e1) {
  LOG.error("ExecutionException Exception.",e1);
}

block: 
TestBSPTaskFaults
public void testBSPTaskSelfDestroy(){
  LOG.info("Testing self kill on lost contact.");
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(0,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    while (groom.pingCount == 0) {
      Thread.sleep(100);
    }
  }
 catch (  Exception e) {
    LOG.error("Interrupted the timer for 1 sec.",e);
  }
  workerServer.stop();
  umbilical=null;
  workerServer=null;
  Integer exitValue=-1;
  try {
    exitValue=future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  assertEquals(69,exitValue.intValue());
  runner.destroyProcess();
}

ID 1132=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#testBSPTaskSelfDestroy()
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (TimeoutException e) {
  LOG.error("TimeoutException Exception.",e);
}

block: 
TestBSPTaskFaults
public void testBSPTaskSelfDestroy(){
  LOG.info("Testing self kill on lost contact.");
  CompletionService<Integer> completionService=new ExecutorCompletionService<Integer>(this.testBSPTaskService);
  TestBSPProcessRunner runner=new TestBSPProcessRunner(0,workerServer.getListenerAddress().getPort());
  Future<Integer> future=completionService.submit(runner);
  try {
    while (groom.pingCount == 0) {
      Thread.sleep(100);
    }
  }
 catch (  Exception e) {
    LOG.error("Interrupted the timer for 1 sec.",e);
  }
  workerServer.stop();
  umbilical=null;
  workerServer=null;
  Integer exitValue=-1;
  try {
    exitValue=future.get(20000,TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e1) {
    LOG.error("Interrupted Exception.",e1);
  }
catch (  ExecutionException e1) {
    LOG.error("ExecutionException Exception.",e1);
  }
catch (  TimeoutException e) {
    LOG.error("TimeoutException Exception.",e);
  }
  assertEquals(69,exitValue.intValue());
  runner.destroyProcess();
}

ID 1133=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestBSPTaskFaults#tearDown()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBSPTaskFaults
@Override protected void tearDown() throws Exception {
  super.tearDown();
  if (groom != null)   groom.setPingCount(0);
  if (umbilical != null) {
    umbilical.close();
    Thread.sleep(2000);
  }
  if (workerServer != null)   workerServer.stop();
  testBSPTaskService.shutdownNow();
  Thread.sleep(2000);
}

ID 1134=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.TestBytes#testIncrementBytes()
Rmethod: org.apache.hama.util.TestBytes#checkTestIncrementBytes(long, long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestBytes
public void testIncrementBytes() throws IOException {
  assertTrue(checkTestIncrementBytes(10,1));
  assertTrue(checkTestIncrementBytes(12,123435445));
  assertTrue(checkTestIncrementBytes(124634654,1));
  assertTrue(checkTestIncrementBytes(10005460,5005645));
  assertTrue(checkTestIncrementBytes(1,-1));
  assertTrue(checkTestIncrementBytes(10,-1));
  assertTrue(checkTestIncrementBytes(10,-5));
  assertTrue(checkTestIncrementBytes(1005435000,-5));
  assertTrue(checkTestIncrementBytes(10,-43657655));
  assertTrue(checkTestIncrementBytes(-1,1));
  assertTrue(checkTestIncrementBytes(-26,5034520));
  assertTrue(checkTestIncrementBytes(-10657200,5));
  assertTrue(checkTestIncrementBytes(-12343250,45376475));
  assertTrue(checkTestIncrementBytes(-10,-5));
  assertTrue(checkTestIncrementBytes(-12343250,-5));
  assertTrue(checkTestIncrementBytes(-12,-34565445));
  assertTrue(checkTestIncrementBytes(-1546543452,-34565445));
}

ID 1135=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TempSyncClient#getInformation(java.lang.String, Writable)
Rmethod: java.io.DataOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.error("Error writing data to write buffer.",e);
}

block: 
TempSyncClient
@Override public boolean getInformation(String key,Writable valueHolder){
  LOG.info("Getting value for key " + key);
  if (!valueMap.containsKey(key)) {
    return false;
  }
  Writable value=valueMap.get(key);
  ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
  DataOutputStream outputStream=new DataOutputStream(byteStream);
  byte[] data=null;
  try {
    value.write(outputStream);
    outputStream.flush();
    data=byteStream.toByteArray();
    ByteArrayInputStream istream=new ByteArrayInputStream(data);
    DataInputStream diStream=new DataInputStream(istream);
    valueHolder.readFields(diStream);
    return true;
  }
 catch (  IOException e) {
    LOG.error("Error writing data to write buffer.",e);
  }
 finally {
    try {
      byteStream.close();
      outputStream.close();
    }
 catch (    IOException e) {
      LOG.error("Error closing byte stream.",e);
    }
  }
  return false;
}

ID 1136=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TempSyncClient#getInformation(java.lang.String, Writable)
Rmethod: java.io.ByteArrayOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.error("Error closing byte stream.",e);
}

block: 
TempSyncClient
@Override public boolean getInformation(String key,Writable valueHolder){
  LOG.info("Getting value for key " + key);
  if (!valueMap.containsKey(key)) {
    return false;
  }
  Writable value=valueMap.get(key);
  ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
  DataOutputStream outputStream=new DataOutputStream(byteStream);
  byte[] data=null;
  try {
    value.write(outputStream);
    outputStream.flush();
    data=byteStream.toByteArray();
    ByteArrayInputStream istream=new ByteArrayInputStream(data);
    DataInputStream diStream=new DataInputStream(istream);
    valueHolder.readFields(diStream);
    return true;
  }
 catch (  IOException e) {
    LOG.error("Error writing data to write buffer.",e);
  }
 finally {
    try {
      byteStream.close();
      outputStream.close();
    }
 catch (    IOException e) {
      LOG.error("Error closing byte stream.",e);
    }
  }
  return false;
}

ID 1137=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TempSyncClient#getInformation(java.lang.String, Writable)
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.error("Error closing byte stream.",e);
}

block: 
TempSyncClient
@Override public boolean getInformation(String key,Writable valueHolder){
  LOG.info("Getting value for key " + key);
  if (!valueMap.containsKey(key)) {
    return false;
  }
  Writable value=valueMap.get(key);
  ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
  DataOutputStream outputStream=new DataOutputStream(byteStream);
  byte[] data=null;
  try {
    value.write(outputStream);
    outputStream.flush();
    data=byteStream.toByteArray();
    ByteArrayInputStream istream=new ByteArrayInputStream(data);
    DataInputStream diStream=new DataInputStream(istream);
    valueHolder.readFields(diStream);
    return true;
  }
 catch (  IOException e) {
    LOG.error("Error writing data to write buffer.",e);
  }
 finally {
    try {
      byteStream.close();
      outputStream.close();
    }
 catch (    IOException e) {
      LOG.error("Error closing byte stream.",e);
    }
  }
  return false;
}

ID 1138=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestCheckpoint#testCheckpointInterval()
Rmethod: org.apache.hama.bsp.TestMessageManager#addMessage(Text)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestCheckpoint
public void testCheckpointInterval() throws Exception {
  Configuration config=new Configuration();
  System.setProperty("user.dir","/tmp");
  config.set(SyncServiceFactory.SYNC_CLIENT_CLASS,TempSyncClient.class.getName());
  config.set(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class.getName());
  config.setBoolean(Constants.FAULT_TOLERANCE_FLAG,true);
  config.setBoolean(Constants.CHECKPOINT_ENABLED,true);
  config.setInt(Constants.CHECKPOINT_INTERVAL,2);
  config.set("bsp.output.dir","/tmp/hama-test_out");
  config.set("bsp.local.dir","/tmp/hama-test");
  FileSystem dfs=FileSystem.get(config);
  BSPJob job=new BSPJob(new BSPJobID("checkpttest",1),"/tmp");
  TaskAttemptID taskId=new TaskAttemptID(new TaskID(job.getJobID(),1),1);
  TestMessageManager messenger=new TestMessageManager();
  PeerSyncClient syncClient=SyncServiceFactory.getPeerSyncClient(config);
  @SuppressWarnings("rawtypes") BSPPeer bspTask=new TestBSPPeer(job,config,taskId,new Counters(),-1L,(BSPPeerSyncClient)syncClient,messenger,TaskStatus.State.RUNNING);
  assertNotNull("BSPPeerImpl should not be null.",bspTask);
  LOG.info("Created bsp peer and other parameters");
  int port=BSPNetUtils.getFreePort(12502);
  LOG.info("Got port = " + port);
  boolean result=syncClient.getInformation(syncClient.constructKey(job.getJobID(),"checkpoint","" + bspTask.getPeerIndex()),new ArrayWritable(LongWritable.class));
  assertFalse(result);
  bspTask.sync();
  checkSuperstepMsgCount(syncClient,bspTask,job,1L,0L);
  Text txtMessage=new Text("data");
  messenger.addMessage(txtMessage);
  bspTask.sync();
  checkSuperstepMsgCount(syncClient,bspTask,job,1L,0L);
  messenger.addMessage(txtMessage);
  bspTask.sync();
  checkSuperstepMsgCount(syncClient,bspTask,job,3L,1L);
  bspTask.sync();
  checkSuperstepMsgCount(syncClient,bspTask,job,3L,1L);
  messenger.addMessage(txtMessage);
  messenger.addMessage(txtMessage);
  bspTask.sync();
  checkSuperstepMsgCount(syncClient,bspTask,job,5L,2L);
  bspTask.sync();
  checkSuperstepMsgCount(syncClient,bspTask,job,5L,2L);
  dfs.delete(new Path("checkpoint"),true);
}

ID 1139=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestCheckpoint#testCheckpoint()
Rmethod: org.apache.hama.bsp.TestMessageManager#addMessage(Text)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestCheckpoint
@SuppressWarnings("rawtypes") public void testCheckpoint() throws Exception {
  Configuration config=new Configuration();
  config.set(SyncServiceFactory.SYNC_CLIENT_CLASS,TempSyncClient.class.getName());
  config.setBoolean(Constants.FAULT_TOLERANCE_FLAG,true);
  config.set(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class.getName());
  config.setBoolean(Constants.CHECKPOINT_ENABLED,true);
  int port=BSPNetUtils.getFreePort(12502);
  LOG.info("Got port = " + port);
  config.set(Constants.PEER_HOST,Constants.DEFAULT_PEER_HOST);
  config.setInt(Constants.PEER_PORT,port);
  config.set("bsp.output.dir","/tmp/hama-test_out");
  config.set("bsp.local.dir","/tmp/hama-test");
  FileSystem dfs=FileSystem.get(config);
  BSPJob job=new BSPJob(new BSPJobID("checkpttest",1),"/tmp");
  TaskAttemptID taskId=new TaskAttemptID(new TaskID(job.getJobID(),1),1);
  TestMessageManager messenger=new TestMessageManager();
  PeerSyncClient syncClient=SyncServiceFactory.getPeerSyncClient(config);
  BSPPeer bspTask=new TestBSPPeer(job,config,taskId,new Counters(),-1L,(BSPPeerSyncClient)syncClient,messenger,TaskStatus.State.RUNNING);
  assertNotNull("BSPPeerImpl should not be null.",bspTask);
  LOG.info("Created bsp peer and other parameters");
  @SuppressWarnings("unused") FaultTolerantPeerService<Text> service=null;
  bspTask.sync();
  LOG.info("Completed first sync.");
  checkSuperstepMsgCount(syncClient,bspTask,job,1L,0L);
  Text txtMessage=new Text("data");
  messenger.addMessage(txtMessage);
  bspTask.sync();
  LOG.info("Completed second sync.");
  checkSuperstepMsgCount(syncClient,bspTask,job,2L,1L);
  String expectedPath="checkpoint/job_checkpttest_0001/2/1";
  FSDataInputStream in=dfs.open(new Path(expectedPath));
  String className=in.readUTF();
  Text message=(Text)ReflectionUtils.newInstance(Class.forName(className),config);
  message.readFields(in);
  assertEquals("data",message.toString());
  dfs.delete(new Path("checkpoint"),true);
}

ID 1140=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestCheckpoint#testCheckpoint()
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestCheckpoint
@SuppressWarnings("rawtypes") public void testCheckpoint() throws Exception {
  Configuration config=new Configuration();
  config.set(SyncServiceFactory.SYNC_CLIENT_CLASS,TempSyncClient.class.getName());
  config.setBoolean(Constants.FAULT_TOLERANCE_FLAG,true);
  config.set(Constants.FAULT_TOLERANCE_CLASS,AsyncRcvdMsgCheckpointImpl.class.getName());
  config.setBoolean(Constants.CHECKPOINT_ENABLED,true);
  int port=BSPNetUtils.getFreePort(12502);
  LOG.info("Got port = " + port);
  config.set(Constants.PEER_HOST,Constants.DEFAULT_PEER_HOST);
  config.setInt(Constants.PEER_PORT,port);
  config.set("bsp.output.dir","/tmp/hama-test_out");
  config.set("bsp.local.dir","/tmp/hama-test");
  FileSystem dfs=FileSystem.get(config);
  BSPJob job=new BSPJob(new BSPJobID("checkpttest",1),"/tmp");
  TaskAttemptID taskId=new TaskAttemptID(new TaskID(job.getJobID(),1),1);
  TestMessageManager messenger=new TestMessageManager();
  PeerSyncClient syncClient=SyncServiceFactory.getPeerSyncClient(config);
  BSPPeer bspTask=new TestBSPPeer(job,config,taskId,new Counters(),-1L,(BSPPeerSyncClient)syncClient,messenger,TaskStatus.State.RUNNING);
  assertNotNull("BSPPeerImpl should not be null.",bspTask);
  LOG.info("Created bsp peer and other parameters");
  @SuppressWarnings("unused") FaultTolerantPeerService<Text> service=null;
  bspTask.sync();
  LOG.info("Completed first sync.");
  checkSuperstepMsgCount(syncClient,bspTask,job,1L,0L);
  Text txtMessage=new Text("data");
  messenger.addMessage(txtMessage);
  bspTask.sync();
  LOG.info("Completed second sync.");
  checkSuperstepMsgCount(syncClient,bspTask,job,2L,1L);
  String expectedPath="checkpoint/job_checkpttest_0001/2/1";
  FSDataInputStream in=dfs.open(new Path(expectedPath));
  String className=in.readUTF();
  Text message=(Text)ReflectionUtils.newInstance(Class.forName(className),config);
  message.readFields(in);
  assertEquals("data",message.toString());
  dfs.delete(new Path("checkpoint"),true);
}

ID 1141=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.DummyCollector#harvest()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
DummyCollector
@Override public Object harvest() throws Exception {
  assertEquals("Test if value is equal before harvest.",expected,sum.get());
  int result=sum.incrementAndGet();
  Thread.sleep(2 * 1000);
  assertEquals("Test if value is equal after harvest.",(expected + 1),result);
  return result;
}

ID 1142=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.TestFederator#testExecutionFlow()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.error(ie);
  Thread.currentThread().interrupt();
}

block: 
TestFederator
public void testExecutionFlow() throws Exception {
  LOG.info("Value before submitted: " + expected);
  final AtomicInteger finalResult=new AtomicInteger(0);
  final Act act=new Act(new DummyCollector(expected),new CollectorHandler(){
    @Override public void handle(    @SuppressWarnings("rawtypes") Future future){
      try {
        finalResult.set(((Integer)future.get()).intValue());
        LOG.info("Value after submitted: " + finalResult);
      }
 catch (      ExecutionException ee) {
        LOG.error(ee);
      }
catch (      InterruptedException ie) {
        LOG.error(ie);
        Thread.currentThread().interrupt();
      }
    }
  }
);
  this.federator.register(act);
  Thread.sleep(3 * 1000);
  assertEquals("Result should be " + (expected + 1) + ".",finalResult.get(),(expected + 1));
}

ID 1143=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.TestFederator#testExecutionFlow()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException ee) {
  LOG.error(ee);
}

block: 
TestFederator
public void testExecutionFlow() throws Exception {
  LOG.info("Value before submitted: " + expected);
  final AtomicInteger finalResult=new AtomicInteger(0);
  final Act act=new Act(new DummyCollector(expected),new CollectorHandler(){
    @Override public void handle(    @SuppressWarnings("rawtypes") Future future){
      try {
        finalResult.set(((Integer)future.get()).intValue());
        LOG.info("Value after submitted: " + finalResult);
      }
 catch (      ExecutionException ee) {
        LOG.error(ee);
      }
catch (      InterruptedException ie) {
        LOG.error(ie);
        Thread.currentThread().interrupt();
      }
    }
  }
);
  this.federator.register(act);
  Thread.sleep(3 * 1000);
  assertEquals("Result should be " + (expected + 1) + ".",finalResult.get(),(expected + 1));
}

ID 1144=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.TestFederator#testExecutionFlow()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestFederator
public void testExecutionFlow() throws Exception {
  LOG.info("Value before submitted: " + expected);
  final AtomicInteger finalResult=new AtomicInteger(0);
  final Act act=new Act(new DummyCollector(expected),new CollectorHandler(){
    @Override public void handle(    @SuppressWarnings("rawtypes") Future future){
      try {
        finalResult.set(((Integer)future.get()).intValue());
        LOG.info("Value after submitted: " + finalResult);
      }
 catch (      ExecutionException ee) {
        LOG.error(ee);
      }
catch (      InterruptedException ie) {
        LOG.error(ie);
        Thread.currentThread().interrupt();
      }
    }
  }
);
  this.federator.register(act);
  Thread.sleep(3 * 1000);
  assertEquals("Result should be " + (expected + 1) + ".",finalResult.get(),(expected + 1));
}

ID 1145=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor#handle(Future#RAW)
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.error(ie);
  Thread.currentThread().interrupt();
}

block: 

@Override public void handle(@SuppressWarnings("rawtypes") Future future){
  try {
    finalResult.set(((Integer)future.get()).intValue());
    LOG.info("Value after submitted: " + finalResult);
  }
 catch (  ExecutionException ee) {
    LOG.error(ee);
  }
catch (  InterruptedException ie) {
    LOG.error(ie);
    Thread.currentThread().interrupt();
  }
}

ID 1146=========================================================================type: Ignore_Log
package: org.apache.hama.monitor
Method:org.apache.hama.monitor#handle(Future#RAW)
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException ee) {
  LOG.error(ee);
}

block: 

@Override public void handle(@SuppressWarnings("rawtypes") Future future){
  try {
    finalResult.set(((Integer)future.get()).intValue());
    LOG.info("Value after submitted: " + finalResult);
  }
 catch (  ExecutionException ee) {
    LOG.error(ee);
  }
catch (  InterruptedException ie) {
    LOG.error(ie);
    Thread.currentThread().interrupt();
  }
}

ID 1147=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.TestHamaAsyncMessageManager#testMemoryMessaging()
Rmethod: org.apache.hama.bsp.message.TestHamaAsyncMessageManager#messagingInternal(HamaConfiguration)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestHamaAsyncMessageManager
public void testMemoryMessaging() throws Exception {
  if (!SystemUtils.IS_OS_LINUX) {
    System.out.println("Skipping testcase because Async is only supported for LINUX!");
    return;
  }
  HamaConfiguration conf=new HamaConfiguration();
  conf.setClass(MessageManager.RECEIVE_QUEUE_TYPE_CLASS,MemoryQueue.class,MessageQueue.class);
  messagingInternal(conf);
}

ID 1148=========================================================================type: only_throws
package: org.apache.hama.bsp.message
Method:org.apache.hama.bsp.message.TestHamaMessageManager#testMemoryMessaging()
Rmethod: org.apache.hama.bsp.message.TestHamaMessageManager#messagingInternal(HamaConfiguration)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestHamaMessageManager
public void testMemoryMessaging() throws Exception {
  HamaConfiguration conf=new HamaConfiguration();
  conf.setClass(MessageManager.RECEIVE_QUEUE_TYPE_CLASS,MemoryQueue.class,MessageQueue.class);
  messagingInternal(conf);
}

ID 1149=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestIPC#testSerial()
Rmethod: org.apache.hama.ipc.TestIPC#testSerial(int, boolean, int, int, int)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestIPC
public void testSerial() throws Exception {
  testSerial(3,false,2,5,100);
}

ID 1150=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestIPC#testSerial(int, boolean, int, int, int)
Rmethod: org.apache.hama.ipc.TestServer#TestServer(int, boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestIPC
public void testSerial(int handlerCount,boolean handlerSleep,int clientCount,int callerCount,int callCount) throws Exception {
  Server server=new TestServer(handlerCount,handlerSleep);
  InetSocketAddress addr=BSPNetUtils.getConnectAddress(server);
  server.start();
  Client[] clients=new Client[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new Client(LongWritable.class,conf);
  }
  SerialCaller[] callers=new SerialCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new SerialCaller(clients[i % clientCount],addr,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  server.stop();
}

ID 1151=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestIPC#testSerial(int, boolean, int, int, int)
Rmethod: java.lang.Thread#join()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestIPC
public void testSerial(int handlerCount,boolean handlerSleep,int clientCount,int callerCount,int callCount) throws Exception {
  Server server=new TestServer(handlerCount,handlerSleep);
  InetSocketAddress addr=BSPNetUtils.getConnectAddress(server);
  server.start();
  Client[] clients=new Client[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new Client(LongWritable.class,conf);
  }
  SerialCaller[] callers=new SerialCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new SerialCaller(clients[i % clientCount],addr,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  server.stop();
}

ID 1152=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestIPC#testParallel()
Rmethod: org.apache.hama.ipc.TestIPC#testParallel(int, boolean, int, int, int, int, int)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestIPC
public void testParallel() throws Exception {
  testParallel(10,false,2,4,2,4,100);
}

ID 1153=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestIPC#testParallel(int, boolean, int, int, int, int, int)
Rmethod: org.apache.hama.ipc.TestServer#TestServer(int, boolean)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestIPC
public void testParallel(int handlerCount,boolean handlerSleep,int serverCount,int addressCount,int clientCount,int callerCount,int callCount) throws Exception {
  Server[] servers=new Server[serverCount];
  for (int i=0; i < serverCount; i++) {
    servers[i]=new TestServer(handlerCount,handlerSleep);
    servers[i].start();
  }
  InetSocketAddress[] addresses=new InetSocketAddress[addressCount];
  for (int i=0; i < addressCount; i++) {
    addresses[i]=BSPNetUtils.getConnectAddress(servers[i % serverCount]);
  }
  Client[] clients=new Client[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new Client(LongWritable.class,conf);
  }
  ParallelCaller[] callers=new ParallelCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new ParallelCaller(clients[i % clientCount],addresses,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  for (int i=0; i < serverCount; i++) {
    servers[i].stop();
  }
}

ID 1154=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestIPC#testParallel(int, boolean, int, int, int, int, int)
Rmethod: java.lang.Thread#join()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestIPC
public void testParallel(int handlerCount,boolean handlerSleep,int serverCount,int addressCount,int clientCount,int callerCount,int callCount) throws Exception {
  Server[] servers=new Server[serverCount];
  for (int i=0; i < serverCount; i++) {
    servers[i]=new TestServer(handlerCount,handlerSleep);
    servers[i].start();
  }
  InetSocketAddress[] addresses=new InetSocketAddress[addressCount];
  for (int i=0; i < addressCount; i++) {
    addresses[i]=BSPNetUtils.getConnectAddress(servers[i % serverCount]);
  }
  Client[] clients=new Client[clientCount];
  for (int i=0; i < clientCount; i++) {
    clients[i]=new Client(LongWritable.class,conf);
  }
  ParallelCaller[] callers=new ParallelCaller[callerCount];
  for (int i=0; i < callerCount; i++) {
    callers[i]=new ParallelCaller(clients[i % clientCount],addresses,callCount);
    callers[i].start();
  }
  for (int i=0; i < callerCount; i++) {
    callers[i].join();
    assertFalse(callers[i].failed);
  }
  for (int i=0; i < clientCount; i++) {
    clients[i].stop();
  }
  for (int i=0; i < serverCount; i++) {
    servers[i].stop();
  }
}

ID 1155=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestIPC#testStandAloneClient()
Rmethod: org.apache.hama.ipc.TestIPC#testParallel(int, boolean, int, int, int, int, int)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestIPC
@SuppressWarnings("deprecation") public void testStandAloneClient() throws Exception {
  testParallel(10,false,2,4,2,4,100);
  Client client=new Client(LongWritable.class,conf);
  InetSocketAddress address=new InetSocketAddress("127.0.0.1",1234);
  try {
    client.call(new LongWritable(RANDOM.nextLong()),address);
    fail("Expected an exception to have been thrown");
  }
 catch (  IOException e) {
    String message=e.getMessage();
    String addressText=address.toString();
    assertTrue("Did not find " + addressText + " in "+ message,message.contains(addressText));
    Throwable cause=e.getCause();
    assertNotNull("No nested exception in " + e,cause);
    String causeText=cause.getMessage();
    assertTrue("Did not find " + causeText + " in "+ message,message.contains(causeText));
  }
}

ID 1156=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.KeyValueHashPartitionedBSP#bsp(BSPPeer<Text,Text,NullWritable,NullWritable,MapWritable>)
Rmethod: java.lang.Integer#valueOf(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
KeyValueHashPartitionedBSP
@Override public void bsp(BSPPeer<Text,Text,NullWritable,NullWritable,MapWritable> peer) throws IOException, SyncException, InterruptedException {
  MapWritable expectedKeys=new MapWritable();
  Text key=null;
  Text value=null;
  MapWritable message=new MapWritable();
  message.put(new Text(KeyValueHashPartitionedBSP.TEST_UNEXPECTED_KEYS),new BooleanWritable(false));
  KeyValuePair<Text,Text> tmp=null;
  while ((tmp=peer.readNext()) != null) {
    key=tmp.getKey();
    value=tmp.getValue();
    int expectedPeerId=Math.abs(key.hashCode() % numTasks);
    if (expectedPeerId == peer.getPeerIndex()) {
      expectedKeys.put(new Text(key),new Text(value));
    }
 else {
      message.put(new Text(KeyValueHashPartitionedBSP.TEST_UNEXPECTED_KEYS),new BooleanWritable(true));
      break;
    }
  }
  message.put(new Text(KeyValueHashPartitionedBSP.TEST_INPUT_VALUES),expectedKeys);
  int master=peer.getNumPeers() / 2;
  peer.send(peer.getPeerName(master),message);
  peer.sync();
  if (peer.getPeerIndex() == master) {
    MapWritable msg=null;
    MapWritable values=null;
    BooleanWritable blValue=null;
    HashMap<Integer,Integer> input=new HashMap<Integer,Integer>();
    while ((msg=peer.getCurrentMessage()) != null) {
      blValue=(BooleanWritable)msg.get(new Text(KeyValueHashPartitionedBSP.TEST_UNEXPECTED_KEYS));
      assertEquals(false,blValue.get());
      values=(MapWritable)msg.get(new Text(KeyValueHashPartitionedBSP.TEST_INPUT_VALUES));
      for (      Map.Entry<Writable,Writable> w : values.entrySet()) {
        input.put(Integer.valueOf(w.getKey().toString()),Integer.valueOf(w.getValue().toString()));
      }
    }
    for (int i=0; i < maxValue; i++) {
      assertEquals(true,input.containsKey(Integer.valueOf(i)));
      assertEquals(i * i,input.get(Integer.valueOf(i)).intValue());
    }
  }
  peer.sync();
}

ID 1157=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.TestKMeansBSP#testRunJob()
Rmethod: org.apache.hama.ml.kmeans.TestKMeansBSP#test(Configuration, FileSystem, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestKMeansBSP
public void testRunJob() throws Exception {
  Configuration conf=new HamaConfiguration();
  FileSystem fs=FileSystem.get(conf);
  if (fs.exists(new Path(TMP_OUTPUT))) {
    fs.delete(new Path(TMP_OUTPUT),true);
  }
  for (int i=1; i < 5; i++) {
    try {
      test(conf,fs,i);
    }
  finally {
      fs.delete(new Path(TMP_OUTPUT),true);
    }
  }
}

ID 1158=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.TestKMeansBSP#testRunJob()
Rmethod: org.apache.hama.ml.kmeans.TestKMeansBSP#test(Configuration, FileSystem, int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestKMeansBSP
public void testRunJob() throws Exception {
  Configuration conf=new HamaConfiguration();
  FileSystem fs=FileSystem.get(conf);
  if (fs.exists(new Path(TMP_OUTPUT))) {
    fs.delete(new Path(TMP_OUTPUT),true);
  }
  for (int i=1; i < 5; i++) {
    try {
      test(conf,fs,i);
    }
  finally {
      fs.delete(new Path(TMP_OUTPUT),true);
    }
  }
}

ID 1159=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.TestKMeansBSP#testRunJob()
Rmethod: org.apache.hama.ml.kmeans.TestKMeansBSP#test(Configuration, FileSystem, int)
hasForStatement: true
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestKMeansBSP
public void testRunJob() throws Exception {
  Configuration conf=new HamaConfiguration();
  FileSystem fs=FileSystem.get(conf);
  if (fs.exists(new Path(TMP_OUTPUT))) {
    fs.delete(new Path(TMP_OUTPUT),true);
  }
  for (int i=1; i < 5; i++) {
    try {
      test(conf,fs,i);
    }
  finally {
      fs.delete(new Path(TMP_OUTPUT),true);
    }
  }
}

ID 1160=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.TestKMeansBSP#test(Configuration, FileSystem, int)
Rmethod: org.apache.hama.ml.kmeans.TestKMeansBSP#generateInputText(int, Configuration, FileSystem, Path, Path, Path, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Test Create 101 input vectors of dimension two Input vectors: (0,0) (1,1) (2,2) ... (100,100) k = 1, maxIterations = 10 Resulting center should be (50,50)
 */

catch: 
null
block: 
TestKMeansBSP
/** 
 * Test Create 101 input vectors of dimension two Input vectors: (0,0) (1,1) (2,2) ... (100,100) k = 1, maxIterations = 10 Resulting center should be (50,50)
 */
private void test(Configuration conf,FileSystem fs,int numBspTask) throws IOException, InterruptedException, ClassNotFoundException {
  Path in=new Path(TMP_OUTPUT + "in");
  Path out=new Path(TMP_OUTPUT + "out");
  Path centerIn=new Path(TMP_OUTPUT + "center/center_input.seq");
  Path centerOut=new Path(TMP_OUTPUT + "center/center_output.seq");
  conf.set(KMeansBSP.CENTER_IN_PATH,centerIn.toString());
  conf.set(KMeansBSP.CENTER_OUT_PATH,centerOut.toString());
  int k=1;
  int iterations=10;
  conf.setInt(KMeansBSP.MAX_ITERATIONS_KEY,iterations);
  in=generateInputText(k,conf,fs,in,centerIn,out,numBspTask);
  BSPJob job=KMeansBSP.createJob(conf,in,out,true);
  job.setNumBspTask(numBspTask);
  boolean result=job.waitForCompletion(true);
  assertEquals(true,result);
  HashMap<Integer,DoubleVector> centerMap=KMeansBSP.readClusterCenters(conf,out,centerOut,fs);
  System.out.println(centerMap);
  assertEquals(1,centerMap.size());
  DoubleVector doubleVector=centerMap.get(0);
  assertEquals(Double.valueOf(50),doubleVector.get(0));
  assertEquals(Double.valueOf(50),doubleVector.get(1));
}

ID 1161=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.TestKMeansBSP#generateInputText(int, Configuration, FileSystem, Path, Path, Path, int)
Rmethod: java.io.Writer#append(java.lang.CharSequence)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestKMeansBSP
private Path generateInputText(int k,Configuration conf,FileSystem fs,Path in,Path centerIn,Path out,int numBspTask) throws IOException {
  int totalNumberOfPoints=100;
  int interval=totalNumberOfPoints / numBspTask;
  Path parts=new Path(in,"parts");
  for (int part=0; part < numBspTask; part++) {
    Path partIn=new Path(parts,"part" + part + "/input.txt");
    BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(fs.create(partIn)));
    int start=interval * part;
    int end=start + interval - 1;
    if ((numBspTask - 1) == part) {
      end=totalNumberOfPoints;
    }
    System.out.println("Partition " + part + ": from "+ start+ " to "+ end);
    for (int i=start; i <= end; i++) {
      bw.append(i + "\t" + i+ "\n");
    }
    bw.close();
    Path seqFile=null;
    if (part == 0) {
      seqFile=KMeansBSP.prepareInputText(k,conf,partIn,centerIn,out,fs,false);
    }
 else {
      seqFile=KMeansBSP.prepareInputText(0,conf,partIn,new Path(centerIn + "_empty.seq"),out,fs,false);
    }
    fs.moveFromLocalFile(seqFile,new Path(parts,"part" + part + ".seq"));
    fs.delete(seqFile.getParent(),true);
    fs.delete(partIn.getParent(),true);
  }
  return parts;
}

ID 1162=========================================================================type: only_throws
package: org.apache.hama.ml.kmeans
Method:org.apache.hama.ml.kmeans.TestKMeansBSP#generateInputText(int, Configuration, FileSystem, Path, Path, Path, int)
Rmethod: java.io.BufferedWriter#close()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestKMeansBSP
private Path generateInputText(int k,Configuration conf,FileSystem fs,Path in,Path centerIn,Path out,int numBspTask) throws IOException {
  int totalNumberOfPoints=100;
  int interval=totalNumberOfPoints / numBspTask;
  Path parts=new Path(in,"parts");
  for (int part=0; part < numBspTask; part++) {
    Path partIn=new Path(parts,"part" + part + "/input.txt");
    BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(fs.create(partIn)));
    int start=interval * part;
    int end=start + interval - 1;
    if ((numBspTask - 1) == part) {
      end=totalNumberOfPoints;
    }
    System.out.println("Partition " + part + ": from "+ start+ " to "+ end);
    for (int i=start; i <= end; i++) {
      bw.append(i + "\t" + i+ "\n");
    }
    bw.close();
    Path seqFile=null;
    if (part == 0) {
      seqFile=KMeansBSP.prepareInputText(k,conf,partIn,centerIn,out,fs,false);
    }
 else {
      seqFile=KMeansBSP.prepareInputText(0,conf,partIn,new Path(centerIn + "_empty.seq"),out,fs,false);
    }
    fs.moveFromLocalFile(seqFile,new Path(parts,"part" + part + ".seq"));
    fs.delete(seqFile.getParent(),true);
    fs.delete(partIn.getParent(),true);
  }
  return parts;
}

ID 1163=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestPersistQueue#testMemoryQueue()
Rmethod: org.apache.hama.bsp.TestPersistQueue#getNewJobConf()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPersistQueue
public void testMemoryQueue() throws Exception {
  BSPMessageBundle<IntWritable> x=new BSPMessageBundle<IntWritable>();
  System.out.println(x.getClass().getCanonicalName() + ", " + BSPMessageBundle.class.getCanonicalName());
  BSPJob bsp=getNewJobConf();
  bsp.set(MessageManager.RECEIVE_QUEUE_TYPE_CLASS,"org.apache.hama.bsp.message.queue.MemoryQueue");
  assertTrue(bsp.waitForCompletion(true));
}

ID 1164=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TestPersistQueue#testSortedQueue()
Rmethod: org.apache.hama.bsp.TestPersistQueue#getNewJobConf()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPersistQueue
public void testSortedQueue() throws Exception {
  BSPJob bsp=getNewJobConf();
  bsp.set(MessageManager.RECEIVE_QUEUE_TYPE_CLASS,"org.apache.hama.bsp.message.queue.SortedMemoryQueue");
  assertTrue(bsp.waitForCompletion(true));
}

ID 1165=========================================================================type: Recover
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#TestPipes()
Rmethod: org.apache.hama.pipes.TestPipes#cleanup(FileSystem, Path)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
TestPipes
public TestPipes(){
  configuration=new HamaConfiguration();
  try {
    fs=FileSystem.get(configuration);
    cleanup(fs,new Path(HAMA_TMP_OUTPUT));
    cleanup(fs,new Path(HAMA_TMP_DISK_QUEUE_OUTPUT));
    cleanup(fs,new Path(EXAMPLE_TMP_OUTPUT));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  configuration.set("bsp.master.address","localhost");
  configuration.set("hama.child.redirect.log.console","true");
  assertEquals("Make sure master addr is set to localhost:","localhost",configuration.get("bsp.master.address"));
  configuration.set("bsp.local.dir",HAMA_TMP_OUTPUT);
  configuration.set(Constants.ZOOKEEPER_QUORUM,"localhost");
  configuration.setInt(Constants.ZOOKEEPER_CLIENT_PORT,21810);
  configuration.set("hama.sync.client.class",org.apache.hama.bsp.sync.ZooKeeperSyncClientImpl.class.getCanonicalName());
}

ID 1166=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#testPipes()
Rmethod: org.apache.hama.pipes.TestPipes#summation()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
public void testPipes() throws Exception {
  assertNotNull("System property " + EXAMPLES_INSTALL_PROPERTY + " is not defined!",System.getProperty(EXAMPLES_INSTALL_PROPERTY));
  if (System.getProperty(EXAMPLES_INSTALL_PROPERTY).isEmpty()) {
    LOG.error("System property " + EXAMPLES_INSTALL_PROPERTY + " is empty! Skipping TestPipes!");
    return;
  }
  this.examplesInstallPath=System.getProperty(EXAMPLES_INSTALL_PROPERTY);
  summation();
  piestimation();
  matrixMult();
  cleanup(fs,new Path(EXAMPLE_TMP_OUTPUT));
}

ID 1167=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#testPipes()
Rmethod: org.apache.hama.pipes.TestPipes#piestimation()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
public void testPipes() throws Exception {
  assertNotNull("System property " + EXAMPLES_INSTALL_PROPERTY + " is not defined!",System.getProperty(EXAMPLES_INSTALL_PROPERTY));
  if (System.getProperty(EXAMPLES_INSTALL_PROPERTY).isEmpty()) {
    LOG.error("System property " + EXAMPLES_INSTALL_PROPERTY + " is empty! Skipping TestPipes!");
    return;
  }
  this.examplesInstallPath=System.getProperty(EXAMPLES_INSTALL_PROPERTY);
  summation();
  piestimation();
  matrixMult();
  cleanup(fs,new Path(EXAMPLE_TMP_OUTPUT));
}

ID 1168=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#testPipes()
Rmethod: org.apache.hama.pipes.TestPipes#matrixMult()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
public void testPipes() throws Exception {
  assertNotNull("System property " + EXAMPLES_INSTALL_PROPERTY + " is not defined!",System.getProperty(EXAMPLES_INSTALL_PROPERTY));
  if (System.getProperty(EXAMPLES_INSTALL_PROPERTY).isEmpty()) {
    LOG.error("System property " + EXAMPLES_INSTALL_PROPERTY + " is empty! Skipping TestPipes!");
    return;
  }
  this.examplesInstallPath=System.getProperty(EXAMPLES_INSTALL_PROPERTY);
  summation();
  piestimation();
  matrixMult();
  cleanup(fs,new Path(EXAMPLE_TMP_OUTPUT));
}

ID 1169=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#testPipes()
Rmethod: org.apache.hama.pipes.TestPipes#cleanup(FileSystem, Path)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
public void testPipes() throws Exception {
  assertNotNull("System property " + EXAMPLES_INSTALL_PROPERTY + " is not defined!",System.getProperty(EXAMPLES_INSTALL_PROPERTY));
  if (System.getProperty(EXAMPLES_INSTALL_PROPERTY).isEmpty()) {
    LOG.error("System property " + EXAMPLES_INSTALL_PROPERTY + " is empty! Skipping TestPipes!");
    return;
  }
  this.examplesInstallPath=System.getProperty(EXAMPLES_INSTALL_PROPERTY);
  summation();
  piestimation();
  matrixMult();
  cleanup(fs,new Path(EXAMPLE_TMP_OUTPUT));
}

ID 1170=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#summation()
Rmethod: org.apache.hama.pipes.TestPipes#writeSummationInputFile(FileSystem, Path)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void summation() throws Exception {
  Path summationExec=new Path(this.examplesInstallPath + EXAMPLE_SUMMATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/out");
  BigDecimal sum=writeSummationInputFile(fs,inputPath);
  runProgram(getSummationJob(configuration),summationExec,inputPath,outputPath,1,this.numOfGroom);
  verifyOutput(configuration,outputPath,sum.doubleValue(),Math.pow(10,(DOUBLE_PRECISION * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1171=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#summation()
Rmethod: org.apache.hama.pipes.TestPipes#getSummationJob(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void summation() throws Exception {
  Path summationExec=new Path(this.examplesInstallPath + EXAMPLE_SUMMATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/out");
  BigDecimal sum=writeSummationInputFile(fs,inputPath);
  runProgram(getSummationJob(configuration),summationExec,inputPath,outputPath,1,this.numOfGroom);
  verifyOutput(configuration,outputPath,sum.doubleValue(),Math.pow(10,(DOUBLE_PRECISION * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1172=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#summation()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void summation() throws Exception {
  Path summationExec=new Path(this.examplesInstallPath + EXAMPLE_SUMMATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/out");
  BigDecimal sum=writeSummationInputFile(fs,inputPath);
  runProgram(getSummationJob(configuration),summationExec,inputPath,outputPath,1,this.numOfGroom);
  verifyOutput(configuration,outputPath,sum.doubleValue(),Math.pow(10,(DOUBLE_PRECISION * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1173=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#summation()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void summation() throws Exception {
  Path summationExec=new Path(this.examplesInstallPath + EXAMPLE_SUMMATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/out");
  BigDecimal sum=writeSummationInputFile(fs,inputPath);
  runProgram(getSummationJob(configuration),summationExec,inputPath,outputPath,1,this.numOfGroom);
  verifyOutput(configuration,outputPath,sum.doubleValue(),Math.pow(10,(DOUBLE_PRECISION * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1174=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#summation()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void summation() throws Exception {
  Path summationExec=new Path(this.examplesInstallPath + EXAMPLE_SUMMATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/out");
  BigDecimal sum=writeSummationInputFile(fs,inputPath);
  runProgram(getSummationJob(configuration),summationExec,inputPath,outputPath,1,this.numOfGroom);
  verifyOutput(configuration,outputPath,sum.doubleValue(),Math.pow(10,(DOUBLE_PRECISION * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1175=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#summation()
Rmethod: org.apache.hama.pipes.TestPipes#verifyOutput(HamaConfiguration, Path, double, double)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void summation() throws Exception {
  Path summationExec=new Path(this.examplesInstallPath + EXAMPLE_SUMMATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/out");
  BigDecimal sum=writeSummationInputFile(fs,inputPath);
  runProgram(getSummationJob(configuration),summationExec,inputPath,outputPath,1,this.numOfGroom);
  verifyOutput(configuration,outputPath,sum.doubleValue(),Math.pow(10,(DOUBLE_PRECISION * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1176=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#summation()
Rmethod: org.apache.hama.pipes.TestPipes#cleanup(FileSystem, Path)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void summation() throws Exception {
  Path summationExec=new Path(this.examplesInstallPath + EXAMPLE_SUMMATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "summation/out");
  BigDecimal sum=writeSummationInputFile(fs,inputPath);
  runProgram(getSummationJob(configuration),summationExec,inputPath,outputPath,1,this.numOfGroom);
  verifyOutput(configuration,outputPath,sum.doubleValue(),Math.pow(10,(DOUBLE_PRECISION * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1177=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#piestimation()
Rmethod: org.apache.hama.pipes.TestPipes#getPiestimatorJob(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void piestimation() throws Exception {
  Path piestimatorExec=new Path(this.examplesInstallPath + EXAMPLE_PIESTIMATOR_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/out");
  runProgram(getPiestimatorJob(configuration),piestimatorExec,inputPath,outputPath,3,this.numOfGroom);
  verifyOutput(configuration,outputPath,Math.PI,Math.pow(10,(2 * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1178=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#piestimation()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void piestimation() throws Exception {
  Path piestimatorExec=new Path(this.examplesInstallPath + EXAMPLE_PIESTIMATOR_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/out");
  runProgram(getPiestimatorJob(configuration),piestimatorExec,inputPath,outputPath,3,this.numOfGroom);
  verifyOutput(configuration,outputPath,Math.PI,Math.pow(10,(2 * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1179=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#piestimation()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void piestimation() throws Exception {
  Path piestimatorExec=new Path(this.examplesInstallPath + EXAMPLE_PIESTIMATOR_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/out");
  runProgram(getPiestimatorJob(configuration),piestimatorExec,inputPath,outputPath,3,this.numOfGroom);
  verifyOutput(configuration,outputPath,Math.PI,Math.pow(10,(2 * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1180=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#piestimation()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void piestimation() throws Exception {
  Path piestimatorExec=new Path(this.examplesInstallPath + EXAMPLE_PIESTIMATOR_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/out");
  runProgram(getPiestimatorJob(configuration),piestimatorExec,inputPath,outputPath,3,this.numOfGroom);
  verifyOutput(configuration,outputPath,Math.PI,Math.pow(10,(2 * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1181=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#piestimation()
Rmethod: org.apache.hama.pipes.TestPipes#verifyOutput(HamaConfiguration, Path, double, double)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void piestimation() throws Exception {
  Path piestimatorExec=new Path(this.examplesInstallPath + EXAMPLE_PIESTIMATOR_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/out");
  runProgram(getPiestimatorJob(configuration),piestimatorExec,inputPath,outputPath,3,this.numOfGroom);
  verifyOutput(configuration,outputPath,Math.PI,Math.pow(10,(2 * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1182=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#piestimation()
Rmethod: org.apache.hama.pipes.TestPipes#cleanup(FileSystem, Path)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void piestimation() throws Exception {
  Path piestimatorExec=new Path(this.examplesInstallPath + EXAMPLE_PIESTIMATOR_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "piestimator/out");
  runProgram(getPiestimatorJob(configuration),piestimatorExec,inputPath,outputPath,3,this.numOfGroom);
  verifyOutput(configuration,outputPath,Math.PI,Math.pow(10,(2 * -1)));
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1183=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#matrixMult()
Rmethod: org.apache.hama.pipes.TestPipes#getMatrixMultiplicationJob(HamaConfiguration, Path)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void matrixMult() throws Exception {
  Path matrixmultiplicationExec=new Path(this.examplesInstallPath + EXAMPLE_MATRIXMULTIPLICATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/out");
  Random rand=new Random();
  int rows=rand.nextInt(20) + 11;
  int cols=rand.nextInt(20) + 11;
  double[][] matrixA=createRandomMatrix(rows,cols,rand);
  double[][] matrixB=createRandomMatrix(cols,rows,rand);
  Path matrixAPath=writeMatrix(configuration,matrixA,new Path(inputPath,"matrixA.seq"),false);
  Path transposedMatrixBPath=writeMatrix(configuration,matrixB,new Path(inputPath,"transposedMatrixB.seq"),true);
  runProgram(getMatrixMultiplicationJob(configuration,transposedMatrixBPath),matrixmultiplicationExec,matrixAPath,outputPath,2,this.numOfGroom);
  double[][] matrixC=multiplyMatrix(matrixA,matrixB);
  verifyMatrixMultiplicationOutput(configuration,outputPath,matrixC);
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1184=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#matrixMult()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void matrixMult() throws Exception {
  Path matrixmultiplicationExec=new Path(this.examplesInstallPath + EXAMPLE_MATRIXMULTIPLICATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/out");
  Random rand=new Random();
  int rows=rand.nextInt(20) + 11;
  int cols=rand.nextInt(20) + 11;
  double[][] matrixA=createRandomMatrix(rows,cols,rand);
  double[][] matrixB=createRandomMatrix(cols,rows,rand);
  Path matrixAPath=writeMatrix(configuration,matrixA,new Path(inputPath,"matrixA.seq"),false);
  Path transposedMatrixBPath=writeMatrix(configuration,matrixB,new Path(inputPath,"transposedMatrixB.seq"),true);
  runProgram(getMatrixMultiplicationJob(configuration,transposedMatrixBPath),matrixmultiplicationExec,matrixAPath,outputPath,2,this.numOfGroom);
  double[][] matrixC=multiplyMatrix(matrixA,matrixB);
  verifyMatrixMultiplicationOutput(configuration,outputPath,matrixC);
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1185=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#matrixMult()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void matrixMult() throws Exception {
  Path matrixmultiplicationExec=new Path(this.examplesInstallPath + EXAMPLE_MATRIXMULTIPLICATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/out");
  Random rand=new Random();
  int rows=rand.nextInt(20) + 11;
  int cols=rand.nextInt(20) + 11;
  double[][] matrixA=createRandomMatrix(rows,cols,rand);
  double[][] matrixB=createRandomMatrix(cols,rows,rand);
  Path matrixAPath=writeMatrix(configuration,matrixA,new Path(inputPath,"matrixA.seq"),false);
  Path transposedMatrixBPath=writeMatrix(configuration,matrixB,new Path(inputPath,"transposedMatrixB.seq"),true);
  runProgram(getMatrixMultiplicationJob(configuration,transposedMatrixBPath),matrixmultiplicationExec,matrixAPath,outputPath,2,this.numOfGroom);
  double[][] matrixC=multiplyMatrix(matrixA,matrixB);
  verifyMatrixMultiplicationOutput(configuration,outputPath,matrixC);
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1186=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#matrixMult()
Rmethod: org.apache.hama.pipes.TestPipes#runProgram(BSPJob, Path, Path, Path, int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void matrixMult() throws Exception {
  Path matrixmultiplicationExec=new Path(this.examplesInstallPath + EXAMPLE_MATRIXMULTIPLICATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/out");
  Random rand=new Random();
  int rows=rand.nextInt(20) + 11;
  int cols=rand.nextInt(20) + 11;
  double[][] matrixA=createRandomMatrix(rows,cols,rand);
  double[][] matrixB=createRandomMatrix(cols,rows,rand);
  Path matrixAPath=writeMatrix(configuration,matrixA,new Path(inputPath,"matrixA.seq"),false);
  Path transposedMatrixBPath=writeMatrix(configuration,matrixB,new Path(inputPath,"transposedMatrixB.seq"),true);
  runProgram(getMatrixMultiplicationJob(configuration,transposedMatrixBPath),matrixmultiplicationExec,matrixAPath,outputPath,2,this.numOfGroom);
  double[][] matrixC=multiplyMatrix(matrixA,matrixB);
  verifyMatrixMultiplicationOutput(configuration,outputPath,matrixC);
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1187=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#matrixMult()
Rmethod: org.apache.hama.pipes.TestPipes#verifyMatrixMultiplicationOutput(HamaConfiguration, Path, double[][])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void matrixMult() throws Exception {
  Path matrixmultiplicationExec=new Path(this.examplesInstallPath + EXAMPLE_MATRIXMULTIPLICATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/out");
  Random rand=new Random();
  int rows=rand.nextInt(20) + 11;
  int cols=rand.nextInt(20) + 11;
  double[][] matrixA=createRandomMatrix(rows,cols,rand);
  double[][] matrixB=createRandomMatrix(cols,rows,rand);
  Path matrixAPath=writeMatrix(configuration,matrixA,new Path(inputPath,"matrixA.seq"),false);
  Path transposedMatrixBPath=writeMatrix(configuration,matrixB,new Path(inputPath,"transposedMatrixB.seq"),true);
  runProgram(getMatrixMultiplicationJob(configuration,transposedMatrixBPath),matrixmultiplicationExec,matrixAPath,outputPath,2,this.numOfGroom);
  double[][] matrixC=multiplyMatrix(matrixA,matrixB);
  verifyMatrixMultiplicationOutput(configuration,outputPath,matrixC);
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1188=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#matrixMult()
Rmethod: org.apache.hama.pipes.TestPipes#cleanup(FileSystem, Path)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
private void matrixMult() throws Exception {
  Path matrixmultiplicationExec=new Path(this.examplesInstallPath + EXAMPLE_MATRIXMULTIPLICATION_EXEC);
  Path inputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/in");
  Path outputPath=new Path(EXAMPLE_TMP_OUTPUT + "matmult/out");
  Random rand=new Random();
  int rows=rand.nextInt(20) + 11;
  int cols=rand.nextInt(20) + 11;
  double[][] matrixA=createRandomMatrix(rows,cols,rand);
  double[][] matrixB=createRandomMatrix(cols,rows,rand);
  Path matrixAPath=writeMatrix(configuration,matrixA,new Path(inputPath,"matrixA.seq"),false);
  Path transposedMatrixBPath=writeMatrix(configuration,matrixB,new Path(inputPath,"transposedMatrixB.seq"),true);
  runProgram(getMatrixMultiplicationJob(configuration,transposedMatrixBPath),matrixmultiplicationExec,matrixAPath,outputPath,2,this.numOfGroom);
  double[][] matrixC=multiplyMatrix(matrixA,matrixB);
  verifyMatrixMultiplicationOutput(configuration,outputPath,matrixC);
  cleanup(fs,inputPath);
  cleanup(fs,outputPath);
}

ID 1189=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#writeSummationInputFile(FileSystem, Path)
Rmethod: java.io.DataOutputStream#writeBytes(java.lang.String)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
static BigDecimal writeSummationInputFile(FileSystem fs,Path dir) throws IOException {
  DataOutputStream out=fs.create(new Path(dir,"part0"));
  Random rand=new Random();
  double rangeMin=0;
  double rangeMax=100;
  BigDecimal sum=new BigDecimal(0);
  for (int i=0; i < rand.nextInt(100) + 50; i++) {
    double randomValue=rangeMin + (rangeMax - rangeMin) * rand.nextDouble();
    String truncatedValue=new BigDecimal(randomValue).setScale(DOUBLE_PRECISION,BigDecimal.ROUND_DOWN).toString();
    String line="key" + (i + 1) + "\t"+ truncatedValue+ "\n";
    out.writeBytes(line);
    sum=sum.add(new BigDecimal(truncatedValue));
  }
  out.close();
  return sum;
}

ID 1190=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#writeSummationInputFile(FileSystem, Path)
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
static BigDecimal writeSummationInputFile(FileSystem fs,Path dir) throws IOException {
  DataOutputStream out=fs.create(new Path(dir,"part0"));
  Random rand=new Random();
  double rangeMin=0;
  double rangeMax=100;
  BigDecimal sum=new BigDecimal(0);
  for (int i=0; i < rand.nextInt(100) + 50; i++) {
    double randomValue=rangeMin + (rangeMax - rangeMin) * rand.nextDouble();
    String truncatedValue=new BigDecimal(randomValue).setScale(DOUBLE_PRECISION,BigDecimal.ROUND_DOWN).toString();
    String line="key" + (i + 1) + "\t"+ truncatedValue+ "\n";
    out.writeBytes(line);
    sum=sum.add(new BigDecimal(truncatedValue));
  }
  out.close();
  return sum;
}

ID 1191=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#verifyOutput(HamaConfiguration, Path, java.lang.String[])
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
static void verifyOutput(HamaConfiguration conf,Path outputPath,String[] expectedResults) throws IOException {
  FileStatus[] listStatus=fs.listStatus(outputPath);
  for (  FileStatus status : listStatus) {
    if (!status.isDir()) {
      if (status.getLen() > 0) {
        LOG.info("Output File: " + status.getPath());
        BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(status.getPath())));
        try {
          String line="";
          int i=0;
          while ((line=br.readLine()) != null) {
            LOG.info("output[" + i + "]: '"+ line+ "'");
            LOG.info("expected[" + i + "]: '"+ expectedResults[i]+ "'");
            assertEquals("'" + expectedResults[i] + "' != '"+ line+ "'",expectedResults[i],line);
            i++;
          }
        }
  finally {
          br.close();
        }
      }
    }
  }
}

ID 1192=========================================================================type: only_throws
package: org.apache.hama.pipes
Method:org.apache.hama.pipes.TestPipes#verifyOutput(HamaConfiguration, Path, java.lang.String[])
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestPipes
static void verifyOutput(HamaConfiguration conf,Path outputPath,String[] expectedResults) throws IOException {
  FileStatus[] listStatus=fs.listStatus(outputPath);
  for (  FileStatus status : listStatus) {
    if (!status.isDir()) {
      if (status.getLen() > 0) {
        LOG.info("Output File: " + status.getPath());
        BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(status.getPath())));
        try {
          String line="";
          int i=0;
          while ((line=br.readLine()) != null) {
            LOG.info("output[" + i + "]: '"+ line+ "'");
            LOG.info("expected[" + i + "]: '"+ expectedResults[i]+ "'");
            assertEquals("'" + expectedResults[i] + "' != '"+ line+ "'",expectedResults[i],line);
            i++;
          }
        }
  finally {
          br.close();
        }
      }
    }
  }
}

ID 1193=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#ping()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1194=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#echo(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1195=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#echo(java.lang.String[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1196=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#add(int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1197=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#add(int[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1198=========================================================================type: Ignore_Log
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#error()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException e) {
  LOG.debug("Caught " + e);
  caught=true;
}

block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1199=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: org.apache.hama.ipc.TestProtocol#testServerGet()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1200=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1201=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#testCalls()
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public void testCalls() throws Exception {
  Server server=RPC.getServer(new TestImpl(),ADDRESS,PORT,conf);
  server.start();
  InetSocketAddress addr=new InetSocketAddress(PORT);
  TestProtocol proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
  proxy.ping();
  String stringResult=proxy.echo("foo");
  assertEquals(stringResult,"foo");
  stringResult=proxy.echo((String)null);
  assertEquals(stringResult,null);
  String[] stringResults=proxy.echo(new String[]{"foo","bar"});
  assertTrue(Arrays.equals(stringResults,new String[]{"foo","bar"}));
  stringResults=proxy.echo((String[])null);
  assertTrue(Arrays.equals(stringResults,null));
  int intResult=proxy.add(1,2);
  assertEquals(intResult,3);
  intResult=proxy.add(new int[]{1,2});
  assertEquals(intResult,3);
  boolean caught=false;
  try {
    proxy.error();
  }
 catch (  IOException e) {
    LOG.debug("Caught " + e);
    caught=true;
  }
  assertTrue(caught);
  proxy.testServerGet();
  Method echo=TestProtocol.class.getMethod("echo",new Class[]{String.class});
  String[] strings=(String[])RPC.call(echo,new String[][]{{"a"},{"b"}},new InetSocketAddress[]{addr,addr},null,conf);
  assertTrue(Arrays.equals(strings,new String[]{"a","b"}));
  Method ping=TestProtocol.class.getMethod("ping",new Class[]{});
  Object[] voids=RPC.call(ping,new Object[][]{{},{}},new InetSocketAddress[]{addr,addr},null,conf);
  assertEquals(voids,null);
  server.stop();
}

ID 1202=========================================================================type: only_throws
package: org.apache.hama.ipc
Method:org.apache.hama.ipc.TestRPC#main(java.lang.String[])
Rmethod: org.apache.hama.ipc.TestRPC#testCalls()
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestRPC
public static void main(String[] args) throws Exception {
  new TestRPC("test").testCalls();
}

ID 1203=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.TestSubmitGraphJob#testSubmitJob()
Rmethod: org.apache.hama.graph.TestSubmitGraphJob#verifyResult()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestSubmitGraphJob
@Override public void testSubmitJob() throws Exception {
  generateTestData();
  GraphJob bsp=new GraphJob(configuration,PageRank.class);
  bsp.setInputPath(new Path("/tmp/pagerank/real-tmp.seq"));
  bsp.setOutputPath(new Path(OUTPUT));
  BSPJobClient jobClient=new BSPJobClient(configuration);
  configuration.setInt(Constants.ZOOKEEPER_SESSION_TIMEOUT,6000);
  configuration.set("hama.graph.self.ref","true");
  injectVerticesInfo();
  ClusterStatus cluster=jobClient.getClusterStatus(false);
  assertEquals(this.numOfGroom,cluster.getGroomServers());
  LOG.info("Client finishes execution job.");
  bsp.setJobName("Pagerank");
  bsp.setVertexClass(PageRank.PageRankVertex.class);
  bsp.setMaxIteration(30);
  bsp.setNumBspTask(2);
  bsp.setCompressionCodec(Bzip2Compressor.class);
  bsp.setAggregatorClass(AverageAggregator.class);
  bsp.setInputFormat(SequenceFileInputFormat.class);
  bsp.setInputKeyClass(Text.class);
  bsp.setInputValueClass(TextArrayWritable.class);
  bsp.setVertexIDClass(Text.class);
  bsp.setVertexValueClass(DoubleWritable.class);
  bsp.setEdgeValueClass(NullWritable.class);
  bsp.setVertexInputReaderClass(PagerankSeqReader.class);
  bsp.setPartitioner(HashPartitioner.class);
  bsp.setOutputFormat(SequenceFileOutputFormat.class);
  bsp.setOutputKeyClass(Text.class);
  bsp.setOutputValueClass(DoubleWritable.class);
  long startTime=System.currentTimeMillis();
  try {
    if (bsp.waitForCompletion(true)) {
      verifyResult();
      LOG.info("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
    }
 else {
      fail();
    }
  }
  finally {
    deleteTempDirs();
  }
}

ID 1204=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.TestZKUtil#setUp()
Rmethod: org.apache.hama.util.MockZK#MockZK(java.lang.String, int, Watcher)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TestZKUtil
@Override public void setUp() throws Exception {
  this.zk=new MockZK("localhost:2181",3000,null);
  this.path="/monitor/groom_lab01_61000/metrics/jvm";
  StringTokenizer token=new StringTokenizer(path,ZKUtil.ZK_SEPARATOR);
  int count=token.countTokens();
  assertEquals("Make sure token are 4.",count,4);
  this.parts=new String[count];
}

ID 1205=========================================================================type: Rethrow
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordWriter#LineRecordWriter(java.io.DataOutputStream, java.lang.String)
Rmethod: java.lang.String#getBytes(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

method comment: null
catch: 
catch (UnsupportedEncodingException uee) {
  throw new IllegalArgumentException("can't find " + utf8 + " encoding");
}

block: 
LineRecordWriter
public LineRecordWriter(DataOutputStream out,String keyValueSeparator){
  this.out=out;
  try {
    this.keyValueSeparator=keyValueSeparator.getBytes(utf8);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new IllegalArgumentException("can't find " + utf8 + " encoding");
  }
}

ID 1206=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordWriter#writeObject(java.lang.Object)
Rmethod: java.io.DataOutputStream#write(byte[], int, int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write the object to the byte stream, handling Text as a special case.
 * @param o the object to print
 * @throws IOException if the write throws, we pass it on
 */

catch: 
null
block: 
LineRecordWriter
/** 
 * Write the object to the byte stream, handling Text as a special case.
 * @param o the object to print
 * @throws IOException if the write throws, we pass it on
 */
private void writeObject(Object o) throws IOException {
  if (o instanceof Text) {
    Text to=(Text)o;
    out.write(to.getBytes(),0,to.getLength());
  }
 else {
    out.write(o.toString().getBytes(utf8));
  }
}

ID 1207=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordWriter#writeObject(java.lang.Object)
Rmethod: java.lang.String#getBytes(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

method comment: /** 
 * Write the object to the byte stream, handling Text as a special case.
 * @param o the object to print
 * @throws IOException if the write throws, we pass it on
 */

catch: 
null
block: 
LineRecordWriter
/** 
 * Write the object to the byte stream, handling Text as a special case.
 * @param o the object to print
 * @throws IOException if the write throws, we pass it on
 */
private void writeObject(Object o) throws IOException {
  if (o instanceof Text) {
    Text to=(Text)o;
    out.write(to.getBytes(),0,to.getLength());
  }
 else {
    out.write(o.toString().getBytes(utf8));
  }
}

ID 1208=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordWriter#writeObject(java.lang.Object)
Rmethod: java.io.FilterOutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write the object to the byte stream, handling Text as a special case.
 * @param o the object to print
 * @throws IOException if the write throws, we pass it on
 */

catch: 
null
block: 
LineRecordWriter
/** 
 * Write the object to the byte stream, handling Text as a special case.
 * @param o the object to print
 * @throws IOException if the write throws, we pass it on
 */
private void writeObject(Object o) throws IOException {
  if (o instanceof Text) {
    Text to=(Text)o;
    out.write(to.getBytes(),0,to.getLength());
  }
 else {
    out.write(o.toString().getBytes(utf8));
  }
}

ID 1209=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordWriter#write(K, V)
Rmethod: org.apache.hama.bsp.LineRecordWriter#writeObject(java.lang.Object)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
LineRecordWriter
@Override public synchronized void write(K key,V value) throws IOException {
  boolean nullKey=key == null || key instanceof NullWritable;
  boolean nullValue=value == null || value instanceof NullWritable;
  if (nullKey && nullValue) {
    return;
  }
  if (!nullKey) {
    writeObject(key);
  }
  if (!(nullKey || nullValue)) {
    out.write(keyValueSeparator);
  }
  if (!nullValue) {
    writeObject(value);
  }
  out.write(newline);
}

ID 1210=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordWriter#write(K, V)
Rmethod: java.io.FilterOutputStream#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
LineRecordWriter
@Override public synchronized void write(K key,V value) throws IOException {
  boolean nullKey=key == null || key instanceof NullWritable;
  boolean nullValue=value == null || value instanceof NullWritable;
  if (nullKey && nullValue) {
    return;
  }
  if (!nullKey) {
    writeObject(key);
  }
  if (!(nullKey || nullValue)) {
    out.write(keyValueSeparator);
  }
  if (!nullValue) {
    writeObject(value);
  }
  out.write(newline);
}

ID 1211=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.LineRecordWriter#close()
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
LineRecordWriter
@Override public synchronized void close() throws IOException {
  out.close();
}

ID 1212=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TrackedRecordReader#next(K, V)
Rmethod: org.apache.hama.bsp.TrackedRecordReader#moveToNext(K, V)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TrackedRecordReader
@Override public synchronized boolean next(K key,V value) throws IOException {
  boolean ret=moveToNext(key,value);
  if (ret) {
    incrCounters();
  }
  return ret;
}

ID 1213=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.TrackedRecordReader#moveToNext(K, V)
Rmethod: org.apache.hama.bsp.TrackedRecordReader#getPos()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
TrackedRecordReader
protected synchronized boolean moveToNext(K key,V value) throws IOException {
  beforePos=getPos();
  boolean ret=rawIn.next(key,value);
  afterPos=getPos();
  return ret;
}

ID 1214=========================================================================type: Recover
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.TupleWritable#readFields(java.io.DataInput)
Rmethod: java.lang.Class#forName(java.lang.String)
hasForStatement: true
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

method comment: /** 
 * {@inheritDoc}
 */

catch: 
catch (ClassNotFoundException e) {
  throw (IOException)new IOException("Failed tuple init").initCause(e);
}

block: 
TupleWritable
/** 
 * {@inheritDoc}
 */
@SuppressWarnings("unchecked") public void readFields(DataInput in) throws IOException {
  int card=WritableUtils.readVInt(in);
  values=new Writable[card];
  written=WritableUtils.readVLong(in);
  Class<? extends Writable>[] cls=new Class[card];
  try {
    for (int i=0; i < card; ++i) {
      cls[i]=Class.forName(Text.readString(in)).asSubclass(Writable.class);
    }
    for (int i=0; i < card; ++i) {
      values[i]=cls[i].newInstance();
      if (has(i)) {
        values[i].readFields(in);
      }
    }
  }
 catch (  ClassNotFoundException e) {
    throw (IOException)new IOException("Failed tuple init").initCause(e);
  }
catch (  IllegalAccessException e) {
    throw (IOException)new IOException("Failed tuple init").initCause(e);
  }
catch (  InstantiationException e) {
    throw (IOException)new IOException("Failed tuple init").initCause(e);
  }
}

ID 1215=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSensor#UDPSensor(HamaConfiguration)
Rmethod: java.nio.channels.DatagramChannel#open()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Constructor for UDP client. Setting up configuration and open DatagramSocket.
 */

catch: 
catch (IOException ioe) {
  LOG.error("Unable to open datagram channel.",ioe);
}

block: 
UDPSensor
/** 
 * Constructor for UDP client. Setting up configuration and open DatagramSocket.
 */
public UDPSensor(HamaConfiguration configuration){
  this.host=configuration.get("bsp.monitor.fd.udp_host","localhost");
  this.port=configuration.getInt("bsp.monitor.fd.udp_port",16384);
  HEARTBEAT_INTERVAL=configuration.getInt("bsp.monitor.fd.heartbeat_interval",1000);
  DatagramChannel tmp=null;
  try {
    tmp=DatagramChannel.open();
  }
 catch (  IOException ioe) {
    LOG.error("Unable to open datagram channel.",ioe);
  }
  this.channel=tmp;
  if (null == this.channel)   throw new NullPointerException("Fail to open udp channel.");
  this.scheduler=Executors.newSingleThreadExecutor();
}

ID 1216=========================================================================type: only_throws
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSensor#heartbeat()
Rmethod: java.nio.channels.DatagramChannel#send(java.nio.ByteBuffer, java.net.SocketAddress)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * The heartbeat function, signifying its existence.
 */

catch: 
null
block: 
UDPSensor
/** 
 * The heartbeat function, signifying its existence.
 */
@Override public void heartbeat() throws IOException {
  ByteBuffer heartbeat=ByteBuffer.allocate(8);
  heartbeat.clear();
  heartbeat.putLong(sequence.incrementAndGet());
  heartbeat.flip();
  channel.send(heartbeat,new InetSocketAddress(this.host,this.port));
  if (LOG.isDebugEnabled()) {
    LOG.debug("Heartbeat sequence " + sequence.get() + " is sent to "+ this.host+ ":"+ this.port);
  }
}

ID 1217=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSensor#call()
Rmethod: org.apache.hama.monitor.fd.UDPSensor#heartbeat()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Sensor fails in sending heartbeat.",ioe);
}

block: 
UDPSensor
@Override public Object call() throws Exception {
  while (running.get()) {
    try {
      heartbeat();
      Thread.sleep(HEARTBEAT_INTERVAL);
    }
 catch (    InterruptedException ie) {
      LOG.error("UDPSensor is interrupted.",ie);
      Thread.currentThread().interrupt();
    }
catch (    IOException ioe) {
      LOG.error("Sensor fails in sending heartbeat.",ioe);
    }
  }
  LOG.info("Sensor at " + this.host + " stops sending heartbeat.");
  return null;
}

ID 1218=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSensor#call()
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG.error("UDPSensor is interrupted.",ie);
  Thread.currentThread().interrupt();
}

block: 
UDPSensor
@Override public Object call() throws Exception {
  while (running.get()) {
    try {
      heartbeat();
      Thread.sleep(HEARTBEAT_INTERVAL);
    }
 catch (    InterruptedException ie) {
      LOG.error("UDPSensor is interrupted.",ie);
      Thread.currentThread().interrupt();
    }
catch (    IOException ioe) {
      LOG.error("Sensor fails in sending heartbeat.",ioe);
    }
  }
  LOG.info("Sensor at " + this.host + " stops sending heartbeat.");
  return null;
}

ID 1219=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSensor#stop()
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Error closing sensor channel.",ioe);
}

block: 
UDPSensor
@Override public void stop(){
  running.set(false);
  if (null != this.channel) {
    try {
      this.channel.socket().close();
      this.channel.close();
    }
 catch (    IOException ioe) {
      LOG.error("Error closing sensor channel.",ioe);
    }
  }
  this.scheduler.shutdown();
}

ID 1220=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.Watcher#run()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException ie) {
  LOG2.warn("Calculator thread is interrupted.",ie);
  Thread.currentThread().interrupt();
}

block: 
Watcher
@Override public void run(){
  try {
    if (!listeners.isEmpty()) {
      for (      Node node : nodes) {
        final String host=node.getHost();
        for (        NodeEventListener listener : listeners) {
          NodeStatus[] states=listener.interest();
          for (          NodeStatus state : states) {
            if (Dead.equals(state)) {
              Future<Boolean> result=this.calculator.submit(new Calculator(node));
              Boolean isAlive=result.get();
              if (!isAlive) {
                listener.notify(state,host);
              }
            }
          }
        }
      }
    }
  }
 catch (  InterruptedException ie) {
    LOG2.warn("Calculator thread is interrupted.",ie);
    Thread.currentThread().interrupt();
  }
catch (  ExecutionException ee) {
    LOG2.warn(ee);
  }
}

ID 1221=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.Watcher#run()
Rmethod: java.util.concurrent.Future#get()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.util.concurrent.ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

method comment: null
catch: 
catch (ExecutionException ee) {
  LOG2.warn(ee);
}

block: 
Watcher
@Override public void run(){
  try {
    if (!listeners.isEmpty()) {
      for (      Node node : nodes) {
        final String host=node.getHost();
        for (        NodeEventListener listener : listeners) {
          NodeStatus[] states=listener.interest();
          for (          NodeStatus state : states) {
            if (Dead.equals(state)) {
              Future<Boolean> result=this.calculator.submit(new Calculator(node));
              Boolean isAlive=result.get();
              if (!isAlive) {
                listener.notify(state,host);
              }
            }
          }
        }
      }
    }
  }
 catch (  InterruptedException ie) {
    LOG2.warn("Calculator thread is interrupted.",ie);
    Thread.currentThread().interrupt();
  }
catch (  ExecutionException ee) {
    LOG2.warn(ee);
  }
}

ID 1222=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSupervisor#UDPSupervisor(HamaConfiguration)
Rmethod: java.nio.channels.DatagramChannel#open()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * UDP Supervisor.
 */

catch: 
catch (IOException ioe) {
  LOG.error("Fail to open udp channel.",ioe);
}

block: 
UDPSupervisor
/** 
 * UDP Supervisor.
 */
public UDPSupervisor(HamaConfiguration conf){
  DatagramChannel ch=null;
  try {
    ch=DatagramChannel.open();
  }
 catch (  IOException ioe) {
    LOG.error("Fail to open udp channel.",ioe);
  }
  this.channel=ch;
  if (null == this.channel)   throw new NullPointerException("Channel can not be opened.");
  try {
    this.channel.socket().bind(new InetSocketAddress(conf.getInt("bsp.monitor.fd.udp_port",16384)));
  }
 catch (  SocketException se) {
    LOG.error("Unable to bind the udp socket.",se);
  }
  WINDOW_SIZE.set(conf.getInt("bsp.monitor.fd.window_size",100));
  this.receiver=Executors.newCachedThreadPool();
  this.supervisor=Executors.newSingleThreadExecutor();
  this.watcher=Executors.newSingleThreadScheduledExecutor();
}

ID 1223=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSupervisor#UDPSupervisor(HamaConfiguration)
Rmethod: java.net.DatagramSocket#bind(java.net.SocketAddress)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.net.SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

method comment: /** 
 * UDP Supervisor.
 */

catch: 
catch (SocketException se) {
  LOG.error("Unable to bind the udp socket.",se);
}

block: 
UDPSupervisor
/** 
 * UDP Supervisor.
 */
public UDPSupervisor(HamaConfiguration conf){
  DatagramChannel ch=null;
  try {
    ch=DatagramChannel.open();
  }
 catch (  IOException ioe) {
    LOG.error("Fail to open udp channel.",ioe);
  }
  this.channel=ch;
  if (null == this.channel)   throw new NullPointerException("Channel can not be opened.");
  try {
    this.channel.socket().bind(new InetSocketAddress(conf.getInt("bsp.monitor.fd.udp_port",16384)));
  }
 catch (  SocketException se) {
    LOG.error("Unable to bind the udp socket.",se);
  }
  WINDOW_SIZE.set(conf.getInt("bsp.monitor.fd.window_size",100));
  this.receiver=Executors.newCachedThreadPool();
  this.supervisor=Executors.newSingleThreadExecutor();
  this.watcher=Executors.newSingleThreadScheduledExecutor();
}

ID 1224=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSupervisor#call()
Rmethod: java.nio.channels.DatagramChannel#receive(java.nio.ByteBuffer)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Problem in receiving packet from channel.",ioe);
  Thread.currentThread().interrupt();
}

block: 
UDPSupervisor
@Override public Object call() throws Exception {
  ByteBuffer packet=ByteBuffer.allocate(8);
  try {
    while (running.get()) {
      final InetSocketAddress source=(InetSocketAddress)channel.receive(packet);
      final String hostName=source.getHostName();
      packet.flip();
      final long seq=packet.getLong();
      packet.clear();
      if (LOG.isDebugEnabled()) {
        LOG.debug("Seqence: " + seq + " src host: "+ hostName);
      }
      final Node tmpNode=new Node(hostName,WINDOW_SIZE.get());
      receiver.submit(new Hermes(tmpNode,seq,System.currentTimeMillis()));
    }
  }
 catch (  IOException ioe) {
    LOG.error("Problem in receiving packet from channel.",ioe);
    Thread.currentThread().interrupt();
  }
 finally {
    if (null != this.channel)     try {
      this.channel.socket().close();
      this.channel.close();
    }
 catch (    IOException ioe) {
      LOG.error("Error closing supervisor channel.",ioe);
    }
  }
  return null;
}

ID 1225=========================================================================type: Ignore_Log
package: org.apache.hama.monitor.fd
Method:org.apache.hama.monitor.fd.UDPSupervisor#call()
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (IOException ioe) {
  LOG.error("Error closing supervisor channel.",ioe);
}

block: 
UDPSupervisor
@Override public Object call() throws Exception {
  ByteBuffer packet=ByteBuffer.allocate(8);
  try {
    while (running.get()) {
      final InetSocketAddress source=(InetSocketAddress)channel.receive(packet);
      final String hostName=source.getHostName();
      packet.flip();
      final long seq=packet.getLong();
      packet.clear();
      if (LOG.isDebugEnabled()) {
        LOG.debug("Seqence: " + seq + " src host: "+ hostName);
      }
      final Node tmpNode=new Node(hostName,WINDOW_SIZE.get());
      receiver.submit(new Hermes(tmpNode,seq,System.currentTimeMillis()));
    }
  }
 catch (  IOException ioe) {
    LOG.error("Problem in receiving packet from channel.",ioe);
    Thread.currentThread().interrupt();
  }
 finally {
    if (null != this.channel)     try {
      this.channel.socket().close();
      this.channel.close();
    }
 catch (    IOException ioe) {
      LOG.error("Error closing supervisor channel.",ioe);
    }
  }
  return null;
}

ID 1226=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateFile(java.lang.String)
Rmethod: java.io.FileInputStream#FileInputStream(java.lang.String)
hasForStatement: false
parentException: IOException Exception Throwable 
thrown: java.io.FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (Exception e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateFile(String fileName){
  FileInputStream fis=null;
  int bytesRemain;
  StringBuilder sb=new StringBuilder();
  try {
    fis=new FileInputStream(fileName);
    while ((bytesRemain=fis.available()) > 0) {
      byte[] data=new byte[bytesRemain];
      int bytesRead=fis.read(data);
      if (bytesRead == -1) {
        break;
      }
      sb.append(new String(data));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1227=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateFile(java.lang.String)
Rmethod: java.io.FileInputStream#available()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (Exception e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateFile(String fileName){
  FileInputStream fis=null;
  int bytesRemain;
  StringBuilder sb=new StringBuilder();
  try {
    fis=new FileInputStream(fileName);
    while ((bytesRemain=fis.available()) > 0) {
      byte[] data=new byte[bytesRemain];
      int bytesRead=fis.read(data);
      if (bytesRead == -1) {
        break;
      }
      sb.append(new String(data));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1228=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateFile(java.lang.String)
Rmethod: java.io.FileInputStream#read(byte[])
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (Exception e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateFile(String fileName){
  FileInputStream fis=null;
  int bytesRemain;
  StringBuilder sb=new StringBuilder();
  try {
    fis=new FileInputStream(fileName);
    while ((bytesRemain=fis.available()) > 0) {
      byte[] data=new byte[bytesRemain];
      int bytesRead=fis.read(data);
      if (bytesRead == -1) {
        break;
      }
      sb.append(new String(data));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1229=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateFile(java.lang.String)
Rmethod: java.io.FileInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateFile(String fileName){
  FileInputStream fis=null;
  int bytesRemain;
  StringBuilder sb=new StringBuilder();
  try {
    fis=new FileInputStream(fileName);
    while ((bytesRemain=fis.available()) > 0) {
      byte[] data=new byte[bytesRemain];
      int bytesRead=fis.read(data);
      if (bytesRead == -1) {
        break;
      }
      sb.append(new String(data));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1230=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateResource(java.lang.String)
Rmethod: java.io.BufferedReader#readLine()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (Exception e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateResource(String fileName){
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=this.getClass().getClassLoader();
  }
  InputStream is=classLoader.getResourceAsStream(fileName);
  InputStreamReader isr=new InputStreamReader(is);
  BufferedReader br=new BufferedReader(isr);
  StringBuffer sb=new StringBuffer();
  String line;
  try {
    while ((line=br.readLine()) != null) {
      sb.append(line);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (br != null) {
      try {
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (isr != null) {
      try {
        isr.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1231=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateResource(java.lang.String)
Rmethod: java.io.BufferedReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateResource(String fileName){
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=this.getClass().getClassLoader();
  }
  InputStream is=classLoader.getResourceAsStream(fileName);
  InputStreamReader isr=new InputStreamReader(is);
  BufferedReader br=new BufferedReader(isr);
  StringBuffer sb=new StringBuffer();
  String line;
  try {
    while ((line=br.readLine()) != null) {
      sb.append(line);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (br != null) {
      try {
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (isr != null) {
      try {
        isr.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1232=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateResource(java.lang.String)
Rmethod: java.io.InputStreamReader#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateResource(String fileName){
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=this.getClass().getClassLoader();
  }
  InputStream is=classLoader.getResourceAsStream(fileName);
  InputStreamReader isr=new InputStreamReader(is);
  BufferedReader br=new BufferedReader(isr);
  StringBuffer sb=new StringBuffer();
  String line;
  try {
    while ((line=br.readLine()) != null) {
      sb.append(line);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (br != null) {
      try {
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (isr != null) {
      try {
        isr.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1233=========================================================================type: Recover
package: org.apache.hama.manager.util
Method:org.apache.hama.manager.util.UITemplate#loadTemplateResource(java.lang.String)
Rmethod: java.io.InputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * read template file contents
 * @param template fileName
 */

catch: 
catch (IOException e) {
  e.printStackTrace();
}

block: 
UITemplate
/** 
 * read template file contents
 * @param template fileName
 */
protected String loadTemplateResource(String fileName){
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=this.getClass().getClassLoader();
  }
  InputStream is=classLoader.getResourceAsStream(fileName);
  InputStreamReader isr=new InputStreamReader(is);
  BufferedReader br=new BufferedReader(isr);
  StringBuffer sb=new StringBuffer();
  String line;
  try {
    while ((line=br.readLine()) != null) {
      sb.append(line);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (br != null) {
      try {
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (isr != null) {
      try {
        isr.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return sb.toString();
}

ID 1234=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.UnsafeByteArrayOutputStream#writeBytes(java.lang.String)
Rmethod: org.apache.hama.util.UnsafeByteArrayOutputStream#writeByte(int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UnsafeByteArrayOutputStream
@Override public void writeBytes(String s) throws IOException {
  int len=s.length();
  ensureSize(len);
  for (int i=0; i < len; i++) {
    int v=s.charAt(i);
    writeByte(v);
  }
}

ID 1235=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.UnsafeByteArrayOutputStream#writeChars(java.lang.String)
Rmethod: org.apache.hama.util.UnsafeByteArrayOutputStream#writeChar(int)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UnsafeByteArrayOutputStream
@Override public void writeChars(String s) throws IOException {
  int len=s.length();
  ensureSize(len * ByteUtils.SIZE_OF_CHAR);
  for (int i=0; i < len; i++) {
    int v=s.charAt(i);
    writeChar(v);
  }
}

ID 1236=========================================================================type: only_throws
package: org.apache.hama.util
Method:org.apache.hama.util.UnsafeByteArrayOutputStream#writeUTF(java.lang.String)
Rmethod: org.apache.hama.util.UnsafeByteArrayOutputStream#writeShort(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UnsafeByteArrayOutputStream
@Override public void writeUTF(String s) throws IOException {
  int strlen=s.length();
  int utflen=0;
  int c;
  for (int i=0; i < strlen; i++) {
    c=s.charAt(i);
    if ((c >= 0x0001) && (c <= 0x007F)) {
      utflen++;
    }
 else     if (c > 0x07FF) {
      utflen+=3;
    }
 else {
      utflen+=2;
    }
  }
  ensureSize(utflen + ByteUtils.SIZE_OF_SHORT);
  writeShort(utflen);
  int i=0;
  for (i=0; i < strlen; i++) {
    c=s.charAt(i);
    if (!((c >= 0x0001) && (c <= 0x007F))) {
      break;
    }
    buf[pos++]=(byte)c;
  }
  for (; i < strlen; i++) {
    c=s.charAt(i);
    if ((c >= 0x0001) && (c <= 0x007F)) {
      buf[pos++]=(byte)c;
    }
 else     if (c > 0x07FF) {
      buf[pos++]=(byte)(0xE0 | ((c >> 12) & 0x0F));
      buf[pos++]=(byte)(0x80 | ((c >> 6) & 0x3F));
      buf[pos++]=(byte)(0x80 | ((c >> 0) & 0x3F));
    }
 else {
      buf[pos++]=(byte)(0xC0 | ((c >> 6) & 0x1F));
      buf[pos++]=(byte)(0x80 | ((c >> 0) & 0x3F));
    }
  }
}

ID 1237=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#readCommand()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1238=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#writeKeyValue()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1239=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#readKeyValue()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1240=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#incrementCounter()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1241=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#sendMessage()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1242=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#sendMessage()
hasForStatement: true
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1243=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#sendMessage()
hasForStatement: true
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1244=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#getMessageCount()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1245=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#getMessage()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1246=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#sync()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1247=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#sync()
hasForStatement: true
parentException: Object 
thrown: org.apache.hama.pipes.protocol.SyncException
exception comment: null
method comment: null
catch: 
null
block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1248=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#sync()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1249=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#getAllPeerNames()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1250=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#getPeerName()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1251=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#getPeerIndex()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1252=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#getPeerCount()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1253=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#getSuperstepCount()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1254=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#reopenInput()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1255=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#clear()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1256=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#seqFileOpen()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1257=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#seqFileReadNext()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1258=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#seqFileAppend()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1259=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#seqFileClose()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1260=========================================================================type: Rethrow
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#run()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#partitionResponse()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Throwable e) {
  onError(e);
  throw new RuntimeException(e);
}

block: 
UplinkReader
@Override public void run(){
  while (true) {
    try {
      if (Thread.currentThread().isInterrupted()) {
        throw new InterruptedException();
      }
      int cmd=readCommand();
      LOG.debug("Handling uplink command: " + cmd);
      if (cmd == -1) {
        continue;
      }
 else       if (cmd == MessageType.WRITE_KEYVALUE.code && isPeerAvailable()) {
        writeKeyValue();
      }
 else       if (cmd == MessageType.READ_KEYVALUE.code && isPeerAvailable()) {
        readKeyValue();
      }
 else       if (cmd == MessageType.INCREMENT_COUNTER.code && isPeerAvailable()) {
        incrementCounter();
      }
 else       if (cmd == MessageType.REGISTER_COUNTER.code && isPeerAvailable()) {
      }
 else       if (cmd == MessageType.TASK_DONE.code) {
synchronized (binProtocol.hasTaskLock) {
          binProtocol.setHasTask(false);
          LOG.debug("Got MessageType.TASK_DONE");
          binProtocol.hasTaskLock.notify();
        }
      }
 else       if (cmd == MessageType.DONE.code) {
        LOG.debug("Pipe child done");
        return;
      }
 else       if (cmd == MessageType.SEND_MSG.code && isPeerAvailable()) {
        sendMessage();
      }
 else       if (cmd == MessageType.GET_MSG_COUNT.code && isPeerAvailable()) {
        getMessageCount();
      }
 else       if (cmd == MessageType.GET_MSG.code && isPeerAvailable()) {
        getMessage();
      }
 else       if (cmd == MessageType.SYNC.code && isPeerAvailable()) {
        sync();
      }
 else       if (cmd == MessageType.GET_ALL_PEERNAME.code && isPeerAvailable()) {
        getAllPeerNames();
      }
 else       if (cmd == MessageType.GET_PEERNAME.code && isPeerAvailable()) {
        getPeerName();
      }
 else       if (cmd == MessageType.GET_PEER_INDEX.code && isPeerAvailable()) {
        getPeerIndex();
      }
 else       if (cmd == MessageType.GET_PEER_COUNT.code && isPeerAvailable()) {
        getPeerCount();
      }
 else       if (cmd == MessageType.GET_SUPERSTEP_COUNT.code && isPeerAvailable()) {
        getSuperstepCount();
      }
 else       if (cmd == MessageType.REOPEN_INPUT.code && isPeerAvailable()) {
        reopenInput();
      }
 else       if (cmd == MessageType.CLEAR.code && isPeerAvailable()) {
        clear();
      }
 else       if (cmd == MessageType.SEQFILE_OPEN.code) {
        seqFileOpen();
      }
 else       if (cmd == MessageType.SEQFILE_READNEXT.code) {
        seqFileReadNext();
      }
 else       if (cmd == MessageType.SEQFILE_APPEND.code) {
        seqFileAppend();
      }
 else       if (cmd == MessageType.SEQFILE_CLOSE.code) {
        seqFileClose();
      }
 else       if (cmd == MessageType.PARTITION_RESPONSE.code) {
        partitionResponse();
      }
 else {
        throw new Exception("Bad command code: " + cmd);
      }
    }
 catch (    InterruptedException e) {
      onError(e);
      return;
    }
catch (    Throwable e) {
      onError(e);
      throw new RuntimeException(e);
    }
  }
}

ID 1261=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#closeConnection()
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UplinkReader
public void closeConnection() throws IOException {
  this.inStream.close();
  for (  int fileID : this.sequenceFileReaders.keySet()) {
    LOG.debug("close SequenceFileReader: " + fileID);
    this.sequenceFileReaders.get(fileID).getKey().close();
  }
  for (  int fileID : this.sequenceFileWriters.keySet()) {
    LOG.debug("close SequenceFileWriter: " + fileID);
    this.sequenceFileWriters.get(fileID).getKey().close();
  }
}

ID 1262=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#sendMessage()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#readObject(Writable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UplinkReader
@SuppressWarnings("unchecked") public void sendMessage() throws IOException, InstantiationException, IllegalAccessException {
  String peerName=Text.readString(this.inStream);
  M message=(M)ReflectionUtils.newInstance((Class<? extends M>)conf.getClass(Constants.MESSAGE_CLASS,BytesWritable.class),conf);
  LOG.debug("Got MessageType.SEND_MSG peerName: " + peerName + " messageClass: "+ message.getClass().getName());
  readObject(message);
  peer.send(peerName,message);
  WritableUtils.writeVInt(this.outStream,MessageType.SEND_MSG.code);
  binProtocol.flush();
  LOG.debug("Responded MessageType.SEND_MSG");
  LOG.debug("Sent message to peerName: " + peerName + " messageClass: "+ message.getClass().getName()+ " Message: "+ ((message.toString().length() < 10) ? message.toString() : message.toString().substring(0,9) + "..."));
}

ID 1263=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#writeKeyValue()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#readObject(Writable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UplinkReader
@SuppressWarnings("unchecked") public void writeKeyValue() throws IOException {
  KEYOUT keyOut=(KEYOUT)ReflectionUtils.newInstance((Class<? extends KEYOUT>)conf.getClass("bsp.output.key.class",Object.class),conf);
  VALUEOUT valueOut=(VALUEOUT)ReflectionUtils.newInstance((Class<? extends VALUEOUT>)conf.getClass("bsp.output.value.class",Object.class),conf);
  LOG.debug("Got MessageType.WRITE_KEYVALUE keyOutClass: " + keyOut.getClass().getName() + " valueOutClass: "+ valueOut.getClass().getName());
  readObject((Writable)keyOut);
  readObject((Writable)valueOut);
  peer.write(keyOut,valueOut);
  WritableUtils.writeVInt(this.outStream,MessageType.WRITE_KEYVALUE.code);
  binProtocol.flush();
  LOG.debug("Responded MessageType.WRITE_KEYVALUE");
  LOG.debug("Done MessageType.WRITE_KEYVALUE -" + " Key: " + ((keyOut.toString().length() < 10) ? keyOut.toString() : keyOut.toString().substring(0,9) + "...") + " Value: "+ ((valueOut.toString().length() < 10) ? valueOut.toString() : valueOut.toString().substring(0,9) + "..."));
}

ID 1264=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#seqFileAppend()
Rmethod: org.apache.hama.pipes.protocol.UplinkReader#readObject(Writable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UplinkReader
public void seqFileAppend() throws IOException {
  int fileID=WritableUtils.readVInt(this.inStream);
  LOG.debug("GOT MessageType.SEQFILE_APPEND - FileID: " + fileID);
  boolean result=false;
  if (this.sequenceFileWriters.containsKey(fileID)) {
    Writable sequenceKeyWritable=sequenceFileWriters.get(fileID).getValue().getKey();
    Writable sequenceValueWritable=sequenceFileWriters.get(fileID).getValue().getValue();
    readObject(sequenceKeyWritable);
    readObject(sequenceValueWritable);
    if ((sequenceKeyWritable != null) && (sequenceValueWritable != null)) {
      this.sequenceFileWriters.get(fileID).getKey().append(sequenceKeyWritable,sequenceValueWritable);
      LOG.debug("Stored data: Key: " + ((sequenceKeyWritable.toString().length() < 10) ? sequenceKeyWritable.toString() : sequenceKeyWritable.toString().substring(0,9) + "...") + " Value: "+ ((sequenceValueWritable.toString().length() < 10) ? sequenceValueWritable.toString() : sequenceValueWritable.toString().substring(0,9) + "..."));
      result=true;
    }
  }
 else {
    int availableBytes=this.inStream.available();
    this.inStream.skip(availableBytes);
    LOG.debug("MessageType.SEQFILE_APPEND: skip " + availableBytes + " bytes");
    LOG.error("MessageType.SEQFILE_APPEND: FileID " + fileID + " not found!");
  }
  WritableUtils.writeVInt(this.outStream,MessageType.SEQFILE_APPEND.code);
  WritableUtils.writeVInt(this.outStream,result ? 1 : 0);
  binProtocol.flush();
  LOG.debug("Responded MessageType.SEQFILE_APPEND - Result: " + result);
}

ID 1265=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#seqFileAppend()
Rmethod: java.io.FilterInputStream#available()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UplinkReader
public void seqFileAppend() throws IOException {
  int fileID=WritableUtils.readVInt(this.inStream);
  LOG.debug("GOT MessageType.SEQFILE_APPEND - FileID: " + fileID);
  boolean result=false;
  if (this.sequenceFileWriters.containsKey(fileID)) {
    Writable sequenceKeyWritable=sequenceFileWriters.get(fileID).getValue().getKey();
    Writable sequenceValueWritable=sequenceFileWriters.get(fileID).getValue().getValue();
    readObject(sequenceKeyWritable);
    readObject(sequenceValueWritable);
    if ((sequenceKeyWritable != null) && (sequenceValueWritable != null)) {
      this.sequenceFileWriters.get(fileID).getKey().append(sequenceKeyWritable,sequenceValueWritable);
      LOG.debug("Stored data: Key: " + ((sequenceKeyWritable.toString().length() < 10) ? sequenceKeyWritable.toString() : sequenceKeyWritable.toString().substring(0,9) + "...") + " Value: "+ ((sequenceValueWritable.toString().length() < 10) ? sequenceValueWritable.toString() : sequenceValueWritable.toString().substring(0,9) + "..."));
      result=true;
    }
  }
 else {
    int availableBytes=this.inStream.available();
    this.inStream.skip(availableBytes);
    LOG.debug("MessageType.SEQFILE_APPEND: skip " + availableBytes + " bytes");
    LOG.error("MessageType.SEQFILE_APPEND: FileID " + fileID + " not found!");
  }
  WritableUtils.writeVInt(this.outStream,MessageType.SEQFILE_APPEND.code);
  WritableUtils.writeVInt(this.outStream,result ? 1 : 0);
  binProtocol.flush();
  LOG.debug("Responded MessageType.SEQFILE_APPEND - Result: " + result);
}

ID 1266=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#seqFileAppend()
Rmethod: java.io.FilterInputStream#skip(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
UplinkReader
public void seqFileAppend() throws IOException {
  int fileID=WritableUtils.readVInt(this.inStream);
  LOG.debug("GOT MessageType.SEQFILE_APPEND - FileID: " + fileID);
  boolean result=false;
  if (this.sequenceFileWriters.containsKey(fileID)) {
    Writable sequenceKeyWritable=sequenceFileWriters.get(fileID).getValue().getKey();
    Writable sequenceValueWritable=sequenceFileWriters.get(fileID).getValue().getValue();
    readObject(sequenceKeyWritable);
    readObject(sequenceValueWritable);
    if ((sequenceKeyWritable != null) && (sequenceValueWritable != null)) {
      this.sequenceFileWriters.get(fileID).getKey().append(sequenceKeyWritable,sequenceValueWritable);
      LOG.debug("Stored data: Key: " + ((sequenceKeyWritable.toString().length() < 10) ? sequenceKeyWritable.toString() : sequenceKeyWritable.toString().substring(0,9) + "...") + " Value: "+ ((sequenceValueWritable.toString().length() < 10) ? sequenceValueWritable.toString() : sequenceValueWritable.toString().substring(0,9) + "..."));
      result=true;
    }
  }
 else {
    int availableBytes=this.inStream.available();
    this.inStream.skip(availableBytes);
    LOG.debug("MessageType.SEQFILE_APPEND: skip " + availableBytes + " bytes");
    LOG.error("MessageType.SEQFILE_APPEND: FileID " + fileID + " not found!");
  }
  WritableUtils.writeVInt(this.outStream,MessageType.SEQFILE_APPEND.code);
  WritableUtils.writeVInt(this.outStream,result ? 1 : 0);
  binProtocol.flush();
  LOG.debug("Responded MessageType.SEQFILE_APPEND - Result: " + result);
}

ID 1267=========================================================================type: only_throws
package: org.apache.hama.pipes.protocol
Method:org.apache.hama.pipes.protocol.UplinkReader#readObject(Writable)
Rmethod: java.io.DataInputStream#readFully(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read the given object from stream. If it is a IntWritable, LongWritable, FloatWritable, DoubleWritable, Text or BytesWritable, read it directly. Otherwise, read it to a buffer and then write the length and data to the stream.
 * @param obj the object to read
 * @throws IOException
 */

catch: 
null
block: 
UplinkReader
/** 
 * Read the given object from stream. If it is a IntWritable, LongWritable, FloatWritable, DoubleWritable, Text or BytesWritable, read it directly. Otherwise, read it to a buffer and then write the length and data to the stream.
 * @param obj the object to read
 * @throws IOException
 */
protected void readObject(Writable obj) throws IOException {
  byte[] buffer;
  if (obj instanceof Text) {
    int numBytes=WritableUtils.readVInt(this.inStream);
    buffer=new byte[numBytes];
    this.inStream.readFully(buffer);
    ((Text)obj).set(buffer);
  }
 else   if (obj instanceof BytesWritable) {
    int numBytes=WritableUtils.readVInt(this.inStream);
    buffer=new byte[numBytes];
    this.inStream.readFully(buffer);
    ((BytesWritable)obj).set(buffer,0,numBytes);
  }
 else   if (obj instanceof IntWritable) {
    ((IntWritable)obj).set(WritableUtils.readVInt(this.inStream));
  }
 else   if (obj instanceof LongWritable) {
    ((LongWritable)obj).set(WritableUtils.readVLong(this.inStream));
  }
 else {
    try {
      LOG.debug("reading type: " + obj.getClass().getName());
      obj.readFields(this.inStream);
    }
 catch (    IOException e) {
      throw new IOException("Hama Pipes is not able to read " + obj.getClass().getName(),e);
    }
  }
}

ID 1268=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.VectorDoubleFileInputFormat#getRecordReader(InputSplit, BSPJob)
Rmethod: org.apache.hama.ml.regression.VectorDoubleRecorderReader#VectorDoubleRecorderReader(Configuration, FileSplit)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorDoubleFileInputFormat
@Override public RecordReader<VectorWritable,DoubleWritable> getRecordReader(InputSplit split,BSPJob job) throws IOException {
  return new VectorDoubleRecorderReader(job.getConfiguration(),(FileSplit)split);
}

ID 1269=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.VectorDoubleRecorderReader#VectorDoubleRecorderReader(Configuration, FileSplit)
Rmethod: org.apache.hama.ml.regression.LineReader#LineReader(java.io.InputStream, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorDoubleRecorderReader
public VectorDoubleRecorderReader(Configuration job,FileSplit split) throws IOException {
  this.maxLineLength=job.getInt("bsp.linerecordreader.maxlength",Integer.MAX_VALUE);
  start=split.getStart();
  end=start + split.getLength();
  final Path file=split.getPath();
  compressionCodecs=new CompressionCodecFactory(job);
  final CompressionCodec codec=compressionCodecs.getCodec(file);
  FileSystem fs=file.getFileSystem(job);
  FSDataInputStream fileIn=fs.open(split.getPath());
  boolean skipFirstLine=false;
  if (codec != null) {
    in=new LineReader(codec.createInputStream(fileIn),job);
    end=Long.MAX_VALUE;
  }
 else {
    if (start != 0) {
      skipFirstLine=true;
      --start;
      fileIn.seek(start);
    }
    in=new LineReader(fileIn,job);
  }
  if (skipFirstLine) {
    start+=in.readLine(new Text(),0,(int)Math.min(Integer.MAX_VALUE,end - start));
  }
  this.pos=start;
}

ID 1270=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.VectorDoubleRecorderReader#VectorDoubleRecorderReader(java.io.InputStream, long, long, Configuration)
Rmethod: org.apache.hama.ml.regression.LineReader#LineReader(java.io.InputStream, Configuration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorDoubleRecorderReader
public VectorDoubleRecorderReader(InputStream in,long offset,long endOffset,Configuration job) throws IOException {
  this.maxLineLength=job.getInt("bsp.linerecordreader.maxlength",Integer.MAX_VALUE);
  this.in=new LineReader(in,job);
  this.start=offset;
  this.pos=offset;
  this.end=endOffset;
}

ID 1271=========================================================================type: only_throws
package: org.apache.hama.ml.regression
Method:org.apache.hama.ml.regression.VectorDoubleRecorderReader#next(VectorWritable, DoubleWritable)
Rmethod: java.lang.Double#valueOf(java.lang.String)
hasForStatement: true
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: /** 
 * Read a line.
 */

catch: 
null
block: 
VectorDoubleRecorderReader
/** 
 * Read a line.
 */
@Override public synchronized boolean next(VectorWritable key,DoubleWritable value) throws IOException {
  while (pos < end) {
    Text textVal=new Text();
    int newSize=in.readLine(textVal,maxLineLength,Math.max((int)Math.min(Integer.MAX_VALUE,end - pos),maxLineLength));
    if (newSize == 0) {
      return false;
    }
    String[] kv=new String(textVal.getBytes()).split(">");
    if (kv.length != 2) {
      throw new IOException("a line was not parsed correctly");
    }
    value.set(Double.valueOf(kv[0]));
    key.set(toDoubleVector(kv[1]));
    if (LOG.isDebugEnabled()) {
      LOG.info("reading " + kv[1] + ":"+ kv[0]);
    }
    pos+=newSize;
    if (newSize < maxLineLength) {
      return true;
    }
    LOG.info("Skipped line of size " + newSize + " at pos "+ (pos - newSize));
  }
  return false;
}

ID 1272=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#write(java.io.DataOutput)
Rmethod: org.apache.hama.commons.io.VectorWritable#writeVector(DoubleVector, java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
@Override public void write(DataOutput out) throws IOException {
  writeVector(this.vector,out);
}

ID 1273=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#readFields(java.io.DataInput)
Rmethod: org.apache.hama.commons.io.VectorWritable#readVector(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
@Override public void readFields(DataInput in) throws IOException {
  this.vector=readVector(in);
}

ID 1274=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#writeVector(DoubleVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static void writeVector(DoubleVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeDouble(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 1275=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#writeVector(DoubleVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeDouble(double)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static void writeVector(DoubleVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeDouble(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 1276=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#writeVector(DoubleVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static void writeVector(DoubleVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeDouble(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 1277=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#writeVector(DoubleVector, java.io.DataOutput)
Rmethod: java.io.DataOutput#writeUTF(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static void writeVector(DoubleVector vector,DataOutput out) throws IOException {
  out.writeInt(vector.getLength());
  for (int i=0; i < vector.getDimension(); i++) {
    out.writeDouble(vector.get(i));
  }
  if (vector.isNamed() && vector.getName() != null) {
    out.writeBoolean(true);
    out.writeUTF(vector.getName());
  }
 else {
    out.writeBoolean(false);
  }
}

ID 1278=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static DoubleVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  DoubleVector vector;
  vector=new DenseDoubleVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readDouble());
  }
  if (in.readBoolean()) {
    vector=new NamedDoubleVector(in.readUTF(),vector);
  }
  return vector;
}

ID 1279=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readDouble()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static DoubleVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  DoubleVector vector;
  vector=new DenseDoubleVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readDouble());
  }
  if (in.readBoolean()) {
    vector=new NamedDoubleVector(in.readUTF(),vector);
  }
  return vector;
}

ID 1280=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static DoubleVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  DoubleVector vector;
  vector=new DenseDoubleVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readDouble());
  }
  if (in.readBoolean()) {
    vector=new NamedDoubleVector(in.readUTF(),vector);
  }
  return vector;
}

ID 1281=========================================================================type: only_throws
package: org.apache.hama.commons.io
Method:org.apache.hama.commons.io.VectorWritable#readVector(java.io.DataInput)
Rmethod: java.io.DataInput#readUTF()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritable
public static DoubleVector readVector(DataInput in) throws IOException {
  int length=in.readInt();
  DoubleVector vector;
  vector=new DenseDoubleVector(length);
  for (int i=0; i < length; i++) {
    vector.set(i,in.readDouble());
  }
  if (in.readBoolean()) {
    vector=new NamedDoubleVector(in.readUTF(),vector);
  }
  return vector;
}

ID 1282=========================================================================type: only_throws
package: org.apache.hama.examples.util
Method:org.apache.hama.examples.util.VectorWritableMatrixGen#main(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritableMatrixGen
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {
  boolean saveTransposed=false;
  boolean usePipesVectorWritable=false;
  double minValue=0;
  double maxValue=1000;
  int precision=3;
  if (args.length < 3) {
    System.out.println("Usage: <rowSize> <colSize> <outputPath>" + " [<saveTransposed=true|false(default)>] [<usePipesVectorWritable=true|false(default)>]" + " [<minValue=" + minValue + ">] [<maxValue="+ maxValue+ ">]"+ " [<precision="+ precision+ ">]");
    System.out.println("e.g., hama jar hama-examples-*.jar gen vectorwritablematrix 10 10 /tmp/matrix.seq");
    System.out.println("      hama jar hama-examples-*.jar gen vectorwritablematrix 10 10 /tmp/matrix.seq" + " false false 0 10 2");
    System.exit(1);
  }
  int rowSize=Integer.parseInt(args[0]);
  int colSize=Integer.parseInt(args[1]);
  Path outputPath=new Path(args[2]);
  if (args.length > 3) {
    saveTransposed=Boolean.parseBoolean(args[3]);
    if (args.length > 4) {
      usePipesVectorWritable=Boolean.parseBoolean(args[4]);
      if (args.length > 5) {
        minValue=Double.parseDouble(args[5]);
        if (args.length > 6) {
          maxValue=Double.parseDouble(args[6]);
          if (args.length > 7) {
            precision=Integer.parseInt(args[7]);
          }
        }
      }
    }
  }
  LOG.debug("rowSize: " + rowSize + " colSize: "+ colSize+ " outputPath: "+ outputPath);
  LOG.debug("saveTransposed: " + saveTransposed + " usePipesVectorWritable: "+ usePipesVectorWritable);
  LOG.debug("minValue: " + minValue + " maxValue: "+ maxValue+ " precision: "+ precision);
  double[][] matrix=createRandomMatrix(rowSize,colSize,new Random(),minValue,maxValue,precision);
  writeMatrix(matrix,outputPath,saveTransposed,usePipesVectorWritable);
}

ID 1283=========================================================================type: only_throws
package: org.apache.hama.examples.util
Method:org.apache.hama.examples.util.VectorWritableMatrixGen#main(java.lang.String[])
Rmethod: java.lang.Double#parseDouble(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
VectorWritableMatrixGen
public static void main(String[] args) throws InterruptedException, IOException, ClassNotFoundException {
  boolean saveTransposed=false;
  boolean usePipesVectorWritable=false;
  double minValue=0;
  double maxValue=1000;
  int precision=3;
  if (args.length < 3) {
    System.out.println("Usage: <rowSize> <colSize> <outputPath>" + " [<saveTransposed=true|false(default)>] [<usePipesVectorWritable=true|false(default)>]" + " [<minValue=" + minValue + ">] [<maxValue="+ maxValue+ ">]"+ " [<precision="+ precision+ ">]");
    System.out.println("e.g., hama jar hama-examples-*.jar gen vectorwritablematrix 10 10 /tmp/matrix.seq");
    System.out.println("      hama jar hama-examples-*.jar gen vectorwritablematrix 10 10 /tmp/matrix.seq" + " false false 0 10 2");
    System.exit(1);
  }
  int rowSize=Integer.parseInt(args[0]);
  int colSize=Integer.parseInt(args[1]);
  Path outputPath=new Path(args[2]);
  if (args.length > 3) {
    saveTransposed=Boolean.parseBoolean(args[3]);
    if (args.length > 4) {
      usePipesVectorWritable=Boolean.parseBoolean(args[4]);
      if (args.length > 5) {
        minValue=Double.parseDouble(args[5]);
        if (args.length > 6) {
          maxValue=Double.parseDouble(args[6]);
          if (args.length > 7) {
            precision=Integer.parseInt(args[7]);
          }
        }
      }
    }
  }
  LOG.debug("rowSize: " + rowSize + " colSize: "+ colSize+ " outputPath: "+ outputPath);
  LOG.debug("saveTransposed: " + saveTransposed + " usePipesVectorWritable: "+ usePipesVectorWritable);
  LOG.debug("minValue: " + minValue + " maxValue: "+ maxValue+ " precision: "+ precision);
  double[][] matrix=createRandomMatrix(rowSize,colSize,new Random(),minValue,maxValue,precision);
  writeMatrix(matrix,outputPath,saveTransposed,usePipesVectorWritable);
}

ID 1284=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#addVertex(V, List<Edge<V,E>>, M)
Rmethod: org.apache.hama.graph.Vertex#alterVertexCounter(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void addVertex(V vertexID,List<Edge<V,E>> edges,M value) throws IOException {
  MapWritable msg=new MapWritable();
  Vertex<V,E,M> vertex=GraphJobRunner.<V,E,M>newVertexInstance(GraphJobRunner.VERTEX_CLASS);
  vertex.setEdges(edges);
  vertex.setValue(value);
  vertex.setVertexID(vertexID);
  msg.put(GraphJobRunner.FLAG_VERTEX_INCREASE,vertex);
  runner.getPeer().send(runner.getHostName(vertexID),new GraphJobMessage(msg));
  alterVertexCounter(1);
}

ID 1285=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#remove()
Rmethod: org.apache.hama.graph.Vertex#alterVertexCounter(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void remove() throws IOException {
  MapWritable msg=new MapWritable();
  msg.put(GraphJobRunner.FLAG_VERTEX_DECREASE,this.vertexID);
  String destPeer=GraphJobRunner.getMasterTask(this.getPeer());
  runner.getPeer().send(destPeer,new GraphJobMessage(msg));
  alterVertexCounter(-1);
}

ID 1286=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    if (this.vertexID == null) {
      this.vertexID=GraphJobRunner.createVertexIDObject();
    }
    this.vertexID.readFields(in);
  }
  if (in.readBoolean()) {
    if (this.value == null) {
      this.value=GraphJobRunner.createVertexValue();
    }
    this.value.readFields(in);
  }
  this.lastComputedSuperstep=in.readLong();
  this.edges=new ArrayList<Edge<V,E>>();
  if (in.readBoolean()) {
    int num=in.readInt();
    if (num > 0) {
      for (int i=0; i < num; ++i) {
        V vertex=GraphJobRunner.createVertexIDObject();
        vertex.readFields(in);
        E edgeCost=null;
        if (in.readBoolean()) {
          edgeCost=GraphJobRunner.createEdgeCostObject();
          edgeCost.readFields(in);
        }
        Edge<V,E> edge=new Edge<V,E>(vertex,edgeCost);
        this.edges.add(edge);
      }
    }
  }
  votedToHalt=in.readBoolean();
  boolean hasMoreContents=in.readBoolean();
  if (hasMoreContents) {
    readState(in);
  }
}

ID 1287=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    if (this.vertexID == null) {
      this.vertexID=GraphJobRunner.createVertexIDObject();
    }
    this.vertexID.readFields(in);
  }
  if (in.readBoolean()) {
    if (this.value == null) {
      this.value=GraphJobRunner.createVertexValue();
    }
    this.value.readFields(in);
  }
  this.lastComputedSuperstep=in.readLong();
  this.edges=new ArrayList<Edge<V,E>>();
  if (in.readBoolean()) {
    int num=in.readInt();
    if (num > 0) {
      for (int i=0; i < num; ++i) {
        V vertex=GraphJobRunner.createVertexIDObject();
        vertex.readFields(in);
        E edgeCost=null;
        if (in.readBoolean()) {
          edgeCost=GraphJobRunner.createEdgeCostObject();
          edgeCost.readFields(in);
        }
        Edge<V,E> edge=new Edge<V,E>(vertex,edgeCost);
        this.edges.add(edge);
      }
    }
  }
  votedToHalt=in.readBoolean();
  boolean hasMoreContents=in.readBoolean();
  if (hasMoreContents) {
    readState(in);
  }
}

ID 1288=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    if (this.vertexID == null) {
      this.vertexID=GraphJobRunner.createVertexIDObject();
    }
    this.vertexID.readFields(in);
  }
  if (in.readBoolean()) {
    if (this.value == null) {
      this.value=GraphJobRunner.createVertexValue();
    }
    this.value.readFields(in);
  }
  this.lastComputedSuperstep=in.readLong();
  this.edges=new ArrayList<Edge<V,E>>();
  if (in.readBoolean()) {
    int num=in.readInt();
    if (num > 0) {
      for (int i=0; i < num; ++i) {
        V vertex=GraphJobRunner.createVertexIDObject();
        vertex.readFields(in);
        E edgeCost=null;
        if (in.readBoolean()) {
          edgeCost=GraphJobRunner.createEdgeCostObject();
          edgeCost.readFields(in);
        }
        Edge<V,E> edge=new Edge<V,E>(vertex,edgeCost);
        this.edges.add(edge);
      }
    }
  }
  votedToHalt=in.readBoolean();
  boolean hasMoreContents=in.readBoolean();
  if (hasMoreContents) {
    readState(in);
  }
}

ID 1289=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#readFields(java.io.DataInput)
Rmethod: java.io.DataInput#readBoolean()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    if (this.vertexID == null) {
      this.vertexID=GraphJobRunner.createVertexIDObject();
    }
    this.vertexID.readFields(in);
  }
  if (in.readBoolean()) {
    if (this.value == null) {
      this.value=GraphJobRunner.createVertexValue();
    }
    this.value.readFields(in);
  }
  this.lastComputedSuperstep=in.readLong();
  this.edges=new ArrayList<Edge<V,E>>();
  if (in.readBoolean()) {
    int num=in.readInt();
    if (num > 0) {
      for (int i=0; i < num; ++i) {
        V vertex=GraphJobRunner.createVertexIDObject();
        vertex.readFields(in);
        E edgeCost=null;
        if (in.readBoolean()) {
          edgeCost=GraphJobRunner.createEdgeCostObject();
          edgeCost.readFields(in);
        }
        Edge<V,E> edge=new Edge<V,E>(vertex,edgeCost);
        this.edges.add(edge);
      }
    }
  }
  votedToHalt=in.readBoolean();
  boolean hasMoreContents=in.readBoolean();
  if (hasMoreContents) {
    readState(in);
  }
}

ID 1290=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#readFields(java.io.DataInput)
Rmethod: org.apache.hama.graph.Vertex#readState(java.io.DataInput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void readFields(DataInput in) throws IOException {
  if (in.readBoolean()) {
    if (this.vertexID == null) {
      this.vertexID=GraphJobRunner.createVertexIDObject();
    }
    this.vertexID.readFields(in);
  }
  if (in.readBoolean()) {
    if (this.value == null) {
      this.value=GraphJobRunner.createVertexValue();
    }
    this.value.readFields(in);
  }
  this.lastComputedSuperstep=in.readLong();
  this.edges=new ArrayList<Edge<V,E>>();
  if (in.readBoolean()) {
    int num=in.readInt();
    if (num > 0) {
      for (int i=0; i < num; ++i) {
        V vertex=GraphJobRunner.createVertexIDObject();
        vertex.readFields(in);
        E edgeCost=null;
        if (in.readBoolean()) {
          edgeCost=GraphJobRunner.createEdgeCostObject();
          edgeCost.readFields(in);
        }
        Edge<V,E> edge=new Edge<V,E>(vertex,edgeCost);
        this.edges.add(edge);
      }
    }
  }
  votedToHalt=in.readBoolean();
  boolean hasMoreContents=in.readBoolean();
  if (hasMoreContents) {
    readState(in);
  }
}

ID 1291=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeBoolean(boolean)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void write(DataOutput out) throws IOException {
  if (vertexID == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    vertexID.write(out);
  }
  if (value == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    value.write(out);
  }
  out.writeLong(lastComputedSuperstep);
  if (this.edges == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.edges.size());
    for (    Edge<V,E> edge : this.edges) {
      edge.getDestinationVertexID().write(out);
      if (edge.getValue() == null) {
        out.writeBoolean(false);
      }
 else {
        out.writeBoolean(true);
        edge.getValue().write(out);
      }
    }
  }
  out.writeBoolean(votedToHalt);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutput customOut=new DataOutputStream(baos);
  boolean hasMoreContents=true;
  try {
    writeState(customOut);
  }
 catch (  NullPointerException e) {
  }
  if (baos.size() == 0) {
    hasMoreContents=false;
  }
  out.writeBoolean(hasMoreContents);
  if (hasMoreContents)   out.write(baos.toByteArray());
}

ID 1292=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeLong(long)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void write(DataOutput out) throws IOException {
  if (vertexID == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    vertexID.write(out);
  }
  if (value == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    value.write(out);
  }
  out.writeLong(lastComputedSuperstep);
  if (this.edges == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.edges.size());
    for (    Edge<V,E> edge : this.edges) {
      edge.getDestinationVertexID().write(out);
      if (edge.getValue() == null) {
        out.writeBoolean(false);
      }
 else {
        out.writeBoolean(true);
        edge.getValue().write(out);
      }
    }
  }
  out.writeBoolean(votedToHalt);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutput customOut=new DataOutputStream(baos);
  boolean hasMoreContents=true;
  try {
    writeState(customOut);
  }
 catch (  NullPointerException e) {
  }
  if (baos.size() == 0) {
    hasMoreContents=false;
  }
  out.writeBoolean(hasMoreContents);
  if (hasMoreContents)   out.write(baos.toByteArray());
}

ID 1293=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#writeInt(int)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void write(DataOutput out) throws IOException {
  if (vertexID == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    vertexID.write(out);
  }
  if (value == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    value.write(out);
  }
  out.writeLong(lastComputedSuperstep);
  if (this.edges == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.edges.size());
    for (    Edge<V,E> edge : this.edges) {
      edge.getDestinationVertexID().write(out);
      if (edge.getValue() == null) {
        out.writeBoolean(false);
      }
 else {
        out.writeBoolean(true);
        edge.getValue().write(out);
      }
    }
  }
  out.writeBoolean(votedToHalt);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutput customOut=new DataOutputStream(baos);
  boolean hasMoreContents=true;
  try {
    writeState(customOut);
  }
 catch (  NullPointerException e) {
  }
  if (baos.size() == 0) {
    hasMoreContents=false;
  }
  out.writeBoolean(hasMoreContents);
  if (hasMoreContents)   out.write(baos.toByteArray());
}

ID 1294=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#write(java.io.DataOutput)
Rmethod: org.apache.hama.graph.Vertex#writeState(java.io.DataOutput)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void write(DataOutput out) throws IOException {
  if (vertexID == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    vertexID.write(out);
  }
  if (value == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    value.write(out);
  }
  out.writeLong(lastComputedSuperstep);
  if (this.edges == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.edges.size());
    for (    Edge<V,E> edge : this.edges) {
      edge.getDestinationVertexID().write(out);
      if (edge.getValue() == null) {
        out.writeBoolean(false);
      }
 else {
        out.writeBoolean(true);
        edge.getValue().write(out);
      }
    }
  }
  out.writeBoolean(votedToHalt);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutput customOut=new DataOutputStream(baos);
  boolean hasMoreContents=true;
  try {
    writeState(customOut);
  }
 catch (  NullPointerException e) {
  }
  if (baos.size() == 0) {
    hasMoreContents=false;
  }
  out.writeBoolean(hasMoreContents);
  if (hasMoreContents)   out.write(baos.toByteArray());
}

ID 1295=========================================================================type: only_throws
package: org.apache.hama.graph
Method:org.apache.hama.graph.Vertex#write(java.io.DataOutput)
Rmethod: java.io.DataOutput#write(byte[])
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
Vertex
@Override public void write(DataOutput out) throws IOException {
  if (vertexID == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    vertexID.write(out);
  }
  if (value == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    value.write(out);
  }
  out.writeLong(lastComputedSuperstep);
  if (this.edges == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(this.edges.size());
    for (    Edge<V,E> edge : this.edges) {
      edge.getDestinationVertexID().write(out);
      if (edge.getValue() == null) {
        out.writeBoolean(false);
      }
 else {
        out.writeBoolean(true);
        edge.getValue().write(out);
      }
    }
  }
  out.writeBoolean(votedToHalt);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  DataOutput customOut=new DataOutputStream(baos);
  boolean hasMoreContents=true;
  try {
    writeState(customOut);
  }
 catch (  NullPointerException e) {
  }
  if (baos.size() == 0) {
    hasMoreContents=false;
  }
  out.writeBoolean(hasMoreContents);
  if (hasMoreContents)   out.write(baos.toByteArray());
}

ID 1296=========================================================================type: Recover
package: org.apache.hama.graph
Method:org.apache.hama.graph.VertexInputReader#convertRecord(KeyValuePair<Writable,Writable>, Configuration)
Rmethod: org.apache.hama.graph.VertexInputReader#parseVertex(KEYIN, VALUEIN, Vertex<V,E,M>)
hasForStatement: false
parentException: Throwable 
thrown: java.lang.Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  vertexCreation=false;
}

block: 
VertexInputReader
@SuppressWarnings("unchecked") @Override public KeyValuePair<Writable,Writable> convertRecord(KeyValuePair<Writable,Writable> inputRecord,Configuration conf) throws IOException {
  Class<Vertex<V,E,M>> vertexClass=(Class<Vertex<V,E,M>>)conf.getClass(GraphJob.VERTEX_CLASS_ATTR,Vertex.class);
  boolean vertexCreation;
  Vertex<V,E,M> vertex=GraphJobRunner.<V,E,M>newVertexInstance(vertexClass);
  try {
    vertexCreation=parseVertex((KEYIN)inputRecord.getKey(),(VALUEIN)inputRecord.getValue(),vertex);
  }
 catch (  Exception e) {
    vertexCreation=false;
  }
  if (!vertexCreation) {
    throw new IOException("Error parsing vertex. Please check your vertex input reader.");
  }
  outputRecord.setKey(vertex.getVertexID());
  outputRecord.setValue(vertex);
  return outputRecord;
}

ID 1297=========================================================================type: Recover
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WrappedRecordReader#WrappedRecordReader(int, RecordReader<K,U>, Class<? extends WritableComparator>)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

method comment: /** 
 * For a given RecordReader rr, occupy position id in collector.
 */

catch: 
catch (InstantiationException e) {
  throw (IOException)new IOException().initCause(e);
}

block: 
WrappedRecordReader
/** 
 * For a given RecordReader rr, occupy position id in collector.
 */
WrappedRecordReader(int id,RecordReader<K,U> rr,Class<? extends WritableComparator> cmpcl) throws IOException {
  this.id=id;
  this.rr=rr;
  khead=rr.createKey();
  vhead=rr.createValue();
  try {
    cmp=(null == cmpcl) ? WritableComparator.get(khead.getClass()) : cmpcl.newInstance();
  }
 catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
  vjoin=new StreamBackedIterator<U>();
  next();
}

ID 1298=========================================================================type: Recover
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WrappedRecordReader#WrappedRecordReader(int, RecordReader<K,U>, Class<? extends WritableComparator>)
Rmethod: java.lang.Class#newInstance()
hasForStatement: false
parentException: ReflectiveOperationException Exception Throwable 
thrown: java.lang.IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

method comment: /** 
 * For a given RecordReader rr, occupy position id in collector.
 */

catch: 
catch (IllegalAccessException e) {
  throw (IOException)new IOException().initCause(e);
}

block: 
WrappedRecordReader
/** 
 * For a given RecordReader rr, occupy position id in collector.
 */
WrappedRecordReader(int id,RecordReader<K,U> rr,Class<? extends WritableComparator> cmpcl) throws IOException {
  this.id=id;
  this.rr=rr;
  khead=rr.createKey();
  vhead=rr.createValue();
  try {
    cmp=(null == cmpcl) ? WritableComparator.get(khead.getClass()) : cmpcl.newInstance();
  }
 catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
  vjoin=new StreamBackedIterator<U>();
  next();
}

ID 1299=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WrappedRecordReader#WrappedRecordReader(int, RecordReader<K,U>, Class<? extends WritableComparator>)
Rmethod: org.apache.hama.bsp.join.WrappedRecordReader#next()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * For a given RecordReader rr, occupy position id in collector.
 */

catch: 
null
block: 
WrappedRecordReader
/** 
 * For a given RecordReader rr, occupy position id in collector.
 */
WrappedRecordReader(int id,RecordReader<K,U> rr,Class<? extends WritableComparator> cmpcl) throws IOException {
  this.id=id;
  this.rr=rr;
  khead=rr.createKey();
  vhead=rr.createValue();
  try {
    cmp=(null == cmpcl) ? WritableComparator.get(khead.getClass()) : cmpcl.newInstance();
  }
 catch (  InstantiationException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  IllegalAccessException e) {
    throw (IOException)new IOException().initCause(e);
  }
  vjoin=new StreamBackedIterator<U>();
  next();
}

ID 1300=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WrappedRecordReader#skip(K)
Rmethod: org.apache.hama.bsp.join.WrappedRecordReader#next()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Skip key-value pairs with keys less than or equal to the key provided.
 */

catch: 
null
block: 
WrappedRecordReader
/** 
 * Skip key-value pairs with keys less than or equal to the key provided.
 */
public void skip(K key) throws IOException {
  if (hasNext()) {
    while (cmp.compare(khead,key) <= 0 && next())     ;
  }
}

ID 1301=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WrappedRecordReader#accept(CompositeRecordReader.JoinCollector, K)
Rmethod: org.apache.hama.bsp.join.WrappedRecordReader#next()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Add an iterator to the collector at the position occupied by this RecordReader over the values in this stream paired with the key provided (ie register a stream of values from this source matching K with a collector).
 */

catch: 
null
block: 
WrappedRecordReader
/** 
 * Add an iterator to the collector at the position occupied by this RecordReader over the values in this stream paired with the key provided (ie register a stream of values from this source matching K with a collector).
 */
@SuppressWarnings("unchecked") public void accept(CompositeRecordReader.JoinCollector i,K key) throws IOException {
  vjoin.clear();
  if (0 == cmp.compare(key,khead)) {
    do {
      vjoin.add(vhead);
    }
 while (next() && 0 == cmp.compare(key,khead));
  }
  i.add(id,vjoin);
}

ID 1302=========================================================================type: only_throws
package: org.apache.hama.bsp.join
Method:org.apache.hama.bsp.join.WrappedRecordReader#next(K, U)
Rmethod: org.apache.hama.bsp.join.WrappedRecordReader#next()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Write key-value pair at the head of this stream to the objects provided; get next key-value pair from proxied RR.
 */

catch: 
null
block: 
WrappedRecordReader
/** 
 * Write key-value pair at the head of this stream to the objects provided; get next key-value pair from proxied RR.
 */
public boolean next(K key,U value) throws IOException {
  if (hasNext()) {
    WritableUtils.cloneInto(key,khead);
    WritableUtils.cloneInto(value,vhead);
    next();
    return true;
  }
  return false;
}

ID 1303=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJob#waitForCompletion(boolean)
Rmethod: org.apache.hama.bsp.YARNBSPJob#submit()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YARNBSPJob
@Override public boolean waitForCompletion(boolean verbose) throws IOException, InterruptedException, ClassNotFoundException {
  LOG.info("Starting job...");
  if (!submitted) {
    this.submit();
  }
  if (report != null && report.getApplicationId() == submitClient.getId()) {
    return true;
  }
 else {
    return false;
  }
}

ID 1304=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJob#waitForCompletion(boolean)
Rmethod: org.apache.hama.bsp.YARNBSPJob#submit()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YARNBSPJob
@Override public boolean waitForCompletion(boolean verbose) throws IOException, InterruptedException, ClassNotFoundException {
  LOG.info("Starting job...");
  if (!submitted) {
    this.submit();
  }
  if (report != null && report.getApplicationId() == submitClient.getId()) {
    return true;
  }
 else {
    return false;
  }
}

ID 1305=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#launchJob(BSPJobID, BSPJob, Path, FileSystem)
Rmethod: org.apache.hama.bsp.YARNBSPJobClient#localJarfromPath(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YARNBSPJobClient
@Override protected RunningJob launchJob(BSPJobID jobId,BSPJob normalJob,Path submitJobFile,FileSystem pFs) throws IOException {
  YARNBSPJob job=(YARNBSPJob)normalJob;
  LOG.info("Submitting job...");
  if (getConf().get("bsp.child.mem.in.mb") == null) {
    LOG.warn("BSP Child memory has not been set, YARN will guess your needs or use default values.");
  }
  FileSystem fs=pFs;
  if (fs == null) {
    fs=FileSystem.get(getConf());
  }
  if (getConf().get("bsp.user.name") == null) {
    String s=getUnixUserName();
    getConf().set("bsp.user.name",s);
    LOG.debug("Retrieved username: " + s);
  }
  yarnClient.start();
  try {
    YarnClusterMetrics clusterMetrics=yarnClient.getYarnClusterMetrics();
    LOG.info("Got Cluster metric info from ASM" + ", numNodeManagers=" + clusterMetrics.getNumNodeManagers());
    List<NodeReport> clusterNodeReports=yarnClient.getNodeReports(NodeState.RUNNING);
    LOG.info("Got Cluster node info from ASM");
    for (    NodeReport node : clusterNodeReports) {
      LOG.info("Got node report from ASM for" + ", nodeId=" + node.getNodeId() + ", nodeAddress"+ node.getHttpAddress()+ ", nodeRackName"+ node.getRackName()+ ", nodeNumContainers"+ node.getNumContainers());
    }
    QueueInfo queueInfo=yarnClient.getQueueInfo("default");
    LOG.info("Queue info" + ", queueName=" + queueInfo.getQueueName() + ", queueCurrentCapacity="+ queueInfo.getCurrentCapacity()+ ", queueMaxCapacity="+ queueInfo.getMaximumCapacity()+ ", queueApplicationCount="+ queueInfo.getApplications().size()+ ", queueChildQueueCount="+ queueInfo.getChildQueues().size());
    List<QueueUserACLInfo> listAclInfo=yarnClient.getQueueAclsInfo();
    for (    QueueUserACLInfo aclInfo : listAclInfo) {
      for (      QueueACL userAcl : aclInfo.getUserAcls()) {
        LOG.info("User ACL Info for Queue" + ", queueName=" + aclInfo.getQueueName() + ", userAcl="+ userAcl.name());
      }
    }
    YarnClientApplication app=yarnClient.createApplication();
    ApplicationSubmissionContext appContext=app.getApplicationSubmissionContext();
    id=appContext.getApplicationId();
    appContext.setApplicationName(job.getJobName());
    ContainerLaunchContext amContainer=Records.newRecord(ContainerLaunchContext.class);
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    if (job.getJar() == null) {
      throw new IllegalArgumentException("Jar must be set in order to run the application!");
    }
    Path jarPath=new Path(job.getJar());
    jarPath=fs.makeQualified(jarPath);
    getConf().set("bsp.jar",jarPath.makeQualified(fs.getUri(),jarPath).toString());
    FileStatus jarStatus=fs.getFileStatus(jarPath);
    LocalResource amJarRsrc=Records.newRecord(LocalResource.class);
    amJarRsrc.setType(LocalResourceType.FILE);
    amJarRsrc.setVisibility(LocalResourceVisibility.APPLICATION);
    amJarRsrc.setResource(ConverterUtils.getYarnUrlFromPath(jarPath));
    amJarRsrc.setTimestamp(jarStatus.getModificationTime());
    amJarRsrc.setSize(jarStatus.getLen());
    localResources.put(YARNBSPConstants.APP_MASTER_JAR_PATH,amJarRsrc);
    List<File> hamaJars;
    if (System.getProperty("hama.home.dir") != null)     hamaJars=localJarfromPath(System.getProperty("hama.home.dir"));
 else     hamaJars=localJarfromPath(getConf().get("hama.home.dir"));
    String hamaPath=getSystemDir() + "/hama";
    for (    File fileEntry : hamaJars) {
      addToLocalResources(fs,fileEntry.getCanonicalPath(),hamaPath,fileEntry.getName(),localResources);
    }
    amContainer.setLocalResources(localResources);
    Map<String,String> env=new HashMap<String,String>();
    StringBuilder classPathEnv=new StringBuilder(ApplicationConstants.Environment.CLASSPATH.$()).append(File.pathSeparatorChar).append("./*");
    for (    String c : yarnConf.getStrings(YarnConfiguration.YARN_APPLICATION_CLASSPATH,YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH)) {
      classPathEnv.append(File.pathSeparatorChar);
      classPathEnv.append(c.trim());
    }
    env.put(YARNBSPConstants.HAMA_YARN_LOCATION,jarPath.toUri().toString());
    env.put(YARNBSPConstants.HAMA_YARN_SIZE,Long.toString(jarStatus.getLen()));
    env.put(YARNBSPConstants.HAMA_YARN_TIMESTAMP,Long.toString(jarStatus.getModificationTime()));
    env.put(YARNBSPConstants.HAMA_LOCATION,hamaPath);
    env.put("CLASSPATH",classPathEnv.toString());
    amContainer.setEnvironment(env);
    Vector<CharSequence> vargs=new Vector<CharSequence>(5);
    vargs.add("${JAVA_HOME}/bin/java");
    vargs.add("-cp " + classPathEnv + "");
    vargs.add(ApplicationMaster.class.getCanonicalName());
    vargs.add(submitJobFile.makeQualified(fs.getUri(),fs.getWorkingDirectory()).toString());
    vargs.add("1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stdout");
    vargs.add("2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stderr");
    StringBuilder command=new StringBuilder();
    for (    CharSequence str : vargs) {
      command.append(str).append(" ");
    }
    List<String> commands=new ArrayList<String>();
    commands.add(command.toString());
    amContainer.setCommands(commands);
    LOG.debug("Start command: " + command);
    Resource capability=Records.newRecord(Resource.class);
    capability.setMemory(3 * job.getNumBspTask() + getConf().getInt("hama.appmaster.memory.mb",100));
    LOG.info("Set memory for the application master to " + capability.getMemory() + "mb!");
    appContext.setResource(capability);
    if (UserGroupInformation.isSecurityEnabled()) {
      Credentials credentials=new Credentials();
      String tokenRenewer=yarnConf.get(YarnConfiguration.RM_PRINCIPAL);
      if (tokenRenewer == null || tokenRenewer.length() == 0) {
        throw new IOException("Can't get Master Kerberos principal for the RM to use as renewer");
      }
      final Token<?> tokens[]=fs.addDelegationTokens(tokenRenewer,credentials);
      if (tokens != null) {
        for (        Token<?> token : tokens) {
          LOG.info("Got dt for " + fs.getUri() + "; "+ token);
        }
      }
      DataOutputBuffer dob=new DataOutputBuffer();
      credentials.writeTokenStorageToStream(dob);
      ByteBuffer fsTokens=ByteBuffer.wrap(dob.getData(),0,dob.getLength());
      amContainer.setTokens(fsTokens);
    }
    appContext.setAMContainerSpec(amContainer);
    ApplicationId appId=appContext.getApplicationId();
    yarnClient.submitApplication(appContext);
    return monitorApplication(appId) ? new NetworkedJob() : null;
  }
 catch (  YarnException e) {
    e.printStackTrace();
    return null;
  }
}

ID 1306=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#launchJob(BSPJobID, BSPJob, Path, FileSystem)
Rmethod: java.io.File#getCanonicalPath()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YARNBSPJobClient
@Override protected RunningJob launchJob(BSPJobID jobId,BSPJob normalJob,Path submitJobFile,FileSystem pFs) throws IOException {
  YARNBSPJob job=(YARNBSPJob)normalJob;
  LOG.info("Submitting job...");
  if (getConf().get("bsp.child.mem.in.mb") == null) {
    LOG.warn("BSP Child memory has not been set, YARN will guess your needs or use default values.");
  }
  FileSystem fs=pFs;
  if (fs == null) {
    fs=FileSystem.get(getConf());
  }
  if (getConf().get("bsp.user.name") == null) {
    String s=getUnixUserName();
    getConf().set("bsp.user.name",s);
    LOG.debug("Retrieved username: " + s);
  }
  yarnClient.start();
  try {
    YarnClusterMetrics clusterMetrics=yarnClient.getYarnClusterMetrics();
    LOG.info("Got Cluster metric info from ASM" + ", numNodeManagers=" + clusterMetrics.getNumNodeManagers());
    List<NodeReport> clusterNodeReports=yarnClient.getNodeReports(NodeState.RUNNING);
    LOG.info("Got Cluster node info from ASM");
    for (    NodeReport node : clusterNodeReports) {
      LOG.info("Got node report from ASM for" + ", nodeId=" + node.getNodeId() + ", nodeAddress"+ node.getHttpAddress()+ ", nodeRackName"+ node.getRackName()+ ", nodeNumContainers"+ node.getNumContainers());
    }
    QueueInfo queueInfo=yarnClient.getQueueInfo("default");
    LOG.info("Queue info" + ", queueName=" + queueInfo.getQueueName() + ", queueCurrentCapacity="+ queueInfo.getCurrentCapacity()+ ", queueMaxCapacity="+ queueInfo.getMaximumCapacity()+ ", queueApplicationCount="+ queueInfo.getApplications().size()+ ", queueChildQueueCount="+ queueInfo.getChildQueues().size());
    List<QueueUserACLInfo> listAclInfo=yarnClient.getQueueAclsInfo();
    for (    QueueUserACLInfo aclInfo : listAclInfo) {
      for (      QueueACL userAcl : aclInfo.getUserAcls()) {
        LOG.info("User ACL Info for Queue" + ", queueName=" + aclInfo.getQueueName() + ", userAcl="+ userAcl.name());
      }
    }
    YarnClientApplication app=yarnClient.createApplication();
    ApplicationSubmissionContext appContext=app.getApplicationSubmissionContext();
    id=appContext.getApplicationId();
    appContext.setApplicationName(job.getJobName());
    ContainerLaunchContext amContainer=Records.newRecord(ContainerLaunchContext.class);
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    if (job.getJar() == null) {
      throw new IllegalArgumentException("Jar must be set in order to run the application!");
    }
    Path jarPath=new Path(job.getJar());
    jarPath=fs.makeQualified(jarPath);
    getConf().set("bsp.jar",jarPath.makeQualified(fs.getUri(),jarPath).toString());
    FileStatus jarStatus=fs.getFileStatus(jarPath);
    LocalResource amJarRsrc=Records.newRecord(LocalResource.class);
    amJarRsrc.setType(LocalResourceType.FILE);
    amJarRsrc.setVisibility(LocalResourceVisibility.APPLICATION);
    amJarRsrc.setResource(ConverterUtils.getYarnUrlFromPath(jarPath));
    amJarRsrc.setTimestamp(jarStatus.getModificationTime());
    amJarRsrc.setSize(jarStatus.getLen());
    localResources.put(YARNBSPConstants.APP_MASTER_JAR_PATH,amJarRsrc);
    List<File> hamaJars;
    if (System.getProperty("hama.home.dir") != null)     hamaJars=localJarfromPath(System.getProperty("hama.home.dir"));
 else     hamaJars=localJarfromPath(getConf().get("hama.home.dir"));
    String hamaPath=getSystemDir() + "/hama";
    for (    File fileEntry : hamaJars) {
      addToLocalResources(fs,fileEntry.getCanonicalPath(),hamaPath,fileEntry.getName(),localResources);
    }
    amContainer.setLocalResources(localResources);
    Map<String,String> env=new HashMap<String,String>();
    StringBuilder classPathEnv=new StringBuilder(ApplicationConstants.Environment.CLASSPATH.$()).append(File.pathSeparatorChar).append("./*");
    for (    String c : yarnConf.getStrings(YarnConfiguration.YARN_APPLICATION_CLASSPATH,YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH)) {
      classPathEnv.append(File.pathSeparatorChar);
      classPathEnv.append(c.trim());
    }
    env.put(YARNBSPConstants.HAMA_YARN_LOCATION,jarPath.toUri().toString());
    env.put(YARNBSPConstants.HAMA_YARN_SIZE,Long.toString(jarStatus.getLen()));
    env.put(YARNBSPConstants.HAMA_YARN_TIMESTAMP,Long.toString(jarStatus.getModificationTime()));
    env.put(YARNBSPConstants.HAMA_LOCATION,hamaPath);
    env.put("CLASSPATH",classPathEnv.toString());
    amContainer.setEnvironment(env);
    Vector<CharSequence> vargs=new Vector<CharSequence>(5);
    vargs.add("${JAVA_HOME}/bin/java");
    vargs.add("-cp " + classPathEnv + "");
    vargs.add(ApplicationMaster.class.getCanonicalName());
    vargs.add(submitJobFile.makeQualified(fs.getUri(),fs.getWorkingDirectory()).toString());
    vargs.add("1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stdout");
    vargs.add("2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stderr");
    StringBuilder command=new StringBuilder();
    for (    CharSequence str : vargs) {
      command.append(str).append(" ");
    }
    List<String> commands=new ArrayList<String>();
    commands.add(command.toString());
    amContainer.setCommands(commands);
    LOG.debug("Start command: " + command);
    Resource capability=Records.newRecord(Resource.class);
    capability.setMemory(3 * job.getNumBspTask() + getConf().getInt("hama.appmaster.memory.mb",100));
    LOG.info("Set memory for the application master to " + capability.getMemory() + "mb!");
    appContext.setResource(capability);
    if (UserGroupInformation.isSecurityEnabled()) {
      Credentials credentials=new Credentials();
      String tokenRenewer=yarnConf.get(YarnConfiguration.RM_PRINCIPAL);
      if (tokenRenewer == null || tokenRenewer.length() == 0) {
        throw new IOException("Can't get Master Kerberos principal for the RM to use as renewer");
      }
      final Token<?> tokens[]=fs.addDelegationTokens(tokenRenewer,credentials);
      if (tokens != null) {
        for (        Token<?> token : tokens) {
          LOG.info("Got dt for " + fs.getUri() + "; "+ token);
        }
      }
      DataOutputBuffer dob=new DataOutputBuffer();
      credentials.writeTokenStorageToStream(dob);
      ByteBuffer fsTokens=ByteBuffer.wrap(dob.getData(),0,dob.getLength());
      amContainer.setTokens(fsTokens);
    }
    appContext.setAMContainerSpec(amContainer);
    ApplicationId appId=appContext.getApplicationId();
    yarnClient.submitApplication(appContext);
    return monitorApplication(appId) ? new NetworkedJob() : null;
  }
 catch (  YarnException e) {
    e.printStackTrace();
    return null;
  }
}

ID 1307=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#launchJob(BSPJobID, BSPJob, Path, FileSystem)
Rmethod: org.apache.hama.bsp.YARNBSPJobClient#addToLocalResources(FileSystem, java.lang.String, java.lang.String, java.lang.String, Map<java.lang.String,LocalResource>)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YARNBSPJobClient
@Override protected RunningJob launchJob(BSPJobID jobId,BSPJob normalJob,Path submitJobFile,FileSystem pFs) throws IOException {
  YARNBSPJob job=(YARNBSPJob)normalJob;
  LOG.info("Submitting job...");
  if (getConf().get("bsp.child.mem.in.mb") == null) {
    LOG.warn("BSP Child memory has not been set, YARN will guess your needs or use default values.");
  }
  FileSystem fs=pFs;
  if (fs == null) {
    fs=FileSystem.get(getConf());
  }
  if (getConf().get("bsp.user.name") == null) {
    String s=getUnixUserName();
    getConf().set("bsp.user.name",s);
    LOG.debug("Retrieved username: " + s);
  }
  yarnClient.start();
  try {
    YarnClusterMetrics clusterMetrics=yarnClient.getYarnClusterMetrics();
    LOG.info("Got Cluster metric info from ASM" + ", numNodeManagers=" + clusterMetrics.getNumNodeManagers());
    List<NodeReport> clusterNodeReports=yarnClient.getNodeReports(NodeState.RUNNING);
    LOG.info("Got Cluster node info from ASM");
    for (    NodeReport node : clusterNodeReports) {
      LOG.info("Got node report from ASM for" + ", nodeId=" + node.getNodeId() + ", nodeAddress"+ node.getHttpAddress()+ ", nodeRackName"+ node.getRackName()+ ", nodeNumContainers"+ node.getNumContainers());
    }
    QueueInfo queueInfo=yarnClient.getQueueInfo("default");
    LOG.info("Queue info" + ", queueName=" + queueInfo.getQueueName() + ", queueCurrentCapacity="+ queueInfo.getCurrentCapacity()+ ", queueMaxCapacity="+ queueInfo.getMaximumCapacity()+ ", queueApplicationCount="+ queueInfo.getApplications().size()+ ", queueChildQueueCount="+ queueInfo.getChildQueues().size());
    List<QueueUserACLInfo> listAclInfo=yarnClient.getQueueAclsInfo();
    for (    QueueUserACLInfo aclInfo : listAclInfo) {
      for (      QueueACL userAcl : aclInfo.getUserAcls()) {
        LOG.info("User ACL Info for Queue" + ", queueName=" + aclInfo.getQueueName() + ", userAcl="+ userAcl.name());
      }
    }
    YarnClientApplication app=yarnClient.createApplication();
    ApplicationSubmissionContext appContext=app.getApplicationSubmissionContext();
    id=appContext.getApplicationId();
    appContext.setApplicationName(job.getJobName());
    ContainerLaunchContext amContainer=Records.newRecord(ContainerLaunchContext.class);
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    if (job.getJar() == null) {
      throw new IllegalArgumentException("Jar must be set in order to run the application!");
    }
    Path jarPath=new Path(job.getJar());
    jarPath=fs.makeQualified(jarPath);
    getConf().set("bsp.jar",jarPath.makeQualified(fs.getUri(),jarPath).toString());
    FileStatus jarStatus=fs.getFileStatus(jarPath);
    LocalResource amJarRsrc=Records.newRecord(LocalResource.class);
    amJarRsrc.setType(LocalResourceType.FILE);
    amJarRsrc.setVisibility(LocalResourceVisibility.APPLICATION);
    amJarRsrc.setResource(ConverterUtils.getYarnUrlFromPath(jarPath));
    amJarRsrc.setTimestamp(jarStatus.getModificationTime());
    amJarRsrc.setSize(jarStatus.getLen());
    localResources.put(YARNBSPConstants.APP_MASTER_JAR_PATH,amJarRsrc);
    List<File> hamaJars;
    if (System.getProperty("hama.home.dir") != null)     hamaJars=localJarfromPath(System.getProperty("hama.home.dir"));
 else     hamaJars=localJarfromPath(getConf().get("hama.home.dir"));
    String hamaPath=getSystemDir() + "/hama";
    for (    File fileEntry : hamaJars) {
      addToLocalResources(fs,fileEntry.getCanonicalPath(),hamaPath,fileEntry.getName(),localResources);
    }
    amContainer.setLocalResources(localResources);
    Map<String,String> env=new HashMap<String,String>();
    StringBuilder classPathEnv=new StringBuilder(ApplicationConstants.Environment.CLASSPATH.$()).append(File.pathSeparatorChar).append("./*");
    for (    String c : yarnConf.getStrings(YarnConfiguration.YARN_APPLICATION_CLASSPATH,YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH)) {
      classPathEnv.append(File.pathSeparatorChar);
      classPathEnv.append(c.trim());
    }
    env.put(YARNBSPConstants.HAMA_YARN_LOCATION,jarPath.toUri().toString());
    env.put(YARNBSPConstants.HAMA_YARN_SIZE,Long.toString(jarStatus.getLen()));
    env.put(YARNBSPConstants.HAMA_YARN_TIMESTAMP,Long.toString(jarStatus.getModificationTime()));
    env.put(YARNBSPConstants.HAMA_LOCATION,hamaPath);
    env.put("CLASSPATH",classPathEnv.toString());
    amContainer.setEnvironment(env);
    Vector<CharSequence> vargs=new Vector<CharSequence>(5);
    vargs.add("${JAVA_HOME}/bin/java");
    vargs.add("-cp " + classPathEnv + "");
    vargs.add(ApplicationMaster.class.getCanonicalName());
    vargs.add(submitJobFile.makeQualified(fs.getUri(),fs.getWorkingDirectory()).toString());
    vargs.add("1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stdout");
    vargs.add("2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stderr");
    StringBuilder command=new StringBuilder();
    for (    CharSequence str : vargs) {
      command.append(str).append(" ");
    }
    List<String> commands=new ArrayList<String>();
    commands.add(command.toString());
    amContainer.setCommands(commands);
    LOG.debug("Start command: " + command);
    Resource capability=Records.newRecord(Resource.class);
    capability.setMemory(3 * job.getNumBspTask() + getConf().getInt("hama.appmaster.memory.mb",100));
    LOG.info("Set memory for the application master to " + capability.getMemory() + "mb!");
    appContext.setResource(capability);
    if (UserGroupInformation.isSecurityEnabled()) {
      Credentials credentials=new Credentials();
      String tokenRenewer=yarnConf.get(YarnConfiguration.RM_PRINCIPAL);
      if (tokenRenewer == null || tokenRenewer.length() == 0) {
        throw new IOException("Can't get Master Kerberos principal for the RM to use as renewer");
      }
      final Token<?> tokens[]=fs.addDelegationTokens(tokenRenewer,credentials);
      if (tokens != null) {
        for (        Token<?> token : tokens) {
          LOG.info("Got dt for " + fs.getUri() + "; "+ token);
        }
      }
      DataOutputBuffer dob=new DataOutputBuffer();
      credentials.writeTokenStorageToStream(dob);
      ByteBuffer fsTokens=ByteBuffer.wrap(dob.getData(),0,dob.getLength());
      amContainer.setTokens(fsTokens);
    }
    appContext.setAMContainerSpec(amContainer);
    ApplicationId appId=appContext.getApplicationId();
    yarnClient.submitApplication(appContext);
    return monitorApplication(appId) ? new NetworkedJob() : null;
  }
 catch (  YarnException e) {
    e.printStackTrace();
    return null;
  }
}

ID 1308=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#launchJob(BSPJobID, BSPJob, Path, FileSystem)
Rmethod: org.apache.hama.bsp.YARNBSPJobClient#monitorApplication(ApplicationId)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YARNBSPJobClient
@Override protected RunningJob launchJob(BSPJobID jobId,BSPJob normalJob,Path submitJobFile,FileSystem pFs) throws IOException {
  YARNBSPJob job=(YARNBSPJob)normalJob;
  LOG.info("Submitting job...");
  if (getConf().get("bsp.child.mem.in.mb") == null) {
    LOG.warn("BSP Child memory has not been set, YARN will guess your needs or use default values.");
  }
  FileSystem fs=pFs;
  if (fs == null) {
    fs=FileSystem.get(getConf());
  }
  if (getConf().get("bsp.user.name") == null) {
    String s=getUnixUserName();
    getConf().set("bsp.user.name",s);
    LOG.debug("Retrieved username: " + s);
  }
  yarnClient.start();
  try {
    YarnClusterMetrics clusterMetrics=yarnClient.getYarnClusterMetrics();
    LOG.info("Got Cluster metric info from ASM" + ", numNodeManagers=" + clusterMetrics.getNumNodeManagers());
    List<NodeReport> clusterNodeReports=yarnClient.getNodeReports(NodeState.RUNNING);
    LOG.info("Got Cluster node info from ASM");
    for (    NodeReport node : clusterNodeReports) {
      LOG.info("Got node report from ASM for" + ", nodeId=" + node.getNodeId() + ", nodeAddress"+ node.getHttpAddress()+ ", nodeRackName"+ node.getRackName()+ ", nodeNumContainers"+ node.getNumContainers());
    }
    QueueInfo queueInfo=yarnClient.getQueueInfo("default");
    LOG.info("Queue info" + ", queueName=" + queueInfo.getQueueName() + ", queueCurrentCapacity="+ queueInfo.getCurrentCapacity()+ ", queueMaxCapacity="+ queueInfo.getMaximumCapacity()+ ", queueApplicationCount="+ queueInfo.getApplications().size()+ ", queueChildQueueCount="+ queueInfo.getChildQueues().size());
    List<QueueUserACLInfo> listAclInfo=yarnClient.getQueueAclsInfo();
    for (    QueueUserACLInfo aclInfo : listAclInfo) {
      for (      QueueACL userAcl : aclInfo.getUserAcls()) {
        LOG.info("User ACL Info for Queue" + ", queueName=" + aclInfo.getQueueName() + ", userAcl="+ userAcl.name());
      }
    }
    YarnClientApplication app=yarnClient.createApplication();
    ApplicationSubmissionContext appContext=app.getApplicationSubmissionContext();
    id=appContext.getApplicationId();
    appContext.setApplicationName(job.getJobName());
    ContainerLaunchContext amContainer=Records.newRecord(ContainerLaunchContext.class);
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    if (job.getJar() == null) {
      throw new IllegalArgumentException("Jar must be set in order to run the application!");
    }
    Path jarPath=new Path(job.getJar());
    jarPath=fs.makeQualified(jarPath);
    getConf().set("bsp.jar",jarPath.makeQualified(fs.getUri(),jarPath).toString());
    FileStatus jarStatus=fs.getFileStatus(jarPath);
    LocalResource amJarRsrc=Records.newRecord(LocalResource.class);
    amJarRsrc.setType(LocalResourceType.FILE);
    amJarRsrc.setVisibility(LocalResourceVisibility.APPLICATION);
    amJarRsrc.setResource(ConverterUtils.getYarnUrlFromPath(jarPath));
    amJarRsrc.setTimestamp(jarStatus.getModificationTime());
    amJarRsrc.setSize(jarStatus.getLen());
    localResources.put(YARNBSPConstants.APP_MASTER_JAR_PATH,amJarRsrc);
    List<File> hamaJars;
    if (System.getProperty("hama.home.dir") != null)     hamaJars=localJarfromPath(System.getProperty("hama.home.dir"));
 else     hamaJars=localJarfromPath(getConf().get("hama.home.dir"));
    String hamaPath=getSystemDir() + "/hama";
    for (    File fileEntry : hamaJars) {
      addToLocalResources(fs,fileEntry.getCanonicalPath(),hamaPath,fileEntry.getName(),localResources);
    }
    amContainer.setLocalResources(localResources);
    Map<String,String> env=new HashMap<String,String>();
    StringBuilder classPathEnv=new StringBuilder(ApplicationConstants.Environment.CLASSPATH.$()).append(File.pathSeparatorChar).append("./*");
    for (    String c : yarnConf.getStrings(YarnConfiguration.YARN_APPLICATION_CLASSPATH,YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH)) {
      classPathEnv.append(File.pathSeparatorChar);
      classPathEnv.append(c.trim());
    }
    env.put(YARNBSPConstants.HAMA_YARN_LOCATION,jarPath.toUri().toString());
    env.put(YARNBSPConstants.HAMA_YARN_SIZE,Long.toString(jarStatus.getLen()));
    env.put(YARNBSPConstants.HAMA_YARN_TIMESTAMP,Long.toString(jarStatus.getModificationTime()));
    env.put(YARNBSPConstants.HAMA_LOCATION,hamaPath);
    env.put("CLASSPATH",classPathEnv.toString());
    amContainer.setEnvironment(env);
    Vector<CharSequence> vargs=new Vector<CharSequence>(5);
    vargs.add("${JAVA_HOME}/bin/java");
    vargs.add("-cp " + classPathEnv + "");
    vargs.add(ApplicationMaster.class.getCanonicalName());
    vargs.add(submitJobFile.makeQualified(fs.getUri(),fs.getWorkingDirectory()).toString());
    vargs.add("1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stdout");
    vargs.add("2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stderr");
    StringBuilder command=new StringBuilder();
    for (    CharSequence str : vargs) {
      command.append(str).append(" ");
    }
    List<String> commands=new ArrayList<String>();
    commands.add(command.toString());
    amContainer.setCommands(commands);
    LOG.debug("Start command: " + command);
    Resource capability=Records.newRecord(Resource.class);
    capability.setMemory(3 * job.getNumBspTask() + getConf().getInt("hama.appmaster.memory.mb",100));
    LOG.info("Set memory for the application master to " + capability.getMemory() + "mb!");
    appContext.setResource(capability);
    if (UserGroupInformation.isSecurityEnabled()) {
      Credentials credentials=new Credentials();
      String tokenRenewer=yarnConf.get(YarnConfiguration.RM_PRINCIPAL);
      if (tokenRenewer == null || tokenRenewer.length() == 0) {
        throw new IOException("Can't get Master Kerberos principal for the RM to use as renewer");
      }
      final Token<?> tokens[]=fs.addDelegationTokens(tokenRenewer,credentials);
      if (tokens != null) {
        for (        Token<?> token : tokens) {
          LOG.info("Got dt for " + fs.getUri() + "; "+ token);
        }
      }
      DataOutputBuffer dob=new DataOutputBuffer();
      credentials.writeTokenStorageToStream(dob);
      ByteBuffer fsTokens=ByteBuffer.wrap(dob.getData(),0,dob.getLength());
      amContainer.setTokens(fsTokens);
    }
    appContext.setAMContainerSpec(amContainer);
    ApplicationId appId=appContext.getApplicationId();
    yarnClient.submitApplication(appContext);
    return monitorApplication(appId) ? new NetworkedJob() : null;
  }
 catch (  YarnException e) {
    e.printStackTrace();
    return null;
  }
}

ID 1309=========================================================================type: Recover
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#launchJob(BSPJobID, BSPJob, Path, FileSystem)
Rmethod: org.apache.hama.bsp.YARNBSPJobClient#monitorApplication(ApplicationId)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.YarnException
exception comment: null
method comment: null
catch: 
catch (YarnException e) {
  e.printStackTrace();
  return null;
}

block: 
YARNBSPJobClient
@Override protected RunningJob launchJob(BSPJobID jobId,BSPJob normalJob,Path submitJobFile,FileSystem pFs) throws IOException {
  YARNBSPJob job=(YARNBSPJob)normalJob;
  LOG.info("Submitting job...");
  if (getConf().get("bsp.child.mem.in.mb") == null) {
    LOG.warn("BSP Child memory has not been set, YARN will guess your needs or use default values.");
  }
  FileSystem fs=pFs;
  if (fs == null) {
    fs=FileSystem.get(getConf());
  }
  if (getConf().get("bsp.user.name") == null) {
    String s=getUnixUserName();
    getConf().set("bsp.user.name",s);
    LOG.debug("Retrieved username: " + s);
  }
  yarnClient.start();
  try {
    YarnClusterMetrics clusterMetrics=yarnClient.getYarnClusterMetrics();
    LOG.info("Got Cluster metric info from ASM" + ", numNodeManagers=" + clusterMetrics.getNumNodeManagers());
    List<NodeReport> clusterNodeReports=yarnClient.getNodeReports(NodeState.RUNNING);
    LOG.info("Got Cluster node info from ASM");
    for (    NodeReport node : clusterNodeReports) {
      LOG.info("Got node report from ASM for" + ", nodeId=" + node.getNodeId() + ", nodeAddress"+ node.getHttpAddress()+ ", nodeRackName"+ node.getRackName()+ ", nodeNumContainers"+ node.getNumContainers());
    }
    QueueInfo queueInfo=yarnClient.getQueueInfo("default");
    LOG.info("Queue info" + ", queueName=" + queueInfo.getQueueName() + ", queueCurrentCapacity="+ queueInfo.getCurrentCapacity()+ ", queueMaxCapacity="+ queueInfo.getMaximumCapacity()+ ", queueApplicationCount="+ queueInfo.getApplications().size()+ ", queueChildQueueCount="+ queueInfo.getChildQueues().size());
    List<QueueUserACLInfo> listAclInfo=yarnClient.getQueueAclsInfo();
    for (    QueueUserACLInfo aclInfo : listAclInfo) {
      for (      QueueACL userAcl : aclInfo.getUserAcls()) {
        LOG.info("User ACL Info for Queue" + ", queueName=" + aclInfo.getQueueName() + ", userAcl="+ userAcl.name());
      }
    }
    YarnClientApplication app=yarnClient.createApplication();
    ApplicationSubmissionContext appContext=app.getApplicationSubmissionContext();
    id=appContext.getApplicationId();
    appContext.setApplicationName(job.getJobName());
    ContainerLaunchContext amContainer=Records.newRecord(ContainerLaunchContext.class);
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    if (job.getJar() == null) {
      throw new IllegalArgumentException("Jar must be set in order to run the application!");
    }
    Path jarPath=new Path(job.getJar());
    jarPath=fs.makeQualified(jarPath);
    getConf().set("bsp.jar",jarPath.makeQualified(fs.getUri(),jarPath).toString());
    FileStatus jarStatus=fs.getFileStatus(jarPath);
    LocalResource amJarRsrc=Records.newRecord(LocalResource.class);
    amJarRsrc.setType(LocalResourceType.FILE);
    amJarRsrc.setVisibility(LocalResourceVisibility.APPLICATION);
    amJarRsrc.setResource(ConverterUtils.getYarnUrlFromPath(jarPath));
    amJarRsrc.setTimestamp(jarStatus.getModificationTime());
    amJarRsrc.setSize(jarStatus.getLen());
    localResources.put(YARNBSPConstants.APP_MASTER_JAR_PATH,amJarRsrc);
    List<File> hamaJars;
    if (System.getProperty("hama.home.dir") != null)     hamaJars=localJarfromPath(System.getProperty("hama.home.dir"));
 else     hamaJars=localJarfromPath(getConf().get("hama.home.dir"));
    String hamaPath=getSystemDir() + "/hama";
    for (    File fileEntry : hamaJars) {
      addToLocalResources(fs,fileEntry.getCanonicalPath(),hamaPath,fileEntry.getName(),localResources);
    }
    amContainer.setLocalResources(localResources);
    Map<String,String> env=new HashMap<String,String>();
    StringBuilder classPathEnv=new StringBuilder(ApplicationConstants.Environment.CLASSPATH.$()).append(File.pathSeparatorChar).append("./*");
    for (    String c : yarnConf.getStrings(YarnConfiguration.YARN_APPLICATION_CLASSPATH,YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH)) {
      classPathEnv.append(File.pathSeparatorChar);
      classPathEnv.append(c.trim());
    }
    env.put(YARNBSPConstants.HAMA_YARN_LOCATION,jarPath.toUri().toString());
    env.put(YARNBSPConstants.HAMA_YARN_SIZE,Long.toString(jarStatus.getLen()));
    env.put(YARNBSPConstants.HAMA_YARN_TIMESTAMP,Long.toString(jarStatus.getModificationTime()));
    env.put(YARNBSPConstants.HAMA_LOCATION,hamaPath);
    env.put("CLASSPATH",classPathEnv.toString());
    amContainer.setEnvironment(env);
    Vector<CharSequence> vargs=new Vector<CharSequence>(5);
    vargs.add("${JAVA_HOME}/bin/java");
    vargs.add("-cp " + classPathEnv + "");
    vargs.add(ApplicationMaster.class.getCanonicalName());
    vargs.add(submitJobFile.makeQualified(fs.getUri(),fs.getWorkingDirectory()).toString());
    vargs.add("1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stdout");
    vargs.add("2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/hama-appmaster.stderr");
    StringBuilder command=new StringBuilder();
    for (    CharSequence str : vargs) {
      command.append(str).append(" ");
    }
    List<String> commands=new ArrayList<String>();
    commands.add(command.toString());
    amContainer.setCommands(commands);
    LOG.debug("Start command: " + command);
    Resource capability=Records.newRecord(Resource.class);
    capability.setMemory(3 * job.getNumBspTask() + getConf().getInt("hama.appmaster.memory.mb",100));
    LOG.info("Set memory for the application master to " + capability.getMemory() + "mb!");
    appContext.setResource(capability);
    if (UserGroupInformation.isSecurityEnabled()) {
      Credentials credentials=new Credentials();
      String tokenRenewer=yarnConf.get(YarnConfiguration.RM_PRINCIPAL);
      if (tokenRenewer == null || tokenRenewer.length() == 0) {
        throw new IOException("Can't get Master Kerberos principal for the RM to use as renewer");
      }
      final Token<?> tokens[]=fs.addDelegationTokens(tokenRenewer,credentials);
      if (tokens != null) {
        for (        Token<?> token : tokens) {
          LOG.info("Got dt for " + fs.getUri() + "; "+ token);
        }
      }
      DataOutputBuffer dob=new DataOutputBuffer();
      credentials.writeTokenStorageToStream(dob);
      ByteBuffer fsTokens=ByteBuffer.wrap(dob.getData(),0,dob.getLength());
      amContainer.setTokens(fsTokens);
    }
    appContext.setAMContainerSpec(amContainer);
    ApplicationId appId=appContext.getApplicationId();
    yarnClient.submitApplication(appContext);
    return monitorApplication(appId) ? new NetworkedJob() : null;
  }
 catch (  YarnException e) {
    e.printStackTrace();
    return null;
  }
}

ID 1310=========================================================================type: Ignore_Log
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#monitorApplication(ApplicationId)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.debug("Thread sleep in monitoring loop interrupted");
}

block: 
YARNBSPJobClient
private boolean monitorApplication(ApplicationId appId) throws IOException, YarnException {
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      LOG.debug("Thread sleep in monitoring loop interrupted");
    }
    report=yarnClient.getApplicationReport(appId);
    LOG.info("Got application report from ASM for" + ", appId=" + appId.getId() + ", clientToAMToken="+ report.getClientToAMToken()+ ", appDiagnostics="+ report.getDiagnostics()+ ", appMasterHost="+ report.getHost()+ ", appQueue="+ report.getQueue()+ ", appMasterRpcPort="+ report.getRpcPort()+ ", appStartTime="+ report.getStartTime()+ ", yarnAppState="+ report.getYarnApplicationState().toString()+ ", distributedFinalState="+ report.getFinalApplicationStatus().toString()+ ", appTrackingUrl="+ report.getTrackingUrl()+ ", appUser="+ report.getUser());
    YarnApplicationState state=report.getYarnApplicationState();
    FinalApplicationStatus dsStatus=report.getFinalApplicationStatus();
    if (YarnApplicationState.FINISHED == state) {
      if (FinalApplicationStatus.SUCCEEDED == dsStatus) {
        LOG.info("Application has completed successfully. Breaking monitoring loop");
        return true;
      }
 else {
        LOG.info("Application did finished unsuccessfully." + " YarnState=" + state.toString() + ", DSFinalStatus="+ dsStatus.toString()+ ". Breaking monitoring loop");
        return false;
      }
    }
 else     if (YarnApplicationState.KILLED == state || YarnApplicationState.FAILED == state) {
      LOG.info("Application did not finish." + " YarnState=" + state.toString() + ", DSFinalStatus="+ dsStatus.toString()+ ". Breaking monitoring loop");
      return false;
    }
    if (System.currentTimeMillis() > (clientStartTime + clientTimeout)) {
      LOG.info("Reached client specified timeout for application. Killing application");
      forceKillApplication(appId);
      return false;
    }
  }
}

ID 1311=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#monitorApplication(ApplicationId)
Rmethod: org.apache.hama.bsp.YARNBSPJobClient#forceKillApplication(ApplicationId)
hasForStatement: true
parentException: Object 
thrown: org.apache.hama.bsp.YarnException
exception comment: null
method comment: null
catch: 
null
block: 
YARNBSPJobClient
private boolean monitorApplication(ApplicationId appId) throws IOException, YarnException {
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      LOG.debug("Thread sleep in monitoring loop interrupted");
    }
    report=yarnClient.getApplicationReport(appId);
    LOG.info("Got application report from ASM for" + ", appId=" + appId.getId() + ", clientToAMToken="+ report.getClientToAMToken()+ ", appDiagnostics="+ report.getDiagnostics()+ ", appMasterHost="+ report.getHost()+ ", appQueue="+ report.getQueue()+ ", appMasterRpcPort="+ report.getRpcPort()+ ", appStartTime="+ report.getStartTime()+ ", yarnAppState="+ report.getYarnApplicationState().toString()+ ", distributedFinalState="+ report.getFinalApplicationStatus().toString()+ ", appTrackingUrl="+ report.getTrackingUrl()+ ", appUser="+ report.getUser());
    YarnApplicationState state=report.getYarnApplicationState();
    FinalApplicationStatus dsStatus=report.getFinalApplicationStatus();
    if (YarnApplicationState.FINISHED == state) {
      if (FinalApplicationStatus.SUCCEEDED == dsStatus) {
        LOG.info("Application has completed successfully. Breaking monitoring loop");
        return true;
      }
 else {
        LOG.info("Application did finished unsuccessfully." + " YarnState=" + state.toString() + ", DSFinalStatus="+ dsStatus.toString()+ ". Breaking monitoring loop");
        return false;
      }
    }
 else     if (YarnApplicationState.KILLED == state || YarnApplicationState.FAILED == state) {
      LOG.info("Application did not finish." + " YarnState=" + state.toString() + ", DSFinalStatus="+ dsStatus.toString()+ ". Breaking monitoring loop");
      return false;
    }
    if (System.currentTimeMillis() > (clientStartTime + clientTimeout)) {
      LOG.info("Reached client specified timeout for application. Killing application");
      forceKillApplication(appId);
      return false;
    }
  }
}

ID 1312=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNBSPJobClient#monitorApplication(ApplicationId)
Rmethod: org.apache.hama.bsp.YARNBSPJobClient#forceKillApplication(ApplicationId)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YARNBSPJobClient
private boolean monitorApplication(ApplicationId appId) throws IOException, YarnException {
  while (true) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      LOG.debug("Thread sleep in monitoring loop interrupted");
    }
    report=yarnClient.getApplicationReport(appId);
    LOG.info("Got application report from ASM for" + ", appId=" + appId.getId() + ", clientToAMToken="+ report.getClientToAMToken()+ ", appDiagnostics="+ report.getDiagnostics()+ ", appMasterHost="+ report.getHost()+ ", appQueue="+ report.getQueue()+ ", appMasterRpcPort="+ report.getRpcPort()+ ", appStartTime="+ report.getStartTime()+ ", yarnAppState="+ report.getYarnApplicationState().toString()+ ", distributedFinalState="+ report.getFinalApplicationStatus().toString()+ ", appTrackingUrl="+ report.getTrackingUrl()+ ", appUser="+ report.getUser());
    YarnApplicationState state=report.getYarnApplicationState();
    FinalApplicationStatus dsStatus=report.getFinalApplicationStatus();
    if (YarnApplicationState.FINISHED == state) {
      if (FinalApplicationStatus.SUCCEEDED == dsStatus) {
        LOG.info("Application has completed successfully. Breaking monitoring loop");
        return true;
      }
 else {
        LOG.info("Application did finished unsuccessfully." + " YarnState=" + state.toString() + ", DSFinalStatus="+ dsStatus.toString()+ ". Breaking monitoring loop");
        return false;
      }
    }
 else     if (YarnApplicationState.KILLED == state || YarnApplicationState.FAILED == state) {
      LOG.info("Application did not finish." + " YarnState=" + state.toString() + ", DSFinalStatus="+ dsStatus.toString()+ ". Breaking monitoring loop");
      return false;
    }
    if (System.currentTimeMillis() > (clientStartTime + clientTimeout)) {
      LOG.info("Reached client specified timeout for application. Killing application");
      forceKillApplication(appId);
      return false;
    }
  }
}

ID 1313=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNGraphJob#YARNGraphJob(HamaConfiguration, Class<?>)
Rmethod: org.apache.hama.bsp.YARNGraphJob#setVertexIDClass(Class<? extends Writable>)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
YARNGraphJob
public YARNGraphJob(HamaConfiguration conf,Class<?> exampleClass) throws IOException {
  super(conf);
  conf.setClass(MessageManager.OUTGOING_MESSAGE_MANAGER_CLASS,OutgoingVertexMessageManager.class,OutgoingMessageManager.class);
  conf.setBoolean(Constants.FORCE_SET_BSP_TASKS,true);
  conf.setBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false);
  conf.setBoolean("hama.use.unsafeserialization",true);
  this.setBspClass(GraphJobRunner.class);
  this.setJarByClass(exampleClass);
  this.setVertexIDClass(Text.class);
  this.setVertexValueClass(IntWritable.class);
  this.setEdgeValueClass(IntWritable.class);
  this.setPartitioner(HashPartitioner.class);
  this.setMessageQueueBehaviour(MessageQueue.PERSISTENT_QUEUE);
}

ID 1314=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNGraphJob#YARNGraphJob(HamaConfiguration, Class<?>)
Rmethod: org.apache.hama.bsp.YARNGraphJob#setVertexValueClass(Class<? extends Writable>)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
YARNGraphJob
public YARNGraphJob(HamaConfiguration conf,Class<?> exampleClass) throws IOException {
  super(conf);
  conf.setClass(MessageManager.OUTGOING_MESSAGE_MANAGER_CLASS,OutgoingVertexMessageManager.class,OutgoingMessageManager.class);
  conf.setBoolean(Constants.FORCE_SET_BSP_TASKS,true);
  conf.setBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false);
  conf.setBoolean("hama.use.unsafeserialization",true);
  this.setBspClass(GraphJobRunner.class);
  this.setJarByClass(exampleClass);
  this.setVertexIDClass(Text.class);
  this.setVertexValueClass(IntWritable.class);
  this.setEdgeValueClass(IntWritable.class);
  this.setPartitioner(HashPartitioner.class);
  this.setMessageQueueBehaviour(MessageQueue.PERSISTENT_QUEUE);
}

ID 1315=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YARNGraphJob#YARNGraphJob(HamaConfiguration, Class<?>)
Rmethod: org.apache.hama.bsp.YARNGraphJob#setEdgeValueClass(Class<? extends Writable>)
hasForStatement: false
parentException: RuntimeException Exception Throwable 
thrown: java.lang.IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

method comment: null
catch: 
null
block: 
YARNGraphJob
public YARNGraphJob(HamaConfiguration conf,Class<?> exampleClass) throws IOException {
  super(conf);
  conf.setClass(MessageManager.OUTGOING_MESSAGE_MANAGER_CLASS,OutgoingVertexMessageManager.class,OutgoingMessageManager.class);
  conf.setBoolean(Constants.FORCE_SET_BSP_TASKS,true);
  conf.setBoolean(Constants.ENABLE_RUNTIME_PARTITIONING,false);
  conf.setBoolean("hama.use.unsafeserialization",true);
  this.setBspClass(GraphJobRunner.class);
  this.setJarByClass(exampleClass);
  this.setVertexIDClass(Text.class);
  this.setVertexValueClass(IntWritable.class);
  this.setEdgeValueClass(IntWritable.class);
  this.setPartitioner(HashPartitioner.class);
  this.setMessageQueueBehaviour(MessageQueue.PERSISTENT_QUEUE);
}

ID 1316=========================================================================type: only_throws
package: org.apache.hama.bsp
Method:org.apache.hama.bsp.YarnSerializePrinting#main(java.lang.String[])
Rmethod: org.apache.hama.bsp.YarnSerializePrinting#printOutput(HamaConfiguration)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
YarnSerializePrinting
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException {
  HamaConfiguration conf=new HamaConfiguration();
  conf.set("hama.home.dir",System.getenv().get("HAMA_HOME"));
  YARNBSPJob job=new YARNBSPJob(conf);
  job.setBspClass(HelloBSP.class);
  job.setJarByClass(HelloBSP.class);
  job.setJobName("Serialize Printing");
  job.setInputFormat(NullInputFormat.class);
  job.setOutputFormat(TextOutputFormat.class);
  job.setOutputKeyClass(IntWritable.class);
  job.setOutputValueClass(Text.class);
  job.setOutputPath(OUTPUT_PATH);
  job.setMemoryUsedPerTaskInMb(100);
  job.setNumBspTask(4);
  long startTime=System.currentTimeMillis();
  job.waitForCompletion(true);
  printOutput(conf);
  System.out.println("Job Finished in " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");
}

ID 1317=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKCollector#harvest()
Rmethod: java.io.DataInputStream#readDouble()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ZKCollector
@Override public MetricsRecord harvest() throws Exception {
  final String path=this.reference.get().path;
  final ZooKeeper zk=this.reference.get().zk;
  LOG.debug("Searching " + path + " in zookeeper.");
  Stat stat=zk.exists(path,false);
  if (null == stat)   return null;
  List<String> children=zk.getChildren(path,false);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Leaves size is " + children.size() + " total znodes in list: "+ children);
  }
  final MetricsRecord record=reference.get().record;
  if (null != children) {
    for (    String child : children) {
      LOG.info("metrics -> " + child);
      String dataType=suffix(child);
      byte[] dataInBytes=zk.getData(path + "/" + child,false,stat);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Data length (in byte): " + dataInBytes.length);
      }
      DataInputStream input=null;
      try {
        String name=removeSuffix(child);
        input=new DataInputStream(new ByteArrayInputStream(dataInBytes));
        if ("d".equals(dataType)) {
          double dv=input.readDouble();
          LOG.info("metrics " + name + " value:"+ dv);
          record.add(new Metric<Double>(name,dv));
        }
 else         if ("f".equals(dataType)) {
          float fv=input.readFloat();
          LOG.info("metrics " + name + " value:"+ fv);
          record.add(new Metric<Float>(name,fv));
        }
 else         if ("i".equals(dataType)) {
          int iv=input.readInt();
          LOG.info("metrics " + name + " value:"+ iv);
          record.add(new Metric<Integer>(name,iv));
        }
 else         if ("l".equals(dataType)) {
          long lv=input.readLong();
          LOG.info("metrics " + name + " value:"+ lv);
          record.add(new Metric<Long>(name,lv));
        }
 else         if ("b".equals(dataType)) {
          LOG.info("metrics" + name + " value:"+ Arrays.toString(dataInBytes));
          record.add(new Metric<byte[]>(name,dataInBytes));
        }
 else {
          LOG.warn("Unkown data type for metrics name: " + child);
        }
      }
  finally {
        input.close();
      }
    }
  }
  return record;
}

ID 1318=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKCollector#harvest()
Rmethod: java.io.DataInputStream#readFloat()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ZKCollector
@Override public MetricsRecord harvest() throws Exception {
  final String path=this.reference.get().path;
  final ZooKeeper zk=this.reference.get().zk;
  LOG.debug("Searching " + path + " in zookeeper.");
  Stat stat=zk.exists(path,false);
  if (null == stat)   return null;
  List<String> children=zk.getChildren(path,false);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Leaves size is " + children.size() + " total znodes in list: "+ children);
  }
  final MetricsRecord record=reference.get().record;
  if (null != children) {
    for (    String child : children) {
      LOG.info("metrics -> " + child);
      String dataType=suffix(child);
      byte[] dataInBytes=zk.getData(path + "/" + child,false,stat);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Data length (in byte): " + dataInBytes.length);
      }
      DataInputStream input=null;
      try {
        String name=removeSuffix(child);
        input=new DataInputStream(new ByteArrayInputStream(dataInBytes));
        if ("d".equals(dataType)) {
          double dv=input.readDouble();
          LOG.info("metrics " + name + " value:"+ dv);
          record.add(new Metric<Double>(name,dv));
        }
 else         if ("f".equals(dataType)) {
          float fv=input.readFloat();
          LOG.info("metrics " + name + " value:"+ fv);
          record.add(new Metric<Float>(name,fv));
        }
 else         if ("i".equals(dataType)) {
          int iv=input.readInt();
          LOG.info("metrics " + name + " value:"+ iv);
          record.add(new Metric<Integer>(name,iv));
        }
 else         if ("l".equals(dataType)) {
          long lv=input.readLong();
          LOG.info("metrics " + name + " value:"+ lv);
          record.add(new Metric<Long>(name,lv));
        }
 else         if ("b".equals(dataType)) {
          LOG.info("metrics" + name + " value:"+ Arrays.toString(dataInBytes));
          record.add(new Metric<byte[]>(name,dataInBytes));
        }
 else {
          LOG.warn("Unkown data type for metrics name: " + child);
        }
      }
  finally {
        input.close();
      }
    }
  }
  return record;
}

ID 1319=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKCollector#harvest()
Rmethod: java.io.DataInputStream#readInt()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ZKCollector
@Override public MetricsRecord harvest() throws Exception {
  final String path=this.reference.get().path;
  final ZooKeeper zk=this.reference.get().zk;
  LOG.debug("Searching " + path + " in zookeeper.");
  Stat stat=zk.exists(path,false);
  if (null == stat)   return null;
  List<String> children=zk.getChildren(path,false);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Leaves size is " + children.size() + " total znodes in list: "+ children);
  }
  final MetricsRecord record=reference.get().record;
  if (null != children) {
    for (    String child : children) {
      LOG.info("metrics -> " + child);
      String dataType=suffix(child);
      byte[] dataInBytes=zk.getData(path + "/" + child,false,stat);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Data length (in byte): " + dataInBytes.length);
      }
      DataInputStream input=null;
      try {
        String name=removeSuffix(child);
        input=new DataInputStream(new ByteArrayInputStream(dataInBytes));
        if ("d".equals(dataType)) {
          double dv=input.readDouble();
          LOG.info("metrics " + name + " value:"+ dv);
          record.add(new Metric<Double>(name,dv));
        }
 else         if ("f".equals(dataType)) {
          float fv=input.readFloat();
          LOG.info("metrics " + name + " value:"+ fv);
          record.add(new Metric<Float>(name,fv));
        }
 else         if ("i".equals(dataType)) {
          int iv=input.readInt();
          LOG.info("metrics " + name + " value:"+ iv);
          record.add(new Metric<Integer>(name,iv));
        }
 else         if ("l".equals(dataType)) {
          long lv=input.readLong();
          LOG.info("metrics " + name + " value:"+ lv);
          record.add(new Metric<Long>(name,lv));
        }
 else         if ("b".equals(dataType)) {
          LOG.info("metrics" + name + " value:"+ Arrays.toString(dataInBytes));
          record.add(new Metric<byte[]>(name,dataInBytes));
        }
 else {
          LOG.warn("Unkown data type for metrics name: " + child);
        }
      }
  finally {
        input.close();
      }
    }
  }
  return record;
}

ID 1320=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKCollector#harvest()
Rmethod: java.io.DataInputStream#readLong()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ZKCollector
@Override public MetricsRecord harvest() throws Exception {
  final String path=this.reference.get().path;
  final ZooKeeper zk=this.reference.get().zk;
  LOG.debug("Searching " + path + " in zookeeper.");
  Stat stat=zk.exists(path,false);
  if (null == stat)   return null;
  List<String> children=zk.getChildren(path,false);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Leaves size is " + children.size() + " total znodes in list: "+ children);
  }
  final MetricsRecord record=reference.get().record;
  if (null != children) {
    for (    String child : children) {
      LOG.info("metrics -> " + child);
      String dataType=suffix(child);
      byte[] dataInBytes=zk.getData(path + "/" + child,false,stat);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Data length (in byte): " + dataInBytes.length);
      }
      DataInputStream input=null;
      try {
        String name=removeSuffix(child);
        input=new DataInputStream(new ByteArrayInputStream(dataInBytes));
        if ("d".equals(dataType)) {
          double dv=input.readDouble();
          LOG.info("metrics " + name + " value:"+ dv);
          record.add(new Metric<Double>(name,dv));
        }
 else         if ("f".equals(dataType)) {
          float fv=input.readFloat();
          LOG.info("metrics " + name + " value:"+ fv);
          record.add(new Metric<Float>(name,fv));
        }
 else         if ("i".equals(dataType)) {
          int iv=input.readInt();
          LOG.info("metrics " + name + " value:"+ iv);
          record.add(new Metric<Integer>(name,iv));
        }
 else         if ("l".equals(dataType)) {
          long lv=input.readLong();
          LOG.info("metrics " + name + " value:"+ lv);
          record.add(new Metric<Long>(name,lv));
        }
 else         if ("b".equals(dataType)) {
          LOG.info("metrics" + name + " value:"+ Arrays.toString(dataInBytes));
          record.add(new Metric<byte[]>(name,dataInBytes));
        }
 else {
          LOG.warn("Unkown data type for metrics name: " + child);
        }
      }
  finally {
        input.close();
      }
    }
  }
  return record;
}

ID 1321=========================================================================type: only_throws
package: org.apache.hama.monitor
Method:org.apache.hama.monitor.ZKCollector#harvest()
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ZKCollector
@Override public MetricsRecord harvest() throws Exception {
  final String path=this.reference.get().path;
  final ZooKeeper zk=this.reference.get().zk;
  LOG.debug("Searching " + path + " in zookeeper.");
  Stat stat=zk.exists(path,false);
  if (null == stat)   return null;
  List<String> children=zk.getChildren(path,false);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Leaves size is " + children.size() + " total znodes in list: "+ children);
  }
  final MetricsRecord record=reference.get().record;
  if (null != children) {
    for (    String child : children) {
      LOG.info("metrics -> " + child);
      String dataType=suffix(child);
      byte[] dataInBytes=zk.getData(path + "/" + child,false,stat);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Data length (in byte): " + dataInBytes.length);
      }
      DataInputStream input=null;
      try {
        String name=removeSuffix(child);
        input=new DataInputStream(new ByteArrayInputStream(dataInBytes));
        if ("d".equals(dataType)) {
          double dv=input.readDouble();
          LOG.info("metrics " + name + " value:"+ dv);
          record.add(new Metric<Double>(name,dv));
        }
 else         if ("f".equals(dataType)) {
          float fv=input.readFloat();
          LOG.info("metrics " + name + " value:"+ fv);
          record.add(new Metric<Float>(name,fv));
        }
 else         if ("i".equals(dataType)) {
          int iv=input.readInt();
          LOG.info("metrics " + name + " value:"+ iv);
          record.add(new Metric<Integer>(name,iv));
        }
 else         if ("l".equals(dataType)) {
          long lv=input.readLong();
          LOG.info("metrics " + name + " value:"+ lv);
          record.add(new Metric<Long>(name,lv));
        }
 else         if ("b".equals(dataType)) {
          LOG.info("metrics" + name + " value:"+ Arrays.toString(dataInBytes));
          record.add(new Metric<byte[]>(name,dataInBytes));
        }
 else {
          LOG.warn("Unkown data type for metrics name: " + child);
        }
      }
  finally {
        input.close();
      }
    }
  }
  return record;
}

ID 1322=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#getBytesForData(Writable)
Rmethod: java.io.DataOutputStream#flush()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Utility function to get byte array out of Writable
 * @param value The Writable object to be converted to byte array.
 * @return byte array from the Writable object. Returns null on given nullvalue or on error.
 */

catch: 
catch (IOException e) {
  LOG.error("Error writing data to write buffer.",e);
}

block: 
ZKSyncClient
/** 
 * Utility function to get byte array out of Writable
 * @param value The Writable object to be converted to byte array.
 * @return byte array from the Writable object. Returns null on given nullvalue or on error.
 */
protected byte[] getBytesForData(Writable value){
  byte[] data=null;
  if (value != null) {
    ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
    DataOutputStream outputStream=new DataOutputStream(byteStream);
    try {
      value.write(outputStream);
      outputStream.flush();
      data=byteStream.toByteArray();
    }
 catch (    IOException e) {
      LOG.error("Error writing data to write buffer.",e);
    }
 finally {
      try {
        byteStream.close();
        outputStream.close();
      }
 catch (      IOException e) {
        LOG.error("Error closing byte stream.",e);
      }
    }
  }
  return data;
}

ID 1323=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#getBytesForData(Writable)
Rmethod: java.io.ByteArrayOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Utility function to get byte array out of Writable
 * @param value The Writable object to be converted to byte array.
 * @return byte array from the Writable object. Returns null on given nullvalue or on error.
 */

catch: 
catch (IOException e) {
  LOG.error("Error closing byte stream.",e);
}

block: 
ZKSyncClient
/** 
 * Utility function to get byte array out of Writable
 * @param value The Writable object to be converted to byte array.
 * @return byte array from the Writable object. Returns null on given nullvalue or on error.
 */
protected byte[] getBytesForData(Writable value){
  byte[] data=null;
  if (value != null) {
    ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
    DataOutputStream outputStream=new DataOutputStream(byteStream);
    try {
      value.write(outputStream);
      outputStream.flush();
      data=byteStream.toByteArray();
    }
 catch (    IOException e) {
      LOG.error("Error writing data to write buffer.",e);
    }
 finally {
      try {
        byteStream.close();
        outputStream.close();
      }
 catch (      IOException e) {
        LOG.error("Error closing byte stream.",e);
      }
    }
  }
  return data;
}

ID 1324=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#getBytesForData(Writable)
Rmethod: java.io.FilterOutputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Utility function to get byte array out of Writable
 * @param value The Writable object to be converted to byte array.
 * @return byte array from the Writable object. Returns null on given nullvalue or on error.
 */

catch: 
catch (IOException e) {
  LOG.error("Error closing byte stream.",e);
}

block: 
ZKSyncClient
/** 
 * Utility function to get byte array out of Writable
 * @param value The Writable object to be converted to byte array.
 * @return byte array from the Writable object. Returns null on given nullvalue or on error.
 */
protected byte[] getBytesForData(Writable value){
  byte[] data=null;
  if (value != null) {
    ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
    DataOutputStream outputStream=new DataOutputStream(byteStream);
    try {
      value.write(outputStream);
      outputStream.flush();
      data=byteStream.toByteArray();
    }
 catch (    IOException e) {
      LOG.error("Error writing data to write buffer.",e);
    }
 finally {
      try {
        byteStream.close();
        outputStream.close();
      }
 catch (      IOException e) {
        LOG.error("Error closing byte stream.",e);
      }
    }
  }
  return data;
}

ID 1325=========================================================================type: only_throws
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#getValueFromBytes(byte[], Writable)
Rmethod: java.io.FilterInputStream#close()
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Utility function to read Writable object value from byte array.
 * @param data The byte array
 * @param valueHolder The Class object of expected Writable object.
 * @return The instance of Writable object.
 * @throws IOException
 */

catch: 
null
block: 
ZKSyncClient
/** 
 * Utility function to read Writable object value from byte array.
 * @param data The byte array
 * @param valueHolder The Class object of expected Writable object.
 * @return The instance of Writable object.
 * @throws IOException
 */
protected boolean getValueFromBytes(byte[] data,Writable valueHolder) throws IOException {
  if (data != null) {
    ByteArrayInputStream istream=new ByteArrayInputStream(data);
    DataInputStream diStream=new DataInputStream(istream);
    try {
      valueHolder.readFields(diStream);
    }
  finally {
      diStream.close();
    }
    return true;
  }
  return false;
}

ID 1326=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#extractData(java.lang.String, Writable)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#getStat(java.lang.String)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: /** 
 * Read value stored in the Zookeeper node.
 * @param path The path of the Zookeeper node.
 * @param valueHolder The expected class type of the Writable object.
 * @return The Writable object constructed from the value read from theZookeeper node.
 */

catch: 
catch (KeeperException e) {
  LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Read value stored in the Zookeeper node.
 * @param path The path of the Zookeeper node.
 * @param valueHolder The expected class type of the Writable object.
 * @return The Writable object constructed from the value read from theZookeeper node.
 */
protected boolean extractData(String path,Writable valueHolder){
  try {
    Stat stat=getStat(path);
    if (stat != null) {
      byte[] data=this.zk.getData(path,false,stat);
      try {
        getValueFromBytes(data,valueHolder);
      }
 catch (      IOException e) {
        LOG.error(new StringBuffer(200).append("Error getting data from path ").append(path).toString(),e);
        return false;
      }
      return true;
    }
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  return false;
}

ID 1327=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#extractData(java.lang.String, Writable)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#getStat(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Read value stored in the Zookeeper node.
 * @param path The path of the Zookeeper node.
 * @param valueHolder The expected class type of the Writable object.
 * @return The Writable object constructed from the value read from theZookeeper node.
 */

catch: 
catch (InterruptedException e) {
  LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Read value stored in the Zookeeper node.
 * @param path The path of the Zookeeper node.
 * @param valueHolder The expected class type of the Writable object.
 * @return The Writable object constructed from the value read from theZookeeper node.
 */
protected boolean extractData(String path,Writable valueHolder){
  try {
    Stat stat=getStat(path);
    if (stat != null) {
      byte[] data=this.zk.getData(path,false,stat);
      try {
        getValueFromBytes(data,valueHolder);
      }
 catch (      IOException e) {
        LOG.error(new StringBuffer(200).append("Error getting data from path ").append(path).toString(),e);
        return false;
      }
      return true;
    }
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  return false;
}

ID 1328=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#extractData(java.lang.String, Writable)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#getValueFromBytes(byte[], Writable)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.io.IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

method comment: /** 
 * Read value stored in the Zookeeper node.
 * @param path The path of the Zookeeper node.
 * @param valueHolder The expected class type of the Writable object.
 * @return The Writable object constructed from the value read from theZookeeper node.
 */

catch: 
catch (IOException e) {
  LOG.error(new StringBuffer(200).append("Error getting data from path ").append(path).toString(),e);
  return false;
}

block: 
ZKSyncClient
/** 
 * Read value stored in the Zookeeper node.
 * @param path The path of the Zookeeper node.
 * @param valueHolder The expected class type of the Writable object.
 * @return The Writable object constructed from the value read from theZookeeper node.
 */
protected boolean extractData(String path,Writable valueHolder){
  try {
    Stat stat=getStat(path);
    if (stat != null) {
      byte[] data=this.zk.getData(path,false,stat);
      try {
        getValueFromBytes(data,valueHolder);
      }
 catch (      IOException e) {
        LOG.error(new StringBuffer(200).append("Error getting data from path ").append(path).toString(),e);
        return false;
      }
      return true;
    }
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  return false;
}

ID 1329=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#writeNode(java.lang.String, Writable, boolean, Watcher)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#isExists(java.lang.String, Watcher)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: /** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */

catch: 
catch (KeeperException e) {
  LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */
protected boolean writeNode(String path,Writable value,boolean persistent,Watcher watcher){
  if (path == null || "".equals(path.trim())) {
    return false;
  }
  path=correctKey(path);
  boolean pathExists=false;
  try {
    pathExists=isExists(path,watcher);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  byte[] data=getBytesForData(value);
  if (!pathExists) {
    try {
      String[] pathComponents=path.split("/");
      StringBuffer pathBuffer=new StringBuffer(path.length() + pathComponents.length);
      for (int i=0; i < pathComponents.length - 1; ++i) {
        if (pathComponents[i].equals(""))         continue;
        pathBuffer.append("/").append(pathComponents[i]);
        createZnode(pathBuffer.toString(),CreateMode.PERSISTENT,null,watcher);
      }
      pathBuffer.append("/").append(pathComponents[pathComponents.length - 1]);
      CreateMode mode=CreateMode.EPHEMERAL;
      if (persistent) {
        mode=CreateMode.PERSISTENT;
      }
      createZnode(pathBuffer.toString(),mode,data,watcher);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
  }
 else   if (value != null) {
    try {
      this.zk.setData(path,data,-1);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
      return false;
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
    }
  }
  return false;
}

ID 1330=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#writeNode(java.lang.String, Writable, boolean, Watcher)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#isExists(java.lang.String, Watcher)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */

catch: 
catch (InterruptedException e) {
  LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */
protected boolean writeNode(String path,Writable value,boolean persistent,Watcher watcher){
  if (path == null || "".equals(path.trim())) {
    return false;
  }
  path=correctKey(path);
  boolean pathExists=false;
  try {
    pathExists=isExists(path,watcher);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  byte[] data=getBytesForData(value);
  if (!pathExists) {
    try {
      String[] pathComponents=path.split("/");
      StringBuffer pathBuffer=new StringBuffer(path.length() + pathComponents.length);
      for (int i=0; i < pathComponents.length - 1; ++i) {
        if (pathComponents[i].equals(""))         continue;
        pathBuffer.append("/").append(pathComponents[i]);
        createZnode(pathBuffer.toString(),CreateMode.PERSISTENT,null,watcher);
      }
      pathBuffer.append("/").append(pathComponents[pathComponents.length - 1]);
      CreateMode mode=CreateMode.EPHEMERAL;
      if (persistent) {
        mode=CreateMode.PERSISTENT;
      }
      createZnode(pathBuffer.toString(),mode,data,watcher);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
  }
 else   if (value != null) {
    try {
      this.zk.setData(path,data,-1);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
      return false;
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
    }
  }
  return false;
}

ID 1331=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#writeNode(java.lang.String, Writable, boolean, Watcher)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#createZnode(java.lang.String, CreateMode, byte[], Watcher)
hasForStatement: true
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: /** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */

catch: 
catch (KeeperException e) {
  LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */
protected boolean writeNode(String path,Writable value,boolean persistent,Watcher watcher){
  if (path == null || "".equals(path.trim())) {
    return false;
  }
  path=correctKey(path);
  boolean pathExists=false;
  try {
    pathExists=isExists(path,watcher);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  byte[] data=getBytesForData(value);
  if (!pathExists) {
    try {
      String[] pathComponents=path.split("/");
      StringBuffer pathBuffer=new StringBuffer(path.length() + pathComponents.length);
      for (int i=0; i < pathComponents.length - 1; ++i) {
        if (pathComponents[i].equals(""))         continue;
        pathBuffer.append("/").append(pathComponents[i]);
        createZnode(pathBuffer.toString(),CreateMode.PERSISTENT,null,watcher);
      }
      pathBuffer.append("/").append(pathComponents[pathComponents.length - 1]);
      CreateMode mode=CreateMode.EPHEMERAL;
      if (persistent) {
        mode=CreateMode.PERSISTENT;
      }
      createZnode(pathBuffer.toString(),mode,data,watcher);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
  }
 else   if (value != null) {
    try {
      this.zk.setData(path,data,-1);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
      return false;
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
    }
  }
  return false;
}

ID 1332=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#writeNode(java.lang.String, Writable, boolean, Watcher)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#createZnode(java.lang.String, CreateMode, byte[], Watcher)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */

catch: 
catch (InterruptedException e) {
  LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */
protected boolean writeNode(String path,Writable value,boolean persistent,Watcher watcher){
  if (path == null || "".equals(path.trim())) {
    return false;
  }
  path=correctKey(path);
  boolean pathExists=false;
  try {
    pathExists=isExists(path,watcher);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  byte[] data=getBytesForData(value);
  if (!pathExists) {
    try {
      String[] pathComponents=path.split("/");
      StringBuffer pathBuffer=new StringBuffer(path.length() + pathComponents.length);
      for (int i=0; i < pathComponents.length - 1; ++i) {
        if (pathComponents[i].equals(""))         continue;
        pathBuffer.append("/").append(pathComponents[i]);
        createZnode(pathBuffer.toString(),CreateMode.PERSISTENT,null,watcher);
      }
      pathBuffer.append("/").append(pathComponents[pathComponents.length - 1]);
      CreateMode mode=CreateMode.EPHEMERAL;
      if (persistent) {
        mode=CreateMode.PERSISTENT;
      }
      createZnode(pathBuffer.toString(),mode,data,watcher);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
  }
 else   if (value != null) {
    try {
      this.zk.setData(path,data,-1);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
      return false;
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
    }
  }
  return false;
}

ID 1333=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#writeNode(java.lang.String, Writable, boolean, Watcher)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#createZnode(java.lang.String, CreateMode, byte[], Watcher)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: /** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */

catch: 
catch (KeeperException e) {
  LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */
protected boolean writeNode(String path,Writable value,boolean persistent,Watcher watcher){
  if (path == null || "".equals(path.trim())) {
    return false;
  }
  path=correctKey(path);
  boolean pathExists=false;
  try {
    pathExists=isExists(path,watcher);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  byte[] data=getBytesForData(value);
  if (!pathExists) {
    try {
      String[] pathComponents=path.split("/");
      StringBuffer pathBuffer=new StringBuffer(path.length() + pathComponents.length);
      for (int i=0; i < pathComponents.length - 1; ++i) {
        if (pathComponents[i].equals(""))         continue;
        pathBuffer.append("/").append(pathComponents[i]);
        createZnode(pathBuffer.toString(),CreateMode.PERSISTENT,null,watcher);
      }
      pathBuffer.append("/").append(pathComponents[pathComponents.length - 1]);
      CreateMode mode=CreateMode.EPHEMERAL;
      if (persistent) {
        mode=CreateMode.PERSISTENT;
      }
      createZnode(pathBuffer.toString(),mode,data,watcher);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
  }
 else   if (value != null) {
    try {
      this.zk.setData(path,data,-1);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
      return false;
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
    }
  }
  return false;
}

ID 1334=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#writeNode(java.lang.String, Writable, boolean, Watcher)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#createZnode(java.lang.String, CreateMode, byte[], Watcher)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */

catch: 
catch (InterruptedException e) {
  LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
}

block: 
ZKSyncClient
/** 
 * Writes data into the Zookeeper node. If the path does not exist the zookeeper node is created recursively and the value is stored in the node.
 * @param path The path of the Zookeeper node.
 * @param value The value to be stored in the Zookeeper node.
 * @param persistent true if the node to be created is ephemeral of permanent
 * @param watcher If any Watcher object should listen to event on theZookeeper node.
 * @return true if operation is successful.
 */
protected boolean writeNode(String path,Writable value,boolean persistent,Watcher watcher){
  if (path == null || "".equals(path.trim())) {
    return false;
  }
  path=correctKey(path);
  boolean pathExists=false;
  try {
    pathExists=isExists(path,watcher);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(path).toString(),e);
  }
  byte[] data=getBytesForData(value);
  if (!pathExists) {
    try {
      String[] pathComponents=path.split("/");
      StringBuffer pathBuffer=new StringBuffer(path.length() + pathComponents.length);
      for (int i=0; i < pathComponents.length - 1; ++i) {
        if (pathComponents[i].equals(""))         continue;
        pathBuffer.append("/").append(pathComponents[i]);
        createZnode(pathBuffer.toString(),CreateMode.PERSISTENT,null,watcher);
      }
      pathBuffer.append("/").append(pathComponents[pathComponents.length - 1]);
      CreateMode mode=CreateMode.EPHEMERAL;
      if (persistent) {
        mode=CreateMode.PERSISTENT;
      }
      createZnode(pathBuffer.toString(),mode,data,watcher);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error creating zk path ").append(path).toString(),e);
    }
  }
 else   if (value != null) {
    try {
      this.zk.setData(path,data,-1);
      return true;
    }
 catch (    InterruptedException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
      return false;
    }
catch (    KeeperException e) {
      LOG.error(new StringBuilder(200).append("Error modifying zk path ").append(path).toString(),e);
    }
  }
  return false;
}

ID 1335=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#hasKey(java.lang.String)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#isExists(java.lang.String, Watcher)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: null
catch: 
catch (KeeperException e) {
  LOG.error(new StringBuilder(200).append("Error checking zk path ").append(key).toString(),e);
}

block: 
ZKSyncClient
@Override public boolean hasKey(String key){
  try {
    return isExists(key,null);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(key).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(key).toString(),e);
  }
  return false;
}

ID 1336=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#hasKey(java.lang.String)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#isExists(java.lang.String, Watcher)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.error(new StringBuilder(200).append("Error checking zk path ").append(key).toString(),e);
}

block: 
ZKSyncClient
@Override public boolean hasKey(String key){
  try {
    return isExists(key,null);
  }
 catch (  KeeperException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(key).toString(),e);
  }
catch (  InterruptedException e) {
    LOG.error(new StringBuilder(200).append("Error checking zk path ").append(key).toString(),e);
  }
  return false;
}

ID 1337=========================================================================type: only_throws
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes()
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: /** 
 * Clears all sub-children of node bspRoot
 */

catch: 
null
block: 
ZKSyncClient
/** 
 * Clears all sub-children of node bspRoot
 */
protected void clearZKNodes(){
  try {
    Stat s=zk.exists(bspRoot,false);
    if (s != null) {
      clearZKNodes(bspRoot);
    }
  }
 catch (  Exception e) {
    LOG.warn("Could not clear zookeeper nodes.",e);
  }
}

ID 1338=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes()
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Clears all sub-children of node bspRoot
 */

catch: 
catch (Exception e) {
  LOG.warn("Could not clear zookeeper nodes.",e);
}

block: 
ZKSyncClient
/** 
 * Clears all sub-children of node bspRoot
 */
protected void clearZKNodes(){
  try {
    Stat s=zk.exists(bspRoot,false);
    if (s != null) {
      clearZKNodes(bspRoot);
    }
  }
 catch (  Exception e) {
    LOG.warn("Could not clear zookeeper nodes.",e);
  }
}

ID 1339=========================================================================type: only_throws
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: /** 
 * Clears all sub-children of node rooted at path.
 * @param path
 * @throws InterruptedException
 * @throws KeeperException
 */

catch: 
null
block: 
ZKSyncClient
/** 
 * Clears all sub-children of node rooted at path.
 * @param path
 * @throws InterruptedException
 * @throws KeeperException
 */
protected void clearZKNodes(String path) throws KeeperException, InterruptedException {
  ArrayList<String> list=(ArrayList<String>)zk.getChildren(path,false);
  if (list.size() == 0) {
    return;
  }
 else {
    for (    String node : list) {
      clearZKNodes(path + "/" + node);
      LOG.debug("Deleting " + path + "/"+ node);
      zk.delete(path + "/" + node,-1);
    }
  }
}

ID 1340=========================================================================type: only_throws
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: /** 
 * Clears all sub-children of node rooted at path.
 * @param path
 * @throws InterruptedException
 * @throws KeeperException
 */

catch: 
null
block: 
ZKSyncClient
/** 
 * Clears all sub-children of node rooted at path.
 * @param path
 * @throws InterruptedException
 * @throws KeeperException
 */
protected void clearZKNodes(String path) throws KeeperException, InterruptedException {
  ArrayList<String> list=(ArrayList<String>)zk.getChildren(path,false);
  if (list.size() == 0) {
    return;
  }
 else {
    for (    String node : list) {
      clearZKNodes(path + "/" + node);
      LOG.debug("Deleting " + path + "/"+ node);
      zk.delete(path + "/" + node,-1);
    }
  }
}

ID 1341=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#remove(java.lang.String, SyncEventListener)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
hasForStatement: false
parentException: Object 
thrown: org.apache.hama.bsp.sync.KeeperException
exception comment: null
method comment: null
catch: 
catch (KeeperException e) {
  LOG.error("Error deleting key " + key);
}

block: 
ZKSyncClient
@Override public boolean remove(String key,SyncEventListener listener){
  key=correctKey(key);
  try {
    clearZKNodes(key);
    this.zk.delete(key,-1);
    return true;
  }
 catch (  KeeperException e) {
    LOG.error("Error deleting key " + key);
  }
catch (  InterruptedException e) {
    LOG.error("Error deleting key " + key);
  }
  return false;
}

ID 1342=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZKSyncClient#remove(java.lang.String, SyncEventListener)
Rmethod: org.apache.hama.bsp.sync.ZKSyncClient#clearZKNodes(java.lang.String)
hasForStatement: false
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (InterruptedException e) {
  LOG.error("Error deleting key " + key);
}

block: 
ZKSyncClient
@Override public boolean remove(String key,SyncEventListener listener){
  key=correctKey(key);
  try {
    clearZKNodes(key);
    this.zk.delete(key,-1);
    return true;
  }
 catch (  KeeperException e) {
    LOG.error("Error deleting key " + key);
  }
catch (  InterruptedException e) {
    LOG.error("Error deleting key " + key);
  }
  return false;
}

ID 1343=========================================================================type: Rethrow
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZooKeeperSyncClientImpl#enterBarrier(BSPJobID, TaskAttemptID, long)
Rmethod: java.lang.Object#wait(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new SyncException(e.toString());
}

block: 
ZooKeeperSyncClientImpl
@Override public void enterBarrier(BSPJobID jobId,TaskAttemptID taskId,long superstep) throws SyncException {
  LOG.debug("[" + getPeerName() + "] enter the enterbarrier: "+ superstep);
  try {
synchronized (zk) {
      final String pathToSuperstepZnode=constructKey(taskId.getJobID(),"sync","" + superstep);
      writeNode(pathToSuperstepZnode,null,true,null);
      BarrierWatcher barrierWatcher=new BarrierWatcher();
      zk.exists(pathToSuperstepZnode + "/ready",barrierWatcher);
      zk.create(getNodeName(taskId,superstep),null,Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
      List<String> znodes=zk.getChildren(pathToSuperstepZnode,false);
      int size=znodes.size();
      boolean hasReady=znodes.contains("ready");
      if (hasReady) {
        size--;
      }
      LOG.debug("===> at superstep :" + superstep + " current znode size: "+ znodes.size()+ " current znodes:"+ znodes);
      LOG.debug("enterBarrier() znode size within " + pathToSuperstepZnode + " is "+ znodes.size()+ ". Znodes include "+ znodes);
      if (size < numBSPTasks) {
        while (!barrierWatcher.isComplete()) {
          if (!hasReady) {
synchronized (mutex) {
              mutex.wait(1000);
            }
          }
        }
        LOG.debug("2. at superstep: " + superstep + " after waiting ..."+ taskId.toString());
      }
 else {
        LOG.debug("---> at superstep: " + superstep + " task that is creating /ready znode:"+ taskId.toString());
        writeNode(pathToSuperstepZnode + "/ready",null,false,null);
      }
    }
  }
 catch (  Exception e) {
    throw new SyncException(e.toString());
  }
}

ID 1344=========================================================================type: Rethrow
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZooKeeperSyncClientImpl#leaveBarrier(BSPJobID, TaskAttemptID, long)
Rmethod: java.lang.Object#wait()
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  throw new SyncException(e.getMessage());
}

block: 
ZooKeeperSyncClientImpl
@Override public void leaveBarrier(final BSPJobID jobId,final TaskAttemptID taskId,final long superstep) throws SyncException {
  try {
    final String pathToSuperstepZnode=constructKey(taskId.getJobID(),"sync","" + superstep);
    while (true) {
      List<String> znodes=zk.getChildren(pathToSuperstepZnode,false);
      LOG.debug("leaveBarrier() !!! checking znodes contnains /ready node or not: at superstep:" + superstep + " znode:"+ znodes);
      if (znodes.contains("ready")) {
        znodes.remove("ready");
      }
      final int size=znodes.size();
      LOG.debug("leaveBarrier() at superstep:" + superstep + " znode size: ("+ size+ ") znodes:"+ znodes);
      if (null == znodes || znodes.isEmpty())       return;
      if (1 == size) {
        try {
          zk.delete(getNodeName(taskId,superstep),0);
        }
 catch (        KeeperException.NoNodeException nne) {
          LOG.debug("+++ (znode size is 1). Ignore because znode may disconnect.",nne);
        }
        return;
      }
      Collections.sort(znodes);
      final String lowest=znodes.get(0);
      final String highest=znodes.get(size - 1);
synchronized (mutex) {
        if (getNodeName(taskId,superstep).equals(pathToSuperstepZnode + "/" + lowest)) {
          Stat s=zk.exists(pathToSuperstepZnode + "/" + highest,new Watcher(){
            @Override public void process(            WatchedEvent event){
synchronized (mutex) {
                LOG.debug("leaveBarrier() at superstep: " + superstep + " taskid:"+ taskId.toString()+ " highest notify lowest.");
                mutex.notifyAll();
              }
            }
          }
);
          if (null != s) {
            LOG.debug("leaveBarrier(): superstep:" + superstep + " taskid:"+ taskId.toString()+ " wait for higest notify.");
            mutex.wait();
          }
        }
 else {
          Stat s1=zk.exists(getNodeName(taskId,superstep),false);
          if (null != s1) {
            try {
              zk.delete(getNodeName(taskId,superstep),0);
            }
 catch (            KeeperException.NoNodeException nne) {
              LOG.debug("++++ Ignore because node may be dleted.",nne);
            }
          }
          Stat s2=zk.exists(pathToSuperstepZnode + "/" + lowest,new Watcher(){
            @Override public void process(            WatchedEvent event){
synchronized (mutex) {
                LOG.debug("leaveBarrier() at superstep: " + superstep + " taskid:"+ taskId.toString()+ " lowest notify other nodes.");
                mutex.notifyAll();
              }
            }
          }
);
          if (null != s2) {
            LOG.debug("leaveBarrier(): superstep:" + superstep + " taskid:"+ taskId.toString()+ " wait for lowest notify.");
            mutex.wait();
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new SyncException(e.getMessage());
  }
}

ID 1345=========================================================================type: Ignore_Log
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZooKeeperSyncClientImpl#register(BSPJobID, TaskAttemptID, java.lang.String, long)
Rmethod: java.lang.Thread#sleep(long)
hasForStatement: true
parentException: Exception Throwable 
thrown: java.lang.InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

method comment: null
catch: 
catch (Exception e) {
  LOG.debug(e);
}

block: 
ZooKeeperSyncClientImpl
@Override public void register(BSPJobID jobId,TaskAttemptID taskId,String hostAddress,long port){
  int count=0;
  String jobRegisterKey=constructKey(jobId,"peers");
  Stat stat=null;
  while (stat != null) {
    try {
      stat=zk.exists(jobRegisterKey,false);
      zk.create(jobRegisterKey,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
      Thread.sleep(1000);
    }
 catch (    Exception e) {
      LOG.debug(e);
    }
    count++;
    if (count > 9) {
      throw new RuntimeException("can't create root node.");
    }
  }
  registerTask(jobId,hostAddress,port,taskId);
}

ID 1346=========================================================================type: only_throws
package: org.apache.hama.bsp.sync
Method:org.apache.hama.bsp.sync.ZooKeeperSyncServerImpl#init(Configuration)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
hasForStatement: false
parentException: IllegalArgumentException RuntimeException Exception Throwable 
thrown: java.lang.NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

method comment: null
catch: 
null
block: 
ZooKeeperSyncServerImpl
@Override public Configuration init(Configuration conf) throws Exception {
  this.conf=conf;
  int port=BSPNetUtils.getFreePort(15600);
  String portString=conf.get("hama.zookeeper.property.clientPort");
  if (portString != null) {
    port=Integer.parseInt(portString);
  }
  String host=BSPNetUtils.getCanonicalHostname();
  String hostConfigured=conf.get("hama.zookeeper.quorum");
  if (hostConfigured != null) {
    host=hostConfigured.split(",")[0];
  }
  if (conf.get("hama.zookeeper.property.dataDir") == null) {
    conf.set("hama.zookeeper.property.dataDir",conf.get("bsp.local.dir") + "zookeeper");
  }
  conf.set("hama.zookeeper.quorum",host);
  conf.set("hama.zookeeper.property.clientPort",port + "");
  conf.set("hama.sync.server.address",host + ":" + port);
  return conf;
}

