ID 47=========================================================================type: 1
Method:websocket.echo.EchoAnnotation#echoTextMessage(javax.websocket.Session, java.lang.String, boolean)
Rmethod: javax.websocket.Basic#sendText(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@OnMessage public void echoTextMessage(Session session,String msg,boolean last){
  try {
    if (session.isOpen()) {
      session.getBasicRemote().sendText(msg,last);
    }
  }
 catch (  IOException e) {
    try {
      session.close();
    }
 catch (    IOException e1) {
    }
  }
}

ID 49=========================================================================type: 1
Method:websocket.echo.EchoAnnotation#echoBinaryMessage(javax.websocket.Session, java.nio.ByteBuffer, boolean)
Rmethod: javax.websocket.Basic#sendBinary(java.nio.ByteBuffer, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@OnMessage public void echoBinaryMessage(Session session,ByteBuffer bb,boolean last){
  try {
    if (session.isOpen()) {
      session.getBasicRemote().sendBinary(bb,last);
    }
  }
 catch (  IOException e) {
    try {
      session.close();
    }
 catch (    IOException e1) {
    }
  }
}

ID 51=========================================================================type: 1
Method:websocket.echo.EchoMessageHandlerText#onMessage(java.lang.String, boolean)
Rmethod: javax.websocket.Basic#sendText(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void onMessage(String message,boolean last){
  try {
    if (remoteEndpointBasic != null) {
      remoteEndpointBasic.sendText(message,last);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}

ID 52=========================================================================type: 1
Method:websocket.echo.EchoMessageHandlerBinary#onMessage(java.nio.ByteBuffer, boolean)
Rmethod: javax.websocket.Basic#sendBinary(java.nio.ByteBuffer, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void onMessage(ByteBuffer message,boolean last){
  try {
    if (remoteEndpointBasic != null) {
      remoteEndpointBasic.sendBinary(message,last);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}

ID 53=========================================================================type: 1
Method:websocket.chat.ChatAnnotation#broadcast(java.lang.String)
Rmethod: javax.websocket.Basic#sendText(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private static void broadcast(String msg){
  for (  ChatAnnotation client : connections) {
    try {
synchronized (client) {
        client.session.getBasicRemote().sendText(msg);
      }
    }
 catch (    IOException e) {
      log.debug("Chat Error: Failed to send message to client",e);
      connections.remove(client);
      try {
        client.session.close();
      }
 catch (      IOException e1) {
      }
      String message=String.format("* %s %s",client.nickname,"has been disconnected.");
      broadcast(message);
    }
  }
}

ID 56=========================================================================type: 1
Method:websocket.drawboard.DrawMessage#parseFromString(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public static DrawMessage parseFromString(String str) throws ParseException {
  int type;
  byte[] colors=new byte[4];
  double thickness;
  double[] coords=new double[4];
  boolean last;
  try {
    String[] elements=str.split(",");
    type=Integer.parseInt(elements[0]);
    if (!(type >= 1 && type <= 4))     throw new ParseException("Invalid type: " + type);
    for (int i=0; i < colors.length; i++) {
      colors[i]=(byte)Integer.parseInt(elements[1 + i]);
    }
    thickness=Double.parseDouble(elements[5]);
    if (Double.isNaN(thickness) || thickness < 0 || thickness > 100)     throw new ParseException("Invalid thickness: " + thickness);
    for (int i=0; i < coords.length; i++) {
      coords[i]=Double.parseDouble(elements[6 + i]);
      if (Double.isNaN(coords[i]))       throw new ParseException("Invalid coordinate: " + coords[i]);
    }
    last=!"0".equals(elements[10]);
  }
 catch (  RuntimeException ex) {
    throw new ParseException(ex);
  }
  DrawMessage m=new DrawMessage(type,colors[0],colors[1],colors[2],colors[3],thickness,coords[0],coords[2],coords[1],coords[3],last);
  return m;
}

ID 57=========================================================================type: 1
Method:websocket.drawboard.DrawMessage#parseFromString(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public static DrawMessage parseFromString(String str) throws ParseException {
  int type;
  byte[] colors=new byte[4];
  double thickness;
  double[] coords=new double[4];
  boolean last;
  try {
    String[] elements=str.split(",");
    type=Integer.parseInt(elements[0]);
    if (!(type >= 1 && type <= 4))     throw new ParseException("Invalid type: " + type);
    for (int i=0; i < colors.length; i++) {
      colors[i]=(byte)Integer.parseInt(elements[1 + i]);
    }
    thickness=Double.parseDouble(elements[5]);
    if (Double.isNaN(thickness) || thickness < 0 || thickness > 100)     throw new ParseException("Invalid thickness: " + thickness);
    for (int i=0; i < coords.length; i++) {
      coords[i]=Double.parseDouble(elements[6 + i]);
      if (Double.isNaN(coords[i]))       throw new ParseException("Invalid coordinate: " + coords[i]);
    }
    last=!"0".equals(elements[10]);
  }
 catch (  RuntimeException ex) {
    throw new ParseException(ex);
  }
  DrawMessage m=new DrawMessage(type,colors[0],colors[1],colors[2],colors[3],thickness,coords[0],coords[2],coords[1],coords[3],last);
  return m;
}

ID 58=========================================================================type: 1
Method:websocket.drawboard.DrawMessage#parseFromString(java.lang.String)
Rmethod: java.lang.Double#parseDouble(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public static DrawMessage parseFromString(String str) throws ParseException {
  int type;
  byte[] colors=new byte[4];
  double thickness;
  double[] coords=new double[4];
  boolean last;
  try {
    String[] elements=str.split(",");
    type=Integer.parseInt(elements[0]);
    if (!(type >= 1 && type <= 4))     throw new ParseException("Invalid type: " + type);
    for (int i=0; i < colors.length; i++) {
      colors[i]=(byte)Integer.parseInt(elements[1 + i]);
    }
    thickness=Double.parseDouble(elements[5]);
    if (Double.isNaN(thickness) || thickness < 0 || thickness > 100)     throw new ParseException("Invalid thickness: " + thickness);
    for (int i=0; i < coords.length; i++) {
      coords[i]=Double.parseDouble(elements[6 + i]);
      if (Double.isNaN(coords[i]))       throw new ParseException("Invalid coordinate: " + coords[i]);
    }
    last=!"0".equals(elements[10]);
  }
 catch (  RuntimeException ex) {
    throw new ParseException(ex);
  }
  DrawMessage m=new DrawMessage(type,colors[0],colors[1],colors[2],colors[3],thickness,coords[0],coords[2],coords[1],coords[3],last);
  return m;
}

ID 59=========================================================================type: 1
Method:websocket.drawboard.DrawMessage#parseFromString(java.lang.String)
Rmethod: java.lang.Double#parseDouble(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public static DrawMessage parseFromString(String str) throws ParseException {
  int type;
  byte[] colors=new byte[4];
  double thickness;
  double[] coords=new double[4];
  boolean last;
  try {
    String[] elements=str.split(",");
    type=Integer.parseInt(elements[0]);
    if (!(type >= 1 && type <= 4))     throw new ParseException("Invalid type: " + type);
    for (int i=0; i < colors.length; i++) {
      colors[i]=(byte)Integer.parseInt(elements[1 + i]);
    }
    thickness=Double.parseDouble(elements[5]);
    if (Double.isNaN(thickness) || thickness < 0 || thickness > 100)     throw new ParseException("Invalid thickness: " + thickness);
    for (int i=0; i < coords.length; i++) {
      coords[i]=Double.parseDouble(elements[6 + i]);
      if (Double.isNaN(coords[i]))       throw new ParseException("Invalid coordinate: " + coords[i]);
    }
    last=!"0".equals(elements[10]);
  }
 catch (  RuntimeException ex) {
    throw new ParseException(ex);
  }
  DrawMessage m=new DrawMessage(type,colors[0],colors[1],colors[2],colors[3],thickness,coords[0],coords[2],coords[1],coords[3],last);
  return m;
}

ID 64=========================================================================type: 1
Method:websocket.drawboard#onMessage(java.lang.String)
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
@Override public void onMessage(final String message){
  room.invokeAndWait(new Runnable(){
    @Override public void run(){
      try {
        boolean dontSwallowException=false;
        try {
          char messageType=message.charAt(0);
          String messageContent=message.substring(1);
switch (messageType) {
case '0':
            break;
case '1':
          int indexOfChar=messageContent.indexOf('|');
        long msgId=Long.parseLong(messageContent.substring(0,indexOfChar));
      DrawMessage msg=DrawMessage.parseFromString(messageContent.substring(indexOfChar + 1));
    dontSwallowException=true;
  if (player != null) {
    player.handleDrawMessage(msg,msgId);
  }
dontSwallowException=false;
break;
}
}
 catch (RuntimeException ex) {
if (dontSwallowException) {
throw ex;
}
}
catch (ParseException ex) {
}
}
 catch (RuntimeException ex) {
log.error("Unexpected exception: " + ex.toString(),ex);
}
}
}
);
}

ID 66=========================================================================type: 1
Method:websocket.drawboard#run()
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  try {
    boolean dontSwallowException=false;
    try {
      char messageType=message.charAt(0);
      String messageContent=message.substring(1);
switch (messageType) {
case '0':
        break;
case '1':
      int indexOfChar=messageContent.indexOf('|');
    long msgId=Long.parseLong(messageContent.substring(0,indexOfChar));
  DrawMessage msg=DrawMessage.parseFromString(messageContent.substring(indexOfChar + 1));
dontSwallowException=true;
if (player != null) {
player.handleDrawMessage(msg,msgId);
}
dontSwallowException=false;
break;
}
}
 catch (RuntimeException ex) {
if (dontSwallowException) {
throw ex;
}
}
catch (ParseException ex) {
}
}
 catch (RuntimeException ex) {
log.error("Unexpected exception: " + ex.toString(),ex);
}
}

ID 68=========================================================================type: 1
Method:websocket.snake.Snake#sendMessage(java.lang.String)
Rmethod: javax.websocket.Basic#sendText(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void sendMessage(String msg){
  try {
    session.getBasicRemote().sendText(msg);
  }
 catch (  IOException ioe) {
    CloseReason cr=new CloseReason(CloseCodes.CLOSED_ABNORMALLY,ioe.getMessage());
    try {
      session.close(cr);
    }
 catch (    IOException ioe2) {
    }
  }
}

ID 92=========================================================================type: 1
Method:chat.MessageSender#run()
Rmethod: javax.servlet.ServletResponse#getWriter()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * The background thread that listens for incoming TCP/IP connections and hands them off to an appropriate processor.
 */
@Override public void run(){
  while (running) {
    String[] pendingMessages;
synchronized (messages) {
      try {
        if (running && messages.size() == 0) {
          messages.wait();
        }
      }
 catch (      InterruptedException e) {
      }
      pendingMessages=messages.toArray(new String[0]);
      messages.clear();
    }
synchronized (connections) {
      for (int i=0; i < connections.size(); i++) {
        try {
          PrintWriter writer=connections.get(i).getWriter();
          for (int j=0; j < pendingMessages.length; j++) {
            writer.println("<div>" + filter(pendingMessages[j]) + "</div>");
          }
          writer.flush();
        }
 catch (        IOException e) {
          log("IOException sending message",e);
        }
      }
    }
  }
}

ID 105=========================================================================type: 1
Method:org.apache.juli.ClassLoaderLogManager#readConfiguration(java.lang.ClassLoader)
Rmethod: java.io.FileInputStream#FileInputStream(java.lang.String)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Read configuration for the specified classloader.
 * @param classLoader 
 * @throws IOException Error
 */
protected synchronized void readConfiguration(ClassLoader classLoader) throws IOException {
  InputStream is=null;
  try {
    if (classLoader instanceof URLClassLoader) {
      URL logConfig=((URLClassLoader)classLoader).findResource("logging.properties");
      if (null != logConfig) {
        if (Boolean.getBoolean(DEBUG_PROPERTY))         System.err.println(getClass().getName() + ".readConfiguration(): " + "Found logging.properties at "+ logConfig);
        is=classLoader.getResourceAsStream("logging.properties");
      }
 else {
        if (Boolean.getBoolean(DEBUG_PROPERTY))         System.err.println(getClass().getName() + ".readConfiguration(): " + "Found no logging.properties");
      }
    }
  }
 catch (  AccessControlException ace) {
    ClassLoaderLogInfo info=classLoaderLoggers.get(ClassLoader.getSystemClassLoader());
    if (info != null) {
      Logger log=info.loggers.get("");
      if (log != null) {
        Permission perm=ace.getPermission();
        if (perm instanceof FilePermission && perm.getActions().equals("read")) {
          log.warning("Reading " + perm.getName() + " is not permitted. See \"per context logging\" in the default catalina.policy file.");
        }
 else {
          log.warning("Reading logging.properties is not permitted in some context. See \"per context logging\" in the default catalina.policy file.");
          log.warning("Original error was: " + ace.getMessage());
        }
      }
    }
  }
  if ((is == null) && (classLoader == ClassLoader.getSystemClassLoader())) {
    String configFileStr=System.getProperty("java.util.logging.config.file");
    if (configFileStr != null) {
      try {
        is=new FileInputStream(replace(configFileStr));
      }
 catch (      IOException e) {
        System.err.println("Configuration error");
        e.printStackTrace();
      }
    }
    if (is == null) {
      File defaultFile=new File(new File(System.getProperty("java.home"),"lib"),"logging.properties");
      try {
        is=new FileInputStream(defaultFile);
      }
 catch (      IOException e) {
        System.err.println("Configuration error");
        e.printStackTrace();
      }
    }
  }
  Logger localRootLogger=new RootLogger();
  if (is == null) {
    ClassLoader current=classLoader.getParent();
    ClassLoaderLogInfo info=null;
    while (current != null && info == null) {
      info=getClassLoaderInfo(current);
      current=current.getParent();
    }
    if (info != null) {
      localRootLogger.setParent(info.rootNode.logger);
    }
  }
  ClassLoaderLogInfo info=new ClassLoaderLogInfo(new LogNode(null,localRootLogger));
  classLoaderLoggers.put(classLoader,info);
  if (is != null) {
    readConfiguration(is,classLoader);
  }
  addLogger(localRootLogger);
}

ID 106=========================================================================type: 1
Method:org.apache.juli.ClassLoaderLogManager#readConfiguration(java.lang.ClassLoader)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Read configuration for the specified classloader.
 * @param classLoader 
 * @throws IOException Error
 */
protected synchronized void readConfiguration(ClassLoader classLoader) throws IOException {
  InputStream is=null;
  try {
    if (classLoader instanceof URLClassLoader) {
      URL logConfig=((URLClassLoader)classLoader).findResource("logging.properties");
      if (null != logConfig) {
        if (Boolean.getBoolean(DEBUG_PROPERTY))         System.err.println(getClass().getName() + ".readConfiguration(): " + "Found logging.properties at "+ logConfig);
        is=classLoader.getResourceAsStream("logging.properties");
      }
 else {
        if (Boolean.getBoolean(DEBUG_PROPERTY))         System.err.println(getClass().getName() + ".readConfiguration(): " + "Found no logging.properties");
      }
    }
  }
 catch (  AccessControlException ace) {
    ClassLoaderLogInfo info=classLoaderLoggers.get(ClassLoader.getSystemClassLoader());
    if (info != null) {
      Logger log=info.loggers.get("");
      if (log != null) {
        Permission perm=ace.getPermission();
        if (perm instanceof FilePermission && perm.getActions().equals("read")) {
          log.warning("Reading " + perm.getName() + " is not permitted. See \"per context logging\" in the default catalina.policy file.");
        }
 else {
          log.warning("Reading logging.properties is not permitted in some context. See \"per context logging\" in the default catalina.policy file.");
          log.warning("Original error was: " + ace.getMessage());
        }
      }
    }
  }
  if ((is == null) && (classLoader == ClassLoader.getSystemClassLoader())) {
    String configFileStr=System.getProperty("java.util.logging.config.file");
    if (configFileStr != null) {
      try {
        is=new FileInputStream(replace(configFileStr));
      }
 catch (      IOException e) {
        System.err.println("Configuration error");
        e.printStackTrace();
      }
    }
    if (is == null) {
      File defaultFile=new File(new File(System.getProperty("java.home"),"lib"),"logging.properties");
      try {
        is=new FileInputStream(defaultFile);
      }
 catch (      IOException e) {
        System.err.println("Configuration error");
        e.printStackTrace();
      }
    }
  }
  Logger localRootLogger=new RootLogger();
  if (is == null) {
    ClassLoader current=classLoader.getParent();
    ClassLoaderLogInfo info=null;
    while (current != null && info == null) {
      info=getClassLoaderInfo(current);
      current=current.getParent();
    }
    if (info != null) {
      localRootLogger.setParent(info.rootNode.logger);
    }
  }
  ClassLoaderLogInfo info=new ClassLoaderLogInfo(new LogNode(null,localRootLogger));
  classLoaderLoggers.put(classLoader,info);
  if (is != null) {
    readConfiguration(is,classLoader);
  }
  addLogger(localRootLogger);
}

ID 108=========================================================================type: 1
Method:org.apache.juli.ClassLoaderLogManager#readConfiguration(java.io.InputStream, java.lang.ClassLoader)
Rmethod: java.util.Properties#load(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Load specified configuration.
 * @param is InputStream to the properties file
 * @param classLoader for which the configuration will be loaded
 * @throws IOException If something wrong happens during loading
 */
protected synchronized void readConfiguration(InputStream is,ClassLoader classLoader) throws IOException {
  ClassLoaderLogInfo info=classLoaderLoggers.get(classLoader);
  try {
    info.props.load(is);
  }
 catch (  IOException e) {
    System.err.println("Configuration error");
    e.printStackTrace();
  }
 finally {
    try {
      is.close();
    }
 catch (    IOException ioe) {
    }
  }
  String rootHandlers=info.props.getProperty(".handlers");
  String handlers=info.props.getProperty("handlers");
  Logger localRootLogger=info.rootNode.logger;
  if (handlers != null) {
    StringTokenizer tok=new StringTokenizer(handlers,",");
    while (tok.hasMoreTokens()) {
      String handlerName=(tok.nextToken().trim());
      String handlerClassName=handlerName;
      String prefix="";
      if (handlerClassName.length() <= 0) {
        continue;
      }
      if (Character.isDigit(handlerClassName.charAt(0))) {
        int pos=handlerClassName.indexOf('.');
        if (pos >= 0) {
          prefix=handlerClassName.substring(0,pos + 1);
          handlerClassName=handlerClassName.substring(pos + 1);
        }
      }
      try {
        this.prefix.set(prefix);
        Handler handler=(Handler)classLoader.loadClass(handlerClassName).newInstance();
        this.prefix.set(null);
        info.handlers.put(handlerName,handler);
        if (rootHandlers == null) {
          localRootLogger.addHandler(handler);
        }
      }
 catch (      Exception e) {
        System.err.println("Handler error");
        e.printStackTrace();
      }
    }
  }
}

ID 128=========================================================================type: 1
Method:org.apache.juli.AsyncFileHandler#publish(java.util.logging.LogRecord)
Rmethod: java.util.concurrent.LinkedBlockingDeque#offer(E, long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void publish(LogRecord record){
  if (!isLoggable(record)) {
    return;
  }
  LogEntry entry=new LogEntry(record,this);
  boolean added=false;
  try {
    while (!added && !queue.offer(entry)) {
switch (OVERFLOW_DROP_TYPE) {
case OVERFLOW_DROP_LAST:
{
          queue.pollLast();
          break;
        }
case OVERFLOW_DROP_FIRST:
{
        queue.pollFirst();
        break;
      }
case OVERFLOW_DROP_FLUSH:
{
      added=queue.offer(entry,1000,TimeUnit.MILLISECONDS);
      break;
    }
case OVERFLOW_DROP_CURRENT:
{
    added=true;
    break;
  }
}
}
}
 catch (InterruptedException x) {
Thread.interrupted();
}
}

ID 129=========================================================================type: 1
Method:org.apache.juli.LoggerThread#run()
Rmethod: java.util.concurrent.LinkedBlockingDeque#poll(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  while (run) {
    try {
      LogEntry entry=queue.poll(LOGGER_SLEEP_TIME,TimeUnit.MILLISECONDS);
      if (entry != null)       entry.flush();
    }
 catch (    InterruptedException x) {
      Thread.interrupted();
    }
catch (    Exception x) {
      x.printStackTrace();
    }
  }
}

ID 136=========================================================================type: 1
Method:org.apache.catalina.ant.JKStatusUpdateTask#createLink()
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Create JkStatus link <ul> <li><b>load balance example: </b>http://localhost/status?cmd=update&mime=txt&w=lb&lf=false&ls=true</li> <li><b>worker example: </b>http://localhost/status?cmd=update&mime=txt&w=node1&l=lb&wf=1&wd=false&ws=false </li> </ul>
 * @return create jkstatus link
 */
private StringBuilder createLink(){
  StringBuilder sb=new StringBuilder();
  try {
    sb.append("?cmd=update&mime=txt");
    sb.append("&w=");
    sb.append(URLEncoder.encode(worker,getCharset()));
    if (isLBMode) {
      if ((lbRetries != null)) {
        sb.append("&lr=");
        sb.append(lbRetries);
      }
      if ((lbRecovertime != null)) {
        sb.append("&lt=");
        sb.append(lbRecovertime);
      }
      if ((lbStickySession != null)) {
        sb.append("&ls=");
        sb.append(lbStickySession);
      }
      if ((lbForceSession != null)) {
        sb.append("&lf=");
        sb.append(lbForceSession);
      }
    }
 else {
      if ((workerLb != null)) {
        sb.append("&l=");
        sb.append(URLEncoder.encode(workerLb,getCharset()));
      }
      if ((workerLoadFactor != null)) {
        sb.append("&wf=");
        sb.append(workerLoadFactor);
      }
      if ((workerDisabled != null)) {
        sb.append("&wd=");
        sb.append(workerDisabled);
      }
      if ((workerStopped != null)) {
        sb.append("&ws=");
        sb.append(workerStopped);
      }
      if ((workerRedirect != null)) {
        sb.append("&wr=");
      }
      if ((workerClusterDomain != null)) {
        sb.append("&wc=");
        sb.append(URLEncoder.encode(workerClusterDomain,getCharset()));
      }
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
  return sb;
}

ID 146=========================================================================type: 1
Method:org.apache.catalina.ant.DeployTask#execute()
Rmethod: java.net.URL#URL(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (path == null) {
    throw new BuildException("Must specify 'path' attribute");
  }
  if ((war == null) && (localWar == null) && (config == null)&& (tag == null)) {
    throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute");
  }
  BufferedInputStream stream=null;
  String contentType=null;
  int contentLength=-1;
  if (war != null) {
    if (PROTOCOL_PATTERN.matcher(war).lookingAt()) {
      try {
        URL url=new URL(war);
        URLConnection conn=url.openConnection();
        contentLength=conn.getContentLength();
        stream=new BufferedInputStream(conn.getInputStream(),1024);
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
    }
 else {
      FileInputStream fsInput=null;
      try {
        fsInput=new FileInputStream(war);
        long size=fsInput.getChannel().size();
        if (size > Integer.MAX_VALUE)         throw new UnsupportedOperationException("DeployTask does not support WAR files " + "greater than 2 Gb");
        contentLength=(int)size;
        stream=new BufferedInputStream(fsInput,1024);
      }
 catch (      IOException e) {
        if (fsInput != null) {
          try {
            fsInput.close();
          }
 catch (          IOException ioe) {
          }
        }
        throw new BuildException(e);
      }
    }
    contentType="application/octet-stream";
  }
  StringBuilder sb=createQueryString("/deploy");
  try {
    if ((war == null) && (config != null)) {
      sb.append("&config=");
      sb.append(URLEncoder.encode(config,getCharset()));
    }
    if ((war == null) && (localWar != null)) {
      sb.append("&war=");
      sb.append(URLEncoder.encode(localWar,getCharset()));
    }
    if (update) {
      sb.append("&update=true");
    }
    if (tag != null) {
      sb.append("&tag=");
      sb.append(URLEncoder.encode(tag,getCharset()));
    }
    execute(sb.toString(),stream,contentType,contentLength);
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
 finally {
    if (stream != null) {
      try {
        stream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}

ID 147=========================================================================type: 1
Method:org.apache.catalina.ant.DeployTask#execute()
Rmethod: java.net.URL#openConnection()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (path == null) {
    throw new BuildException("Must specify 'path' attribute");
  }
  if ((war == null) && (localWar == null) && (config == null)&& (tag == null)) {
    throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute");
  }
  BufferedInputStream stream=null;
  String contentType=null;
  int contentLength=-1;
  if (war != null) {
    if (PROTOCOL_PATTERN.matcher(war).lookingAt()) {
      try {
        URL url=new URL(war);
        URLConnection conn=url.openConnection();
        contentLength=conn.getContentLength();
        stream=new BufferedInputStream(conn.getInputStream(),1024);
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
    }
 else {
      FileInputStream fsInput=null;
      try {
        fsInput=new FileInputStream(war);
        long size=fsInput.getChannel().size();
        if (size > Integer.MAX_VALUE)         throw new UnsupportedOperationException("DeployTask does not support WAR files " + "greater than 2 Gb");
        contentLength=(int)size;
        stream=new BufferedInputStream(fsInput,1024);
      }
 catch (      IOException e) {
        if (fsInput != null) {
          try {
            fsInput.close();
          }
 catch (          IOException ioe) {
          }
        }
        throw new BuildException(e);
      }
    }
    contentType="application/octet-stream";
  }
  StringBuilder sb=createQueryString("/deploy");
  try {
    if ((war == null) && (config != null)) {
      sb.append("&config=");
      sb.append(URLEncoder.encode(config,getCharset()));
    }
    if ((war == null) && (localWar != null)) {
      sb.append("&war=");
      sb.append(URLEncoder.encode(localWar,getCharset()));
    }
    if (update) {
      sb.append("&update=true");
    }
    if (tag != null) {
      sb.append("&tag=");
      sb.append(URLEncoder.encode(tag,getCharset()));
    }
    execute(sb.toString(),stream,contentType,contentLength);
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
 finally {
    if (stream != null) {
      try {
        stream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}

ID 148=========================================================================type: 1
Method:org.apache.catalina.ant.DeployTask#execute()
Rmethod: java.net.URLConnection#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (path == null) {
    throw new BuildException("Must specify 'path' attribute");
  }
  if ((war == null) && (localWar == null) && (config == null)&& (tag == null)) {
    throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute");
  }
  BufferedInputStream stream=null;
  String contentType=null;
  int contentLength=-1;
  if (war != null) {
    if (PROTOCOL_PATTERN.matcher(war).lookingAt()) {
      try {
        URL url=new URL(war);
        URLConnection conn=url.openConnection();
        contentLength=conn.getContentLength();
        stream=new BufferedInputStream(conn.getInputStream(),1024);
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
    }
 else {
      FileInputStream fsInput=null;
      try {
        fsInput=new FileInputStream(war);
        long size=fsInput.getChannel().size();
        if (size > Integer.MAX_VALUE)         throw new UnsupportedOperationException("DeployTask does not support WAR files " + "greater than 2 Gb");
        contentLength=(int)size;
        stream=new BufferedInputStream(fsInput,1024);
      }
 catch (      IOException e) {
        if (fsInput != null) {
          try {
            fsInput.close();
          }
 catch (          IOException ioe) {
          }
        }
        throw new BuildException(e);
      }
    }
    contentType="application/octet-stream";
  }
  StringBuilder sb=createQueryString("/deploy");
  try {
    if ((war == null) && (config != null)) {
      sb.append("&config=");
      sb.append(URLEncoder.encode(config,getCharset()));
    }
    if ((war == null) && (localWar != null)) {
      sb.append("&war=");
      sb.append(URLEncoder.encode(localWar,getCharset()));
    }
    if (update) {
      sb.append("&update=true");
    }
    if (tag != null) {
      sb.append("&tag=");
      sb.append(URLEncoder.encode(tag,getCharset()));
    }
    execute(sb.toString(),stream,contentType,contentLength);
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
 finally {
    if (stream != null) {
      try {
        stream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}

ID 149=========================================================================type: 1
Method:org.apache.catalina.ant.DeployTask#execute()
Rmethod: java.io.FileInputStream#FileInputStream(java.lang.String)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (path == null) {
    throw new BuildException("Must specify 'path' attribute");
  }
  if ((war == null) && (localWar == null) && (config == null)&& (tag == null)) {
    throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute");
  }
  BufferedInputStream stream=null;
  String contentType=null;
  int contentLength=-1;
  if (war != null) {
    if (PROTOCOL_PATTERN.matcher(war).lookingAt()) {
      try {
        URL url=new URL(war);
        URLConnection conn=url.openConnection();
        contentLength=conn.getContentLength();
        stream=new BufferedInputStream(conn.getInputStream(),1024);
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
    }
 else {
      FileInputStream fsInput=null;
      try {
        fsInput=new FileInputStream(war);
        long size=fsInput.getChannel().size();
        if (size > Integer.MAX_VALUE)         throw new UnsupportedOperationException("DeployTask does not support WAR files " + "greater than 2 Gb");
        contentLength=(int)size;
        stream=new BufferedInputStream(fsInput,1024);
      }
 catch (      IOException e) {
        if (fsInput != null) {
          try {
            fsInput.close();
          }
 catch (          IOException ioe) {
          }
        }
        throw new BuildException(e);
      }
    }
    contentType="application/octet-stream";
  }
  StringBuilder sb=createQueryString("/deploy");
  try {
    if ((war == null) && (config != null)) {
      sb.append("&config=");
      sb.append(URLEncoder.encode(config,getCharset()));
    }
    if ((war == null) && (localWar != null)) {
      sb.append("&war=");
      sb.append(URLEncoder.encode(localWar,getCharset()));
    }
    if (update) {
      sb.append("&update=true");
    }
    if (tag != null) {
      sb.append("&tag=");
      sb.append(URLEncoder.encode(tag,getCharset()));
    }
    execute(sb.toString(),stream,contentType,contentLength);
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
 finally {
    if (stream != null) {
      try {
        stream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}

ID 150=========================================================================type: 1
Method:org.apache.catalina.ant.DeployTask#execute()
Rmethod: java.nio.channels.FileChannel#size()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (path == null) {
    throw new BuildException("Must specify 'path' attribute");
  }
  if ((war == null) && (localWar == null) && (config == null)&& (tag == null)) {
    throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute");
  }
  BufferedInputStream stream=null;
  String contentType=null;
  int contentLength=-1;
  if (war != null) {
    if (PROTOCOL_PATTERN.matcher(war).lookingAt()) {
      try {
        URL url=new URL(war);
        URLConnection conn=url.openConnection();
        contentLength=conn.getContentLength();
        stream=new BufferedInputStream(conn.getInputStream(),1024);
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
    }
 else {
      FileInputStream fsInput=null;
      try {
        fsInput=new FileInputStream(war);
        long size=fsInput.getChannel().size();
        if (size > Integer.MAX_VALUE)         throw new UnsupportedOperationException("DeployTask does not support WAR files " + "greater than 2 Gb");
        contentLength=(int)size;
        stream=new BufferedInputStream(fsInput,1024);
      }
 catch (      IOException e) {
        if (fsInput != null) {
          try {
            fsInput.close();
          }
 catch (          IOException ioe) {
          }
        }
        throw new BuildException(e);
      }
    }
    contentType="application/octet-stream";
  }
  StringBuilder sb=createQueryString("/deploy");
  try {
    if ((war == null) && (config != null)) {
      sb.append("&config=");
      sb.append(URLEncoder.encode(config,getCharset()));
    }
    if ((war == null) && (localWar != null)) {
      sb.append("&war=");
      sb.append(URLEncoder.encode(localWar,getCharset()));
    }
    if (update) {
      sb.append("&update=true");
    }
    if (tag != null) {
      sb.append("&tag=");
      sb.append(URLEncoder.encode(tag,getCharset()));
    }
    execute(sb.toString(),stream,contentType,contentLength);
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
 finally {
    if (stream != null) {
      try {
        stream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}

ID 153=========================================================================type: 1
Method:org.apache.catalina.ant.DeployTask#execute()
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (path == null) {
    throw new BuildException("Must specify 'path' attribute");
  }
  if ((war == null) && (localWar == null) && (config == null)&& (tag == null)) {
    throw new BuildException("Must specify either 'war', 'localWar', 'config', or 'tag' attribute");
  }
  BufferedInputStream stream=null;
  String contentType=null;
  int contentLength=-1;
  if (war != null) {
    if (PROTOCOL_PATTERN.matcher(war).lookingAt()) {
      try {
        URL url=new URL(war);
        URLConnection conn=url.openConnection();
        contentLength=conn.getContentLength();
        stream=new BufferedInputStream(conn.getInputStream(),1024);
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
    }
 else {
      FileInputStream fsInput=null;
      try {
        fsInput=new FileInputStream(war);
        long size=fsInput.getChannel().size();
        if (size > Integer.MAX_VALUE)         throw new UnsupportedOperationException("DeployTask does not support WAR files " + "greater than 2 Gb");
        contentLength=(int)size;
        stream=new BufferedInputStream(fsInput,1024);
      }
 catch (      IOException e) {
        if (fsInput != null) {
          try {
            fsInput.close();
          }
 catch (          IOException ioe) {
          }
        }
        throw new BuildException(e);
      }
    }
    contentType="application/octet-stream";
  }
  StringBuilder sb=createQueryString("/deploy");
  try {
    if ((war == null) && (config != null)) {
      sb.append("&config=");
      sb.append(URLEncoder.encode(config,getCharset()));
    }
    if ((war == null) && (localWar != null)) {
      sb.append("&war=");
      sb.append(URLEncoder.encode(localWar,getCharset()));
    }
    if (update) {
      sb.append("&update=true");
    }
    if (tag != null) {
      sb.append("&tag=");
      sb.append(URLEncoder.encode(tag,getCharset()));
    }
    execute(sb.toString(),stream,contentType,contentLength);
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
 finally {
    if (stream != null) {
      try {
        stream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}

ID 226=========================================================================type: 1
Method:org.apache.catalina.ant.jmx.JMXAccessorTask#execute()
Rmethod: org.apache.catalina.ant.jmx.JMXAccessorTask#jmxExecute(javax.management.MBeanServerConnection)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Execute the specified command. This logic only performs the common attribute validation required by all subclasses; it does not perform any functional logic directly.
 * @exception BuildException if a validation error occurs
 */
@Override public void execute() throws BuildException {
  if (testIfCondition() && testUnlessCondition()) {
    try {
      String error=null;
      MBeanServerConnection jmxServerConnection=getJMXConnection();
      error=jmxExecute(jmxServerConnection);
      if (error != null && isFailOnError()) {
        throw new BuildException(error);
      }
    }
 catch (    Exception e) {
      if (isFailOnError()) {
        throw new BuildException(e);
      }
 else {
        handleErrorOutput(e.getMessage());
      }
    }
 finally {
      closeRedirector();
    }
  }
}

ID 234=========================================================================type: 1
Method:org.apache.catalina.ant.jmx.JMXAccessorTask#convertStringToType(java.lang.String, java.lang.String)
Rmethod: java.lang.Integer#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Convert string to datatype FIXME How we can transfer values from ant project reference store (ref)?
 * @param value The value
 * @param valueType The type
 * @return The converted object
 */
protected Object convertStringToType(String value,String valueType){
  if ("java.lang.String".equals(valueType))   return value;
  Object convertValue=value;
  if ("java.lang.Integer".equals(valueType) || "int".equals(valueType)) {
    try {
      convertValue=Integer.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to integer:" + value);
    }
  }
 else   if ("java.lang.Long".equals(valueType) || "long".equals(valueType)) {
    try {
      convertValue=Long.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to long:" + value);
    }
  }
 else   if ("java.lang.Boolean".equals(valueType) || "boolean".equals(valueType)) {
    convertValue=Boolean.valueOf(value);
  }
 else   if ("java.lang.Float".equals(valueType) || "float".equals(valueType)) {
    try {
      convertValue=Float.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to float:" + value);
    }
  }
 else   if ("java.lang.Double".equals(valueType) || "double".equals(valueType)) {
    try {
      convertValue=Double.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to double:" + value);
    }
  }
 else   if ("javax.management.ObjectName".equals(valueType) || "name".equals(valueType)) {
    try {
      convertValue=new ObjectName(value);
    }
 catch (    MalformedObjectNameException e) {
      if (isEcho())       handleErrorOutput("Unable to convert to ObjectName:" + value);
    }
  }
 else   if ("java.net.InetAddress".equals(valueType)) {
    try {
      convertValue=InetAddress.getByName(value);
    }
 catch (    UnknownHostException exc) {
      if (isEcho())       handleErrorOutput("Unable to resolve host name:" + value);
    }
  }
  return convertValue;
}

ID 235=========================================================================type: 1
Method:org.apache.catalina.ant.jmx.JMXAccessorTask#convertStringToType(java.lang.String, java.lang.String)
Rmethod: java.lang.Long#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Convert string to datatype FIXME How we can transfer values from ant project reference store (ref)?
 * @param value The value
 * @param valueType The type
 * @return The converted object
 */
protected Object convertStringToType(String value,String valueType){
  if ("java.lang.String".equals(valueType))   return value;
  Object convertValue=value;
  if ("java.lang.Integer".equals(valueType) || "int".equals(valueType)) {
    try {
      convertValue=Integer.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to integer:" + value);
    }
  }
 else   if ("java.lang.Long".equals(valueType) || "long".equals(valueType)) {
    try {
      convertValue=Long.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to long:" + value);
    }
  }
 else   if ("java.lang.Boolean".equals(valueType) || "boolean".equals(valueType)) {
    convertValue=Boolean.valueOf(value);
  }
 else   if ("java.lang.Float".equals(valueType) || "float".equals(valueType)) {
    try {
      convertValue=Float.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to float:" + value);
    }
  }
 else   if ("java.lang.Double".equals(valueType) || "double".equals(valueType)) {
    try {
      convertValue=Double.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to double:" + value);
    }
  }
 else   if ("javax.management.ObjectName".equals(valueType) || "name".equals(valueType)) {
    try {
      convertValue=new ObjectName(value);
    }
 catch (    MalformedObjectNameException e) {
      if (isEcho())       handleErrorOutput("Unable to convert to ObjectName:" + value);
    }
  }
 else   if ("java.net.InetAddress".equals(valueType)) {
    try {
      convertValue=InetAddress.getByName(value);
    }
 catch (    UnknownHostException exc) {
      if (isEcho())       handleErrorOutput("Unable to resolve host name:" + value);
    }
  }
  return convertValue;
}

ID 236=========================================================================type: 1
Method:org.apache.catalina.ant.jmx.JMXAccessorTask#convertStringToType(java.lang.String, java.lang.String)
Rmethod: java.lang.Float#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Convert string to datatype FIXME How we can transfer values from ant project reference store (ref)?
 * @param value The value
 * @param valueType The type
 * @return The converted object
 */
protected Object convertStringToType(String value,String valueType){
  if ("java.lang.String".equals(valueType))   return value;
  Object convertValue=value;
  if ("java.lang.Integer".equals(valueType) || "int".equals(valueType)) {
    try {
      convertValue=Integer.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to integer:" + value);
    }
  }
 else   if ("java.lang.Long".equals(valueType) || "long".equals(valueType)) {
    try {
      convertValue=Long.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to long:" + value);
    }
  }
 else   if ("java.lang.Boolean".equals(valueType) || "boolean".equals(valueType)) {
    convertValue=Boolean.valueOf(value);
  }
 else   if ("java.lang.Float".equals(valueType) || "float".equals(valueType)) {
    try {
      convertValue=Float.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to float:" + value);
    }
  }
 else   if ("java.lang.Double".equals(valueType) || "double".equals(valueType)) {
    try {
      convertValue=Double.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to double:" + value);
    }
  }
 else   if ("javax.management.ObjectName".equals(valueType) || "name".equals(valueType)) {
    try {
      convertValue=new ObjectName(value);
    }
 catch (    MalformedObjectNameException e) {
      if (isEcho())       handleErrorOutput("Unable to convert to ObjectName:" + value);
    }
  }
 else   if ("java.net.InetAddress".equals(valueType)) {
    try {
      convertValue=InetAddress.getByName(value);
    }
 catch (    UnknownHostException exc) {
      if (isEcho())       handleErrorOutput("Unable to resolve host name:" + value);
    }
  }
  return convertValue;
}

ID 237=========================================================================type: 1
Method:org.apache.catalina.ant.jmx.JMXAccessorTask#convertStringToType(java.lang.String, java.lang.String)
Rmethod: java.lang.Double#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Convert string to datatype FIXME How we can transfer values from ant project reference store (ref)?
 * @param value The value
 * @param valueType The type
 * @return The converted object
 */
protected Object convertStringToType(String value,String valueType){
  if ("java.lang.String".equals(valueType))   return value;
  Object convertValue=value;
  if ("java.lang.Integer".equals(valueType) || "int".equals(valueType)) {
    try {
      convertValue=Integer.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to integer:" + value);
    }
  }
 else   if ("java.lang.Long".equals(valueType) || "long".equals(valueType)) {
    try {
      convertValue=Long.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to long:" + value);
    }
  }
 else   if ("java.lang.Boolean".equals(valueType) || "boolean".equals(valueType)) {
    convertValue=Boolean.valueOf(value);
  }
 else   if ("java.lang.Float".equals(valueType) || "float".equals(valueType)) {
    try {
      convertValue=Float.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to float:" + value);
    }
  }
 else   if ("java.lang.Double".equals(valueType) || "double".equals(valueType)) {
    try {
      convertValue=Double.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to double:" + value);
    }
  }
 else   if ("javax.management.ObjectName".equals(valueType) || "name".equals(valueType)) {
    try {
      convertValue=new ObjectName(value);
    }
 catch (    MalformedObjectNameException e) {
      if (isEcho())       handleErrorOutput("Unable to convert to ObjectName:" + value);
    }
  }
 else   if ("java.net.InetAddress".equals(valueType)) {
    try {
      convertValue=InetAddress.getByName(value);
    }
 catch (    UnknownHostException exc) {
      if (isEcho())       handleErrorOutput("Unable to resolve host name:" + value);
    }
  }
  return convertValue;
}

ID 238=========================================================================type: 1
Method:org.apache.catalina.ant.jmx.JMXAccessorTask#convertStringToType(java.lang.String, java.lang.String)
Rmethod: javax.management.ObjectName#ObjectName(java.lang.String)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Convert string to datatype FIXME How we can transfer values from ant project reference store (ref)?
 * @param value The value
 * @param valueType The type
 * @return The converted object
 */
protected Object convertStringToType(String value,String valueType){
  if ("java.lang.String".equals(valueType))   return value;
  Object convertValue=value;
  if ("java.lang.Integer".equals(valueType) || "int".equals(valueType)) {
    try {
      convertValue=Integer.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to integer:" + value);
    }
  }
 else   if ("java.lang.Long".equals(valueType) || "long".equals(valueType)) {
    try {
      convertValue=Long.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to long:" + value);
    }
  }
 else   if ("java.lang.Boolean".equals(valueType) || "boolean".equals(valueType)) {
    convertValue=Boolean.valueOf(value);
  }
 else   if ("java.lang.Float".equals(valueType) || "float".equals(valueType)) {
    try {
      convertValue=Float.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to float:" + value);
    }
  }
 else   if ("java.lang.Double".equals(valueType) || "double".equals(valueType)) {
    try {
      convertValue=Double.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to double:" + value);
    }
  }
 else   if ("javax.management.ObjectName".equals(valueType) || "name".equals(valueType)) {
    try {
      convertValue=new ObjectName(value);
    }
 catch (    MalformedObjectNameException e) {
      if (isEcho())       handleErrorOutput("Unable to convert to ObjectName:" + value);
    }
  }
 else   if ("java.net.InetAddress".equals(valueType)) {
    try {
      convertValue=InetAddress.getByName(value);
    }
 catch (    UnknownHostException exc) {
      if (isEcho())       handleErrorOutput("Unable to resolve host name:" + value);
    }
  }
  return convertValue;
}

ID 239=========================================================================type: 1
Method:org.apache.catalina.ant.jmx.JMXAccessorTask#convertStringToType(java.lang.String, java.lang.String)
Rmethod: java.net.InetAddress#getByName(java.lang.String)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
/** 
 * Convert string to datatype FIXME How we can transfer values from ant project reference store (ref)?
 * @param value The value
 * @param valueType The type
 * @return The converted object
 */
protected Object convertStringToType(String value,String valueType){
  if ("java.lang.String".equals(valueType))   return value;
  Object convertValue=value;
  if ("java.lang.Integer".equals(valueType) || "int".equals(valueType)) {
    try {
      convertValue=Integer.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to integer:" + value);
    }
  }
 else   if ("java.lang.Long".equals(valueType) || "long".equals(valueType)) {
    try {
      convertValue=Long.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to long:" + value);
    }
  }
 else   if ("java.lang.Boolean".equals(valueType) || "boolean".equals(valueType)) {
    convertValue=Boolean.valueOf(value);
  }
 else   if ("java.lang.Float".equals(valueType) || "float".equals(valueType)) {
    try {
      convertValue=Float.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to float:" + value);
    }
  }
 else   if ("java.lang.Double".equals(valueType) || "double".equals(valueType)) {
    try {
      convertValue=Double.valueOf(value);
    }
 catch (    NumberFormatException ex) {
      if (isEcho())       handleErrorOutput("Unable to convert to double:" + value);
    }
  }
 else   if ("javax.management.ObjectName".equals(valueType) || "name".equals(valueType)) {
    try {
      convertValue=new ObjectName(value);
    }
 catch (    MalformedObjectNameException e) {
      if (isEcho())       handleErrorOutput("Unable to convert to ObjectName:" + value);
    }
  }
 else   if ("java.net.InetAddress".equals(valueType)) {
    try {
      convertValue=InetAddress.getByName(value);
    }
 catch (    UnknownHostException exc) {
      if (isEcho())       handleErrorOutput("Unable to resolve host name:" + value);
    }
  }
  return convertValue;
}

ID 270=========================================================================type: 1
Method:org.apache.catalina.ant.AbstractCatalinaCommandTask#createQueryString(java.lang.String)
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Create query string for the specified command.
 * @param command Command to be executed
 * @exception BuildException if an error occurs
 */
public StringBuilder createQueryString(String command) throws BuildException {
  StringBuilder buffer=new StringBuilder();
  try {
    buffer.append(command);
    if (path == null) {
      throw new BuildException("Must specify 'path' attribute");
    }
 else {
      buffer.append("?path=");
      buffer.append(URLEncoder.encode(this.path,getCharset()));
      if (this.version != null) {
        buffer.append("&version=");
        buffer.append(URLEncoder.encode(this.version,getCharset()));
      }
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
  return buffer;
}

ID 273=========================================================================type: 1
Method:org.apache.catalina.ant.JMXGetTask#execute()
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (bean == null || attribute == null) {
    throw new BuildException("Must specify 'bean' and 'attribute' attributes");
  }
  log("Getting attribute " + attribute + " in bean "+ bean);
  try {
    execute("/jmxproxy/?get=" + URLEncoder.encode(bean,getCharset()) + "&att="+ URLEncoder.encode(attribute,getCharset()));
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
}

ID 275=========================================================================type: 1
Method:org.apache.catalina.ant.ResourcesTask#execute()
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (type != null) {
    try {
      execute("/resources?type=" + URLEncoder.encode(type,getCharset()));
    }
 catch (    UnsupportedEncodingException e) {
      throw new BuildException("Invalid 'charset' attribute: " + getCharset());
    }
  }
 else {
    execute("/resources");
  }
}

ID 296=========================================================================type: 1
Method:org.apache.catalina.ant.JMXSetTask#execute()
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  if (bean == null || attribute == null || value == null) {
    throw new BuildException("Must specify 'bean', 'attribute' and 'value' attributes");
  }
  log("Setting attribute " + attribute + " in bean "+ bean+ " to "+ value);
  try {
    execute("/jmxproxy/?set=" + URLEncoder.encode(bean,getCharset()) + "&att="+ URLEncoder.encode(attribute,getCharset())+ "&val="+ URLEncoder.encode(value,getCharset()));
  }
 catch (  UnsupportedEncodingException e) {
    throw new BuildException("Invalid 'charset' attribute: " + getCharset());
  }
}

ID 298=========================================================================type: 1
Method:org.apache.catalina.ant.JMXQueryTask#execute()
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Execute the requested operation.
 * @exception BuildException if an error occurs
 */
@Override public void execute() throws BuildException {
  super.execute();
  String queryString;
  if (query == null) {
    queryString="";
  }
 else {
    try {
      queryString="?qry=" + URLEncoder.encode(query,getCharset());
    }
 catch (    UnsupportedEncodingException e) {
      throw new BuildException("Invalid 'charset' attribute: " + getCharset());
    }
  }
  log("Query string is " + queryString);
  execute("/jmxproxy/" + queryString);
}

ID 303=========================================================================type: 1
Method:org.apache.catalina.filters.RemoteIpFilter#setPorts(org.apache.catalina.filters.RemoteIpFilter.XForwardedRequest, int)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
private void setPorts(XForwardedRequest xrequest,int defaultPort){
  int port=defaultPort;
  if (getPortHeader() != null) {
    String portHeaderValue=xrequest.getHeader(getPortHeader());
    if (portHeaderValue != null) {
      try {
        port=Integer.parseInt(portHeaderValue);
      }
 catch (      NumberFormatException nfe) {
        log.debug("Invalid port value [" + portHeaderValue + "] provided in header ["+ getPortHeader()+ "]");
      }
    }
  }
  xrequest.setServerPort(port);
  if (isChangeLocalPort()) {
    xrequest.setLocalPort(port);
  }
}

ID 308=========================================================================type: 1
Method:org.apache.catalina.filters.RemoteIpFilter#init(javax.servlet.FilterConfig)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
@Override public void init(FilterConfig filterConfig) throws ServletException {
  if (filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER) != null) {
    setInternalProxies(filterConfig.getInitParameter(INTERNAL_PROXIES_PARAMETER));
  }
  if (filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER) != null) {
    setProtocolHeader(filterConfig.getInitParameter(PROTOCOL_HEADER_PARAMETER));
  }
  if (filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER) != null) {
    setProtocolHeaderHttpsValue(filterConfig.getInitParameter(PROTOCOL_HEADER_HTTPS_VALUE_PARAMETER));
  }
  if (filterConfig.getInitParameter(PORT_HEADER_PARAMETER) != null) {
    setPortHeader(filterConfig.getInitParameter(PORT_HEADER_PARAMETER));
  }
  if (filterConfig.getInitParameter(CHANGE_LOCAL_PORT_PARAMETER) != null) {
    setChangeLocalPort(Boolean.parseBoolean(filterConfig.getInitParameter(CHANGE_LOCAL_PORT_PARAMETER)));
  }
  if (filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER) != null) {
    setProxiesHeader(filterConfig.getInitParameter(PROXIES_HEADER_PARAMETER));
  }
  if (filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER) != null) {
    setRemoteIpHeader(filterConfig.getInitParameter(REMOTE_IP_HEADER_PARAMETER));
  }
  if (filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER) != null) {
    setTrustedProxies(filterConfig.getInitParameter(TRUSTED_PROXIES_PARAMETER));
  }
  if (filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER) != null) {
    try {
      setHttpServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTP_SERVER_PORT_PARAMETER)));
    }
 catch (    NumberFormatException e) {
      throw new NumberFormatException("Illegal " + HTTP_SERVER_PORT_PARAMETER + " : "+ e.getMessage());
    }
  }
  if (filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER) != null) {
    try {
      setHttpsServerPort(Integer.parseInt(filterConfig.getInitParameter(HTTPS_SERVER_PORT_PARAMETER)));
    }
 catch (    NumberFormatException e) {
      throw new NumberFormatException("Illegal " + HTTPS_SERVER_PORT_PARAMETER + " : "+ e.getMessage());
    }
  }
}

ID 356=========================================================================type: 1
Method:org.apache.catalina.filters.ExpiresFilter#commaDelimitedListToIntArray(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Convert a comma delimited list of numbers into an  {@code int[]}.
 * @param commaDelimitedInts can be  {@code null}
 * @return never {@code null} array
 */
protected static int[] commaDelimitedListToIntArray(String commaDelimitedInts){
  String[] intsAsStrings=commaDelimitedListToStringArray(commaDelimitedInts);
  int[] ints=new int[intsAsStrings.length];
  for (int i=0; i < intsAsStrings.length; i++) {
    String intAsString=intsAsStrings[i];
    try {
      ints[i]=Integer.parseInt(intAsString);
    }
 catch (    NumberFormatException e) {
      throw new RuntimeException("Exception parsing number '" + i + "' (zero based) of comma delimited list '"+ commaDelimitedInts+ "'");
    }
  }
  return ints;
}

ID 359=========================================================================type: 1
Method:org.apache.catalina.filters.ExpiresFilter#parseExpiresConfiguration(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parse configuration lines like ' {@code access plus 1 month 15 days 2 hours}' or ' {@code modification 1 day 2 hours 5 seconds}'
 * @param inputLine
 */
protected ExpiresConfiguration parseExpiresConfiguration(String inputLine){
  String line=inputLine.trim();
  StringTokenizer tokenizer=new StringTokenizer(line," ");
  String currentToken;
  try {
    currentToken=tokenizer.nextToken();
  }
 catch (  NoSuchElementException e) {
    throw new IllegalStateException(sm.getString("expiresFilter.startingPointNotFound",line));
  }
  StartingPoint startingPoint;
  if ("access".equalsIgnoreCase(currentToken) || "now".equalsIgnoreCase(currentToken)) {
    startingPoint=StartingPoint.ACCESS_TIME;
  }
 else   if ("modification".equalsIgnoreCase(currentToken)) {
    startingPoint=StartingPoint.LAST_MODIFICATION_TIME;
  }
 else   if (!tokenizer.hasMoreTokens() && startsWithIgnoreCase(currentToken,"a")) {
    startingPoint=StartingPoint.ACCESS_TIME;
    tokenizer=new StringTokenizer(currentToken.substring(1) + " seconds"," ");
  }
 else   if (!tokenizer.hasMoreTokens() && startsWithIgnoreCase(currentToken,"m")) {
    startingPoint=StartingPoint.LAST_MODIFICATION_TIME;
    tokenizer=new StringTokenizer(currentToken.substring(1) + " seconds"," ");
  }
 else {
    throw new IllegalStateException(sm.getString("expiresFilter.startingPointInvalid",currentToken,line));
  }
  try {
    currentToken=tokenizer.nextToken();
  }
 catch (  NoSuchElementException e) {
    throw new IllegalStateException(sm.getString("expiresFilter.noDurationFound",line));
  }
  if ("plus".equalsIgnoreCase(currentToken)) {
    try {
      currentToken=tokenizer.nextToken();
    }
 catch (    NoSuchElementException e) {
      throw new IllegalStateException(sm.getString("expiresFilter.noDurationFound",line));
    }
  }
  List<Duration> durations=new ArrayList<Duration>();
  while (currentToken != null) {
    int amount;
    try {
      amount=Integer.parseInt(currentToken);
    }
 catch (    NumberFormatException e) {
      throw new IllegalStateException(sm.getString("expiresFilter.invalidDurationNumber",currentToken,line));
    }
    try {
      currentToken=tokenizer.nextToken();
    }
 catch (    NoSuchElementException e) {
      throw new IllegalStateException(sm.getString("expiresFilter.noDurationUnitAfterAmount",Integer.valueOf(amount),line));
    }
    DurationUnit durationUnit;
    if ("year".equalsIgnoreCase(currentToken) || "years".equalsIgnoreCase(currentToken)) {
      durationUnit=DurationUnit.YEAR;
    }
 else     if ("month".equalsIgnoreCase(currentToken) || "months".equalsIgnoreCase(currentToken)) {
      durationUnit=DurationUnit.MONTH;
    }
 else     if ("week".equalsIgnoreCase(currentToken) || "weeks".equalsIgnoreCase(currentToken)) {
      durationUnit=DurationUnit.WEEK;
    }
 else     if ("day".equalsIgnoreCase(currentToken) || "days".equalsIgnoreCase(currentToken)) {
      durationUnit=DurationUnit.DAY;
    }
 else     if ("hour".equalsIgnoreCase(currentToken) || "hours".equalsIgnoreCase(currentToken)) {
      durationUnit=DurationUnit.HOUR;
    }
 else     if ("minute".equalsIgnoreCase(currentToken) || "minutes".equalsIgnoreCase(currentToken)) {
      durationUnit=DurationUnit.MINUTE;
    }
 else     if ("second".equalsIgnoreCase(currentToken) || "seconds".equalsIgnoreCase(currentToken)) {
      durationUnit=DurationUnit.SECOND;
    }
 else {
      throw new IllegalStateException(sm.getString("expiresFilter.invalidDurationUnit",currentToken,line));
    }
    Duration duration=new Duration(amount,durationUnit);
    durations.add(duration);
    if (tokenizer.hasMoreTokens()) {
      currentToken=tokenizer.nextToken();
    }
 else {
      currentToken=null;
    }
  }
  return new ExpiresConfiguration(startingPoint,durations);
}

ID 368=========================================================================type: 1
Method:org.apache.catalina.filters.HttpHeaderSecurityFilter#setAntiClickJackingUri(java.lang.String)
Rmethod: java.net.URI#URI(java.lang.String)
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
public void setAntiClickJackingUri(String antiClickJackingUri){
  URI uri;
  try {
    uri=new URI(antiClickJackingUri);
  }
 catch (  URISyntaxException e) {
    throw new IllegalArgumentException(e);
  }
  this.antiClickJackingUri=uri;
}

ID 380=========================================================================type: 1
Method:org.apache.catalina.filters.CorsFilter#parseAndStore(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parses each param-value and populates configuration variables. If a param is provided, it overrides the default.
 * @param allowedOrigins A  {@link String} of comma separated origins.
 * @param allowedHttpMethods A  {@link String} of comma separated HTTP methods.
 * @param allowedHttpHeaders A  {@link String} of comma separated HTTP headers.
 * @param exposedHeaders A  {@link String} of comma separated headers that needs to beexposed.
 * @param supportsCredentials "true" if support credentials needs to be enabled.
 * @param preflightMaxAge The amount of seconds the user agent is allowed to cache the result of the pre-flight request.
 * @throws ServletException
 */
private void parseAndStore(final String allowedOrigins,final String allowedHttpMethods,final String allowedHttpHeaders,final String exposedHeaders,final String supportsCredentials,final String preflightMaxAge,final String decorateRequest) throws ServletException {
  if (allowedOrigins != null) {
    if (allowedOrigins.trim().equals("*")) {
      this.anyOriginAllowed=true;
    }
 else {
      this.anyOriginAllowed=false;
      Set<String> setAllowedOrigins=parseStringToSet(allowedOrigins);
      this.allowedOrigins.clear();
      this.allowedOrigins.addAll(setAllowedOrigins);
    }
  }
  if (allowedHttpMethods != null) {
    Set<String> setAllowedHttpMethods=parseStringToSet(allowedHttpMethods);
    this.allowedHttpMethods.clear();
    this.allowedHttpMethods.addAll(setAllowedHttpMethods);
  }
  if (allowedHttpHeaders != null) {
    Set<String> setAllowedHttpHeaders=parseStringToSet(allowedHttpHeaders);
    Set<String> lowerCaseHeaders=new HashSet<String>();
    for (    String header : setAllowedHttpHeaders) {
      String lowerCase=header.toLowerCase(Locale.ENGLISH);
      lowerCaseHeaders.add(lowerCase);
    }
    this.allowedHttpHeaders.clear();
    this.allowedHttpHeaders.addAll(lowerCaseHeaders);
  }
  if (exposedHeaders != null) {
    Set<String> setExposedHeaders=parseStringToSet(exposedHeaders);
    this.exposedHeaders.clear();
    this.exposedHeaders.addAll(setExposedHeaders);
  }
  if (supportsCredentials != null) {
    this.supportsCredentials=Boolean.parseBoolean(supportsCredentials);
  }
  if (preflightMaxAge != null) {
    try {
      if (!preflightMaxAge.isEmpty()) {
        this.preflightMaxAge=Long.parseLong(preflightMaxAge);
      }
 else {
        this.preflightMaxAge=0L;
      }
    }
 catch (    NumberFormatException e) {
      throw new ServletException(sm.getString("corsFilter.invalidPreflightMaxAge"),e);
    }
  }
  if (decorateRequest != null) {
    this.decorateRequest=Boolean.parseBoolean(decorateRequest);
  }
}

ID 381=========================================================================type: 1
Method:org.apache.catalina.filters.CorsFilter#isValidOrigin(java.lang.String)
Rmethod: java.net.URI#URI(java.lang.String)
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
/** 
 * Checks if a given origin is valid or not. Criteria: <ul> <li>If an encoded character is present in origin, it's not valid.</li> <li>If origin is "null", it's valid.</li> <li>Origin should be a valid  {@link URI}</li> </ul>
 * @param origin
 * @see <a href="http://tools.ietf.org/html/rfc952">RFC952</a>
 */
protected static boolean isValidOrigin(String origin){
  if (origin.contains("%")) {
    return false;
  }
  if ("null".equals(origin)) {
    return true;
  }
  if (origin.startsWith("file://")) {
    return true;
  }
  URI originURI;
  try {
    originURI=new URI(origin);
  }
 catch (  URISyntaxException e) {
    return false;
  }
  return originURI.getScheme() != null;
}

ID 382=========================================================================type: 1
Method:org.apache.catalina.filters.CsrfPreventionFilterBase#init(javax.servlet.FilterConfig)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@Override public void init(FilterConfig filterConfig) throws ServletException {
  super.init(filterConfig);
  try {
    Class<?> clazz=Class.forName(randomClass);
    randomSource=(Random)clazz.newInstance();
  }
 catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
catch (  InstantiationException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
}

ID 383=========================================================================type: 1
Method:org.apache.catalina.filters.CsrfPreventionFilterBase#init(javax.servlet.FilterConfig)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public void init(FilterConfig filterConfig) throws ServletException {
  super.init(filterConfig);
  try {
    Class<?> clazz=Class.forName(randomClass);
    randomSource=(Random)clazz.newInstance();
  }
 catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
catch (  InstantiationException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
}

ID 384=========================================================================type: 1
Method:org.apache.catalina.filters.CsrfPreventionFilterBase#init(javax.servlet.FilterConfig)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public void init(FilterConfig filterConfig) throws ServletException {
  super.init(filterConfig);
  try {
    Class<?> clazz=Class.forName(randomClass);
    randomSource=(Random)clazz.newInstance();
  }
 catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
catch (  InstantiationException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(sm.getString("csrfPrevention.invalidRandomClass",randomClass),e);
    throw se;
  }
}

ID 397=========================================================================type: 1
Method:org.apache.catalina.websocket.WebSocketServlet#getWebSocketAccept(java.lang.String)
Rmethod: java.security.MessageDigest#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
private String getWebSocketAccept(String key) throws ServletException {
  MessageDigest sha1Helper=sha1Helpers.poll();
  if (sha1Helper == null) {
    try {
      sha1Helper=MessageDigest.getInstance("SHA1");
    }
 catch (    NoSuchAlgorithmException e) {
      throw new ServletException(e);
    }
  }
  sha1Helper.reset();
  sha1Helper.update(key.getBytes(B2CConverter.ISO_8859_1));
  String result=Base64.encode(sha1Helper.digest(WS_ACCEPT));
  sha1Helpers.add(sha1Helper);
  return result;
}

ID 398=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeBinaryData(int)
Rmethod: org.apache.catalina.websocket.WsOutbound#doFlush(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Adds the data to the buffer for binary data. If a textual message is currently in progress that message will be completed and a new binary message started. If the buffer for binary data is full, the buffer will be flushed and a new binary continuation fragment started.
 * @param b The byte (only the least significant byte is used) of data tosend to the client.
 * @throws IOException  If a flush is required and an error occurs writingthe WebSocket frame to the client
 */
public void writeBinaryData(int b) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (bb.position() == bb.capacity()) {
        doFlush(false);
      }
      if (text == null) {
        text=Boolean.FALSE;
      }
 else       if (Boolean.TRUE.equals(text)) {
        flush();
        text=Boolean.FALSE;
      }
      bb.put((byte)(b & 0xFF));
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 399=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeBinaryData(int)
Rmethod: org.apache.catalina.websocket.WsOutbound#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Adds the data to the buffer for binary data. If a textual message is currently in progress that message will be completed and a new binary message started. If the buffer for binary data is full, the buffer will be flushed and a new binary continuation fragment started.
 * @param b The byte (only the least significant byte is used) of data tosend to the client.
 * @throws IOException  If a flush is required and an error occurs writingthe WebSocket frame to the client
 */
public void writeBinaryData(int b) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (bb.position() == bb.capacity()) {
        doFlush(false);
      }
      if (text == null) {
        text=Boolean.FALSE;
      }
 else       if (Boolean.TRUE.equals(text)) {
        flush();
        text=Boolean.FALSE;
      }
      bb.put((byte)(b & 0xFF));
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 400=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeTextData(char)
Rmethod: org.apache.catalina.websocket.WsOutbound#doFlush(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Adds the data to the buffer for textual data. If a binary message is currently in progress that message will be completed and a new textual message started. If the buffer for textual data is full, the buffer will be flushed and a new textual continuation fragment started.
 * @param c The character to send to the client.
 * @throws IOException  If a flush is required and an error occurs writingthe WebSocket frame to the client
 */
public void writeTextData(char c) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (cb.position() == cb.capacity()) {
        doFlush(false);
      }
      if (text == null) {
        text=Boolean.TRUE;
      }
 else       if (Boolean.FALSE.equals(text)) {
        flush();
        text=Boolean.TRUE;
      }
      cb.append(c);
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 401=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeTextData(char)
Rmethod: org.apache.catalina.websocket.WsOutbound#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Adds the data to the buffer for textual data. If a binary message is currently in progress that message will be completed and a new textual message started. If the buffer for textual data is full, the buffer will be flushed and a new textual continuation fragment started.
 * @param c The character to send to the client.
 * @throws IOException  If a flush is required and an error occurs writingthe WebSocket frame to the client
 */
public void writeTextData(char c) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (cb.position() == cb.capacity()) {
        doFlush(false);
      }
      if (text == null) {
        text=Boolean.TRUE;
      }
 else       if (Boolean.FALSE.equals(text)) {
        flush();
        text=Boolean.TRUE;
      }
      cb.append(c);
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 402=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeBinaryMessage(java.nio.ByteBuffer)
Rmethod: org.apache.catalina.websocket.WsOutbound#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Flush any message (binary or textual) that may be buffered and then send a WebSocket binary message as a single frame with the provided buffer as the payload of the message.
 * @param msgBb The buffer containing the payload
 * @throws IOException  If an error occurs writing to the client
 */
public void writeBinaryMessage(ByteBuffer msgBb) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (text != null) {
        flush();
      }
      text=Boolean.FALSE;
      doWriteBytes(msgBb,true);
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 403=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeBinaryMessage(java.nio.ByteBuffer)
Rmethod: org.apache.catalina.websocket.WsOutbound#doWriteBytes(java.nio.ByteBuffer, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Flush any message (binary or textual) that may be buffered and then send a WebSocket binary message as a single frame with the provided buffer as the payload of the message.
 * @param msgBb The buffer containing the payload
 * @throws IOException  If an error occurs writing to the client
 */
public void writeBinaryMessage(ByteBuffer msgBb) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (text != null) {
        flush();
      }
      text=Boolean.FALSE;
      doWriteBytes(msgBb,true);
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 404=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeTextMessage(java.nio.CharBuffer)
Rmethod: org.apache.catalina.websocket.WsOutbound#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Flush any message (binary or textual) that may be buffered and then send a WebSocket text message as a single frame with the provided buffer as the payload of the message.
 * @param msgCb The buffer containing the payload
 * @throws IOException  If an error occurs writing to the client
 */
public void writeTextMessage(CharBuffer msgCb) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (text != null) {
        flush();
      }
      text=Boolean.TRUE;
      doWriteText(msgCb,true);
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 405=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#writeTextMessage(java.nio.CharBuffer)
Rmethod: org.apache.catalina.websocket.WsOutbound#doWriteText(java.nio.CharBuffer, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Flush any message (binary or textual) that may be buffered and then send a WebSocket text message as a single frame with the provided buffer as the payload of the message.
 * @param msgCb The buffer containing the payload
 * @throws IOException  If an error occurs writing to the client
 */
public void writeTextMessage(CharBuffer msgCb) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      if (text != null) {
        flush();
      }
      text=Boolean.TRUE;
      doWriteText(msgCb,true);
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 406=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#flush()
Rmethod: org.apache.catalina.websocket.WsOutbound#doFlush(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Flush any message (binary or textual) that may be buffered.
 * @throws IOException  If an error occurs writing to the client
 */
public void flush() throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      doFlush(true);
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 411=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#close(int, java.nio.ByteBuffer)
Rmethod: org.apache.coyote.http11.upgrade.UpgradeOutbound#write(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send a close message to the client
 * @param status    Must be a valid status code or zero to send no code
 * @param data      Optional message. If message is defined, a valid statuscode must be provided.
 * @throws IOException  If an error occurs writing to the client
 */
public void close(int status,ByteBuffer data) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        return;
      }
      try {
        doFlush(false);
      }
  finally {
        closed=true;
      }
      upgradeOutbound.write(0x88);
      if (status == 0) {
        upgradeOutbound.write(0);
      }
 else       if (data == null || data.position() == data.limit()) {
        upgradeOutbound.write(2);
        upgradeOutbound.write(status >>> 8);
        upgradeOutbound.write(status);
      }
 else {
        upgradeOutbound.write(2 + data.limit() - data.position());
        upgradeOutbound.write(status >>> 8);
        upgradeOutbound.write(status);
        upgradeOutbound.write(data.array(),data.position(),data.limit() - data.position());
      }
      upgradeOutbound.flush();
      bb=null;
      cb=null;
      upgradeOutbound=null;
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 412=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#close(int, java.nio.ByteBuffer)
Rmethod: org.apache.coyote.http11.upgrade.UpgradeOutbound#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send a close message to the client
 * @param status    Must be a valid status code or zero to send no code
 * @param data      Optional message. If message is defined, a valid statuscode must be provided.
 * @throws IOException  If an error occurs writing to the client
 */
public void close(int status,ByteBuffer data) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        return;
      }
      try {
        doFlush(false);
      }
  finally {
        closed=true;
      }
      upgradeOutbound.write(0x88);
      if (status == 0) {
        upgradeOutbound.write(0);
      }
 else       if (data == null || data.position() == data.limit()) {
        upgradeOutbound.write(2);
        upgradeOutbound.write(status >>> 8);
        upgradeOutbound.write(status);
      }
 else {
        upgradeOutbound.write(2 + data.limit() - data.position());
        upgradeOutbound.write(status >>> 8);
        upgradeOutbound.write(status);
        upgradeOutbound.write(data.array(),data.position(),data.limit() - data.position());
      }
      upgradeOutbound.flush();
      bb=null;
      cb=null;
      upgradeOutbound=null;
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 413=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#close(int, java.nio.ByteBuffer)
Rmethod: org.apache.coyote.http11.upgrade.UpgradeOutbound#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send a close message to the client
 * @param status    Must be a valid status code or zero to send no code
 * @param data      Optional message. If message is defined, a valid statuscode must be provided.
 * @throws IOException  If an error occurs writing to the client
 */
public void close(int status,ByteBuffer data) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        return;
      }
      try {
        doFlush(false);
      }
  finally {
        closed=true;
      }
      upgradeOutbound.write(0x88);
      if (status == 0) {
        upgradeOutbound.write(0);
      }
 else       if (data == null || data.position() == data.limit()) {
        upgradeOutbound.write(2);
        upgradeOutbound.write(status >>> 8);
        upgradeOutbound.write(status);
      }
 else {
        upgradeOutbound.write(2 + data.limit() - data.position());
        upgradeOutbound.write(status >>> 8);
        upgradeOutbound.write(status);
        upgradeOutbound.write(data.array(),data.position(),data.limit() - data.position());
      }
      upgradeOutbound.flush();
      bb=null;
      cb=null;
      upgradeOutbound=null;
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 416=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#sendControlMessage(java.nio.ByteBuffer, byte)
Rmethod: org.apache.catalina.websocket.WsOutbound#doFlush(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Generic function to send either a ping or a pong.
 * @param data      Optional message.
 * @param opcode    The byte to include as the opcode.
 * @throws IOException  If an error occurs writing to the client
 */
private void sendControlMessage(ByteBuffer data,byte opcode) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      doFlush(false);
      upgradeOutbound.write(0x80 | opcode);
      if (data == null) {
        upgradeOutbound.write(0);
      }
 else {
        upgradeOutbound.write(data.limit() - data.position());
        upgradeOutbound.write(data.array(),data.position(),data.limit() - data.position());
      }
      upgradeOutbound.flush();
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 417=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#sendControlMessage(java.nio.ByteBuffer, byte)
Rmethod: org.apache.coyote.http11.upgrade.UpgradeOutbound#write(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Generic function to send either a ping or a pong.
 * @param data      Optional message.
 * @param opcode    The byte to include as the opcode.
 * @throws IOException  If an error occurs writing to the client
 */
private void sendControlMessage(ByteBuffer data,byte opcode) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      doFlush(false);
      upgradeOutbound.write(0x80 | opcode);
      if (data == null) {
        upgradeOutbound.write(0);
      }
 else {
        upgradeOutbound.write(data.limit() - data.position());
        upgradeOutbound.write(data.array(),data.position(),data.limit() - data.position());
      }
      upgradeOutbound.flush();
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 418=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#sendControlMessage(java.nio.ByteBuffer, byte)
Rmethod: org.apache.coyote.http11.upgrade.UpgradeOutbound#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Generic function to send either a ping or a pong.
 * @param data      Optional message.
 * @param opcode    The byte to include as the opcode.
 * @throws IOException  If an error occurs writing to the client
 */
private void sendControlMessage(ByteBuffer data,byte opcode) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      doFlush(false);
      upgradeOutbound.write(0x80 | opcode);
      if (data == null) {
        upgradeOutbound.write(0);
      }
 else {
        upgradeOutbound.write(data.limit() - data.position());
        upgradeOutbound.write(data.array(),data.position(),data.limit() - data.position());
      }
      upgradeOutbound.flush();
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 419=========================================================================type: 1
Method:org.apache.catalina.websocket.WsOutbound#sendControlMessage(java.nio.ByteBuffer, byte)
Rmethod: org.apache.coyote.http11.upgrade.UpgradeOutbound#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Generic function to send either a ping or a pong.
 * @param data      Optional message.
 * @param opcode    The byte to include as the opcode.
 * @throws IOException  If an error occurs writing to the client
 */
private void sendControlMessage(ByteBuffer data,byte opcode) throws IOException {
  try {
synchronized (stateLock) {
      if (closed) {
        throw new IOException(sm.getString("outbound.closed"));
      }
      doFlush(false);
      upgradeOutbound.write(0x80 | opcode);
      if (data == null) {
        upgradeOutbound.write(0);
      }
 else {
        upgradeOutbound.write(data.limit() - data.position());
        upgradeOutbound.write(data.array(),data.position(),data.limit() - data.position());
      }
      upgradeOutbound.flush();
    }
  }
 catch (  IOException ioe) {
    streamInbound.doOnClose(Constants.STATUS_CLOSED_UNEXPECTEDLY);
    throw ioe;
  }
}

ID 448=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.WsInputStream#nextFrame(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 449=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.StreamInbound#closeOutboundConnection(int, java.nio.ByteBuffer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 450=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.StreamInbound#doOnBinaryData(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 451=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.StreamInbound#doOnTextData(java.io.Reader)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 452=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.StreamInbound#closeOutboundConnection(org.apache.catalina.websocket.WsFrame)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 453=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.WsOutbound#pong(java.nio.ByteBuffer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 454=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.WsInputStream#nextFrame(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 455=========================================================================type: 1
Method:org.apache.catalina.websocket.StreamInbound#onData()
Rmethod: org.apache.catalina.websocket.StreamInbound#closeOutboundConnection(int, java.nio.ByteBuffer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState onData() throws IOException {
  WsInputStream wsIs=new WsInputStream(processor,getWsOutbound());
  try {
    WsFrame frame=wsIs.nextFrame(false);
    while (frame != null) {
      if (frame.getRsv() > 0) {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      byte opCode=frame.getOpCode();
      if (opCode == Constants.OPCODE_BINARY) {
        doOnBinaryData(wsIs);
      }
 else       if (opCode == Constants.OPCODE_TEXT) {
        InputStreamReader r=new InputStreamReader(wsIs,new Utf8Decoder());
        doOnTextData(r);
      }
 else       if (opCode == Constants.OPCODE_CLOSE) {
        closeOutboundConnection(frame);
        return SocketState.CLOSED;
      }
 else       if (opCode == Constants.OPCODE_PING) {
        getWsOutbound().pong(frame.getPayLoad());
      }
 else       if (opCode == Constants.OPCODE_PONG) {
        doOnPong(frame.getPayLoad());
      }
 else {
        closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
        return SocketState.CLOSED;
      }
      frame=wsIs.nextFrame(false);
    }
  }
 catch (  MalformedInputException mie) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  UnmappableCharacterException uce) {
    closeOutboundConnection(Constants.STATUS_BAD_DATA,null);
    return SocketState.CLOSED;
  }
catch (  IOException ioe) {
    closeOutboundConnection(Constants.STATUS_PROTOCOL_ERROR,null);
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 479=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationDispatcher#forward(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Forward this request and response to another resource for processing. Any runtime exception, IOException, or ServletException thrown by the called servlet will be propagated to the caller.
 * @param request The servlet request to be forwarded
 * @param response The servlet response to be forwarded
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet exception occurs
 */
@Override public void forward(ServletRequest request,ServletResponse response) throws ServletException, IOException {
  if (Globals.IS_SECURITY_ENABLED) {
    try {
      PrivilegedForward dp=new PrivilegedForward(request,response);
      AccessController.doPrivileged(dp);
    }
 catch (    PrivilegedActionException pe) {
      Exception e=pe.getException();
      if (e instanceof ServletException)       throw (ServletException)e;
      throw (IOException)e;
    }
  }
 else {
    doForward(request,response);
  }
}

ID 490=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationDispatcher#include(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Include the response from another resource in the current response. Any runtime exception, IOException, or ServletException thrown by the called servlet will be propagated to the caller.
 * @param request The servlet request that is including this one
 * @param response The servlet response to be appended to
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet exception occurs
 */
@Override public void include(ServletRequest request,ServletResponse response) throws ServletException, IOException {
  if (Globals.IS_SECURITY_ENABLED) {
    try {
      PrivilegedInclude dp=new PrivilegedInclude(request,response);
      AccessController.doPrivileged(dp);
    }
 catch (    PrivilegedActionException pe) {
      Exception e=pe.getException();
      if (e instanceof ServletException)       throw (ServletException)e;
      throw (IOException)e;
    }
  }
 else {
    doInclude(request,response);
  }
}

ID 496=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationDispatcher#dispatch(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public void dispatch(ServletRequest request,ServletResponse response) throws ServletException, IOException {
  if (Globals.IS_SECURITY_ENABLED) {
    try {
      PrivilegedDispatch dp=new PrivilegedDispatch(request,response);
      AccessController.doPrivileged(dp);
    }
 catch (    PrivilegedActionException pe) {
      Exception e=pe.getException();
      if (e instanceof ServletException)       throw (ServletException)e;
      throw (IOException)e;
    }
  }
 else {
    doDispatch(request,response);
  }
}

ID 502=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationDispatcher#invoke(javax.servlet.ServletRequest, javax.servlet.ServletResponse, org.apache.catalina.core.ApplicationDispatcher.State)
Rmethod: org.apache.catalina.Wrapper#allocate()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Ask the resource represented by this RequestDispatcher to process the associated request, and create (or append to) the associated response. <p> <strong>IMPLEMENTATION NOTE</strong>: This implementation assumes that no filters are applied to a forwarded or included resource, because they were already done for the original request.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet error occurs
 */
private void invoke(ServletRequest request,ServletResponse response,State state) throws IOException, ServletException {
  ClassLoader oldCCL=Thread.currentThread().getContextClassLoader();
  ClassLoader contextClassLoader=context.getLoader().getClassLoader();
  if (oldCCL != contextClassLoader) {
    Thread.currentThread().setContextClassLoader(contextClassLoader);
  }
 else {
    oldCCL=null;
  }
  HttpServletResponse hresponse=state.hresponse;
  Servlet servlet=null;
  IOException ioException=null;
  ServletException servletException=null;
  RuntimeException runtimeException=null;
  boolean unavailable=false;
  if (wrapper.isUnavailable()) {
    wrapper.getLogger().warn(sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE))     hresponse.setDateHeader("Retry-After",available);
    hresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servlet=null;
  }
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  try {
    support.fireInstanceEvent(InstanceEvent.BEFORE_DISPATCH_EVENT,servlet,request,response);
    if ((servlet != null) && (filterChain != null)) {
      filterChain.doFilter(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
  }
 catch (  ClientAbortException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    ioException=e;
  }
catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    ioException=e;
  }
catch (  UnavailableException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    servletException=e;
    wrapper.unavailable(e);
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),rootCause);
    }
    servletException=e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    runtimeException=e;
  }
  try {
    if (filterChain != null)     filterChain.release();
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("standardWrapper.releaseFilters",wrapper.getName()),e);
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
  }
  if (oldCCL != null)   Thread.currentThread().setContextClassLoader(oldCCL);
  unwrapRequest(state);
  unwrapResponse(state);
  recycleRequestWrapper(state);
  if (ioException != null)   throw ioException;
  if (servletException != null)   throw servletException;
  if (runtimeException != null)   throw runtimeException;
}

ID 503=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationDispatcher#invoke(javax.servlet.ServletRequest, javax.servlet.ServletResponse, org.apache.catalina.core.ApplicationDispatcher.State)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Ask the resource represented by this RequestDispatcher to process the associated request, and create (or append to) the associated response. <p> <strong>IMPLEMENTATION NOTE</strong>: This implementation assumes that no filters are applied to a forwarded or included resource, because they were already done for the original request.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet error occurs
 */
private void invoke(ServletRequest request,ServletResponse response,State state) throws IOException, ServletException {
  ClassLoader oldCCL=Thread.currentThread().getContextClassLoader();
  ClassLoader contextClassLoader=context.getLoader().getClassLoader();
  if (oldCCL != contextClassLoader) {
    Thread.currentThread().setContextClassLoader(contextClassLoader);
  }
 else {
    oldCCL=null;
  }
  HttpServletResponse hresponse=state.hresponse;
  Servlet servlet=null;
  IOException ioException=null;
  ServletException servletException=null;
  RuntimeException runtimeException=null;
  boolean unavailable=false;
  if (wrapper.isUnavailable()) {
    wrapper.getLogger().warn(sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE))     hresponse.setDateHeader("Retry-After",available);
    hresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servlet=null;
  }
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  try {
    support.fireInstanceEvent(InstanceEvent.BEFORE_DISPATCH_EVENT,servlet,request,response);
    if ((servlet != null) && (filterChain != null)) {
      filterChain.doFilter(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
  }
 catch (  ClientAbortException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    ioException=e;
  }
catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    ioException=e;
  }
catch (  UnavailableException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    servletException=e;
    wrapper.unavailable(e);
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),rootCause);
    }
    servletException=e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    runtimeException=e;
  }
  try {
    if (filterChain != null)     filterChain.release();
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("standardWrapper.releaseFilters",wrapper.getName()),e);
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
  }
  if (oldCCL != null)   Thread.currentThread().setContextClassLoader(oldCCL);
  unwrapRequest(state);
  unwrapResponse(state);
  recycleRequestWrapper(state);
  if (ioException != null)   throw ioException;
  if (servletException != null)   throw servletException;
  if (runtimeException != null)   throw runtimeException;
}

ID 504=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationDispatcher#invoke(javax.servlet.ServletRequest, javax.servlet.ServletResponse, org.apache.catalina.core.ApplicationDispatcher.State)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Ask the resource represented by this RequestDispatcher to process the associated request, and create (or append to) the associated response. <p> <strong>IMPLEMENTATION NOTE</strong>: This implementation assumes that no filters are applied to a forwarded or included resource, because they were already done for the original request.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet error occurs
 */
private void invoke(ServletRequest request,ServletResponse response,State state) throws IOException, ServletException {
  ClassLoader oldCCL=Thread.currentThread().getContextClassLoader();
  ClassLoader contextClassLoader=context.getLoader().getClassLoader();
  if (oldCCL != contextClassLoader) {
    Thread.currentThread().setContextClassLoader(contextClassLoader);
  }
 else {
    oldCCL=null;
  }
  HttpServletResponse hresponse=state.hresponse;
  Servlet servlet=null;
  IOException ioException=null;
  ServletException servletException=null;
  RuntimeException runtimeException=null;
  boolean unavailable=false;
  if (wrapper.isUnavailable()) {
    wrapper.getLogger().warn(sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE))     hresponse.setDateHeader("Retry-After",available);
    hresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servlet=null;
  }
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  try {
    support.fireInstanceEvent(InstanceEvent.BEFORE_DISPATCH_EVENT,servlet,request,response);
    if ((servlet != null) && (filterChain != null)) {
      filterChain.doFilter(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
  }
 catch (  ClientAbortException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    ioException=e;
  }
catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    ioException=e;
  }
catch (  UnavailableException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    servletException=e;
    wrapper.unavailable(e);
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),rootCause);
    }
    servletException=e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    runtimeException=e;
  }
  try {
    if (filterChain != null)     filterChain.release();
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("standardWrapper.releaseFilters",wrapper.getName()),e);
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
  }
  if (oldCCL != null)   Thread.currentThread().setContextClassLoader(oldCCL);
  unwrapRequest(state);
  unwrapResponse(state);
  recycleRequestWrapper(state);
  if (ioException != null)   throw ioException;
  if (servletException != null)   throw servletException;
  if (runtimeException != null)   throw runtimeException;
}

ID 505=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationDispatcher#invoke(javax.servlet.ServletRequest, javax.servlet.ServletResponse, org.apache.catalina.core.ApplicationDispatcher.State)
Rmethod: org.apache.catalina.Wrapper#deallocate(javax.servlet.Servlet)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Ask the resource represented by this RequestDispatcher to process the associated request, and create (or append to) the associated response. <p> <strong>IMPLEMENTATION NOTE</strong>: This implementation assumes that no filters are applied to a forwarded or included resource, because they were already done for the original request.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet error occurs
 */
private void invoke(ServletRequest request,ServletResponse response,State state) throws IOException, ServletException {
  ClassLoader oldCCL=Thread.currentThread().getContextClassLoader();
  ClassLoader contextClassLoader=context.getLoader().getClassLoader();
  if (oldCCL != contextClassLoader) {
    Thread.currentThread().setContextClassLoader(contextClassLoader);
  }
 else {
    oldCCL=null;
  }
  HttpServletResponse hresponse=state.hresponse;
  Servlet servlet=null;
  IOException ioException=null;
  ServletException servletException=null;
  RuntimeException runtimeException=null;
  boolean unavailable=false;
  if (wrapper.isUnavailable()) {
    wrapper.getLogger().warn(sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE))     hresponse.setDateHeader("Retry-After",available);
    hresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("applicationDispatcher.isUnavailable",wrapper.getName()));
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.allocateException",wrapper.getName()),e);
    servlet=null;
  }
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  try {
    support.fireInstanceEvent(InstanceEvent.BEFORE_DISPATCH_EVENT,servlet,request,response);
    if ((servlet != null) && (filterChain != null)) {
      filterChain.doFilter(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
  }
 catch (  ClientAbortException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    ioException=e;
  }
catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    ioException=e;
  }
catch (  UnavailableException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    servletException=e;
    wrapper.unavailable(e);
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),rootCause);
    }
    servletException=e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_DISPATCH_EVENT,servlet,request,response);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.serviceException",wrapper.getName()),e);
    runtimeException=e;
  }
  try {
    if (filterChain != null)     filterChain.release();
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("standardWrapper.releaseFilters",wrapper.getName()),e);
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  ServletException e) {
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    wrapper.getLogger().error(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
    servletException=new ServletException(sm.getString("applicationDispatcher.deallocateException",wrapper.getName()),e);
  }
  if (oldCCL != null)   Thread.currentThread().setContextClassLoader(oldCCL);
  unwrapRequest(state);
  unwrapResponse(state);
  recycleRequestWrapper(state);
  if (ioException != null)   throw ioException;
  if (servletException != null)   throw servletException;
  if (runtimeException != null)   throw runtimeException;
}

ID 519=========================================================================type: 1
Method:org.apache.catalina.core.AsyncContextImpl#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("unchecked") @Override public <T extends AsyncListener>T createListener(Class<T> clazz) throws ServletException {
  check();
  T listener=null;
  try {
    listener=(T)getInstanceManager().newInstance(clazz.getName(),clazz.getClassLoader());
  }
 catch (  InstantiationException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  NamingException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  Exception e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
  return listener;
}

ID 520=========================================================================type: 1
Method:org.apache.catalina.core.AsyncContextImpl#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@SuppressWarnings("unchecked") @Override public <T extends AsyncListener>T createListener(Class<T> clazz) throws ServletException {
  check();
  T listener=null;
  try {
    listener=(T)getInstanceManager().newInstance(clazz.getName(),clazz.getClassLoader());
  }
 catch (  InstantiationException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  NamingException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  Exception e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
  return listener;
}

ID 521=========================================================================type: 1
Method:org.apache.catalina.core.AsyncContextImpl#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String, java.lang.ClassLoader)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@SuppressWarnings("unchecked") @Override public <T extends AsyncListener>T createListener(Class<T> clazz) throws ServletException {
  check();
  T listener=null;
  try {
    listener=(T)getInstanceManager().newInstance(clazz.getName(),clazz.getClassLoader());
  }
 catch (  InstantiationException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  NamingException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  Exception e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
  return listener;
}

ID 522=========================================================================type: 1
Method:org.apache.catalina.core.AsyncContextImpl#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("unchecked") @Override public <T extends AsyncListener>T createListener(Class<T> clazz) throws ServletException {
  check();
  T listener=null;
  try {
    listener=(T)getInstanceManager().newInstance(clazz.getName(),clazz.getClassLoader());
  }
 catch (  InstantiationException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  NamingException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  Exception e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
  return listener;
}

ID 523=========================================================================type: 1
Method:org.apache.catalina.core.AsyncContextImpl#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("unchecked") @Override public <T extends AsyncListener>T createListener(Class<T> clazz) throws ServletException {
  check();
  T listener=null;
  try {
    listener=(T)getInstanceManager().newInstance(clazz.getName(),clazz.getClassLoader());
  }
 catch (  InstantiationException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  IllegalAccessException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  NamingException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  ClassNotFoundException e) {
    ServletException se=new ServletException(e);
    throw se;
  }
catch (  Exception e) {
    ExceptionUtils.handleThrowable(e.getCause());
    ServletException se=new ServletException(e);
    throw se;
  }
  return listener;
}

ID 530=========================================================================type: 1
Method:org.apache.catalina.core.StandardPipeline#setBasic(org.apache.catalina.Valve)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * <p>Set the Valve instance that has been distinguished as the basic Valve for this Pipeline (if any).  Prior to setting the basic Valve, the Valve's <code>setContainer()</code> will be called, if it implements <code>Contained</code>, with the owning Container as an argument.  The method may throw an <code>IllegalArgumentException</code> if this Valve chooses not to be associated with this Container, or <code>IllegalStateException</code> if it is already associated with a different Container.</p>
 * @param valve Valve to be distinguished as the basic Valve
 */
@Override public void setBasic(Valve valve){
  Valve oldBasic=this.basic;
  if (oldBasic == valve)   return;
  if (oldBasic != null) {
    if (getState().isAvailable() && (oldBasic instanceof Lifecycle)) {
      try {
        ((Lifecycle)oldBasic).stop();
      }
 catch (      LifecycleException e) {
        log.error("StandardPipeline.setBasic: stop",e);
      }
    }
    if (oldBasic instanceof Contained) {
      try {
        ((Contained)oldBasic).setContainer(null);
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
    }
  }
  if (valve == null)   return;
  if (valve instanceof Contained) {
    ((Contained)valve).setContainer(this.container);
  }
  if (getState().isAvailable() && valve instanceof Lifecycle) {
    try {
      ((Lifecycle)valve).start();
    }
 catch (    LifecycleException e) {
      log.error("StandardPipeline.setBasic: start",e);
      return;
    }
  }
  Valve current=first;
  while (current != null) {
    if (current.getNext() == oldBasic) {
      current.setNext(valve);
      break;
    }
    current=current.getNext();
  }
  this.basic=valve;
}

ID 531=========================================================================type: 1
Method:org.apache.catalina.core.StandardPipeline#setBasic(org.apache.catalina.Valve)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * <p>Set the Valve instance that has been distinguished as the basic Valve for this Pipeline (if any).  Prior to setting the basic Valve, the Valve's <code>setContainer()</code> will be called, if it implements <code>Contained</code>, with the owning Container as an argument.  The method may throw an <code>IllegalArgumentException</code> if this Valve chooses not to be associated with this Container, or <code>IllegalStateException</code> if it is already associated with a different Container.</p>
 * @param valve Valve to be distinguished as the basic Valve
 */
@Override public void setBasic(Valve valve){
  Valve oldBasic=this.basic;
  if (oldBasic == valve)   return;
  if (oldBasic != null) {
    if (getState().isAvailable() && (oldBasic instanceof Lifecycle)) {
      try {
        ((Lifecycle)oldBasic).stop();
      }
 catch (      LifecycleException e) {
        log.error("StandardPipeline.setBasic: stop",e);
      }
    }
    if (oldBasic instanceof Contained) {
      try {
        ((Contained)oldBasic).setContainer(null);
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
    }
  }
  if (valve == null)   return;
  if (valve instanceof Contained) {
    ((Contained)valve).setContainer(this.container);
  }
  if (getState().isAvailable() && valve instanceof Lifecycle) {
    try {
      ((Lifecycle)valve).start();
    }
 catch (    LifecycleException e) {
      log.error("StandardPipeline.setBasic: start",e);
      return;
    }
  }
  Valve current=first;
  while (current != null) {
    if (current.getNext() == oldBasic) {
      current.setNext(valve);
      break;
    }
    current=current.getNext();
  }
  this.basic=valve;
}

ID 532=========================================================================type: 1
Method:org.apache.catalina.core.StandardPipeline#addValve(org.apache.catalina.Valve)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * <p>Add a new Valve to the end of the pipeline associated with this Container.  Prior to adding the Valve, the Valve's <code>setContainer()</code> method will be called, if it implements <code>Contained</code>, with the owning Container as an argument. The method may throw an <code>IllegalArgumentException</code> if this Valve chooses not to be associated with this Container, or <code>IllegalStateException</code> if it is already associated with a different Container.</p>
 * @param valve Valve to be added
 * @exception IllegalArgumentException if this Container refused toaccept the specified Valve
 * @exception IllegalArgumentException if the specified Valve refuses to beassociated with this Container
 * @exception IllegalStateException if the specified Valve is alreadyassociated with a different Container #Value
 */
@Override public void addValve(Valve valve){
  if (valve instanceof Contained)   ((Contained)valve).setContainer(this.container);
  if (getState().isAvailable()) {
    if (valve instanceof Lifecycle) {
      try {
        ((Lifecycle)valve).start();
      }
 catch (      LifecycleException e) {
        log.error("StandardPipeline.addValve: start: ",e);
      }
    }
  }
  if (first == null) {
    first=valve;
    valve.setNext(basic);
  }
 else {
    Valve current=first;
    while (current != null) {
      if (current.getNext() == basic) {
        current.setNext(valve);
        valve.setNext(basic);
        break;
      }
      current=current.getNext();
    }
  }
  container.fireContainerEvent(Container.ADD_VALVE_EVENT,valve);
}

ID 533=========================================================================type: 1
Method:org.apache.catalina.core.StandardPipeline#removeValve(org.apache.catalina.Valve)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Remove the specified Valve from the pipeline associated with this Container, if it is found; otherwise, do nothing.  If the Valve is found and removed, the Valve's <code>setContainer(null)</code> method will be called if it implements <code>Contained</code>.
 * @param valve Valve to be removed
 */
@Override public void removeValve(Valve valve){
  Valve current;
  if (first == valve) {
    first=first.getNext();
    current=null;
  }
 else {
    current=first;
  }
  while (current != null) {
    if (current.getNext() == valve) {
      current.setNext(valve.getNext());
      break;
    }
    current=current.getNext();
  }
  if (first == basic)   first=null;
  if (valve instanceof Contained)   ((Contained)valve).setContainer(null);
  if (valve instanceof Lifecycle) {
    if (getState().isAvailable()) {
      try {
        ((Lifecycle)valve).stop();
      }
 catch (      LifecycleException e) {
        log.error("StandardPipeline.removeValve: stop: ",e);
      }
    }
    try {
      ((Lifecycle)valve).destroy();
    }
 catch (    LifecycleException e) {
      log.error("StandardPipeline.removeValve: destroy: ",e);
    }
  }
  container.fireContainerEvent(Container.REMOVE_VALVE_EVENT,valve);
}

ID 534=========================================================================type: 1
Method:org.apache.catalina.core.StandardPipeline#removeValve(org.apache.catalina.Valve)
Rmethod: org.apache.catalina.Lifecycle#destroy()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Remove the specified Valve from the pipeline associated with this Container, if it is found; otherwise, do nothing.  If the Valve is found and removed, the Valve's <code>setContainer(null)</code> method will be called if it implements <code>Contained</code>.
 * @param valve Valve to be removed
 */
@Override public void removeValve(Valve valve){
  Valve current;
  if (first == valve) {
    first=first.getNext();
    current=null;
  }
 else {
    current=first;
  }
  while (current != null) {
    if (current.getNext() == valve) {
      current.setNext(valve.getNext());
      break;
    }
    current=current.getNext();
  }
  if (first == basic)   first=null;
  if (valve instanceof Contained)   ((Contained)valve).setContainer(null);
  if (valve instanceof Lifecycle) {
    if (getState().isAvailable()) {
      try {
        ((Lifecycle)valve).stop();
      }
 catch (      LifecycleException e) {
        log.error("StandardPipeline.removeValve: stop: ",e);
      }
    }
    try {
      ((Lifecycle)valve).destroy();
    }
 catch (    LifecycleException e) {
      log.error("StandardPipeline.removeValve: destroy: ",e);
    }
  }
  container.fireContainerEvent(Container.REMOVE_VALVE_EVENT,valve);
}

ID 539=========================================================================type: 1
Method:org.apache.catalina.core.StandardServer#await()
Rmethod: java.net.InetAddress#getByName(java.lang.String)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
/** 
 * Wait until a proper shutdown command is received, then return. This keeps the main thread alive - the thread pool listening for http  connections is daemon threads.
 */
@Override public void await(){
  if (port == -2) {
    return;
  }
  if (port == -1) {
    try {
      awaitThread=Thread.currentThread();
      while (!stopAwait) {
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  finally {
      awaitThread=null;
    }
    return;
  }
  try {
    awaitSocket=new ServerSocket(port,1,InetAddress.getByName(address));
  }
 catch (  IOException e) {
    log.error("StandardServer.await: create[" + address + ":"+ port+ "]: ",e);
    return;
  }
  try {
    awaitThread=Thread.currentThread();
    while (!stopAwait) {
      ServerSocket serverSocket=awaitSocket;
      if (serverSocket == null) {
        break;
      }
      Socket socket=null;
      StringBuilder command=new StringBuilder();
      try {
        InputStream stream;
        long acceptStartTime=System.currentTimeMillis();
        try {
          socket=serverSocket.accept();
          socket.setSoTimeout(10 * 1000);
          stream=socket.getInputStream();
        }
 catch (        SocketTimeoutException ste) {
          log.warn(sm.getString("standardServer.accept.timeout",Long.valueOf(System.currentTimeMillis() - acceptStartTime)),ste);
          continue;
        }
catch (        AccessControlException ace) {
          log.warn("StandardServer.accept security exception: " + ace.getMessage(),ace);
          continue;
        }
catch (        IOException e) {
          if (stopAwait) {
            break;
          }
          log.error("StandardServer.await: accept: ",e);
          break;
        }
        int expected=1024;
        while (expected < shutdown.length()) {
          if (random == null)           random=new Random();
          expected+=(random.nextInt() % 1024);
        }
        while (expected > 0) {
          int ch=-1;
          try {
            ch=stream.read();
          }
 catch (          IOException e) {
            log.warn("StandardServer.await: read: ",e);
            ch=-1;
          }
          if (ch < 32 || ch == 127) {
            break;
          }
          command.append((char)ch);
          expected--;
        }
      }
  finally {
        try {
          if (socket != null) {
            socket.close();
          }
        }
 catch (        IOException e) {
        }
      }
      boolean match=command.toString().equals(shutdown);
      if (match) {
        log.info(sm.getString("standardServer.shutdownViaPort"));
        break;
      }
 else       log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received");
    }
  }
  finally {
    ServerSocket serverSocket=awaitSocket;
    awaitThread=null;
    awaitSocket=null;
    if (serverSocket != null) {
      try {
        serverSocket.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 540=========================================================================type: 1
Method:org.apache.catalina.core.StandardServer#await()
Rmethod: java.net.ServerSocket#ServerSocket(int, int, java.net.InetAddress)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Wait until a proper shutdown command is received, then return. This keeps the main thread alive - the thread pool listening for http  connections is daemon threads.
 */
@Override public void await(){
  if (port == -2) {
    return;
  }
  if (port == -1) {
    try {
      awaitThread=Thread.currentThread();
      while (!stopAwait) {
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  finally {
      awaitThread=null;
    }
    return;
  }
  try {
    awaitSocket=new ServerSocket(port,1,InetAddress.getByName(address));
  }
 catch (  IOException e) {
    log.error("StandardServer.await: create[" + address + ":"+ port+ "]: ",e);
    return;
  }
  try {
    awaitThread=Thread.currentThread();
    while (!stopAwait) {
      ServerSocket serverSocket=awaitSocket;
      if (serverSocket == null) {
        break;
      }
      Socket socket=null;
      StringBuilder command=new StringBuilder();
      try {
        InputStream stream;
        long acceptStartTime=System.currentTimeMillis();
        try {
          socket=serverSocket.accept();
          socket.setSoTimeout(10 * 1000);
          stream=socket.getInputStream();
        }
 catch (        SocketTimeoutException ste) {
          log.warn(sm.getString("standardServer.accept.timeout",Long.valueOf(System.currentTimeMillis() - acceptStartTime)),ste);
          continue;
        }
catch (        AccessControlException ace) {
          log.warn("StandardServer.accept security exception: " + ace.getMessage(),ace);
          continue;
        }
catch (        IOException e) {
          if (stopAwait) {
            break;
          }
          log.error("StandardServer.await: accept: ",e);
          break;
        }
        int expected=1024;
        while (expected < shutdown.length()) {
          if (random == null)           random=new Random();
          expected+=(random.nextInt() % 1024);
        }
        while (expected > 0) {
          int ch=-1;
          try {
            ch=stream.read();
          }
 catch (          IOException e) {
            log.warn("StandardServer.await: read: ",e);
            ch=-1;
          }
          if (ch < 32 || ch == 127) {
            break;
          }
          command.append((char)ch);
          expected--;
        }
      }
  finally {
        try {
          if (socket != null) {
            socket.close();
          }
        }
 catch (        IOException e) {
        }
      }
      boolean match=command.toString().equals(shutdown);
      if (match) {
        log.info(sm.getString("standardServer.shutdownViaPort"));
        break;
      }
 else       log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received");
    }
  }
  finally {
    ServerSocket serverSocket=awaitSocket;
    awaitThread=null;
    awaitSocket=null;
    if (serverSocket != null) {
      try {
        serverSocket.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 541=========================================================================type: 1
Method:org.apache.catalina.core.StandardServer#await()
Rmethod: java.net.ServerSocket#accept()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Wait until a proper shutdown command is received, then return. This keeps the main thread alive - the thread pool listening for http  connections is daemon threads.
 */
@Override public void await(){
  if (port == -2) {
    return;
  }
  if (port == -1) {
    try {
      awaitThread=Thread.currentThread();
      while (!stopAwait) {
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  finally {
      awaitThread=null;
    }
    return;
  }
  try {
    awaitSocket=new ServerSocket(port,1,InetAddress.getByName(address));
  }
 catch (  IOException e) {
    log.error("StandardServer.await: create[" + address + ":"+ port+ "]: ",e);
    return;
  }
  try {
    awaitThread=Thread.currentThread();
    while (!stopAwait) {
      ServerSocket serverSocket=awaitSocket;
      if (serverSocket == null) {
        break;
      }
      Socket socket=null;
      StringBuilder command=new StringBuilder();
      try {
        InputStream stream;
        long acceptStartTime=System.currentTimeMillis();
        try {
          socket=serverSocket.accept();
          socket.setSoTimeout(10 * 1000);
          stream=socket.getInputStream();
        }
 catch (        SocketTimeoutException ste) {
          log.warn(sm.getString("standardServer.accept.timeout",Long.valueOf(System.currentTimeMillis() - acceptStartTime)),ste);
          continue;
        }
catch (        AccessControlException ace) {
          log.warn("StandardServer.accept security exception: " + ace.getMessage(),ace);
          continue;
        }
catch (        IOException e) {
          if (stopAwait) {
            break;
          }
          log.error("StandardServer.await: accept: ",e);
          break;
        }
        int expected=1024;
        while (expected < shutdown.length()) {
          if (random == null)           random=new Random();
          expected+=(random.nextInt() % 1024);
        }
        while (expected > 0) {
          int ch=-1;
          try {
            ch=stream.read();
          }
 catch (          IOException e) {
            log.warn("StandardServer.await: read: ",e);
            ch=-1;
          }
          if (ch < 32 || ch == 127) {
            break;
          }
          command.append((char)ch);
          expected--;
        }
      }
  finally {
        try {
          if (socket != null) {
            socket.close();
          }
        }
 catch (        IOException e) {
        }
      }
      boolean match=command.toString().equals(shutdown);
      if (match) {
        log.info(sm.getString("standardServer.shutdownViaPort"));
        break;
      }
 else       log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received");
    }
  }
  finally {
    ServerSocket serverSocket=awaitSocket;
    awaitThread=null;
    awaitSocket=null;
    if (serverSocket != null) {
      try {
        serverSocket.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 542=========================================================================type: 1
Method:org.apache.catalina.core.StandardServer#await()
Rmethod: java.net.Socket#setSoTimeout(int)
parentException: IOException 
thrown: SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

block: 
/** 
 * Wait until a proper shutdown command is received, then return. This keeps the main thread alive - the thread pool listening for http  connections is daemon threads.
 */
@Override public void await(){
  if (port == -2) {
    return;
  }
  if (port == -1) {
    try {
      awaitThread=Thread.currentThread();
      while (!stopAwait) {
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  finally {
      awaitThread=null;
    }
    return;
  }
  try {
    awaitSocket=new ServerSocket(port,1,InetAddress.getByName(address));
  }
 catch (  IOException e) {
    log.error("StandardServer.await: create[" + address + ":"+ port+ "]: ",e);
    return;
  }
  try {
    awaitThread=Thread.currentThread();
    while (!stopAwait) {
      ServerSocket serverSocket=awaitSocket;
      if (serverSocket == null) {
        break;
      }
      Socket socket=null;
      StringBuilder command=new StringBuilder();
      try {
        InputStream stream;
        long acceptStartTime=System.currentTimeMillis();
        try {
          socket=serverSocket.accept();
          socket.setSoTimeout(10 * 1000);
          stream=socket.getInputStream();
        }
 catch (        SocketTimeoutException ste) {
          log.warn(sm.getString("standardServer.accept.timeout",Long.valueOf(System.currentTimeMillis() - acceptStartTime)),ste);
          continue;
        }
catch (        AccessControlException ace) {
          log.warn("StandardServer.accept security exception: " + ace.getMessage(),ace);
          continue;
        }
catch (        IOException e) {
          if (stopAwait) {
            break;
          }
          log.error("StandardServer.await: accept: ",e);
          break;
        }
        int expected=1024;
        while (expected < shutdown.length()) {
          if (random == null)           random=new Random();
          expected+=(random.nextInt() % 1024);
        }
        while (expected > 0) {
          int ch=-1;
          try {
            ch=stream.read();
          }
 catch (          IOException e) {
            log.warn("StandardServer.await: read: ",e);
            ch=-1;
          }
          if (ch < 32 || ch == 127) {
            break;
          }
          command.append((char)ch);
          expected--;
        }
      }
  finally {
        try {
          if (socket != null) {
            socket.close();
          }
        }
 catch (        IOException e) {
        }
      }
      boolean match=command.toString().equals(shutdown);
      if (match) {
        log.info(sm.getString("standardServer.shutdownViaPort"));
        break;
      }
 else       log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received");
    }
  }
  finally {
    ServerSocket serverSocket=awaitSocket;
    awaitThread=null;
    awaitSocket=null;
    if (serverSocket != null) {
      try {
        serverSocket.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 543=========================================================================type: 1
Method:org.apache.catalina.core.StandardServer#await()
Rmethod: java.net.Socket#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Wait until a proper shutdown command is received, then return. This keeps the main thread alive - the thread pool listening for http  connections is daemon threads.
 */
@Override public void await(){
  if (port == -2) {
    return;
  }
  if (port == -1) {
    try {
      awaitThread=Thread.currentThread();
      while (!stopAwait) {
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  finally {
      awaitThread=null;
    }
    return;
  }
  try {
    awaitSocket=new ServerSocket(port,1,InetAddress.getByName(address));
  }
 catch (  IOException e) {
    log.error("StandardServer.await: create[" + address + ":"+ port+ "]: ",e);
    return;
  }
  try {
    awaitThread=Thread.currentThread();
    while (!stopAwait) {
      ServerSocket serverSocket=awaitSocket;
      if (serverSocket == null) {
        break;
      }
      Socket socket=null;
      StringBuilder command=new StringBuilder();
      try {
        InputStream stream;
        long acceptStartTime=System.currentTimeMillis();
        try {
          socket=serverSocket.accept();
          socket.setSoTimeout(10 * 1000);
          stream=socket.getInputStream();
        }
 catch (        SocketTimeoutException ste) {
          log.warn(sm.getString("standardServer.accept.timeout",Long.valueOf(System.currentTimeMillis() - acceptStartTime)),ste);
          continue;
        }
catch (        AccessControlException ace) {
          log.warn("StandardServer.accept security exception: " + ace.getMessage(),ace);
          continue;
        }
catch (        IOException e) {
          if (stopAwait) {
            break;
          }
          log.error("StandardServer.await: accept: ",e);
          break;
        }
        int expected=1024;
        while (expected < shutdown.length()) {
          if (random == null)           random=new Random();
          expected+=(random.nextInt() % 1024);
        }
        while (expected > 0) {
          int ch=-1;
          try {
            ch=stream.read();
          }
 catch (          IOException e) {
            log.warn("StandardServer.await: read: ",e);
            ch=-1;
          }
          if (ch < 32 || ch == 127) {
            break;
          }
          command.append((char)ch);
          expected--;
        }
      }
  finally {
        try {
          if (socket != null) {
            socket.close();
          }
        }
 catch (        IOException e) {
        }
      }
      boolean match=command.toString().equals(shutdown);
      if (match) {
        log.info(sm.getString("standardServer.shutdownViaPort"));
        break;
      }
 else       log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received");
    }
  }
  finally {
    ServerSocket serverSocket=awaitSocket;
    awaitThread=null;
    awaitSocket=null;
    if (serverSocket != null) {
      try {
        serverSocket.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 544=========================================================================type: 1
Method:org.apache.catalina.core.StandardServer#await()
Rmethod: java.io.InputStream#read()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Wait until a proper shutdown command is received, then return. This keeps the main thread alive - the thread pool listening for http  connections is daemon threads.
 */
@Override public void await(){
  if (port == -2) {
    return;
  }
  if (port == -1) {
    try {
      awaitThread=Thread.currentThread();
      while (!stopAwait) {
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  finally {
      awaitThread=null;
    }
    return;
  }
  try {
    awaitSocket=new ServerSocket(port,1,InetAddress.getByName(address));
  }
 catch (  IOException e) {
    log.error("StandardServer.await: create[" + address + ":"+ port+ "]: ",e);
    return;
  }
  try {
    awaitThread=Thread.currentThread();
    while (!stopAwait) {
      ServerSocket serverSocket=awaitSocket;
      if (serverSocket == null) {
        break;
      }
      Socket socket=null;
      StringBuilder command=new StringBuilder();
      try {
        InputStream stream;
        long acceptStartTime=System.currentTimeMillis();
        try {
          socket=serverSocket.accept();
          socket.setSoTimeout(10 * 1000);
          stream=socket.getInputStream();
        }
 catch (        SocketTimeoutException ste) {
          log.warn(sm.getString("standardServer.accept.timeout",Long.valueOf(System.currentTimeMillis() - acceptStartTime)),ste);
          continue;
        }
catch (        AccessControlException ace) {
          log.warn("StandardServer.accept security exception: " + ace.getMessage(),ace);
          continue;
        }
catch (        IOException e) {
          if (stopAwait) {
            break;
          }
          log.error("StandardServer.await: accept: ",e);
          break;
        }
        int expected=1024;
        while (expected < shutdown.length()) {
          if (random == null)           random=new Random();
          expected+=(random.nextInt() % 1024);
        }
        while (expected > 0) {
          int ch=-1;
          try {
            ch=stream.read();
          }
 catch (          IOException e) {
            log.warn("StandardServer.await: read: ",e);
            ch=-1;
          }
          if (ch < 32 || ch == 127) {
            break;
          }
          command.append((char)ch);
          expected--;
        }
      }
  finally {
        try {
          if (socket != null) {
            socket.close();
          }
        }
 catch (        IOException e) {
        }
      }
      boolean match=command.toString().equals(shutdown);
      if (match) {
        log.info(sm.getString("standardServer.shutdownViaPort"));
        break;
      }
 else       log.warn("StandardServer.await: Invalid command '" + command.toString() + "' received");
    }
  }
  finally {
    ServerSocket serverSocket=awaitSocket;
    awaitThread=null;
    awaitSocket=null;
    if (serverSocket != null) {
      try {
        serverSocket.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 568=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContextFacade#getResource(java.lang.String)
Rmethod: org.apache.catalina.core.ApplicationContextFacade#invokeMethod(org.apache.catalina.core.ApplicationContext, java.lang.String, java.lang.Object[])
parentException: Object 
thrown: Throwable
exception comment: null
block: 
@Override public URL getResource(String path) throws MalformedURLException {
  if (Globals.IS_SECURITY_ENABLED) {
    try {
      return (URL)invokeMethod(context,"getResource",new Object[]{path});
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      if (t instanceof MalformedURLException) {
        throw (MalformedURLException)t;
      }
      return null;
    }
  }
 else {
    return context.getResource(path);
  }
}

ID 570=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContextFacade#getServlet(java.lang.String)
Rmethod: org.apache.catalina.core.ApplicationContextFacade#invokeMethod(org.apache.catalina.core.ApplicationContext, java.lang.String, java.lang.Object[])
parentException: Object 
thrown: Throwable
exception comment: null
block: 
/** 
 * @deprecated As of Java Servlet API 2.1, with no direct replacement.
 */
@Override @Deprecated public Servlet getServlet(String name) throws ServletException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      return (Servlet)invokeMethod(context,"getServlet",new Object[]{name});
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      if (t instanceof ServletException) {
        throw (ServletException)t;
      }
      return null;
    }
  }
 else {
    return context.getServlet(name);
  }
}

ID 571=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContextFacade#createFilter(Class<T>)
Rmethod: org.apache.catalina.core.ApplicationContextFacade#invokeMethod(org.apache.catalina.core.ApplicationContext, java.lang.String, java.lang.Object[])
parentException: Object 
thrown: Throwable
exception comment: null
block: 
@Override @SuppressWarnings("unchecked") public <T extends Filter>T createFilter(Class<T> c) throws ServletException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      return (T)invokeMethod(context,"createFilter",new Object[]{c});
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      if (t instanceof ServletException) {
        throw (ServletException)t;
      }
      return null;
    }
  }
 else {
    return context.createFilter(c);
  }
}

ID 573=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContextFacade#createServlet(Class<T>)
Rmethod: org.apache.catalina.core.ApplicationContextFacade#invokeMethod(org.apache.catalina.core.ApplicationContext, java.lang.String, java.lang.Object[])
parentException: Object 
thrown: Throwable
exception comment: null
block: 
@Override @SuppressWarnings("unchecked") public <T extends Servlet>T createServlet(Class<T> c) throws ServletException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      return (T)invokeMethod(context,"createServlet",new Object[]{c});
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      if (t instanceof ServletException) {
        throw (ServletException)t;
      }
      return null;
    }
  }
 else {
    return context.createServlet(c);
  }
}

ID 575=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContextFacade#createListener(Class<T>)
Rmethod: org.apache.catalina.core.ApplicationContextFacade#invokeMethod(org.apache.catalina.core.ApplicationContext, java.lang.String, java.lang.Object[])
parentException: Object 
thrown: Throwable
exception comment: null
block: 
@Override @SuppressWarnings("unchecked") public <T extends EventListener>T createListener(Class<T> c) throws ServletException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      return (T)invokeMethod(context,"createListener",new Object[]{c});
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      if (t instanceof ServletException) {
        throw (ServletException)t;
      }
      return null;
    }
  }
 else {
    return context.createListener(c);
  }
}

ID 577=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContextFacade#doPrivileged(java.lang.String, java.lang.Object[])
Rmethod: org.apache.catalina.core.ApplicationContextFacade#invokeMethod(org.apache.catalina.core.ApplicationContext, java.lang.String, java.lang.Object[])
parentException: Object 
thrown: Throwable
exception comment: null
block: 
/** 
 * Use reflection to invoke the requested method. Cache the method object  to speed up the process
 * @param methodName The method to call.
 * @param params The arguments passed to the called method.
 */
private Object doPrivileged(final String methodName,final Object[] params){
  try {
    return invokeMethod(context,methodName,params);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    throw new RuntimeException(t.getMessage(),t);
  }
}

ID 589=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContextFacade#doPrivileged(java.lang.String, Class<?>[], java.lang.Object[])
Rmethod: org.apache.catalina.core.ApplicationContextFacade#handleException(java.lang.Exception)
parentException: Object 
thrown: Throwable
exception comment: null
block: 
/** 
 * Use reflection to invoke the requested method. Cache the method object  to speed up the process
 * @param methodName The method to invoke.
 * @param clazz The class where the method is.
 * @param params The arguments passed to the called method.
 */
private Object doPrivileged(final String methodName,final Class<?>[] clazz,Object[] params){
  try {
    Method method=context.getClass().getMethod(methodName,clazz);
    return executeMethod(method,context,params);
  }
 catch (  Exception ex) {
    try {
      handleException(ex);
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      throw new RuntimeException(t.getMessage());
    }
    return null;
  }
 finally {
    params=null;
  }
}

ID 601=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#getRequestDispatcher(java.lang.String)
Rmethod: org.apache.tomcat.util.http.mapper.Mapper#map(org.apache.tomcat.util.buf.MessageBytes, org.apache.tomcat.util.http.mapper.MappingData)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Return a <code>RequestDispatcher</code> instance that acts as a wrapper for the resource at the given path.  The path must begin with a "/" and is interpreted as relative to the current context root.
 * @param path The path to the desired resource.
 */
@Override public RequestDispatcher getRequestDispatcher(String path){
  if (path == null)   return (null);
  if (!path.startsWith("/"))   throw new IllegalArgumentException(sm.getString("applicationContext.requestDispatcher.iae",path));
  String queryString=null;
  String normalizedPath=path;
  int pos=normalizedPath.indexOf('?');
  if (pos >= 0) {
    queryString=normalizedPath.substring(pos + 1);
    normalizedPath=normalizedPath.substring(0,pos);
  }
  normalizedPath=RequestUtil.normalize(normalizedPath);
  if (normalizedPath == null)   return (null);
  if (getContext().getDispatchersUseEncodedPaths()) {
    String decodedPath;
    try {
      decodedPath=URLDecoder.decode(normalizedPath,"UTF-8");
    }
 catch (    UnsupportedEncodingException e) {
      return null;
    }
    normalizedPath=RequestUtil.normalize(decodedPath);
    if (!decodedPath.equals(normalizedPath)) {
      getContext().getLogger().warn(sm.getString("applicationContext.illegalDispatchPath",path),new IllegalArgumentException());
      return null;
    }
  }
  pos=normalizedPath.length();
  DispatchData dd=dispatchData.get();
  if (dd == null) {
    dd=new DispatchData();
    dispatchData.set(dd);
  }
  MessageBytes uriMB=dd.uriMB;
  uriMB.recycle();
  MappingData mappingData=dd.mappingData;
  CharChunk uriCC=uriMB.getCharChunk();
  try {
    uriCC.append(context.getPath(),0,context.getPath().length());
    int semicolon=normalizedPath.indexOf(';');
    if (pos >= 0 && semicolon > pos) {
      semicolon=-1;
    }
    uriCC.append(normalizedPath,0,semicolon > 0 ? semicolon : pos);
    context.getMapper().map(uriMB,mappingData);
    if (mappingData.wrapper == null) {
      return (null);
    }
    if (semicolon > 0) {
      uriCC.append(normalizedPath,semicolon,pos - semicolon);
    }
  }
 catch (  Exception e) {
    log(sm.getString("applicationContext.mapping.error"),e);
    return (null);
  }
  Wrapper wrapper=(Wrapper)mappingData.wrapper;
  String wrapperPath=mappingData.wrapperPath.toString();
  String pathInfo=mappingData.pathInfo.toString();
  mappingData.recycle();
  String encodedUri=URLEncoder.DEFAULT.encode(uriCC.toString(),"UTF-8");
  return new ApplicationDispatcher(wrapper,encodedUri,wrapperPath,pathInfo,queryString,null);
}

ID 607=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#getResourcePathsInternal(javax.naming.directory.DirContext, java.lang.String)
Rmethod: org.apache.catalina.core.ApplicationContext#listCollectionPaths(Set<java.lang.String>, javax.naming.directory.DirContext, java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Internal implementation of getResourcesPath() logic.
 * @param resources Directory context to search
 * @param path Collection path
 */
private Set<String> getResourcePathsInternal(DirContext resources,String path){
  ResourceSet<String> set=new ResourceSet<String>();
  try {
    listCollectionPaths(set,resources,path);
  }
 catch (  NamingException e) {
    return (null);
  }
  set.setLocked(true);
  return (set);
}

ID 611=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createFilter(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public <T extends Filter>T createFilter(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T filter=(T)context.getInstanceManager().newInstance(c.getName());
    return filter;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 612=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createFilter(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public <T extends Filter>T createFilter(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T filter=(T)context.getInstanceManager().newInstance(c.getName());
    return filter;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 613=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createFilter(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@Override public <T extends Filter>T createFilter(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T filter=(T)context.getInstanceManager().newInstance(c.getName());
    return filter;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 614=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createFilter(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public <T extends Filter>T createFilter(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T filter=(T)context.getInstanceManager().newInstance(c.getName());
    return filter;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 615=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createFilter(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@Override public <T extends Filter>T createFilter(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T filter=(T)context.getInstanceManager().newInstance(c.getName());
    return filter;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 619=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createServlet(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public <T extends Servlet>T createServlet(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T servlet=(T)context.getInstanceManager().newInstance(c.getName());
    context.dynamicServletCreated(servlet);
    return servlet;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 620=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createServlet(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public <T extends Servlet>T createServlet(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T servlet=(T)context.getInstanceManager().newInstance(c.getName());
    context.dynamicServletCreated(servlet);
    return servlet;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 621=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createServlet(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@Override public <T extends Servlet>T createServlet(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T servlet=(T)context.getInstanceManager().newInstance(c.getName());
    context.dynamicServletCreated(servlet);
    return servlet;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 622=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createServlet(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public <T extends Servlet>T createServlet(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T servlet=(T)context.getInstanceManager().newInstance(c.getName());
    context.dynamicServletCreated(servlet);
    return servlet;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 623=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createServlet(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@Override public <T extends Servlet>T createServlet(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T servlet=(T)context.getInstanceManager().newInstance(c.getName());
    context.dynamicServletCreated(servlet);
    return servlet;
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  ClassNotFoundException e) {
    throw new ServletException(e);
  }
}

ID 624=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#addListener(Class<? extends java.util.EventListener>)
Rmethod: org.apache.catalina.core.ApplicationContext#createListener(Class<T>)
parentException: 
thrown: ServletException
exception comment: null
block: 
@Override public void addListener(Class<? extends EventListener> listenerClass){
  EventListener listener;
  try {
    listener=createListener(listenerClass);
  }
 catch (  ServletException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.init",listenerClass.getName()),e);
  }
  addListener(listener);
}

ID 625=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public void addListener(String className){
  try {
    if (context.getInstanceManager() != null) {
      Object obj=context.getInstanceManager().newInstance(className);
      if (!(obj instanceof EventListener)) {
        throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",className));
      }
      EventListener listener=(EventListener)obj;
      addListener(listener);
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  NamingException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
}

ID 626=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public void addListener(String className){
  try {
    if (context.getInstanceManager() != null) {
      Object obj=context.getInstanceManager().newInstance(className);
      if (!(obj instanceof EventListener)) {
        throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",className));
      }
      EventListener listener=(EventListener)obj;
      addListener(listener);
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  NamingException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
}

ID 627=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@Override public void addListener(String className){
  try {
    if (context.getInstanceManager() != null) {
      Object obj=context.getInstanceManager().newInstance(className);
      if (!(obj instanceof EventListener)) {
        throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",className));
      }
      EventListener listener=(EventListener)obj;
      addListener(listener);
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  NamingException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
}

ID 628=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public void addListener(String className){
  try {
    if (context.getInstanceManager() != null) {
      Object obj=context.getInstanceManager().newInstance(className);
      if (!(obj instanceof EventListener)) {
        throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",className));
      }
      EventListener listener=(EventListener)obj;
      addListener(listener);
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  NamingException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
}

ID 629=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#addListener(java.lang.String)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@Override public void addListener(String className){
  try {
    if (context.getInstanceManager() != null) {
      Object obj=context.getInstanceManager().newInstance(className);
      if (!(obj instanceof EventListener)) {
        throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",className));
      }
      EventListener listener=(EventListener)obj;
      addListener(listener);
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  NamingException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.cnfe",className),e);
  }
}

ID 630=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public <T extends EventListener>T createListener(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T listener=(T)context.getInstanceManager().newInstance(c);
    if (listener instanceof ServletContextListener || listener instanceof ServletContextAttributeListener || listener instanceof ServletRequestListener|| listener instanceof ServletRequestAttributeListener|| listener instanceof HttpSessionListener|| listener instanceof HttpSessionAttributeListener) {
      return listener;
    }
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",listener.getClass().getName()));
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
}

ID 631=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public <T extends EventListener>T createListener(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T listener=(T)context.getInstanceManager().newInstance(c);
    if (listener instanceof ServletContextListener || listener instanceof ServletContextAttributeListener || listener instanceof ServletRequestListener|| listener instanceof ServletRequestAttributeListener|| listener instanceof HttpSessionListener|| listener instanceof HttpSessionAttributeListener) {
      return listener;
    }
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",listener.getClass().getName()));
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
}

ID 632=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@Override public <T extends EventListener>T createListener(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T listener=(T)context.getInstanceManager().newInstance(c);
    if (listener instanceof ServletContextListener || listener instanceof ServletContextAttributeListener || listener instanceof ServletRequestListener|| listener instanceof ServletRequestAttributeListener|| listener instanceof HttpSessionListener|| listener instanceof HttpSessionAttributeListener) {
      return listener;
    }
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",listener.getClass().getName()));
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
}

ID 633=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationContext#createListener(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public <T extends EventListener>T createListener(Class<T> c) throws ServletException {
  try {
    @SuppressWarnings("unchecked") T listener=(T)context.getInstanceManager().newInstance(c);
    if (listener instanceof ServletContextListener || listener instanceof ServletContextAttributeListener || listener instanceof ServletRequestListener|| listener instanceof ServletRequestAttributeListener|| listener instanceof HttpSessionListener|| listener instanceof HttpSessionAttributeListener) {
      return listener;
    }
    throw new IllegalArgumentException(sm.getString("applicationContext.addListener.iae.wrongType",listener.getClass().getName()));
  }
 catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    ExceptionUtils.handleThrowable(e.getCause());
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
catch (  InstantiationException e) {
    throw new ServletException(e);
  }
}

ID 636=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.catalina.core.NamingContextListener#createNamingContext()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Acknowledge the occurrence of the specified event.
 * @param event LifecycleEvent that has occurred
 */
@Override public void lifecycleEvent(LifecycleEvent event){
  container=event.getLifecycle();
  if (container instanceof Context) {
    namingResources=((Context)container).getNamingResources();
    logger=log;
  }
 else   if (container instanceof Server) {
    namingResources=((Server)container).getGlobalNamingResources();
  }
 else {
    return;
  }
  if (Lifecycle.CONFIGURE_START_EVENT.equals(event.getType())) {
    if (initialized)     return;
    try {
      Hashtable<String,Object> contextEnv=new Hashtable<String,Object>();
      try {
        namingContext=new NamingContext(contextEnv,getName());
      }
 catch (      NamingException e) {
      }
      ContextAccessController.setSecurityToken(getName(),container);
      ContextAccessController.setSecurityToken(container,container);
      ContextBindings.bindContext(container,namingContext,container);
      if (log.isDebugEnabled()) {
        log.debug("Bound " + container);
      }
      namingContext.setExceptionOnFailedWrite(getExceptionOnFailedWrite());
      ContextAccessController.setWritable(getName(),container);
      try {
        createNamingContext();
      }
 catch (      NamingException e) {
        logger.error(sm.getString("naming.namingContextCreationFailed",e));
      }
      namingResources.addPropertyChangeListener(this);
      if (container instanceof Context) {
        ContextAccessController.setReadOnly(getName());
        try {
          ContextBindings.bindClassLoader(container,container,((Container)container).getLoader().getClassLoader());
        }
 catch (        NamingException e) {
          logger.error(sm.getString("naming.bindFailed",e));
        }
      }
      if (container instanceof Server) {
        org.apache.naming.factory.ResourceLinkFactory.setGlobalContext(namingContext);
        try {
          ContextBindings.bindClassLoader(container,container,this.getClass().getClassLoader());
        }
 catch (        NamingException e) {
          logger.error(sm.getString("naming.bindFailed",e));
        }
        if (container instanceof StandardServer) {
          ((StandardServer)container).setGlobalNamingContext(namingContext);
        }
      }
    }
  finally {
      initialized=true;
    }
  }
 else   if (Lifecycle.CONFIGURE_STOP_EVENT.equals(event.getType())) {
    if (!initialized)     return;
    try {
      ContextAccessController.setWritable(getName(),container);
      ContextBindings.unbindContext(container,container);
      if (container instanceof Context) {
        ContextBindings.unbindClassLoader(container,container,((Container)container).getLoader().getClassLoader());
      }
      if (container instanceof Server) {
        namingResources.removePropertyChangeListener(this);
        ContextBindings.unbindClassLoader(container,container,this.getClass().getClassLoader());
      }
      ContextAccessController.unsetSecurityToken(getName(),container);
      ContextAccessController.unsetSecurityToken(container,container);
      if (!objectNames.isEmpty()) {
        Collection<ObjectName> names=objectNames.values();
        Registry registry=Registry.getRegistry(null,null);
        for (        ObjectName objectName : names) {
          registry.unregisterComponent(objectName);
        }
      }
      javax.naming.Context global=getGlobalNamingContext();
      if (global != null) {
        ResourceLinkFactory.deregisterGlobalResourceAccess(global);
      }
    }
  finally {
      objectNames.clear();
      namingContext=null;
      envCtx=null;
      compCtx=null;
      initialized=false;
    }
  }
}

ID 637=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.naming.ContextBindings#bindClassLoader(java.lang.Object, java.lang.Object, java.lang.ClassLoader)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Acknowledge the occurrence of the specified event.
 * @param event LifecycleEvent that has occurred
 */
@Override public void lifecycleEvent(LifecycleEvent event){
  container=event.getLifecycle();
  if (container instanceof Context) {
    namingResources=((Context)container).getNamingResources();
    logger=log;
  }
 else   if (container instanceof Server) {
    namingResources=((Server)container).getGlobalNamingResources();
  }
 else {
    return;
  }
  if (Lifecycle.CONFIGURE_START_EVENT.equals(event.getType())) {
    if (initialized)     return;
    try {
      Hashtable<String,Object> contextEnv=new Hashtable<String,Object>();
      try {
        namingContext=new NamingContext(contextEnv,getName());
      }
 catch (      NamingException e) {
      }
      ContextAccessController.setSecurityToken(getName(),container);
      ContextAccessController.setSecurityToken(container,container);
      ContextBindings.bindContext(container,namingContext,container);
      if (log.isDebugEnabled()) {
        log.debug("Bound " + container);
      }
      namingContext.setExceptionOnFailedWrite(getExceptionOnFailedWrite());
      ContextAccessController.setWritable(getName(),container);
      try {
        createNamingContext();
      }
 catch (      NamingException e) {
        logger.error(sm.getString("naming.namingContextCreationFailed",e));
      }
      namingResources.addPropertyChangeListener(this);
      if (container instanceof Context) {
        ContextAccessController.setReadOnly(getName());
        try {
          ContextBindings.bindClassLoader(container,container,((Container)container).getLoader().getClassLoader());
        }
 catch (        NamingException e) {
          logger.error(sm.getString("naming.bindFailed",e));
        }
      }
      if (container instanceof Server) {
        org.apache.naming.factory.ResourceLinkFactory.setGlobalContext(namingContext);
        try {
          ContextBindings.bindClassLoader(container,container,this.getClass().getClassLoader());
        }
 catch (        NamingException e) {
          logger.error(sm.getString("naming.bindFailed",e));
        }
        if (container instanceof StandardServer) {
          ((StandardServer)container).setGlobalNamingContext(namingContext);
        }
      }
    }
  finally {
      initialized=true;
    }
  }
 else   if (Lifecycle.CONFIGURE_STOP_EVENT.equals(event.getType())) {
    if (!initialized)     return;
    try {
      ContextAccessController.setWritable(getName(),container);
      ContextBindings.unbindContext(container,container);
      if (container instanceof Context) {
        ContextBindings.unbindClassLoader(container,container,((Container)container).getLoader().getClassLoader());
      }
      if (container instanceof Server) {
        namingResources.removePropertyChangeListener(this);
        ContextBindings.unbindClassLoader(container,container,this.getClass().getClassLoader());
      }
      ContextAccessController.unsetSecurityToken(getName(),container);
      ContextAccessController.unsetSecurityToken(container,container);
      if (!objectNames.isEmpty()) {
        Collection<ObjectName> names=objectNames.values();
        Registry registry=Registry.getRegistry(null,null);
        for (        ObjectName objectName : names) {
          registry.unregisterComponent(objectName);
        }
      }
      javax.naming.Context global=getGlobalNamingContext();
      if (global != null) {
        ResourceLinkFactory.deregisterGlobalResourceAccess(global);
      }
    }
  finally {
      objectNames.clear();
      namingContext=null;
      envCtx=null;
      compCtx=null;
      initialized=false;
    }
  }
}

ID 640=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#createNamingContext()
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Create and initialize the JNDI naming context.
 */
private void createNamingContext() throws NamingException {
  if (container instanceof Server) {
    compCtx=namingContext;
    envCtx=namingContext;
  }
 else {
    compCtx=namingContext.createSubcontext("comp");
    envCtx=compCtx.createSubcontext("env");
  }
  int i;
  if (log.isDebugEnabled())   log.debug("Creating JNDI naming context");
  if (namingResources == null) {
    namingResources=new NamingResources();
    namingResources.setContainer(container);
  }
  ContextResourceLink[] resourceLinks=namingResources.findResourceLinks();
  for (i=0; i < resourceLinks.length; i++) {
    addResourceLink(resourceLinks[i]);
  }
  ContextResource[] resources=namingResources.findResources();
  for (i=0; i < resources.length; i++) {
    addResource(resources[i]);
  }
  ContextResourceEnvRef[] resourceEnvRefs=namingResources.findResourceEnvRefs();
  for (i=0; i < resourceEnvRefs.length; i++) {
    addResourceEnvRef(resourceEnvRefs[i]);
  }
  ContextEnvironment[] contextEnvironments=namingResources.findEnvironments();
  for (i=0; i < contextEnvironments.length; i++) {
    addEnvironment(contextEnvironments[i]);
  }
  ContextEjb[] ejbs=namingResources.findEjbs();
  for (i=0; i < ejbs.length; i++) {
    addEjb(ejbs[i]);
  }
  ContextService[] services=namingResources.findServices();
  for (i=0; i < services.length; i++) {
    addService(services[i]);
  }
  if (container instanceof Context) {
    try {
      Reference ref=new TransactionRef();
      compCtx.bind("UserTransaction",ref);
      ContextTransaction transaction=namingResources.getTransaction();
      if (transaction != null) {
        Iterator<String> params=transaction.listProperties();
        while (params.hasNext()) {
          String paramName=params.next();
          String paramValue=(String)transaction.getProperty(paramName);
          StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
          ref.add(refAddr);
        }
      }
    }
 catch (    NameAlreadyBoundException e) {
    }
catch (    NamingException e) {
      logger.error(sm.getString("naming.bindFailed",e));
    }
  }
  if (container instanceof Context) {
    try {
      compCtx.bind("Resources",((Container)container).getResources());
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.bindFailed",e));
    }
  }
}

ID 642=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEjb(org.apache.catalina.deploy.ContextEjb)
Rmethod: org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified EJBs in the naming context.
 */
public void addEjb(ContextEjb ejb){
  Reference ref=new EjbRef(ejb.getType(),ejb.getHome(),ejb.getRemote(),ejb.getLink());
  Iterator<String> params=ejb.listProperties();
  while (params.hasNext()) {
    String paramName=params.next();
    String paramValue=(String)ejb.getProperty(paramName);
    StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
    ref.add(refAddr);
  }
  try {
    createSubcontexts(envCtx,ejb.getName());
    envCtx.bind(ejb.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
}

ID 643=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEjb(org.apache.catalina.deploy.ContextEjb)
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified EJBs in the naming context.
 */
public void addEjb(ContextEjb ejb){
  Reference ref=new EjbRef(ejb.getType(),ejb.getHome(),ejb.getRemote(),ejb.getLink());
  Iterator<String> params=ejb.listProperties();
  while (params.hasNext()) {
    String paramName=params.next();
    String paramValue=(String)ejb.getProperty(paramName);
    StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
    ref.add(refAddr);
  }
  try {
    createSubcontexts(envCtx,ejb.getName());
    envCtx.bind(ejb.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
}

ID 644=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: java.lang.Byte#decode(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 645=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: java.lang.Short#decode(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 646=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: java.lang.Integer#decode(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 647=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: java.lang.Long#decode(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 648=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: java.lang.Double#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 649=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: java.lang.Float#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 650=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 651=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void addEnvironment(ContextEnvironment env){
  Object value=null;
  String type=env.getType();
  try {
    if (type.equals("java.lang.String")) {
      value=env.getValue();
    }
 else     if (type.equals("java.lang.Byte")) {
      if (env.getValue() == null) {
        value=Byte.valueOf((byte)0);
      }
 else {
        value=Byte.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Short")) {
      if (env.getValue() == null) {
        value=Short.valueOf((short)0);
      }
 else {
        value=Short.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Integer")) {
      if (env.getValue() == null) {
        value=Integer.valueOf(0);
      }
 else {
        value=Integer.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Long")) {
      if (env.getValue() == null) {
        value=Long.valueOf(0);
      }
 else {
        value=Long.decode(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Boolean")) {
      value=Boolean.valueOf(env.getValue());
    }
 else     if (type.equals("java.lang.Double")) {
      if (env.getValue() == null) {
        value=Double.valueOf(0);
      }
 else {
        value=Double.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Float")) {
      if (env.getValue() == null) {
        value=Float.valueOf(0);
      }
 else {
        value=Float.valueOf(env.getValue());
      }
    }
 else     if (type.equals("java.lang.Character")) {
      if (env.getValue() == null) {
        value=Character.valueOf((char)0);
      }
 else {
        if (env.getValue().length() == 1) {
          value=Character.valueOf(env.getValue().charAt(0));
        }
 else {
          throw new IllegalArgumentException();
        }
      }
    }
 else {
      value=constructEnvEntry(env.getType(),env.getValue());
      if (value == null) {
        logger.error(sm.getString("naming.invalidEnvEntryType",env.getName()));
      }
    }
  }
 catch (  NumberFormatException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
catch (  IllegalArgumentException e) {
    logger.error(sm.getString("naming.invalidEnvEntryValue",env.getName()));
  }
  if (value != null) {
    try {
      if (logger.isDebugEnabled())       logger.debug("  Adding environment entry " + env.getName());
      createSubcontexts(envCtx,env.getName());
      envCtx.bind(env.getName(),value);
    }
 catch (    NamingException e) {
      logger.error(sm.getString("naming.invalidEnvEntryValue",e));
    }
  }
}

ID 661=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addService(org.apache.catalina.deploy.ContextService)
Rmethod: javax.servlet.ServletContext#getResource(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified web service in the naming context.
 */
public void addService(ContextService service){
  if (service.getWsdlfile() != null) {
    URL wsdlURL=null;
    try {
      wsdlURL=new URL(service.getWsdlfile());
    }
 catch (    MalformedURLException e) {
    }
    if (wsdlURL == null) {
      try {
        wsdlURL=((Context)container).getServletContext().getResource(service.getWsdlfile());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (wsdlURL == null) {
      try {
        wsdlURL=((Context)container).getServletContext().getResource("/" + service.getWsdlfile());
        logger.debug("  Changing service ref wsdl file for /" + service.getWsdlfile());
      }
 catch (      MalformedURLException e) {
        logger.error(sm.getString("naming.wsdlFailed",e));
      }
    }
    if (wsdlURL == null)     service.setWsdlfile(null);
 else     service.setWsdlfile(wsdlURL.toString());
  }
  if (service.getJaxrpcmappingfile() != null) {
    URL jaxrpcURL=null;
    try {
      jaxrpcURL=new URL(service.getJaxrpcmappingfile());
    }
 catch (    MalformedURLException e) {
    }
    if (jaxrpcURL == null) {
      try {
        jaxrpcURL=((Context)container).getServletContext().getResource(service.getJaxrpcmappingfile());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (jaxrpcURL == null) {
      try {
        jaxrpcURL=((Context)container).getServletContext().getResource("/" + service.getJaxrpcmappingfile());
        logger.debug("  Changing service ref jaxrpc file for /" + service.getJaxrpcmappingfile());
      }
 catch (      MalformedURLException e) {
        logger.error(sm.getString("naming.wsdlFailed",e));
      }
    }
    if (jaxrpcURL == null)     service.setJaxrpcmappingfile(null);
 else     service.setJaxrpcmappingfile(jaxrpcURL.toString());
  }
  Reference ref=new ServiceRef(service.getName(),service.getType(),service.getServiceqname(),service.getWsdlfile(),service.getJaxrpcmappingfile());
  Iterator<String> portcomponent=service.getServiceendpoints();
  while (portcomponent.hasNext()) {
    String serviceendpoint=portcomponent.next();
    StringRefAddr refAddr=new StringRefAddr(ServiceRef.SERVICEENDPOINTINTERFACE,serviceendpoint);
    ref.add(refAddr);
    String portlink=service.getPortlink(serviceendpoint);
    refAddr=new StringRefAddr(ServiceRef.PORTCOMPONENTLINK,portlink);
    ref.add(refAddr);
  }
  Iterator<String> handlers=service.getHandlers();
  while (handlers.hasNext()) {
    String handlername=handlers.next();
    ContextHandler handler=service.getHandler(handlername);
    HandlerRef handlerRef=new HandlerRef(handlername,handler.getHandlerclass());
    Iterator<String> localParts=handler.getLocalparts();
    while (localParts.hasNext()) {
      String localPart=localParts.next();
      String namespaceURI=handler.getNamespaceuri(localPart);
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_LOCALPART,localPart));
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_NAMESPACE,namespaceURI));
    }
    Iterator<String> params=handler.listProperties();
    while (params.hasNext()) {
      String paramName=params.next();
      String paramValue=(String)handler.getProperty(paramName);
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PARAMNAME,paramName));
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PARAMVALUE,paramValue));
    }
    for (int i=0; i < handler.getSoapRolesSize(); i++) {
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_SOAPROLE,handler.getSoapRole(i)));
    }
    for (int i=0; i < handler.getPortNamesSize(); i++) {
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PORTNAME,handler.getPortName(i)));
    }
    ((ServiceRef)ref).addHandler(handlerRef);
  }
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("  Adding service ref " + service.getName() + "  "+ ref);
    }
    createSubcontexts(envCtx,service.getName());
    envCtx.bind(service.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
}

ID 662=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addService(org.apache.catalina.deploy.ContextService)
Rmethod: org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified web service in the naming context.
 */
public void addService(ContextService service){
  if (service.getWsdlfile() != null) {
    URL wsdlURL=null;
    try {
      wsdlURL=new URL(service.getWsdlfile());
    }
 catch (    MalformedURLException e) {
    }
    if (wsdlURL == null) {
      try {
        wsdlURL=((Context)container).getServletContext().getResource(service.getWsdlfile());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (wsdlURL == null) {
      try {
        wsdlURL=((Context)container).getServletContext().getResource("/" + service.getWsdlfile());
        logger.debug("  Changing service ref wsdl file for /" + service.getWsdlfile());
      }
 catch (      MalformedURLException e) {
        logger.error(sm.getString("naming.wsdlFailed",e));
      }
    }
    if (wsdlURL == null)     service.setWsdlfile(null);
 else     service.setWsdlfile(wsdlURL.toString());
  }
  if (service.getJaxrpcmappingfile() != null) {
    URL jaxrpcURL=null;
    try {
      jaxrpcURL=new URL(service.getJaxrpcmappingfile());
    }
 catch (    MalformedURLException e) {
    }
    if (jaxrpcURL == null) {
      try {
        jaxrpcURL=((Context)container).getServletContext().getResource(service.getJaxrpcmappingfile());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (jaxrpcURL == null) {
      try {
        jaxrpcURL=((Context)container).getServletContext().getResource("/" + service.getJaxrpcmappingfile());
        logger.debug("  Changing service ref jaxrpc file for /" + service.getJaxrpcmappingfile());
      }
 catch (      MalformedURLException e) {
        logger.error(sm.getString("naming.wsdlFailed",e));
      }
    }
    if (jaxrpcURL == null)     service.setJaxrpcmappingfile(null);
 else     service.setJaxrpcmappingfile(jaxrpcURL.toString());
  }
  Reference ref=new ServiceRef(service.getName(),service.getType(),service.getServiceqname(),service.getWsdlfile(),service.getJaxrpcmappingfile());
  Iterator<String> portcomponent=service.getServiceendpoints();
  while (portcomponent.hasNext()) {
    String serviceendpoint=portcomponent.next();
    StringRefAddr refAddr=new StringRefAddr(ServiceRef.SERVICEENDPOINTINTERFACE,serviceendpoint);
    ref.add(refAddr);
    String portlink=service.getPortlink(serviceendpoint);
    refAddr=new StringRefAddr(ServiceRef.PORTCOMPONENTLINK,portlink);
    ref.add(refAddr);
  }
  Iterator<String> handlers=service.getHandlers();
  while (handlers.hasNext()) {
    String handlername=handlers.next();
    ContextHandler handler=service.getHandler(handlername);
    HandlerRef handlerRef=new HandlerRef(handlername,handler.getHandlerclass());
    Iterator<String> localParts=handler.getLocalparts();
    while (localParts.hasNext()) {
      String localPart=localParts.next();
      String namespaceURI=handler.getNamespaceuri(localPart);
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_LOCALPART,localPart));
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_NAMESPACE,namespaceURI));
    }
    Iterator<String> params=handler.listProperties();
    while (params.hasNext()) {
      String paramName=params.next();
      String paramValue=(String)handler.getProperty(paramName);
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PARAMNAME,paramName));
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PARAMVALUE,paramValue));
    }
    for (int i=0; i < handler.getSoapRolesSize(); i++) {
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_SOAPROLE,handler.getSoapRole(i)));
    }
    for (int i=0; i < handler.getPortNamesSize(); i++) {
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PORTNAME,handler.getPortName(i)));
    }
    ((ServiceRef)ref).addHandler(handlerRef);
  }
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("  Adding service ref " + service.getName() + "  "+ ref);
    }
    createSubcontexts(envCtx,service.getName());
    envCtx.bind(service.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
}

ID 663=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addService(org.apache.catalina.deploy.ContextService)
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified web service in the naming context.
 */
public void addService(ContextService service){
  if (service.getWsdlfile() != null) {
    URL wsdlURL=null;
    try {
      wsdlURL=new URL(service.getWsdlfile());
    }
 catch (    MalformedURLException e) {
    }
    if (wsdlURL == null) {
      try {
        wsdlURL=((Context)container).getServletContext().getResource(service.getWsdlfile());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (wsdlURL == null) {
      try {
        wsdlURL=((Context)container).getServletContext().getResource("/" + service.getWsdlfile());
        logger.debug("  Changing service ref wsdl file for /" + service.getWsdlfile());
      }
 catch (      MalformedURLException e) {
        logger.error(sm.getString("naming.wsdlFailed",e));
      }
    }
    if (wsdlURL == null)     service.setWsdlfile(null);
 else     service.setWsdlfile(wsdlURL.toString());
  }
  if (service.getJaxrpcmappingfile() != null) {
    URL jaxrpcURL=null;
    try {
      jaxrpcURL=new URL(service.getJaxrpcmappingfile());
    }
 catch (    MalformedURLException e) {
    }
    if (jaxrpcURL == null) {
      try {
        jaxrpcURL=((Context)container).getServletContext().getResource(service.getJaxrpcmappingfile());
      }
 catch (      MalformedURLException e) {
      }
    }
    if (jaxrpcURL == null) {
      try {
        jaxrpcURL=((Context)container).getServletContext().getResource("/" + service.getJaxrpcmappingfile());
        logger.debug("  Changing service ref jaxrpc file for /" + service.getJaxrpcmappingfile());
      }
 catch (      MalformedURLException e) {
        logger.error(sm.getString("naming.wsdlFailed",e));
      }
    }
    if (jaxrpcURL == null)     service.setJaxrpcmappingfile(null);
 else     service.setJaxrpcmappingfile(jaxrpcURL.toString());
  }
  Reference ref=new ServiceRef(service.getName(),service.getType(),service.getServiceqname(),service.getWsdlfile(),service.getJaxrpcmappingfile());
  Iterator<String> portcomponent=service.getServiceendpoints();
  while (portcomponent.hasNext()) {
    String serviceendpoint=portcomponent.next();
    StringRefAddr refAddr=new StringRefAddr(ServiceRef.SERVICEENDPOINTINTERFACE,serviceendpoint);
    ref.add(refAddr);
    String portlink=service.getPortlink(serviceendpoint);
    refAddr=new StringRefAddr(ServiceRef.PORTCOMPONENTLINK,portlink);
    ref.add(refAddr);
  }
  Iterator<String> handlers=service.getHandlers();
  while (handlers.hasNext()) {
    String handlername=handlers.next();
    ContextHandler handler=service.getHandler(handlername);
    HandlerRef handlerRef=new HandlerRef(handlername,handler.getHandlerclass());
    Iterator<String> localParts=handler.getLocalparts();
    while (localParts.hasNext()) {
      String localPart=localParts.next();
      String namespaceURI=handler.getNamespaceuri(localPart);
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_LOCALPART,localPart));
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_NAMESPACE,namespaceURI));
    }
    Iterator<String> params=handler.listProperties();
    while (params.hasNext()) {
      String paramName=params.next();
      String paramValue=(String)handler.getProperty(paramName);
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PARAMNAME,paramName));
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PARAMVALUE,paramValue));
    }
    for (int i=0; i < handler.getSoapRolesSize(); i++) {
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_SOAPROLE,handler.getSoapRole(i)));
    }
    for (int i=0; i < handler.getPortNamesSize(); i++) {
      handlerRef.add(new StringRefAddr(HandlerRef.HANDLER_PORTNAME,handler.getPortName(i)));
    }
    ((ServiceRef)ref).addHandler(handlerRef);
  }
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("  Adding service ref " + service.getName() + "  "+ ref);
    }
    createSubcontexts(envCtx,service.getName());
    envCtx.bind(service.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
}

ID 664=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addResource(org.apache.catalina.deploy.ContextResource)
Rmethod: org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void addResource(ContextResource resource){
  Reference ref=new ResourceRef(resource.getType(),resource.getDescription(),resource.getScope(),resource.getAuth(),resource.getSingleton());
  Iterator<String> params=resource.listProperties();
  while (params.hasNext()) {
    String paramName=params.next();
    String paramValue=(String)resource.getProperty(paramName);
    StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
    ref.add(refAddr);
  }
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("  Adding resource ref " + resource.getName() + "  "+ ref);
    }
    createSubcontexts(envCtx,resource.getName());
    envCtx.bind(resource.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
  if ("javax.sql.DataSource".equals(ref.getClassName()) && resource.getSingleton()) {
    try {
      ObjectName on=createObjectName(resource);
      Object actualResource=envCtx.lookup(resource.getName());
      Registry.getRegistry(null,null).registerComponent(actualResource,on,null);
      objectNames.put(resource.getName(),on);
    }
 catch (    Exception e) {
      logger.warn(sm.getString("naming.jmxRegistrationFailed",e));
    }
  }
}

ID 665=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addResource(org.apache.catalina.deploy.ContextResource)
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void addResource(ContextResource resource){
  Reference ref=new ResourceRef(resource.getType(),resource.getDescription(),resource.getScope(),resource.getAuth(),resource.getSingleton());
  Iterator<String> params=resource.listProperties();
  while (params.hasNext()) {
    String paramName=params.next();
    String paramValue=(String)resource.getProperty(paramName);
    StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
    ref.add(refAddr);
  }
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("  Adding resource ref " + resource.getName() + "  "+ ref);
    }
    createSubcontexts(envCtx,resource.getName());
    envCtx.bind(resource.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
  if ("javax.sql.DataSource".equals(ref.getClassName()) && resource.getSingleton()) {
    try {
      ObjectName on=createObjectName(resource);
      Object actualResource=envCtx.lookup(resource.getName());
      Registry.getRegistry(null,null).registerComponent(actualResource,on,null);
      objectNames.put(resource.getName(),on);
    }
 catch (    Exception e) {
      logger.warn(sm.getString("naming.jmxRegistrationFailed",e));
    }
  }
}

ID 668=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addResource(org.apache.catalina.deploy.ContextResource)
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void addResource(ContextResource resource){
  Reference ref=new ResourceRef(resource.getType(),resource.getDescription(),resource.getScope(),resource.getAuth(),resource.getSingleton());
  Iterator<String> params=resource.listProperties();
  while (params.hasNext()) {
    String paramName=params.next();
    String paramValue=(String)resource.getProperty(paramName);
    StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
    ref.add(refAddr);
  }
  try {
    if (logger.isDebugEnabled()) {
      logger.debug("  Adding resource ref " + resource.getName() + "  "+ ref);
    }
    createSubcontexts(envCtx,resource.getName());
    envCtx.bind(resource.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
  if ("javax.sql.DataSource".equals(ref.getClassName()) && resource.getSingleton()) {
    try {
      ObjectName on=createObjectName(resource);
      Object actualResource=envCtx.lookup(resource.getName());
      Registry.getRegistry(null,null).registerComponent(actualResource,on,null);
      objectNames.put(resource.getName(),on);
    }
 catch (    Exception e) {
      logger.warn(sm.getString("naming.jmxRegistrationFailed",e));
    }
  }
}

ID 669=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addResourceEnvRef(org.apache.catalina.deploy.ContextResourceEnvRef)
Rmethod: org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void addResourceEnvRef(ContextResourceEnvRef resourceEnvRef){
  Reference ref=new ResourceEnvRef(resourceEnvRef.getType());
  Iterator<String> params=resourceEnvRef.listProperties();
  while (params.hasNext()) {
    String paramName=params.next();
    String paramValue=(String)resourceEnvRef.getProperty(paramName);
    StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
    ref.add(refAddr);
  }
  try {
    if (logger.isDebugEnabled())     log.debug("  Adding resource env ref " + resourceEnvRef.getName());
    createSubcontexts(envCtx,resourceEnvRef.getName());
    envCtx.bind(resourceEnvRef.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
}

ID 670=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addResourceEnvRef(org.apache.catalina.deploy.ContextResourceEnvRef)
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void addResourceEnvRef(ContextResourceEnvRef resourceEnvRef){
  Reference ref=new ResourceEnvRef(resourceEnvRef.getType());
  Iterator<String> params=resourceEnvRef.listProperties();
  while (params.hasNext()) {
    String paramName=params.next();
    String paramValue=(String)resourceEnvRef.getProperty(paramName);
    StringRefAddr refAddr=new StringRefAddr(paramName,paramValue);
    ref.add(refAddr);
  }
  try {
    if (logger.isDebugEnabled())     log.debug("  Adding resource env ref " + resourceEnvRef.getName());
    createSubcontexts(envCtx,resourceEnvRef.getName());
    envCtx.bind(resourceEnvRef.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
}

ID 671=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addResourceLink(org.apache.catalina.deploy.ContextResourceLink)
Rmethod: org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resource link in the naming context.
 */
public void addResourceLink(ContextResourceLink resourceLink){
  Reference ref=new ResourceLinkRef(resourceLink.getType(),resourceLink.getGlobal(),resourceLink.getFactory(),null);
  Iterator<String> i=resourceLink.listProperties();
  while (i.hasNext()) {
    String key=i.next();
    Object val=resourceLink.getProperty(key);
    if (val != null) {
      StringRefAddr refAddr=new StringRefAddr(key,val.toString());
      ref.add(refAddr);
    }
  }
  javax.naming.Context ctx="UserTransaction".equals(resourceLink.getName()) ? compCtx : envCtx;
  try {
    if (logger.isDebugEnabled())     log.debug("  Adding resource link " + resourceLink.getName());
    createSubcontexts(envCtx,resourceLink.getName());
    ctx.bind(resourceLink.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
  ResourceLinkFactory.registerGlobalResourceAccess(getGlobalNamingContext(),resourceLink.getName(),resourceLink.getGlobal());
}

ID 672=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#addResourceLink(org.apache.catalina.deploy.ContextResourceLink)
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resource link in the naming context.
 */
public void addResourceLink(ContextResourceLink resourceLink){
  Reference ref=new ResourceLinkRef(resourceLink.getType(),resourceLink.getGlobal(),resourceLink.getFactory(),null);
  Iterator<String> i=resourceLink.listProperties();
  while (i.hasNext()) {
    String key=i.next();
    Object val=resourceLink.getProperty(key);
    if (val != null) {
      StringRefAddr refAddr=new StringRefAddr(key,val.toString());
      ref.add(refAddr);
    }
  }
  javax.naming.Context ctx="UserTransaction".equals(resourceLink.getName()) ? compCtx : envCtx;
  try {
    if (logger.isDebugEnabled())     log.debug("  Adding resource link " + resourceLink.getName());
    createSubcontexts(envCtx,resourceLink.getName());
    ctx.bind(resourceLink.getName(),ref);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.bindFailed",e));
  }
  ResourceLinkFactory.registerGlobalResourceAccess(getGlobalNamingContext(),resourceLink.getName(),resourceLink.getGlobal());
}

ID 673=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#removeEjb(java.lang.String)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified EJBs in the naming context.
 */
public void removeEjb(String name){
  try {
    envCtx.unbind(name);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.unbindFailed",e));
  }
}

ID 674=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#removeEnvironment(java.lang.String)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified environment entries in the naming context.
 */
public void removeEnvironment(String name){
  try {
    envCtx.unbind(name);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.unbindFailed",e));
  }
}

ID 675=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#removeLocalEjb(java.lang.String)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified local EJBs in the naming context.
 */
public void removeLocalEjb(String name){
  try {
    envCtx.unbind(name);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.unbindFailed",e));
  }
}

ID 676=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#removeService(java.lang.String)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified web services in the naming context.
 */
public void removeService(String name){
  try {
    envCtx.unbind(name);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.unbindFailed",e));
  }
}

ID 677=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#removeResource(java.lang.String)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void removeResource(String name){
  try {
    envCtx.unbind(name);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.unbindFailed",e));
  }
  ObjectName on=objectNames.get(name);
  if (on != null) {
    Registry.getRegistry(null,null).unregisterComponent(on);
  }
}

ID 678=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#removeResourceEnvRef(java.lang.String)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void removeResourceEnvRef(String name){
  try {
    envCtx.unbind(name);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.unbindFailed",e));
  }
}

ID 679=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#removeResourceLink(java.lang.String)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the specified resources in the naming context.
 */
public void removeResourceLink(String name){
  try {
    envCtx.unbind(name);
  }
 catch (  NamingException e) {
    logger.error(sm.getString("naming.unbindFailed",e));
  }
  ResourceLinkFactory.deregisterGlobalResourceAccess(getGlobalNamingContext(),name);
}

ID 680=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
Rmethod: javax.naming.Context#createSubcontext(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Create all intermediate subcontexts.
 */
private void createSubcontexts(javax.naming.Context ctx,String name) throws NamingException {
  javax.naming.Context currentContext=ctx;
  StringTokenizer tokenizer=new StringTokenizer(name,"/");
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    if ((!token.equals("")) && (tokenizer.hasMoreTokens())) {
      try {
        currentContext=currentContext.createSubcontext(token);
      }
 catch (      NamingException e) {
        currentContext=(javax.naming.Context)currentContext.lookup(token);
      }
    }
  }
}

ID 681=========================================================================type: 1
Method:org.apache.catalina.core.NamingContextListener#createSubcontexts(javax.naming.Context, java.lang.String)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Create all intermediate subcontexts.
 */
private void createSubcontexts(javax.naming.Context ctx,String name) throws NamingException {
  javax.naming.Context currentContext=ctx;
  StringTokenizer tokenizer=new StringTokenizer(name,"/");
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    if ((!token.equals("")) && (tokenizer.hasMoreTokens())) {
      try {
        currentContext=currentContext.createSubcontext(token);
      }
 catch (      NamingException e) {
        currentContext=(javax.naming.Context)currentContext.lookup(token);
      }
    }
  }
}

ID 704=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterConfig#registerJMX()
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
private void registerJMX(){
  String parentName=context.getName();
  if (!parentName.startsWith("/")) {
    parentName="/" + parentName;
  }
  String hostName=context.getParent().getName();
  hostName=(hostName == null) ? "DEFAULT" : hostName;
  String domain=context.getParent().getParent().getName();
  String webMod="//" + hostName + parentName;
  String onameStr=null;
  String filterName=filterDef.getFilterName();
  if (Util.objectNameValueNeedsQuote(filterName)) {
    filterName=ObjectName.quote(filterName);
  }
  if (context instanceof StandardContext) {
    StandardContext standardContext=(StandardContext)context;
    onameStr=domain + ":j2eeType=Filter,name=" + filterName+ ",WebModule="+ webMod+ ",J2EEApplication="+ standardContext.getJ2EEApplication()+ ",J2EEServer="+ standardContext.getJ2EEServer();
  }
 else {
    onameStr=domain + ":j2eeType=Filter,name=" + filterName+ ",WebModule="+ webMod;
  }
  try {
    oname=new ObjectName(onameStr);
    Registry.getRegistry(null,null).registerComponent(this,oname,null);
  }
 catch (  Exception ex) {
    log.info(sm.getString("applicationFilterConfig.jmxRegisterFail",getFilterClass(),getFilterName()),ex);
  }
}

ID 712=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#setNamingResources(org.apache.catalina.deploy.NamingResources)
Rmethod: org.apache.catalina.util.LifecycleBase#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the naming resources for this web application.
 * @param namingResources The new naming resources
 */
@Override public void setNamingResources(NamingResources namingResources){
  NamingResources oldNamingResources=this.namingResources;
  this.namingResources=namingResources;
  if (namingResources != null) {
    namingResources.setContainer(this);
  }
  support.firePropertyChange("namingResources",oldNamingResources,this.namingResources);
  if (getState() == LifecycleState.NEW || getState() == LifecycleState.INITIALIZING || getState() == LifecycleState.INITIALIZED) {
    return;
  }
  if (oldNamingResources != null) {
    try {
      oldNamingResources.stop();
      oldNamingResources.destroy();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.destroy.fail",e);
    }
  }
  if (namingResources != null) {
    try {
      namingResources.init();
      namingResources.start();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.init.fail",e);
    }
  }
}

ID 713=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#setNamingResources(org.apache.catalina.deploy.NamingResources)
Rmethod: org.apache.catalina.util.LifecycleBase#destroy()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the naming resources for this web application.
 * @param namingResources The new naming resources
 */
@Override public void setNamingResources(NamingResources namingResources){
  NamingResources oldNamingResources=this.namingResources;
  this.namingResources=namingResources;
  if (namingResources != null) {
    namingResources.setContainer(this);
  }
  support.firePropertyChange("namingResources",oldNamingResources,this.namingResources);
  if (getState() == LifecycleState.NEW || getState() == LifecycleState.INITIALIZING || getState() == LifecycleState.INITIALIZED) {
    return;
  }
  if (oldNamingResources != null) {
    try {
      oldNamingResources.stop();
      oldNamingResources.destroy();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.destroy.fail",e);
    }
  }
  if (namingResources != null) {
    try {
      namingResources.init();
      namingResources.start();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.init.fail",e);
    }
  }
}

ID 714=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#setNamingResources(org.apache.catalina.deploy.NamingResources)
Rmethod: org.apache.catalina.util.LifecycleBase#init()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the naming resources for this web application.
 * @param namingResources The new naming resources
 */
@Override public void setNamingResources(NamingResources namingResources){
  NamingResources oldNamingResources=this.namingResources;
  this.namingResources=namingResources;
  if (namingResources != null) {
    namingResources.setContainer(this);
  }
  support.firePropertyChange("namingResources",oldNamingResources,this.namingResources);
  if (getState() == LifecycleState.NEW || getState() == LifecycleState.INITIALIZING || getState() == LifecycleState.INITIALIZED) {
    return;
  }
  if (oldNamingResources != null) {
    try {
      oldNamingResources.stop();
      oldNamingResources.destroy();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.destroy.fail",e);
    }
  }
  if (namingResources != null) {
    try {
      namingResources.init();
      namingResources.start();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.init.fail",e);
    }
  }
}

ID 715=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#setNamingResources(org.apache.catalina.deploy.NamingResources)
Rmethod: org.apache.catalina.util.LifecycleBase#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the naming resources for this web application.
 * @param namingResources The new naming resources
 */
@Override public void setNamingResources(NamingResources namingResources){
  NamingResources oldNamingResources=this.namingResources;
  this.namingResources=namingResources;
  if (namingResources != null) {
    namingResources.setContainer(this);
  }
  support.firePropertyChange("namingResources",oldNamingResources,this.namingResources);
  if (getState() == LifecycleState.NEW || getState() == LifecycleState.INITIALIZING || getState() == LifecycleState.INITIALIZED) {
    return;
  }
  if (oldNamingResources != null) {
    try {
      oldNamingResources.stop();
      oldNamingResources.destroy();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.destroy.fail",e);
    }
  }
  if (namingResources != null) {
    try {
      namingResources.init();
      namingResources.start();
    }
 catch (    LifecycleException e) {
      log.warn("standardContext.namingResource.init.fail",e);
    }
  }
}

ID 716=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#setWrapperClass(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the Java class name of the Wrapper implementation used for servlets registered in this Context.
 * @param wrapperClassName The new wrapper class name
 * @throws IllegalArgumentException if the specified wrapper classcannot be found or is not a subclass of StandardWrapper
 */
@Override public void setWrapperClass(String wrapperClassName){
  this.wrapperClassName=wrapperClassName;
  try {
    wrapperClass=Class.forName(wrapperClassName);
    if (!StandardWrapper.class.isAssignableFrom(wrapperClass)) {
      throw new IllegalArgumentException(sm.getString("standardContext.invalidWrapperClass",wrapperClassName));
    }
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IllegalArgumentException(cnfe.getMessage());
  }
}

ID 717=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#getWorkPath()
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Get the absolute path to the work dir. To avoid duplication.
 * @return The work path
 */
public String getWorkPath(){
  if (getWorkDir() == null) {
    return null;
  }
  File workDir=new File(getWorkDir());
  if (!workDir.isAbsolute()) {
    File catalinaHome=engineBase();
    String catalinaHomePath=null;
    try {
      catalinaHomePath=catalinaHome.getCanonicalPath();
      workDir=new File(catalinaHomePath,getWorkDir());
    }
 catch (    IOException e) {
      log.warn(sm.getString("standardContext.workPath",getName()),e);
    }
  }
  return workDir.getAbsolutePath();
}

ID 723=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#reload()
Rmethod: org.apache.catalina.util.LifecycleBase#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Reload this web application, if reloading is supported. <p> <b>IMPLEMENTATION NOTE</b>:  This method is designed to deal with reloads required by changes to classes in the underlying repositories of our class loader and changes to the web.xml file. It does not handle changes to any context.xml file. If the context.xml has changed, you should stop this Context and create (and start) a new Context instance instead. Note that there is additional code in <code>CoyoteAdapter#postParseRequest()</code> to handle mapping requests to paused Contexts.
 * @exception IllegalStateException if the <code>reloadable</code>property is set to <code>false</code>.
 */
@Override public synchronized void reload(){
  if (!getState().isAvailable())   throw new IllegalStateException(sm.getString("standardContext.notStarted",getName()));
  if (log.isInfoEnabled())   log.info(sm.getString("standardContext.reloadingStarted",getName()));
  setPaused(true);
  try {
    stop();
  }
 catch (  LifecycleException e) {
    log.error(sm.getString("standardContext.stoppingContext",getName()),e);
  }
  try {
    start();
  }
 catch (  LifecycleException e) {
    log.error(sm.getString("standardContext.startingContext",getName()),e);
  }
  setPaused(false);
  if (log.isInfoEnabled())   log.info(sm.getString("standardContext.reloadingCompleted",getName()));
}

ID 724=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#reload()
Rmethod: org.apache.catalina.util.LifecycleBase#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Reload this web application, if reloading is supported. <p> <b>IMPLEMENTATION NOTE</b>:  This method is designed to deal with reloads required by changes to classes in the underlying repositories of our class loader and changes to the web.xml file. It does not handle changes to any context.xml file. If the context.xml has changed, you should stop this Context and create (and start) a new Context instance instead. Note that there is additional code in <code>CoyoteAdapter#postParseRequest()</code> to handle mapping requests to paused Contexts.
 * @exception IllegalStateException if the <code>reloadable</code>property is set to <code>false</code>.
 */
@Override public synchronized void reload(){
  if (!getState().isAvailable())   throw new IllegalStateException(sm.getString("standardContext.notStarted",getName()));
  if (log.isInfoEnabled())   log.info(sm.getString("standardContext.reloadingStarted",getName()));
  setPaused(true);
  try {
    stop();
  }
 catch (  LifecycleException e) {
    log.error(sm.getString("standardContext.stoppingContext",getName()),e);
  }
  try {
    start();
  }
 catch (  LifecycleException e) {
    log.error(sm.getString("standardContext.startingContext",getName()),e);
  }
  setPaused(false);
  if (log.isInfoEnabled())   log.info(sm.getString("standardContext.reloadingCompleted",getName()));
}

ID 741=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#resourcesStart()
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Allocate resources, including proxy. Return <code>true</code> if initialization was successfull, or <code>false</code> otherwise.
 */
public boolean resourcesStart(){
  boolean ok=true;
  Hashtable<String,String> env=new Hashtable<String,String>();
  if (getParent() != null)   env.put(ProxyDirContext.HOST,getParent().getName());
  env.put(ProxyDirContext.CONTEXT,getName());
  try {
    ProxyDirContext proxyDirContext=new ProxyDirContext(env,webappResources);
    if (webappResources instanceof FileDirContext) {
      filesystemBased=true;
      ((FileDirContext)webappResources).setAllowLinking(isAllowLinking());
    }
    if (webappResources instanceof BaseDirContext) {
      ((BaseDirContext)webappResources).setDocBase(getBasePath());
      ((BaseDirContext)webappResources).setCached(isCachingAllowed());
      ((BaseDirContext)webappResources).setCacheTTL(getCacheTTL());
      ((BaseDirContext)webappResources).setCacheMaxSize(getCacheMaxSize());
      ((BaseDirContext)webappResources).allocate();
      ((BaseDirContext)webappResources).setAliases(getAliases());
      if (effectiveMajorVersion >= 3 && addWebinfClassesResources) {
        try {
          DirContext webInfCtx=(DirContext)webappResources.lookup("/WEB-INF/classes");
          webInfCtx.lookup("META-INF/resources");
          ((BaseDirContext)webappResources).addAltDirContext(webInfCtx);
        }
 catch (        NamingException e) {
        }
      }
    }
    if (isCachingAllowed() && proxyDirContext.getCache() != null) {
      String contextName=getName();
      if (!contextName.startsWith("/")) {
        contextName="/" + contextName;
      }
      ObjectName resourcesName=new ObjectName(this.getDomain() + ":type=Cache,host=" + getHostname()+ ",context="+ contextName);
      Registry.getRegistry(null,null).registerComponent(proxyDirContext.getCache(),resourcesName,null);
    }
    this.resources=proxyDirContext;
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log.error(sm.getString("standardContext.resourcesStart"),t);
    ok=false;
  }
  return (ok);
}

ID 744=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#loadOnStartup(org.apache.catalina.Container[])
Rmethod: org.apache.catalina.Wrapper#load()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Load and initialize all servlets marked "load on startup" in the web application deployment descriptor.
 * @param children Array of wrappers for all currently definedservlets (including those not declared load on startup) web.xml -Mn servlet StandardWrapper   
 */
public boolean loadOnStartup(Container children[]){
  TreeMap<Integer,ArrayList<Wrapper>> map=new TreeMap<Integer,ArrayList<Wrapper>>();
  for (int i=0; i < children.length; i++) {
    Wrapper wrapper=(Wrapper)children[i];
    int loadOnStartup=wrapper.getLoadOnStartup();
    if (loadOnStartup < 0)     continue;
    Integer key=Integer.valueOf(loadOnStartup);
    ArrayList<Wrapper> list=map.get(key);
    if (list == null) {
      list=new ArrayList<Wrapper>();
      map.put(key,list);
    }
    list.add(wrapper);
  }
  for (  ArrayList<Wrapper> list : map.values()) {
    for (    Wrapper wrapper : list) {
      try {
        wrapper.load();
      }
 catch (      ServletException e) {
        getLogger().error(sm.getString("standardContext.loadOnStartup.loadException",getName(),wrapper.getName()),StandardWrapper.getRootCause(e));
        if (getComputedFailCtxIfServletStartFails()) {
          return false;
        }
      }
    }
  }
  return true;
}

ID 746=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#startInternal()
Rmethod: org.apache.catalina.util.ExtensionValidator#validateApplication(javax.naming.directory.DirContext, org.apache.catalina.Context)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Start this component and implement the requirements of  {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used ;q
 */
@Override protected synchronized void startInternal() throws LifecycleException {
  if (log.isDebugEnabled())   log.debug("Starting " + getBaseName());
  if (this.getObjectName() != null) {
    Notification notification=new Notification("j2ee.state.starting",this.getObjectName(),sequenceNumber.getAndIncrement());
    broadcaster.sendNotification(notification);
  }
  setConfigured(false);
  boolean ok=true;
  if (namingResources != null) {
    namingResources.start();
  }
  if (webappResources == null) {
    if (log.isDebugEnabled())     log.debug("Configuring default Resources");
    try {
      String docBase=getDocBase();
      if (docBase == null) {
        setResources(new EmptyDirContext());
      }
 else       if (docBase.endsWith(".war") && !(new File(getBasePath())).isDirectory()) {
        setResources(new WARDirContext());
      }
 else {
        setResources(new FileDirContext());
      }
    }
 catch (    IllegalArgumentException e) {
      log.error(sm.getString("standardContext.resourcesInit"),e);
      ok=false;
    }
  }
  if (ok) {
    if (!resourcesStart()) {
      throw new LifecycleException("Error in resourceStart()");
    }
  }
  if (getLoader() == null) {
    WebappLoader webappLoader=new WebappLoader(getParentClassLoader());
    webappLoader.setDelegate(getDelegate());
    setLoader(webappLoader);
  }
  getCharsetMapper();
  postWorkDirectory();
  boolean dependencyCheck=true;
  try {
    dependencyCheck=ExtensionValidator.validateApplication(getResources(),this);
  }
 catch (  IOException ioe) {
    log.error(sm.getString("standardContext.extensionValidationError"),ioe);
    dependencyCheck=false;
  }
  if (!dependencyCheck) {
    ok=false;
  }
  String useNamingProperty=System.getProperty("catalina.useNaming");
  if ((useNamingProperty != null) && (useNamingProperty.equals("false"))) {
    useNaming=false;
  }
  if (ok && isUseNaming()) {
    if (getNamingContextListener() == null) {
      NamingContextListener ncl=new NamingContextListener();
      ncl.setName(getNamingContextName());
      ncl.setExceptionOnFailedWrite(getJndiExceptionOnFailedWrite());
      addLifecycleListener(ncl);
      setNamingContextListener(ncl);
    }
  }
  if (log.isDebugEnabled())   log.debug("Processing standard container startup");
  ClassLoader oldCCL=bindThread();
  try {
    if (ok) {
      if ((loader != null) && (loader instanceof Lifecycle))       ((Lifecycle)loader).start();
      unbindThread(oldCCL);
      oldCCL=bindThread();
      logger=null;
      getLogger();
      if ((cluster != null) && (cluster instanceof Lifecycle))       ((Lifecycle)cluster).start();
      Realm realm=getRealmInternal();
      if ((realm != null) && (realm instanceof Lifecycle))       ((Lifecycle)realm).start();
      if ((resources != null) && (resources instanceof Lifecycle))       ((Lifecycle)resources).start();
      fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT,null);
      for (      Container child : findChildren()) {
        if (!child.getState().isAvailable()) {
          child.start();
        }
      }
      if (pipeline instanceof Lifecycle) {
        ((Lifecycle)pipeline).start();
      }
      Manager contextManager=null;
      if (manager == null) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("standardContext.cluster.noManager",Boolean.valueOf((getCluster() != null)),Boolean.valueOf(distributable)));
        }
        if ((getCluster() != null) && distributable) {
          try {
            contextManager=getCluster().createManager(getName());
          }
 catch (          Exception ex) {
            log.error("standardContext.clusterFail",ex);
            ok=false;
          }
        }
 else {
          contextManager=new StandardManager();
        }
      }
      if (contextManager != null) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("standardContext.manager",contextManager.getClass().getName()));
        }
        setManager(contextManager);
      }
      if (manager != null && (getCluster() != null) && distributable) {
        getCluster().registerManager(manager);
      }
    }
  }
  finally {
    unbindThread(oldCCL);
  }
  if (!getConfigured()) {
    log.error(sm.getString("standardContext.configurationFail"));
    ok=false;
  }
  if (ok)   getServletContext().setAttribute(Globals.RESOURCES_ATTR,getResources());
  mapper.setContext(getPath(),welcomeFiles,resources);
  oldCCL=bindThread();
  if (ok) {
    if (getInstanceManager() == null) {
      javax.naming.Context context=null;
      if (isUseNaming() && getNamingContextListener() != null) {
        context=getNamingContextListener().getEnvContext();
      }
      Map<String,Map<String,String>> injectionMap=buildInjectionMap(getIgnoreAnnotations() ? new NamingResources() : getNamingResources());
      setInstanceManager(new DefaultInstanceManager(context,injectionMap,this,this.getClass().getClassLoader()));
      getServletContext().setAttribute(InstanceManager.class.getName(),getInstanceManager());
    }
  }
  try {
    if (ok) {
      getServletContext().setAttribute(JarScanner.class.getName(),getJarScanner());
    }
    mergeParameters();
    for (    Map.Entry<ServletContainerInitializer,Set<Class<?>>> entry : initializers.entrySet()) {
      try {
        entry.getKey().onStartup(entry.getValue(),getServletContext());
      }
 catch (      ServletException e) {
        log.error(sm.getString("standardContext.sciFail"),e);
        ok=false;
        break;
      }
    }
    if (ok) {
      if (!listenerStart()) {
        log.error(sm.getString("standardContext.listenerFail"));
        ok=false;
      }
    }
    try {
      if ((manager != null) && (manager instanceof Lifecycle)) {
        ((Lifecycle)getManager()).start();
      }
    }
 catch (    Exception e) {
      log.error(sm.getString("standardContext.managerFail"),e);
      ok=false;
    }
    if (ok) {
      if (!filterStart()) {
        log.error(sm.getString("standardContext.filterFail"));
        ok=false;
      }
    }
    if (ok) {
      if (!loadOnStartup(findChildren())) {
        log.error(sm.getString("standardContext.servletFail"));
        ok=false;
      }
    }
    super.threadStart();
  }
  finally {
    unbindThread(oldCCL);
  }
  if (ok) {
    if (log.isDebugEnabled())     log.debug("Starting completed");
  }
 else {
    log.error(sm.getString("standardContext.startFailed",getName()));
  }
  startTime=System.currentTimeMillis();
  if (ok && (this.getObjectName() != null)) {
    Notification notification=new Notification("j2ee.state.running",this.getObjectName(),sequenceNumber.getAndIncrement());
    broadcaster.sendNotification(notification);
  }
  if (getLoader() instanceof WebappLoader) {
    ((WebappLoader)getLoader()).closeJARs(true);
  }
  if (!ok) {
    setState(LifecycleState.FAILED);
  }
 else {
    setState(LifecycleState.STARTING);
  }
}

ID 748=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#startInternal()
Rmethod: javax.servlet.ServletContainerInitializer#onStartup(Set<Class<?>>, javax.servlet.ServletContext)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Start this component and implement the requirements of  {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used ;q
 */
@Override protected synchronized void startInternal() throws LifecycleException {
  if (log.isDebugEnabled())   log.debug("Starting " + getBaseName());
  if (this.getObjectName() != null) {
    Notification notification=new Notification("j2ee.state.starting",this.getObjectName(),sequenceNumber.getAndIncrement());
    broadcaster.sendNotification(notification);
  }
  setConfigured(false);
  boolean ok=true;
  if (namingResources != null) {
    namingResources.start();
  }
  if (webappResources == null) {
    if (log.isDebugEnabled())     log.debug("Configuring default Resources");
    try {
      String docBase=getDocBase();
      if (docBase == null) {
        setResources(new EmptyDirContext());
      }
 else       if (docBase.endsWith(".war") && !(new File(getBasePath())).isDirectory()) {
        setResources(new WARDirContext());
      }
 else {
        setResources(new FileDirContext());
      }
    }
 catch (    IllegalArgumentException e) {
      log.error(sm.getString("standardContext.resourcesInit"),e);
      ok=false;
    }
  }
  if (ok) {
    if (!resourcesStart()) {
      throw new LifecycleException("Error in resourceStart()");
    }
  }
  if (getLoader() == null) {
    WebappLoader webappLoader=new WebappLoader(getParentClassLoader());
    webappLoader.setDelegate(getDelegate());
    setLoader(webappLoader);
  }
  getCharsetMapper();
  postWorkDirectory();
  boolean dependencyCheck=true;
  try {
    dependencyCheck=ExtensionValidator.validateApplication(getResources(),this);
  }
 catch (  IOException ioe) {
    log.error(sm.getString("standardContext.extensionValidationError"),ioe);
    dependencyCheck=false;
  }
  if (!dependencyCheck) {
    ok=false;
  }
  String useNamingProperty=System.getProperty("catalina.useNaming");
  if ((useNamingProperty != null) && (useNamingProperty.equals("false"))) {
    useNaming=false;
  }
  if (ok && isUseNaming()) {
    if (getNamingContextListener() == null) {
      NamingContextListener ncl=new NamingContextListener();
      ncl.setName(getNamingContextName());
      ncl.setExceptionOnFailedWrite(getJndiExceptionOnFailedWrite());
      addLifecycleListener(ncl);
      setNamingContextListener(ncl);
    }
  }
  if (log.isDebugEnabled())   log.debug("Processing standard container startup");
  ClassLoader oldCCL=bindThread();
  try {
    if (ok) {
      if ((loader != null) && (loader instanceof Lifecycle))       ((Lifecycle)loader).start();
      unbindThread(oldCCL);
      oldCCL=bindThread();
      logger=null;
      getLogger();
      if ((cluster != null) && (cluster instanceof Lifecycle))       ((Lifecycle)cluster).start();
      Realm realm=getRealmInternal();
      if ((realm != null) && (realm instanceof Lifecycle))       ((Lifecycle)realm).start();
      if ((resources != null) && (resources instanceof Lifecycle))       ((Lifecycle)resources).start();
      fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT,null);
      for (      Container child : findChildren()) {
        if (!child.getState().isAvailable()) {
          child.start();
        }
      }
      if (pipeline instanceof Lifecycle) {
        ((Lifecycle)pipeline).start();
      }
      Manager contextManager=null;
      if (manager == null) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("standardContext.cluster.noManager",Boolean.valueOf((getCluster() != null)),Boolean.valueOf(distributable)));
        }
        if ((getCluster() != null) && distributable) {
          try {
            contextManager=getCluster().createManager(getName());
          }
 catch (          Exception ex) {
            log.error("standardContext.clusterFail",ex);
            ok=false;
          }
        }
 else {
          contextManager=new StandardManager();
        }
      }
      if (contextManager != null) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("standardContext.manager",contextManager.getClass().getName()));
        }
        setManager(contextManager);
      }
      if (manager != null && (getCluster() != null) && distributable) {
        getCluster().registerManager(manager);
      }
    }
  }
  finally {
    unbindThread(oldCCL);
  }
  if (!getConfigured()) {
    log.error(sm.getString("standardContext.configurationFail"));
    ok=false;
  }
  if (ok)   getServletContext().setAttribute(Globals.RESOURCES_ATTR,getResources());
  mapper.setContext(getPath(),welcomeFiles,resources);
  oldCCL=bindThread();
  if (ok) {
    if (getInstanceManager() == null) {
      javax.naming.Context context=null;
      if (isUseNaming() && getNamingContextListener() != null) {
        context=getNamingContextListener().getEnvContext();
      }
      Map<String,Map<String,String>> injectionMap=buildInjectionMap(getIgnoreAnnotations() ? new NamingResources() : getNamingResources());
      setInstanceManager(new DefaultInstanceManager(context,injectionMap,this,this.getClass().getClassLoader()));
      getServletContext().setAttribute(InstanceManager.class.getName(),getInstanceManager());
    }
  }
  try {
    if (ok) {
      getServletContext().setAttribute(JarScanner.class.getName(),getJarScanner());
    }
    mergeParameters();
    for (    Map.Entry<ServletContainerInitializer,Set<Class<?>>> entry : initializers.entrySet()) {
      try {
        entry.getKey().onStartup(entry.getValue(),getServletContext());
      }
 catch (      ServletException e) {
        log.error(sm.getString("standardContext.sciFail"),e);
        ok=false;
        break;
      }
    }
    if (ok) {
      if (!listenerStart()) {
        log.error(sm.getString("standardContext.listenerFail"));
        ok=false;
      }
    }
    try {
      if ((manager != null) && (manager instanceof Lifecycle)) {
        ((Lifecycle)getManager()).start();
      }
    }
 catch (    Exception e) {
      log.error(sm.getString("standardContext.managerFail"),e);
      ok=false;
    }
    if (ok) {
      if (!filterStart()) {
        log.error(sm.getString("standardContext.filterFail"));
        ok=false;
      }
    }
    if (ok) {
      if (!loadOnStartup(findChildren())) {
        log.error(sm.getString("standardContext.servletFail"));
        ok=false;
      }
    }
    super.threadStart();
  }
  finally {
    unbindThread(oldCCL);
  }
  if (ok) {
    if (log.isDebugEnabled())     log.debug("Starting completed");
  }
 else {
    log.error(sm.getString("standardContext.startFailed",getName()));
  }
  startTime=System.currentTimeMillis();
  if (ok && (this.getObjectName() != null)) {
    Notification notification=new Notification("j2ee.state.running",this.getObjectName(),sequenceNumber.getAndIncrement());
    broadcaster.sendNotification(notification);
  }
  if (getLoader() instanceof WebappLoader) {
    ((WebappLoader)getLoader()).closeJARs(true);
  }
  if (!ok) {
    setState(LifecycleState.FAILED);
  }
 else {
    setState(LifecycleState.STARTING);
  }
}

ID 754=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#stopInternal()
Rmethod: org.apache.catalina.core.StandardContext#resetContext()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Stop this component and implement the requirements of  {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected synchronized void stopInternal() throws LifecycleException {
  if (this.getObjectName() != null) {
    Notification notification=new Notification("j2ee.state.stopping",this.getObjectName(),sequenceNumber.getAndIncrement());
    broadcaster.sendNotification(notification);
  }
  setState(LifecycleState.STOPPING);
  ClassLoader oldCCL=bindThread();
  try {
    final Container[] children=findChildren();
    ClassLoader old=bindThread();
    try {
      threadStop();
      for (int i=0; i < children.length; i++) {
        children[i].stop();
      }
      filterStop();
      if (manager != null && manager instanceof Lifecycle && ((Lifecycle)manager).getState().isAvailable()) {
        ((Lifecycle)manager).stop();
      }
      listenerStop();
    }
  finally {
      unbindThread(old);
    }
    setCharsetMapper(null);
    if (log.isDebugEnabled())     log.debug("Processing standard container shutdown");
    if (namingResources != null) {
      namingResources.stop();
    }
    fireLifecycleEvent(Lifecycle.CONFIGURE_STOP_EVENT,null);
    if (pipeline instanceof Lifecycle && ((Lifecycle)pipeline).getState().isAvailable()) {
      ((Lifecycle)pipeline).stop();
    }
    if (context != null)     context.clearAttributes();
    resourcesStop();
    Realm realm=getRealmInternal();
    if ((realm != null) && (realm instanceof Lifecycle)) {
      ((Lifecycle)realm).stop();
    }
    if ((cluster != null) && (cluster instanceof Lifecycle)) {
      ((Lifecycle)cluster).stop();
    }
    if ((loader != null) && (loader instanceof Lifecycle)) {
      ((Lifecycle)loader).stop();
    }
  }
  finally {
    unbindThread(oldCCL);
  }
  if (this.getObjectName() != null) {
    Notification notification=new Notification("j2ee.state.stopped",this.getObjectName(),sequenceNumber.getAndIncrement());
    broadcaster.sendNotification(notification);
  }
  context=null;
  try {
    resetContext();
  }
 catch (  Exception ex) {
    log.error("Error reseting context " + this + " "+ ex,ex);
  }
  setInstanceManager(null);
  if (log.isDebugEnabled())   log.debug("Stopping complete");
}

ID 757=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#postWorkDirectory()
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Set the appropriate context attribute for our work directory.
 */
private void postWorkDirectory(){
  String workDir=getWorkDir();
  if (workDir == null || workDir.length() == 0) {
    String hostName=null;
    String engineName=null;
    String hostWorkDir=null;
    Container parentHost=getParent();
    if (parentHost != null) {
      hostName=parentHost.getName();
      if (parentHost instanceof StandardHost) {
        hostWorkDir=((StandardHost)parentHost).getWorkDir();
      }
      Container parentEngine=parentHost.getParent();
      if (parentEngine != null) {
        engineName=parentEngine.getName();
      }
    }
    if ((hostName == null) || (hostName.length() < 1))     hostName="_";
    if ((engineName == null) || (engineName.length() < 1))     engineName="_";
    String temp=getName();
    if (temp.startsWith("/"))     temp=temp.substring(1);
    temp=temp.replace('/','_');
    temp=temp.replace('\\','_');
    if (temp.length() < 1)     temp="_";
    if (hostWorkDir != null) {
      workDir=hostWorkDir + File.separator + temp;
    }
 else {
      workDir="work" + File.separator + engineName+ File.separator+ hostName+ File.separator+ temp;
    }
    setWorkDir(workDir);
  }
  File dir=new File(workDir);
  if (!dir.isAbsolute()) {
    File catalinaHome=engineBase();
    String catalinaHomePath=null;
    try {
      catalinaHomePath=catalinaHome.getCanonicalPath();
      dir=new File(catalinaHomePath,workDir);
    }
 catch (    IOException e) {
      log.warn(sm.getString("standardContext.workCreateException",workDir,catalinaHomePath,getName()),e);
    }
  }
  if (!dir.mkdirs() && !dir.isDirectory()) {
    log.warn(sm.getString("standardContext.workCreateFail",dir,getName()));
  }
  if (context == null) {
    getServletContext();
  }
  context.setAttribute(ServletContext.TEMPDIR,dir);
  context.setAttributeReadOnly(ServletContext.TEMPDIR);
}

ID 758=========================================================================type: 1
Method:org.apache.catalina.core.StandardContext#getDeploymentDescriptor()
Rmethod: java.io.BufferedReader#readLine()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * JSR77 deploymentDescriptor attribute
 * @return string deployment descriptor 
 */
public String getDeploymentDescriptor(){
  InputStream stream=null;
  ServletContext servletContext=getServletContext();
  if (servletContext != null) {
    stream=servletContext.getResourceAsStream(org.apache.catalina.startup.Constants.ApplicationWebXml);
  }
  if (stream == null) {
    return "";
  }
  StringBuilder sb=new StringBuilder();
  BufferedReader br=null;
  try {
    br=new BufferedReader(new InputStreamReader(stream));
    String strRead="";
    while (strRead != null) {
      sb.append(strRead);
      strRead=br.readLine();
    }
  }
 catch (  IOException e) {
    return "";
  }
 finally {
    if (br != null) {
      try {
        br.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
  return sb.toString();
}

ID 770=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationPart#write(java.lang.String)
Rmethod: org.apache.tomcat.util.http.fileupload.FileItem#write(java.io.File)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void write(String fileName) throws IOException {
  File file=new File(fileName);
  if (!file.isAbsolute()) {
    file=new File(location,fileName);
  }
  try {
    fileItem.write(file);
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}

ID 772=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapper#setLoadOnStartupString(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the load-on-startup order value from a (possibly null) string. Per the specification, any missing or non-numeric value is converted to a zero, so that this servlet will still be loaded at startup time, but in an arbitrary order.
 * @param value New load-on-startup value
 */
public void setLoadOnStartupString(String value){
  try {
    setLoadOnStartup(Integer.parseInt(value));
  }
 catch (  NumberFormatException e) {
    setLoadOnStartup(0);
  }
}

ID 774=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapper#allocate()
Rmethod: org.apache.catalina.core.StandardWrapper#loadServlet()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Allocate an initialized instance of this Servlet that is ready to have its <code>service()</code> method called.  If the servlet class does not implement <code>SingleThreadModel</code>, the (only) initialized instance may be returned immediately.  If the servlet class implements <code>SingleThreadModel</code>, the Wrapper implementation must ensure that this instance is not allocated again until it is deallocated by a call to <code>deallocate()</code>.
 * @exception ServletException if the servlet init() method threwan exception
 * @exception ServletException if a loading error occursallocate ['lYkejt] vt. MP=
 */
@Override public Servlet allocate() throws ServletException {
  if (unloading) {
    throw new ServletException(sm.getString("standardWrapper.unloading",getName()));
  }
  boolean newInstance=false;
  if (!singleThreadModel) {
    if (instance == null || !instanceInitialized) {
synchronized (this) {
        if (instance == null) {
          try {
            if (log.isDebugEnabled()) {
              log.debug("Allocating non-STM instance");
            }
            instance=loadServlet();
            newInstance=true;
            if (!singleThreadModel) {
              countAllocated.incrementAndGet();
            }
          }
 catch (          ServletException e) {
            throw e;
          }
catch (          Throwable e) {
            ExceptionUtils.handleThrowable(e);
            throw new ServletException(sm.getString("standardWrapper.allocate"),e);
          }
        }
        if (!instanceInitialized) {
          initServlet(instance);
        }
      }
    }
    if (singleThreadModel) {
      if (newInstance) {
synchronized (instancePool) {
          instancePool.push(instance);
          nInstances++;
        }
      }
    }
 else {
      if (log.isTraceEnabled()) {
        log.trace("  Returning non-STM instance");
      }
      if (!newInstance) {
        countAllocated.incrementAndGet();
      }
      return instance;
    }
  }
synchronized (instancePool) {
    while (countAllocated.get() >= nInstances) {
      if (nInstances < maxInstances) {
        try {
          instancePool.push(loadServlet());
          nInstances++;
        }
 catch (        ServletException e) {
          throw e;
        }
catch (        Throwable e) {
          ExceptionUtils.handleThrowable(e);
          throw new ServletException(sm.getString("standardWrapper.allocate"),e);
        }
      }
 else {
        try {
          instancePool.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    if (log.isTraceEnabled()) {
      log.trace("  Returning allocated STM instance");
    }
    countAllocated.incrementAndGet();
    return instancePool.pop();
  }
}

ID 776=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapper#allocate()
Rmethod: org.apache.catalina.core.StandardWrapper#loadServlet()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Allocate an initialized instance of this Servlet that is ready to have its <code>service()</code> method called.  If the servlet class does not implement <code>SingleThreadModel</code>, the (only) initialized instance may be returned immediately.  If the servlet class implements <code>SingleThreadModel</code>, the Wrapper implementation must ensure that this instance is not allocated again until it is deallocated by a call to <code>deallocate()</code>.
 * @exception ServletException if the servlet init() method threwan exception
 * @exception ServletException if a loading error occursallocate ['lYkejt] vt. MP=
 */
@Override public Servlet allocate() throws ServletException {
  if (unloading) {
    throw new ServletException(sm.getString("standardWrapper.unloading",getName()));
  }
  boolean newInstance=false;
  if (!singleThreadModel) {
    if (instance == null || !instanceInitialized) {
synchronized (this) {
        if (instance == null) {
          try {
            if (log.isDebugEnabled()) {
              log.debug("Allocating non-STM instance");
            }
            instance=loadServlet();
            newInstance=true;
            if (!singleThreadModel) {
              countAllocated.incrementAndGet();
            }
          }
 catch (          ServletException e) {
            throw e;
          }
catch (          Throwable e) {
            ExceptionUtils.handleThrowable(e);
            throw new ServletException(sm.getString("standardWrapper.allocate"),e);
          }
        }
        if (!instanceInitialized) {
          initServlet(instance);
        }
      }
    }
    if (singleThreadModel) {
      if (newInstance) {
synchronized (instancePool) {
          instancePool.push(instance);
          nInstances++;
        }
      }
    }
 else {
      if (log.isTraceEnabled()) {
        log.trace("  Returning non-STM instance");
      }
      if (!newInstance) {
        countAllocated.incrementAndGet();
      }
      return instance;
    }
  }
synchronized (instancePool) {
    while (countAllocated.get() >= nInstances) {
      if (nInstances < maxInstances) {
        try {
          instancePool.push(loadServlet());
          nInstances++;
        }
 catch (        ServletException e) {
          throw e;
        }
catch (        Throwable e) {
          ExceptionUtils.handleThrowable(e);
          throw new ServletException(sm.getString("standardWrapper.allocate"),e);
        }
      }
 else {
        try {
          instancePool.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    if (log.isTraceEnabled()) {
      log.trace("  Returning allocated STM instance");
    }
    countAllocated.incrementAndGet();
    return instancePool.pop();
  }
}

ID 781=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapper#load()
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Load and initialize an instance of this servlet, if there is not already at least one initialized instance.  This can be used, for example, to load servlets that are marked in the deployment descriptor to be loaded at server startup time. <p> <b>IMPLEMENTATION NOTE</b>:  Servlets whose classnames begin with <code>org.apache.catalina.</code> (so-called "container" servlets) are loaded by the same classloader that loaded this class, rather than the classloader for the current web application. This gives such classes access to Catalina internals, which are prevented for classes loaded for web applications.
 * @exception ServletException if the servlet init() method threwan exception
 * @exception ServletException if some other loading problem occurs
 */
@Override public synchronized void load() throws ServletException {
  instance=loadServlet();
  if (!instanceInitialized) {
    initServlet(instance);
  }
  if (isJspServlet) {
    StringBuilder oname=new StringBuilder(MBeanUtils.getDomain(getParent()));
    oname.append(":type=JspMonitor,name=");
    oname.append(getName());
    oname.append(getWebModuleKeyProperties());
    try {
      jspMonitorON=new ObjectName(oname.toString());
      Registry.getRegistry(null,null).registerComponent(instance,jspMonitorON,null);
    }
 catch (    Exception ex) {
      log.info("Error registering JSP monitoring with jmx " + instance);
    }
  }
}

ID 790=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapper#initServlet(javax.servlet.Servlet)
Rmethod: javax.servlet.Servlet#init(javax.servlet.ServletConfig)
parentException: 
thrown: ServletException
exception comment: null
block: 
private synchronized void initServlet(Servlet servlet) throws ServletException {
  if (instanceInitialized && !singleThreadModel)   return;
  try {
    instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT,servlet);
    if (Globals.IS_SECURITY_ENABLED) {
      boolean success=false;
      try {
        Object[] args=new Object[]{facade};
        SecurityUtil.doAsPrivilege("init",servlet,classType,args);
        success=true;
      }
  finally {
        if (!success) {
          SecurityUtil.remove(servlet);
        }
      }
    }
 else {
      servlet.init(facade);
    }
    instanceInitialized=true;
    instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,servlet);
  }
 catch (  UnavailableException f) {
    instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,servlet,f);
    unavailable(f);
    throw f;
  }
catch (  ServletException f) {
    instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,servlet,f);
    throw f;
  }
catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
    getServletContext().log("StandardWrapper.Throwable",f);
    instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT,servlet,f);
    throw new ServletException(sm.getString("standardWrapper.initException",getName()),f);
  }
}

ID 799=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapper#stopInternal()
Rmethod: org.apache.catalina.core.StandardWrapper#unload()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Stop this component and implement the requirements of  {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected synchronized void stopInternal() throws LifecycleException {
  setAvailable(Long.MAX_VALUE);
  if (this.getObjectName() != null) {
    Notification notification=new Notification("j2ee.state.stopping",this.getObjectName(),sequenceNumber++);
    broadcaster.sendNotification(notification);
  }
  try {
    unload();
  }
 catch (  ServletException e) {
    getServletContext().log(sm.getString("standardWrapper.unloadException",getName()),e);
  }
  super.stopInternal();
  if (this.getObjectName() != null) {
    Notification notification=new Notification("j2ee.state.stopped",this.getObjectName(),sequenceNumber++);
    broadcaster.sendNotification(notification);
  }
  Notification notification=new Notification("j2ee.object.deleted",this.getObjectName(),sequenceNumber++);
  broadcaster.sendNotification(notification);
}

ID 801=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 802=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.Class#getDeclaredMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 803=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.Class#getDeclaredMethod(java.lang.String, Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 804=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 805=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 806=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 807=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 810=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.net.URL#URL(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 811=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.net.URL#openConnection()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 812=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: javax.xml.parsers.DocumentBuilderFactory#newDocumentBuilder()
parentException: 
thrown: ParserConfigurationException
exception comment: /** 
 * Indicates a serious configuration error.
 * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 816=========================================================================type: 1
Method:org.apache.catalina.core.JreMemoryLeakPreventionListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());
      if (driverManagerProtection) {
        DriverManager.getDrivers();
      }
      if (appContextProtection) {
        ImageIO.getCacheDirectory();
      }
      if (awtThreadProtection) {
        java.awt.Toolkit.getDefaultToolkit();
      }
      if (java2dDisposerProtection) {
        try {
          Class.forName("sun.java2d.Disposer");
        }
 catch (        ClassNotFoundException cnfe) {
        }
      }
      if (gcDaemonProtection) {
        try {
          Class<?> clazz=Class.forName("sun.misc.GC");
          Method method=clazz.getDeclaredMethod("requestLatency",new Class[]{long.class});
          method.invoke(null,Long.valueOf(Long.MAX_VALUE - 1));
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.gcDaemonFail"),e);
          }
        }
catch (        SecurityException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        NoSuchMethodException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        IllegalAccessException e) {
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.error(sm.getString("jreLeakListener.gcDaemonFail"),e);
        }
      }
      if (securityPolicyProtection) {
        try {
          Class<?> policyClass=Class.forName("javax.security.auth.Policy");
          Method method=policyClass.getMethod("getPolicy");
          method.invoke(null);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        SecurityException e) {
        }
catch (        NoSuchMethodException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
catch (        InvocationTargetException e) {
          ExceptionUtils.handleThrowable(e.getCause());
          log.warn(sm.getString("jreLeakListener.authPolicyFail"),e);
        }
      }
      if (securityLoginConfigurationProtection) {
        try {
          Class.forName("javax.security.auth.login.Configuration",true,ClassLoader.getSystemClassLoader());
        }
 catch (        ClassNotFoundException e) {
        }
      }
      if (tokenPollerProtection) {
        java.security.Security.getProviders();
      }
      if (urlCacheProtection) {
        try {
          URL url=new URL("jar:file://dummy.jar!/");
          URLConnection uConn=url.openConnection();
          uConn.setDefaultUseCaches(false);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
catch (        IOException e) {
          log.error(sm.getString("jreLeakListener.jarUrlConnCacheFail"),e);
        }
      }
      if (xmlParsingProtection) {
        DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
        try {
          DocumentBuilder documentBuilder=factory.newDocumentBuilder();
          Document document=documentBuilder.newDocument();
          document.createElement("dummy");
          DOMImplementationLS implementation=(DOMImplementationLS)document.getImplementation();
          implementation.createLSSerializer().writeToString(document);
          document.normalize();
        }
 catch (        ParserConfigurationException e) {
          log.error(sm.getString("jreLeakListener.xmlParseFail"),e);
        }
      }
      if (ldapPoolProtection) {
        try {
          Class.forName("com.sun.jndi.ldap.LdapPoolManager");
        }
 catch (        ClassNotFoundException e) {
          if (JreVendor.IS_ORACLE_JVM) {
            log.error(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
 else {
            log.debug(sm.getString("jreLeakListener.ldapPoolManagerFail"),e);
          }
        }
      }
      if (classesToInitialize != null) {
        StringTokenizer strTok=new StringTokenizer(classesToInitialize,", \r\n\t");
        while (strTok.hasMoreTokens()) {
          String classNameToLoad=strTok.nextToken();
          try {
            Class.forName(classNameToLoad);
          }
 catch (          ClassNotFoundException e) {
            log.error(sm.getString("jreLeakListener.classToInitializeFail",classNameToLoad),e);
          }
        }
      }
    }
  finally {
      Thread.currentThread().setContextClassLoader(loader);
    }
  }
}

ID 873=========================================================================type: 1
Method:org.apache.catalina.core.DefaultInstanceManager#loadClassMaybePrivileged(java.lang.String, java.lang.ClassLoader)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
protected Class<?> loadClassMaybePrivileged(final String className,final ClassLoader classLoader) throws ClassNotFoundException {
  Class<?> clazz;
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      clazz=AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>(){
        @Override public Class<?> run() throws Exception {
          return loadClass(className,classLoader);
        }
      }
);
    }
 catch (    PrivilegedActionException e) {
      Throwable t=e.getCause();
      if (t instanceof ClassNotFoundException) {
        throw (ClassNotFoundException)t;
      }
      throw new RuntimeException(t);
    }
  }
 else {
    clazz=loadClass(className,classLoader);
  }
  checkAccess(clazz);
  return clazz;
}

ID 885=========================================================================type: 1
Method:org.apache.catalina.core.DefaultInstanceManager#loadProperties(Set<java.lang.String>, java.lang.String, java.lang.String, org.apache.juli.logging.Log)
Rmethod: java.util.Properties#load(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private static void loadProperties(Set<String> classNames,String resourceName,String messageKey,Log log){
  Properties properties=new Properties();
  ClassLoader cl=DefaultInstanceManager.class.getClassLoader();
  InputStream is=null;
  try {
    is=cl.getResourceAsStream(resourceName);
    if (is == null) {
      log.error(sm.getString(messageKey,resourceName));
    }
 else {
      properties.load(is);
    }
  }
 catch (  IOException ioe) {
    log.error(sm.getString(messageKey,resourceName),ioe);
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
  if (properties.isEmpty()) {
    return;
  }
  for (  Map.Entry<Object,Object> e : properties.entrySet()) {
    if ("restricted".equals(e.getValue())) {
      classNames.add(e.getKey().toString());
    }
 else {
      log.warn(sm.getString("defaultInstanceManager.restrictedWrongValue",resourceName,e.getKey(),e.getValue()));
    }
  }
}

ID 898=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.core.StandardWrapper#allocate()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 905=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.core.AsyncContextImpl#doInternalDispatch()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 906=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.core.AsyncContextImpl#doInternalDispatch()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 907=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilterEvent(org.apache.catalina.comet.CometEvent)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 908=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilterEvent(org.apache.catalina.comet.CometEvent)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 909=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 910=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 911=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.connector.Response#sendError(int, java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Invoke the servlet we are managing, respecting the rules regarding servlet lifecycle and SingleThreadModel support.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurredWrapper b1 Servlet so ( servlet  service 
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  boolean unavailable=false;
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  requestCount++;
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  if (!context.getState().isAvailable()) {
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardContext.isUnavailable"));
    unavailable=true;
  }
  if (!unavailable && wrapper.isUnavailable()) {
    container.getLogger().info(sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
    unavailable=true;
  }
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  boolean comet=false;
  if (servlet instanceof CometProcessor && Boolean.TRUE.equals(request.getAttribute(Globals.COMET_SUPPORTED_ATTR))) {
    comet=true;
    request.setComet(true);
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  DispatcherType dispatcherType=DispatcherType.REQUEST;
  if (request.getDispatcherType() == DispatcherType.ASYNC)   dispatcherType=DispatcherType.ASYNC;
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterFactory factory=ApplicationFilterFactory.getInstance();
  ApplicationFilterChain filterChain=factory.createFilterChain(request,wrapper,servlet);
  request.setComet(false);
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          if (request.isAsyncDispatching()) {
            request.getAsyncContextInternal().doInternalDispatch();
          }
 else           if (comet) {
            filterChain.doFilterEvent(request.getEvent());
            request.setComet(true);
          }
 else {
            filterChain.doFilter(request.getRequest(),response.getResponse());
          }
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        if (request.isAsyncDispatching()) {
          request.getAsyncContextInternal().doInternalDispatch();
        }
 else         if (comet) {
          request.setComet(true);
          filterChain.doFilterEvent(request.getEvent());
        }
 else {
          filterChain.doFilter(request.getRequest(),response.getResponse());
        }
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    wrapper.unavailable(e);
    long available=wrapper.getAvailable();
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      response.setDateHeader("Retry-After",available);
      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,sm.getString("standardWrapper.isUnavailable",wrapper.getName()));
    }
 else     if (available == Long.MAX_VALUE) {
      response.sendError(HttpServletResponse.SC_NOT_FOUND,sm.getString("standardWrapper.notFound",wrapper.getName()));
    }
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    if (request.isComet()) {
      filterChain.reuse();
    }
 else {
      filterChain.release();
    }
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 914=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#event(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.core.StandardWrapper#allocate()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Process a Comet event. The main differences here are to not use sendError (the response is committed), to avoid creating a new filter chain (which would work but be pointless), and a few very minor tweaks.
 * @param request The servlet request to be processed
 * @param response The servlet response to be created
 * @exception IOException if an input/output error occurs, or is thrownby a subsequently invoked Valve, Filter, or Servlet
 * @exception ServletException if a servlet error occurs, or is thrownby a subsequently invoked Valve, Filter, or Servlet
 */
@Override public void event(Request request,Response response,CometEvent event) throws IOException, ServletException {
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  if (wrapper == null) {
    return;
  }
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  boolean unavailable=!context.getState().isAvailable() || wrapper.isUnavailable();
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,DispatcherType.REQUEST);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterChain filterChain=(ApplicationFilterChain)request.getFilterChain();
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          filterChain.doFilterEvent(request.getEvent());
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        filterChain.doFilterEvent(request.getEvent());
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    filterChain.reuse();
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 917=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#event(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilterEvent(org.apache.catalina.comet.CometEvent)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process a Comet event. The main differences here are to not use sendError (the response is committed), to avoid creating a new filter chain (which would work but be pointless), and a few very minor tweaks.
 * @param request The servlet request to be processed
 * @param response The servlet response to be created
 * @exception IOException if an input/output error occurs, or is thrownby a subsequently invoked Valve, Filter, or Servlet
 * @exception ServletException if a servlet error occurs, or is thrownby a subsequently invoked Valve, Filter, or Servlet
 */
@Override public void event(Request request,Response response,CometEvent event) throws IOException, ServletException {
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  if (wrapper == null) {
    return;
  }
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  boolean unavailable=!context.getState().isAvailable() || wrapper.isUnavailable();
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,DispatcherType.REQUEST);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterChain filterChain=(ApplicationFilterChain)request.getFilterChain();
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          filterChain.doFilterEvent(request.getEvent());
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        filterChain.doFilterEvent(request.getEvent());
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    filterChain.reuse();
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 918=========================================================================type: 1
Method:org.apache.catalina.core.StandardWrapperValve#event(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.core.ApplicationFilterChain#doFilterEvent(org.apache.catalina.comet.CometEvent)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * Process a Comet event. The main differences here are to not use sendError (the response is committed), to avoid creating a new filter chain (which would work but be pointless), and a few very minor tweaks.
 * @param request The servlet request to be processed
 * @param response The servlet response to be created
 * @exception IOException if an input/output error occurs, or is thrownby a subsequently invoked Valve, Filter, or Servlet
 * @exception ServletException if a servlet error occurs, or is thrownby a subsequently invoked Valve, Filter, or Servlet
 */
@Override public void event(Request request,Response response,CometEvent event) throws IOException, ServletException {
  Throwable throwable=null;
  long t1=System.currentTimeMillis();
  StandardWrapper wrapper=(StandardWrapper)getContainer();
  if (wrapper == null) {
    return;
  }
  Servlet servlet=null;
  Context context=(Context)wrapper.getParent();
  boolean unavailable=!context.getState().isAvailable() || wrapper.isUnavailable();
  try {
    if (!unavailable) {
      servlet=wrapper.allocate();
    }
  }
 catch (  UnavailableException e) {
  }
catch (  ServletException e) {
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),StandardWrapper.getRootCause(e));
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.allocateException",wrapper.getName()),e);
    throwable=e;
    exception(request,response,e);
    servlet=null;
  }
  MessageBytes requestPathMB=request.getRequestPathMB();
  request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,DispatcherType.REQUEST);
  request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,requestPathMB);
  ApplicationFilterChain filterChain=(ApplicationFilterChain)request.getFilterChain();
  try {
    if ((servlet != null) && (filterChain != null)) {
      if (context.getSwallowOutput()) {
        try {
          SystemLogHandler.startCapture();
          filterChain.doFilterEvent(request.getEvent());
        }
  finally {
          String log=SystemLogHandler.stopCapture();
          if (log != null && log.length() > 0) {
            context.getLogger().info(log);
          }
        }
      }
 else {
        filterChain.doFilterEvent(request.getEvent());
      }
    }
  }
 catch (  ClientAbortException e) {
    throwable=e;
    exception(request,response,e);
  }
catch (  IOException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
catch (  UnavailableException e) {
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
  }
catch (  ServletException e) {
    Throwable rootCause=StandardWrapper.getRootCause(e);
    if (!(rootCause instanceof ClientAbortException)) {
      container.getLogger().error(sm.getString("standardWrapper.serviceExceptionRoot",wrapper.getName(),context.getName(),e.getMessage()),rootCause);
    }
    throwable=e;
    exception(request,response,e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.serviceException",wrapper.getName(),context.getName()),e);
    throwable=e;
    exception(request,response,e);
  }
  if (filterChain != null) {
    filterChain.reuse();
  }
  try {
    if (servlet != null) {
      wrapper.deallocate(servlet);
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.deallocateException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  try {
    if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {
      wrapper.unload();
    }
  }
 catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    container.getLogger().error(sm.getString("standardWrapper.unloadException",wrapper.getName()),e);
    if (throwable == null) {
      throwable=e;
      exception(request,response,e);
    }
  }
  long t2=System.currentTimeMillis();
  long time=t2 - t1;
  processingTime+=time;
  if (time > maxTime)   maxTime=time;
  if (time < minTime)   minTime=time;
}

ID 926=========================================================================type: 1
Method:org.apache.catalina.core.StandardHostValve#status(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.connector.Response#finishResponse()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Handle the HTTP status code (and corresponding message) generated while processing the specified Request to produce the specified Response.  Any exceptions that occur during generation of the error report are logged and swallowed.
 * @param request The request being processed
 * @param response The response being generated
 */
private void status(Request request,Response response){
  int statusCode=response.getStatus();
  Context context=request.getContext();
  if (context == null)   return;
  if (!response.isError())   return;
  ErrorPage errorPage=context.findErrorPage(statusCode);
  if (errorPage == null) {
    errorPage=context.findErrorPage(0);
  }
  if (errorPage != null && response.isErrorReportRequired()) {
    response.setAppCommitted(false);
    request.setAttribute(RequestDispatcher.ERROR_STATUS_CODE,Integer.valueOf(statusCode));
    String message=response.getMessage();
    if (message == null)     message="";
    request.setAttribute(RequestDispatcher.ERROR_MESSAGE,message);
    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,errorPage.getLocation());
    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,DispatcherType.ERROR);
    Wrapper wrapper=request.getWrapper();
    if (wrapper != null)     request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME,wrapper.getName());
    request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI,request.getRequestURI());
    if (custom(request,response,errorPage)) {
      response.setErrorReported();
      try {
        response.finishResponse();
      }
 catch (      ClientAbortException e) {
      }
catch (      IOException e) {
        container.getLogger().warn("Exception Processing " + errorPage,e);
      }
    }
  }
}

ID 927=========================================================================type: 1
Method:org.apache.catalina.core.StandardHostValve#throwable(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, java.lang.Throwable)
Rmethod: org.apache.catalina.connector.Response#finishResponse()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Handle the specified Throwable encountered while processing the specified Request to produce the specified Response.  Any exceptions that occur during generation of the exception report are logged and swallowed.
 * @param request The request being processed
 * @param response The response being generated
 * @param throwable The exception that occurred (which possibly wrapsa root cause exception
 */
protected void throwable(Request request,Response response,Throwable throwable){
  Context context=request.getContext();
  if (context == null)   return;
  Throwable realError=throwable;
  if (realError instanceof ServletException) {
    realError=((ServletException)realError).getRootCause();
    if (realError == null) {
      realError=throwable;
    }
  }
  if (realError instanceof ClientAbortException) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("standardHost.clientAbort",realError.getCause().getMessage()));
    }
    return;
  }
  ErrorPage errorPage=findErrorPage(context,throwable);
  if ((errorPage == null) && (realError != throwable)) {
    errorPage=findErrorPage(context,realError);
  }
  if (errorPage != null) {
    if (response.setErrorReported()) {
      response.setAppCommitted(false);
      request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,errorPage.getLocation());
      request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,DispatcherType.ERROR);
      request.setAttribute(RequestDispatcher.ERROR_STATUS_CODE,Integer.valueOf(HttpServletResponse.SC_INTERNAL_SERVER_ERROR));
      request.setAttribute(RequestDispatcher.ERROR_MESSAGE,throwable.getMessage());
      request.setAttribute(RequestDispatcher.ERROR_EXCEPTION,realError);
      Wrapper wrapper=request.getWrapper();
      if (wrapper != null)       request.setAttribute(RequestDispatcher.ERROR_SERVLET_NAME,wrapper.getName());
      request.setAttribute(RequestDispatcher.ERROR_REQUEST_URI,request.getRequestURI());
      request.setAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE,realError.getClass());
      if (custom(request,response,errorPage)) {
        try {
          response.finishResponse();
        }
 catch (        IOException e) {
          container.getLogger().warn("Exception Processing " + errorPage,e);
        }
      }
    }
  }
 else {
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    response.setError();
    status(request,response);
  }
}

ID 932=========================================================================type: 1
Method:org.apache.catalina.core.AprLifecycleListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.catalina.core.AprLifecycleListener#initializeSSL()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Primary entry point for startup and shutdown events.
 * @param event The event that has occurred
 */
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_INIT_EVENT.equals(event.getType())) {
synchronized (lock) {
      init();
      for (      String msg : initInfoLogMessages) {
        log.info(msg);
      }
      initInfoLogMessages.clear();
      if (aprAvailable) {
        try {
          initializeSSL();
        }
 catch (        Throwable t) {
          t=ExceptionUtils.unwrapInvocationTargetException(t);
          ExceptionUtils.handleThrowable(t);
          log.error(sm.getString("aprListener.sslInit"),t);
        }
      }
      if (!(null == FIPSMode || "off".equalsIgnoreCase(FIPSMode)) && !isFIPSModeActive()) {
        Error e=new Error(sm.getString("aprListener.initializeFIPSFailed"));
        log.fatal(e.getMessage(),e);
        throw e;
      }
    }
  }
 else   if (Lifecycle.AFTER_DESTROY_EVENT.equals(event.getType())) {
synchronized (lock) {
      if (!aprAvailable) {
        return;
      }
      try {
        terminateAPR();
      }
 catch (      Throwable t) {
        t=ExceptionUtils.unwrapInvocationTargetException(t);
        ExceptionUtils.handleThrowable(t);
        log.info(sm.getString("aprListener.aprDestroy"));
      }
    }
  }
}

ID 943=========================================================================type: 1
Method:org.apache.catalina.core.AprLifecycleListener#init()
Rmethod: org.apache.tomcat.jni.Library#initialize(java.lang.String)
parentException: Object 
thrown: Throwable
exception comment: null
block: 
private static void init(){
  int major=0;
  int minor=0;
  int patch=0;
  int apver=0;
  int rqver=TCN_REQUIRED_MAJOR * 1000 + TCN_REQUIRED_MINOR * 100 + TCN_REQUIRED_PATCH;
  int rcver=TCN_REQUIRED_MAJOR * 1000 + TCN_RECOMMENDED_MINOR * 100 + TCN_RECOMMENDED_PV;
  if (aprInitialized) {
    return;
  }
  aprInitialized=true;
  try {
    Library.initialize(null);
    major=Library.TCN_MAJOR_VERSION;
    minor=Library.TCN_MINOR_VERSION;
    patch=Library.TCN_PATCH_VERSION;
    apver=major * 1000 + minor * 100 + patch;
  }
 catch (  LibraryNotFoundError lnfe) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("aprListener.aprInitDebug",lnfe.getLibraryNames(),System.getProperty("java.library.path"),lnfe.getMessage()),lnfe);
    }
    initInfoLogMessages.add(sm.getString("aprListener.aprInit",System.getProperty("java.library.path")));
    return;
  }
catch (  Throwable t) {
    t=ExceptionUtils.unwrapInvocationTargetException(t);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("aprListener.aprInitError",t.getMessage()),t);
    return;
  }
  if (apver < rqver) {
    log.error(sm.getString("aprListener.tcnInvalid",major + "." + minor+ "."+ patch,TCN_REQUIRED_MAJOR + "." + TCN_REQUIRED_MINOR+ "."+ TCN_REQUIRED_PATCH));
    try {
      terminateAPR();
    }
 catch (    Throwable t) {
      t=ExceptionUtils.unwrapInvocationTargetException(t);
      ExceptionUtils.handleThrowable(t);
    }
    return;
  }
  if (apver < rcver) {
    initInfoLogMessages.add(sm.getString("aprListener.tcnVersion",major + "." + minor+ "."+ patch,TCN_REQUIRED_MAJOR + "." + TCN_RECOMMENDED_MINOR+ "."+ TCN_RECOMMENDED_PV));
  }
  initInfoLogMessages.add(sm.getString("aprListener.tcnValid",major + "." + minor+ "."+ patch,Library.APR_MAJOR_VERSION + "." + Library.APR_MINOR_VERSION+ "."+ Library.APR_PATCH_VERSION));
  initInfoLogMessages.add(sm.getString("aprListener.flags",Boolean.valueOf(Library.APR_HAVE_IPV6),Boolean.valueOf(Library.APR_HAS_SENDFILE),Boolean.valueOf(Library.APR_HAS_SO_ACCEPTFILTER),Boolean.valueOf(Library.APR_HAS_RANDOM)));
  aprAvailable=true;
}

ID 956=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setLoader(org.apache.catalina.Loader)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Loader with which this Container is associated.
 * @param loader The newly associated loader
 */
@Override public synchronized void setLoader(Loader loader){
  Loader oldLoader=this.loader;
  if (oldLoader == loader)   return;
  this.loader=loader;
  if (getState().isAvailable() && (oldLoader != null) && (oldLoader instanceof Lifecycle)) {
    try {
      ((Lifecycle)oldLoader).stop();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setLoader: stop: ",e);
    }
  }
  if (loader != null)   loader.setContainer(this);
  if (getState().isAvailable() && (loader != null) && (loader instanceof Lifecycle)) {
    try {
      ((Lifecycle)loader).start();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setLoader: start: ",e);
    }
  }
  support.firePropertyChange("loader",oldLoader,this.loader);
}

ID 957=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setLoader(org.apache.catalina.Loader)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Loader with which this Container is associated.
 * @param loader The newly associated loader
 */
@Override public synchronized void setLoader(Loader loader){
  Loader oldLoader=this.loader;
  if (oldLoader == loader)   return;
  this.loader=loader;
  if (getState().isAvailable() && (oldLoader != null) && (oldLoader instanceof Lifecycle)) {
    try {
      ((Lifecycle)oldLoader).stop();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setLoader: stop: ",e);
    }
  }
  if (loader != null)   loader.setContainer(this);
  if (getState().isAvailable() && (loader != null) && (loader instanceof Lifecycle)) {
    try {
      ((Lifecycle)loader).start();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setLoader: start: ",e);
    }
  }
  support.firePropertyChange("loader",oldLoader,this.loader);
}

ID 958=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setManager(org.apache.catalina.Manager)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Manager with which this Container is associated.
 * @param manager The newly associated Manager
 */
@Override public synchronized void setManager(Manager manager){
  Manager oldManager=this.manager;
  if (oldManager == manager)   return;
  this.manager=manager;
  if (oldManager instanceof Lifecycle) {
    try {
      ((Lifecycle)oldManager).stop();
      ((Lifecycle)oldManager).destroy();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setManager: stop-destroy: ",e);
    }
  }
  if (manager != null)   manager.setContainer(this);
  if (getState().isAvailable() && manager instanceof Lifecycle) {
    try {
      ((Lifecycle)manager).start();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setManager: start: ",e);
    }
  }
  support.firePropertyChange("manager",oldManager,this.manager);
}

ID 959=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setManager(org.apache.catalina.Manager)
Rmethod: org.apache.catalina.Lifecycle#destroy()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Manager with which this Container is associated.
 * @param manager The newly associated Manager
 */
@Override public synchronized void setManager(Manager manager){
  Manager oldManager=this.manager;
  if (oldManager == manager)   return;
  this.manager=manager;
  if (oldManager instanceof Lifecycle) {
    try {
      ((Lifecycle)oldManager).stop();
      ((Lifecycle)oldManager).destroy();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setManager: stop-destroy: ",e);
    }
  }
  if (manager != null)   manager.setContainer(this);
  if (getState().isAvailable() && manager instanceof Lifecycle) {
    try {
      ((Lifecycle)manager).start();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setManager: start: ",e);
    }
  }
  support.firePropertyChange("manager",oldManager,this.manager);
}

ID 960=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setManager(org.apache.catalina.Manager)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Manager with which this Container is associated.
 * @param manager The newly associated Manager
 */
@Override public synchronized void setManager(Manager manager){
  Manager oldManager=this.manager;
  if (oldManager == manager)   return;
  this.manager=manager;
  if (oldManager instanceof Lifecycle) {
    try {
      ((Lifecycle)oldManager).stop();
      ((Lifecycle)oldManager).destroy();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setManager: stop-destroy: ",e);
    }
  }
  if (manager != null)   manager.setContainer(this);
  if (getState().isAvailable() && manager instanceof Lifecycle) {
    try {
      ((Lifecycle)manager).start();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setManager: start: ",e);
    }
  }
  support.firePropertyChange("manager",oldManager,this.manager);
}

ID 961=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setCluster(org.apache.catalina.Cluster)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Cluster with which this Container is associated.
 * @param cluster The newly associated Cluster
 */
@Override public synchronized void setCluster(Cluster cluster){
  Cluster oldCluster=this.cluster;
  if (oldCluster == cluster)   return;
  this.cluster=cluster;
  if (getState().isAvailable() && (oldCluster != null) && (oldCluster instanceof Lifecycle)) {
    try {
      ((Lifecycle)oldCluster).stop();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setCluster: stop: ",e);
    }
  }
  if (cluster != null)   cluster.setContainer(this);
  if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) {
    try {
      ((Lifecycle)cluster).start();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setCluster: start: ",e);
    }
  }
  support.firePropertyChange("cluster",oldCluster,this.cluster);
}

ID 962=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setCluster(org.apache.catalina.Cluster)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Cluster with which this Container is associated.
 * @param cluster The newly associated Cluster
 */
@Override public synchronized void setCluster(Cluster cluster){
  Cluster oldCluster=this.cluster;
  if (oldCluster == cluster)   return;
  this.cluster=cluster;
  if (getState().isAvailable() && (oldCluster != null) && (oldCluster instanceof Lifecycle)) {
    try {
      ((Lifecycle)oldCluster).stop();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setCluster: stop: ",e);
    }
  }
  if (cluster != null)   cluster.setContainer(this);
  if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) {
    try {
      ((Lifecycle)cluster).start();
    }
 catch (    LifecycleException e) {
      log.error("ContainerBase.setCluster: start: ",e);
    }
  }
  support.firePropertyChange("cluster",oldCluster,this.cluster);
}

ID 963=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setRealm(org.apache.catalina.Realm)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Realm with which this Container is associated.
 * @param realm The newly associated Realm
 */
@Override public void setRealm(Realm realm){
  Lock l=realmLock.writeLock();
  try {
    l.lock();
    Realm oldRealm=this.realm;
    if (oldRealm == realm)     return;
    this.realm=realm;
    if (getState().isAvailable() && (oldRealm != null) && (oldRealm instanceof Lifecycle)) {
      try {
        ((Lifecycle)oldRealm).stop();
      }
 catch (      LifecycleException e) {
        log.error("ContainerBase.setRealm: stop: ",e);
      }
    }
    if (realm != null)     realm.setContainer(this);
    if (getState().isAvailable() && (realm != null) && (realm instanceof Lifecycle)) {
      try {
        ((Lifecycle)realm).start();
      }
 catch (      LifecycleException e) {
        log.error("ContainerBase.setRealm: start: ",e);
      }
    }
    support.firePropertyChange("realm",oldRealm,this.realm);
  }
  finally {
    l.unlock();
  }
}

ID 964=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#setRealm(org.apache.catalina.Realm)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Set the Realm with which this Container is associated.
 * @param realm The newly associated Realm
 */
@Override public void setRealm(Realm realm){
  Lock l=realmLock.writeLock();
  try {
    l.lock();
    Realm oldRealm=this.realm;
    if (oldRealm == realm)     return;
    this.realm=realm;
    if (getState().isAvailable() && (oldRealm != null) && (oldRealm instanceof Lifecycle)) {
      try {
        ((Lifecycle)oldRealm).stop();
      }
 catch (      LifecycleException e) {
        log.error("ContainerBase.setRealm: stop: ",e);
      }
    }
    if (realm != null)     realm.setContainer(this);
    if (getState().isAvailable() && (realm != null) && (realm instanceof Lifecycle)) {
      try {
        ((Lifecycle)realm).start();
      }
 catch (      LifecycleException e) {
        log.error("ContainerBase.setRealm: start: ",e);
      }
    }
    support.firePropertyChange("realm",oldRealm,this.realm);
  }
  finally {
    l.unlock();
  }
}

ID 965=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#addChildInternal(org.apache.catalina.Container)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
private void addChildInternal(Container child){
  if (log.isDebugEnabled())   log.debug("Add child " + child + " "+ this);
synchronized (children) {
    if (children.get(child.getName()) != null)     throw new IllegalArgumentException("addChild:  Child name '" + child.getName() + "' is not unique");
    child.setParent(this);
    children.put(child.getName(),child);
  }
  try {
    if ((getState().isAvailable() || LifecycleState.STARTING_PREP.equals(getState())) && startChildren) {
      child.start();
    }
  }
 catch (  LifecycleException e) {
    log.error("ContainerBase.addChild: start: ",e);
    throw new IllegalStateException("ContainerBase.addChild: start: " + e);
  }
 finally {
    fireContainerEvent(ADD_CHILD_EVENT,child);
  }
}

ID 968=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#removeChild(org.apache.catalina.Container)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Remove an existing child Container from association with this parent Container.
 * @param child Existing child Container to be removed
 */
@Override public void removeChild(Container child){
  if (child == null) {
    return;
  }
  try {
    if (child.getState().isAvailable()) {
      child.stop();
    }
  }
 catch (  LifecycleException e) {
    log.error("ContainerBase.removeChild: stop: ",e);
  }
  try {
    if (!LifecycleState.DESTROYING.equals(child.getState())) {
      child.destroy();
    }
  }
 catch (  LifecycleException e) {
    log.error("ContainerBase.removeChild: destroy: ",e);
  }
synchronized (children) {
    if (children.get(child.getName()) == null)     return;
    children.remove(child.getName());
  }
  fireContainerEvent(REMOVE_CHILD_EVENT,child);
}

ID 969=========================================================================type: 1
Method:org.apache.catalina.core.ContainerBase#removeChild(org.apache.catalina.Container)
Rmethod: org.apache.catalina.Lifecycle#destroy()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Remove an existing child Container from association with this parent Container.
 * @param child Existing child Container to be removed
 */
@Override public void removeChild(Container child){
  if (child == null) {
    return;
  }
  try {
    if (child.getState().isAvailable()) {
      child.stop();
    }
  }
 catch (  LifecycleException e) {
    log.error("ContainerBase.removeChild: stop: ",e);
  }
  try {
    if (!LifecycleState.DESTROYING.equals(child.getState())) {
      child.destroy();
    }
  }
 catch (  LifecycleException e) {
    log.error("ContainerBase.removeChild: destroy: ",e);
  }
synchronized (children) {
    if (children.get(child.getName()) == null)     return;
    children.remove(child.getName());
  }
  fireContainerEvent(REMOVE_CHILD_EVENT,child);
}

ID 984=========================================================================type: 1
Method:org.apache.catalina.core.StandardService#addConnector(org.apache.catalina.connector.Connector)
Rmethod: org.apache.catalina.util.LifecycleBase#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Add a new Connector to the set of defined Connectors, and associate it with this Service's Container.
 * @param connector The Connector to be added
 */
@Override public void addConnector(Connector connector){
synchronized (connectorsLock) {
    connector.setService(this);
    Connector results[]=new Connector[connectors.length + 1];
    System.arraycopy(connectors,0,results,0,connectors.length);
    results[connectors.length]=connector;
    connectors=results;
    if (getState().isAvailable()) {
      try {
        connector.start();
      }
 catch (      LifecycleException e) {
        log.error(sm.getString("standardService.connector.startFailed",connector),e);
      }
    }
    support.firePropertyChange("connector",null,connector);
  }
}

ID 985=========================================================================type: 1
Method:org.apache.catalina.core.StandardService#removeConnector(org.apache.catalina.connector.Connector)
Rmethod: org.apache.catalina.util.LifecycleBase#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Remove the specified Connector from the set associated from this Service.  The removed Connector will also be disassociated from our Container.
 * @param connector The Connector to be removed
 */
@Override public void removeConnector(Connector connector){
synchronized (connectorsLock) {
    int j=-1;
    for (int i=0; i < connectors.length; i++) {
      if (connector == connectors[i]) {
        j=i;
        break;
      }
    }
    if (j < 0)     return;
    if (connectors[j].getState().isAvailable()) {
      try {
        connectors[j].stop();
      }
 catch (      LifecycleException e) {
        log.error(sm.getString("standardService.connector.stopFailed",connectors[j]),e);
      }
    }
    connector.setService(null);
    int k=0;
    Connector results[]=new Connector[connectors.length - 1];
    for (int i=0; i < connectors.length; i++) {
      if (i != j)       results[k++]=connectors[i];
    }
    connectors=results;
    support.firePropertyChange("connector",connector,null);
  }
}

ID 986=========================================================================type: 1
Method:org.apache.catalina.core.StandardService#addExecutor(org.apache.catalina.Executor)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Adds a named executor to the service
 * @param ex Executor
 */
@Override public void addExecutor(Executor ex){
synchronized (executors) {
    if (!executors.contains(ex)) {
      executors.add(ex);
      if (getState().isAvailable())       try {
        ex.start();
      }
 catch (      LifecycleException x) {
        log.error("Executor.start",x);
      }
    }
  }
}

ID 987=========================================================================type: 1
Method:org.apache.catalina.core.StandardService#removeExecutor(org.apache.catalina.Executor)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Removes an executor from the service
 * @param ex Executor
 */
@Override public void removeExecutor(Executor ex){
synchronized (executors) {
    if (executors.remove(ex) && getState().isAvailable()) {
      try {
        ex.stop();
      }
 catch (      LifecycleException e) {
        log.error("Executor.stop",e);
      }
    }
  }
}

ID 999=========================================================================type: 1
Method:org.apache.catalina.core.StandardContextValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.connector.Response#sendAcknowledgement()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Select the appropriate child Wrapper to process this request, based on the specified request URI.  If no matching Wrapper can be found, return an appropriate HTTP error.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurred
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  MessageBytes requestPathMB=request.getRequestPathMB();
  if ((requestPathMB.startsWithIgnoreCase("/META-INF/",0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) || (requestPathMB.startsWithIgnoreCase("/WEB-INF/",0))|| (requestPathMB.equalsIgnoreCase("/WEB-INF"))) {
    response.sendError(HttpServletResponse.SC_NOT_FOUND);
    return;
  }
  Wrapper wrapper=request.getWrapper();
  if (wrapper == null || wrapper.isUnavailable()) {
    response.sendError(HttpServletResponse.SC_NOT_FOUND);
    return;
  }
  try {
    response.sendAcknowledgement();
  }
 catch (  IOException ioe) {
    container.getLogger().error(sm.getString("standardContextValve.acknowledgeException"),ioe);
    request.setAttribute(RequestDispatcher.ERROR_EXCEPTION,ioe);
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    return;
  }
  if (request.isAsyncSupported()) {
    request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());
  }
  wrapper.getPipeline().getFirst().invoke(request,response);
}

ID 1000=========================================================================type: 1
Method:org.apache.catalina.core.StandardContextValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: org.apache.catalina.connector.Response#sendError(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Select the appropriate child Wrapper to process this request, based on the specified request URI.  If no matching Wrapper can be found, return an appropriate HTTP error.
 * @param request Request to be processed
 * @param response Response to be produced
 * @exception IOException if an input/output error occurred
 * @exception ServletException if a servlet error occurred
 */
@Override public final void invoke(Request request,Response response) throws IOException, ServletException {
  MessageBytes requestPathMB=request.getRequestPathMB();
  if ((requestPathMB.startsWithIgnoreCase("/META-INF/",0)) || (requestPathMB.equalsIgnoreCase("/META-INF")) || (requestPathMB.startsWithIgnoreCase("/WEB-INF/",0))|| (requestPathMB.equalsIgnoreCase("/WEB-INF"))) {
    response.sendError(HttpServletResponse.SC_NOT_FOUND);
    return;
  }
  Wrapper wrapper=request.getWrapper();
  if (wrapper == null || wrapper.isUnavailable()) {
    response.sendError(HttpServletResponse.SC_NOT_FOUND);
    return;
  }
  try {
    response.sendAcknowledgement();
  }
 catch (  IOException ioe) {
    container.getLogger().error(sm.getString("standardContextValve.acknowledgeException"),ioe);
    request.setAttribute(RequestDispatcher.ERROR_EXCEPTION,ioe);
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    return;
  }
  if (request.isAsyncSupported()) {
    request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());
  }
  wrapper.getPipeline().getFirst().invoke(request,response);
}

ID 1007=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Invoke the next filter in this chain, passing the specified request and response.  If there are no more filters in this chain, invoke the <code>service()</code> method of the servlet itself.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet exception occurs(egLh Servlet
 */
@Override public void doFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (Globals.IS_SECURITY_ENABLED) {
    final ServletRequest req=request;
    final ServletResponse res=response;
    try {
      java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws ServletException, IOException {
          internalDoFilter(req,res);
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException pe) {
      Exception e=pe.getException();
      if (e instanceof ServletException)       throw (ServletException)e;
 else       if (e instanceof IOException)       throw (IOException)e;
 else       if (e instanceof RuntimeException)       throw (RuntimeException)e;
 else       throw new ServletException(e.getMessage(),e);
    }
  }
 else {
    internalDoFilter(request,response);
  }
}

ID 1010=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: org.apache.catalina.core.ApplicationFilterConfig#getFilter()
parentException: RuntimeException 
thrown: ClassCastException
exception comment: /** 
 * Thrown to indicate that the code has attempted to cast an object to a subclass of which it is not an instance. For example, the following code generates a <code>ClassCastException</code>: <blockquote><pre> Object x = new Integer(0); System.out.println((String)x); </pre></blockquote>
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1014=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: org.apache.catalina.core.ApplicationFilterConfig#getFilter()
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1017=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: org.apache.catalina.security.SecurityUtil#doAsPrivilege(java.lang.String, javax.servlet.Filter, Class<?>[], java.lang.Object[], java.security.Principal)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1018=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1019=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1020=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: org.apache.catalina.security.SecurityUtil#doAsPrivilege(java.lang.String, javax.servlet.Servlet, Class<?>[], java.lang.Object[], java.security.Principal)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1021=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: javax.servlet.Servlet#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: ServletException
exception comment: null
block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1022=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
Rmethod: javax.servlet.Servlet#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * ;Z2 1	gLh  Filter.doFilter  2	gL  Servlet.service  
 * @param request
 * @param response
 * @throws IOException
 * @throws ServletException
 */
private void internalDoFilter(ServletRequest request,ServletResponse response) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    Filter filter=null;
    try {
      filter=filterConfig.getFilter();
      support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,filter,request,response);
      if (request.isAsyncSupported() && "false".equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) {
        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
      }
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res,this};
        SecurityUtil.doAsPrivilege("doFilter",filter,classType,args,principal);
      }
 else {
        filter.doFilter(request,response,this);
      }
      support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response);
    }
 catch (    IOException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    ServletException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    RuntimeException e) {
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      if (filter != null)       support.fireInstanceEvent(InstanceEvent.AFTER_FILTER_EVENT,filter,request,response,e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(request);
      lastServicedResponse.set(response);
    }
    support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,servlet,request,response);
    if (request.isAsyncSupported() && !support.getWrapper().isAsyncSupported()) {
      request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,Boolean.FALSE);
    }
    if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse)) {
      if (Globals.IS_SECURITY_ENABLED) {
        final ServletRequest req=request;
        final ServletResponse res=response;
        Principal principal=((HttpServletRequest)req).getUserPrincipal();
        Object[] args=new Object[]{req,res};
        SecurityUtil.doAsPrivilege("service",servlet,classTypeUsedInService,args,principal);
      }
 else {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response);
  }
 catch (  IOException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  ServletException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  RuntimeException e) {
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    support.fireInstanceEvent(InstanceEvent.AFTER_SERVICE_EVENT,servlet,request,response,e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
 finally {
    if (ApplicationDispatcher.WRAP_SAME_OBJECT) {
      lastServicedRequest.set(null);
      lastServicedResponse.set(null);
    }
  }
}

ID 1025=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#doFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Process the event, using the security manager if the option is enabled.
 * @param event the event to process
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet exception occurs
 */
@Override public void doFilterEvent(CometEvent event) throws IOException, ServletException {
  if (Globals.IS_SECURITY_ENABLED) {
    final CometEvent ev=event;
    try {
      java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws ServletException, IOException {
          internalDoFilterEvent(ev);
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException pe) {
      Exception e=pe.getException();
      if (e instanceof ServletException)       throw (ServletException)e;
 else       if (e instanceof IOException)       throw (IOException)e;
 else       if (e instanceof RuntimeException)       throw (RuntimeException)e;
 else       throw new ServletException(e.getMessage(),e);
    }
  }
 else {
    internalDoFilterEvent(event);
  }
}

ID 1028=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.core.ApplicationFilterConfig#getFilter()
parentException: RuntimeException 
thrown: ClassCastException
exception comment: /** 
 * Thrown to indicate that the code has attempted to cast an object to a subclass of which it is not an instance. For example, the following code generates a <code>ClassCastException</code>: <blockquote><pre> Object x = new Integer(0); System.out.println((String)x); </pre></blockquote>
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1032=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.core.ApplicationFilterConfig#getFilter()
parentException: 
thrown: ServletException
exception comment: null
block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1035=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.security.SecurityUtil#doAsPrivilege(java.lang.String, javax.servlet.Filter, Class<?>[], java.lang.Object[], java.security.Principal)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1036=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.comet.CometFilter#doFilterEvent(org.apache.catalina.comet.CometEvent, org.apache.catalina.comet.CometFilterChain)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1037=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.comet.CometFilter#doFilterEvent(org.apache.catalina.comet.CometEvent, org.apache.catalina.comet.CometFilterChain)
parentException: 
thrown: ServletException
exception comment: null
block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1038=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.security.SecurityUtil#doAsPrivilege(java.lang.String, javax.servlet.Servlet, Class<?>[], java.lang.Object[], java.security.Principal)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1039=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.comet.CometProcessor#event(org.apache.catalina.comet.CometEvent)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1040=========================================================================type: 1
Method:org.apache.catalina.core.ApplicationFilterChain#internalDoFilterEvent(org.apache.catalina.comet.CometEvent)
Rmethod: org.apache.catalina.comet.CometProcessor#event(org.apache.catalina.comet.CometEvent)
parentException: 
thrown: ServletException
exception comment: null
block: 
private void internalDoFilterEvent(CometEvent event) throws IOException, ServletException {
  if (pos < n) {
    ApplicationFilterConfig filterConfig=filters[pos++];
    CometFilter filter=null;
    try {
      filter=(CometFilter)filterConfig.getFilter();
      if (Globals.IS_SECURITY_ENABLED) {
        final CometEvent ev=event;
        Principal principal=ev.getHttpServletRequest().getUserPrincipal();
        Object[] args=new Object[]{ev,this};
        SecurityUtil.doAsPrivilege("doFilterEvent",filter,cometClassType,args,principal);
      }
 else {
        filter.doFilterEvent(event,this);
      }
    }
 catch (    IOException e) {
      throw e;
    }
catch (    ServletException e) {
      throw e;
    }
catch (    RuntimeException e) {
      throw e;
    }
catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      throw new ServletException(sm.getString("filterChain.filter"),e);
    }
    return;
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      final CometEvent ev=event;
      Principal principal=ev.getHttpServletRequest().getUserPrincipal();
      Object[] args=new Object[]{ev};
      SecurityUtil.doAsPrivilege("event",servlet,classTypeUsedInEvent,args,principal);
    }
 else {
      ((CometProcessor)servlet).event(event);
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(sm.getString("filterChain.servlet"),e);
  }
}

ID 1048=========================================================================type: 1
Method:org.apache.catalina.valves.RemoteIpValve#setPorts(org.apache.catalina.connector.Request, int)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
private void setPorts(Request request,int defaultPort){
  int port=defaultPort;
  if (portHeader != null) {
    String portHeaderValue=request.getHeader(portHeader);
    if (portHeaderValue != null) {
      try {
        port=Integer.parseInt(portHeaderValue);
      }
 catch (      NumberFormatException nfe) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("remoteIpValve.invalidPortHeader",portHeaderValue,portHeader),nfe);
        }
      }
    }
  }
  request.setServerPort(port);
  if (changeLocalPort) {
    request.setLocalPort(port);
  }
}

ID 1058=========================================================================type: 1
Method:org.apache.catalina.valves.MonitoredThread#markAsDone()
Rmethod: java.util.concurrent.Semaphore#acquire()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
public MonitoredThreadState markAsDone(){
  int val=this.state.getAndSet(MonitoredThreadState.DONE.ordinal());
  MonitoredThreadState threadState=MonitoredThreadState.values()[val];
  if (threadState == MonitoredThreadState.STUCK && interruptionSemaphore != null) {
    try {
      this.interruptionSemaphore.acquire();
    }
 catch (    InterruptedException e) {
      log.debug("thread interrupted after the request is finished, ignoring",e);
    }
  }
  return threadState;
}

ID 1063=========================================================================type: 1
Method:org.apache.catalina.valves.SSLValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: java.security.cert.CertificateFactory#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: CertificateException
exception comment: /** 
 * This exception indicates one of a variety of certificate problems. <p><em>Note: The classes in the package  {@code javax.security.cert}exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE). New applications should instead use the standard Java SE certificate classes located in {@code java.security.cert}.</em></p>
 * @author Hemma Prafullchandra
 * @since 1.4
 * @see Certificate
 */

block: 
@Override public void invoke(Request request,Response response) throws IOException, ServletException {
  String strcert0=mygetHeader(request,sslClientCertHeader);
  if (strcert0 != null && strcert0.length() > 28) {
    String strcert1=strcert0.replace(' ','\n');
    String strcert2=strcert1.substring(28,strcert1.length() - 26);
    String strcert3="-----BEGIN CERTIFICATE-----\n";
    String strcert4=strcert3.concat(strcert2);
    String strcerts=strcert4.concat("\n-----END CERTIFICATE-----\n");
    ByteArrayInputStream bais=new ByteArrayInputStream(strcerts.getBytes(Charset.defaultCharset()));
    X509Certificate jsseCerts[]=null;
    String providerName=(String)request.getConnector().getProperty("clientCertProvider");
    try {
      CertificateFactory cf;
      if (providerName == null) {
        cf=CertificateFactory.getInstance("X.509");
      }
 else {
        cf=CertificateFactory.getInstance("X.509",providerName);
      }
      X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
      jsseCerts=new X509Certificate[1];
      jsseCerts[0]=cert;
    }
 catch (    java.security.cert.CertificateException e) {
      log.warn(sm.getString("sslValve.certError",strcerts),e);
    }
catch (    NoSuchProviderException e) {
      log.error(sm.getString("sslValve.invalidProvider",providerName),e);
    }
    request.setAttribute(Globals.CERTIFICATES_ATTR,jsseCerts);
  }
  strcert0=mygetHeader(request,sslCipherHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.CIPHER_SUITE_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslSessionIdHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.SSL_SESSION_ID_ATTR,strcert0);
    request.setAttribute(Globals.SSL_SESSION_ID_TOMCAT_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslCipherUserKeySizeHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.KEY_SIZE_ATTR,Integer.valueOf(strcert0));
  }
  getNext().invoke(request,response);
}

ID 1064=========================================================================type: 1
Method:org.apache.catalina.valves.SSLValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: java.security.cert.CertificateFactory#getInstance(java.lang.String, java.lang.String)
parentException: GeneralSecurityException 
thrown: CertificateException
exception comment: /** 
 * This exception indicates one of a variety of certificate problems. <p><em>Note: The classes in the package  {@code javax.security.cert}exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE). New applications should instead use the standard Java SE certificate classes located in {@code java.security.cert}.</em></p>
 * @author Hemma Prafullchandra
 * @since 1.4
 * @see Certificate
 */

block: 
@Override public void invoke(Request request,Response response) throws IOException, ServletException {
  String strcert0=mygetHeader(request,sslClientCertHeader);
  if (strcert0 != null && strcert0.length() > 28) {
    String strcert1=strcert0.replace(' ','\n');
    String strcert2=strcert1.substring(28,strcert1.length() - 26);
    String strcert3="-----BEGIN CERTIFICATE-----\n";
    String strcert4=strcert3.concat(strcert2);
    String strcerts=strcert4.concat("\n-----END CERTIFICATE-----\n");
    ByteArrayInputStream bais=new ByteArrayInputStream(strcerts.getBytes(Charset.defaultCharset()));
    X509Certificate jsseCerts[]=null;
    String providerName=(String)request.getConnector().getProperty("clientCertProvider");
    try {
      CertificateFactory cf;
      if (providerName == null) {
        cf=CertificateFactory.getInstance("X.509");
      }
 else {
        cf=CertificateFactory.getInstance("X.509",providerName);
      }
      X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
      jsseCerts=new X509Certificate[1];
      jsseCerts[0]=cert;
    }
 catch (    java.security.cert.CertificateException e) {
      log.warn(sm.getString("sslValve.certError",strcerts),e);
    }
catch (    NoSuchProviderException e) {
      log.error(sm.getString("sslValve.invalidProvider",providerName),e);
    }
    request.setAttribute(Globals.CERTIFICATES_ATTR,jsseCerts);
  }
  strcert0=mygetHeader(request,sslCipherHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.CIPHER_SUITE_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslSessionIdHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.SSL_SESSION_ID_ATTR,strcert0);
    request.setAttribute(Globals.SSL_SESSION_ID_TOMCAT_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslCipherUserKeySizeHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.KEY_SIZE_ATTR,Integer.valueOf(strcert0));
  }
  getNext().invoke(request,response);
}

ID 1065=========================================================================type: 1
Method:org.apache.catalina.valves.SSLValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: java.security.cert.CertificateFactory#getInstance(java.lang.String, java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchProviderException
exception comment: /** 
 * This exception is thrown when a particular security provider is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
@Override public void invoke(Request request,Response response) throws IOException, ServletException {
  String strcert0=mygetHeader(request,sslClientCertHeader);
  if (strcert0 != null && strcert0.length() > 28) {
    String strcert1=strcert0.replace(' ','\n');
    String strcert2=strcert1.substring(28,strcert1.length() - 26);
    String strcert3="-----BEGIN CERTIFICATE-----\n";
    String strcert4=strcert3.concat(strcert2);
    String strcerts=strcert4.concat("\n-----END CERTIFICATE-----\n");
    ByteArrayInputStream bais=new ByteArrayInputStream(strcerts.getBytes(Charset.defaultCharset()));
    X509Certificate jsseCerts[]=null;
    String providerName=(String)request.getConnector().getProperty("clientCertProvider");
    try {
      CertificateFactory cf;
      if (providerName == null) {
        cf=CertificateFactory.getInstance("X.509");
      }
 else {
        cf=CertificateFactory.getInstance("X.509",providerName);
      }
      X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
      jsseCerts=new X509Certificate[1];
      jsseCerts[0]=cert;
    }
 catch (    java.security.cert.CertificateException e) {
      log.warn(sm.getString("sslValve.certError",strcerts),e);
    }
catch (    NoSuchProviderException e) {
      log.error(sm.getString("sslValve.invalidProvider",providerName),e);
    }
    request.setAttribute(Globals.CERTIFICATES_ATTR,jsseCerts);
  }
  strcert0=mygetHeader(request,sslCipherHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.CIPHER_SUITE_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslSessionIdHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.SSL_SESSION_ID_ATTR,strcert0);
    request.setAttribute(Globals.SSL_SESSION_ID_TOMCAT_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslCipherUserKeySizeHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.KEY_SIZE_ATTR,Integer.valueOf(strcert0));
  }
  getNext().invoke(request,response);
}

ID 1066=========================================================================type: 1
Method:org.apache.catalina.valves.SSLValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: java.security.cert.CertificateFactory#generateCertificate(java.io.InputStream)
parentException: GeneralSecurityException 
thrown: CertificateException
exception comment: /** 
 * This exception indicates one of a variety of certificate problems. <p><em>Note: The classes in the package  {@code javax.security.cert}exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE). New applications should instead use the standard Java SE certificate classes located in {@code java.security.cert}.</em></p>
 * @author Hemma Prafullchandra
 * @since 1.4
 * @see Certificate
 */

block: 
@Override public void invoke(Request request,Response response) throws IOException, ServletException {
  String strcert0=mygetHeader(request,sslClientCertHeader);
  if (strcert0 != null && strcert0.length() > 28) {
    String strcert1=strcert0.replace(' ','\n');
    String strcert2=strcert1.substring(28,strcert1.length() - 26);
    String strcert3="-----BEGIN CERTIFICATE-----\n";
    String strcert4=strcert3.concat(strcert2);
    String strcerts=strcert4.concat("\n-----END CERTIFICATE-----\n");
    ByteArrayInputStream bais=new ByteArrayInputStream(strcerts.getBytes(Charset.defaultCharset()));
    X509Certificate jsseCerts[]=null;
    String providerName=(String)request.getConnector().getProperty("clientCertProvider");
    try {
      CertificateFactory cf;
      if (providerName == null) {
        cf=CertificateFactory.getInstance("X.509");
      }
 else {
        cf=CertificateFactory.getInstance("X.509",providerName);
      }
      X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
      jsseCerts=new X509Certificate[1];
      jsseCerts[0]=cert;
    }
 catch (    java.security.cert.CertificateException e) {
      log.warn(sm.getString("sslValve.certError",strcerts),e);
    }
catch (    NoSuchProviderException e) {
      log.error(sm.getString("sslValve.invalidProvider",providerName),e);
    }
    request.setAttribute(Globals.CERTIFICATES_ATTR,jsseCerts);
  }
  strcert0=mygetHeader(request,sslCipherHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.CIPHER_SUITE_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslSessionIdHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.SSL_SESSION_ID_ATTR,strcert0);
    request.setAttribute(Globals.SSL_SESSION_ID_TOMCAT_ATTR,strcert0);
  }
  strcert0=mygetHeader(request,sslCipherUserKeySizeHeader);
  if (strcert0 != null) {
    request.setAttribute(Globals.KEY_SIZE_ATTR,Integer.valueOf(strcert0));
  }
  getNext().invoke(request,response);
}

ID 1074=========================================================================type: 1
Method:org.apache.catalina.valves.SemaphoreValve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
Rmethod: java.util.concurrent.Semaphore#acquire()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Do concurrency control on the request using the semaphore.
 * @param request The servlet request to be processed
 * @param response The servlet response to be created
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet error occurs
 */
@Override public void invoke(Request request,Response response) throws IOException, ServletException {
  if (controlConcurrency(request,response)) {
    boolean shouldRelease=true;
    try {
      if (block) {
        if (interruptible) {
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException e) {
            shouldRelease=false;
            permitDenied(request,response);
            return;
          }
        }
 else {
          semaphore.acquireUninterruptibly();
        }
      }
 else {
        if (!semaphore.tryAcquire()) {
          shouldRelease=false;
          permitDenied(request,response);
          return;
        }
      }
      getNext().invoke(request,response);
    }
  finally {
      if (shouldRelease) {
        semaphore.release();
      }
    }
  }
 else {
    getNext().invoke(request,response);
  }
}

ID 1083=========================================================================type: 1
Method:org.apache.catalina.valves.CometConnectionManagerValve#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.catalina.connector.CometEventImpl#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.BEFORE_STOP_EVENT.equals(event.getType())) {
    Iterator<Request> iterator=cometRequests.iterator();
    while (iterator.hasNext()) {
      Request request=iterator.next();
      HttpSession session=request.getSession(false);
      if (session != null) {
        session.removeAttribute(cometRequestsAttribute);
      }
      CometEventImpl cometEvent=request.getEvent();
      try {
        cometEvent.setEventType(CometEvent.EventType.END);
        cometEvent.setEventSubType(CometEvent.EventSubType.WEBAPP_RELOAD);
        getNext().event(request,request.getResponse(),cometEvent);
      }
 catch (      Exception e) {
        container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"),e);
      }
 finally {
        try {
          cometEvent.close();
        }
 catch (        IOException e) {
          container.getLogger().warn(sm.getString("cometConnectionManagerValve.event"),e);
        }
      }
    }
    cometRequests.clear();
  }
}

ID 1110=========================================================================type: 1
Method:org.apache.catalina.valves.AccessLogValve#open()
Rmethod: org.apache.tomcat.util.buf.B2CConverter#getCharset(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Open the new log file for the date specified by <code>dateStamp</code>.
 */
protected synchronized void open(){
  File pathname=getLogFile(rotatable && !renameOnRotate);
  Charset charset=null;
  if (encoding != null) {
    try {
      charset=B2CConverter.getCharset(encoding);
    }
 catch (    UnsupportedEncodingException ex) {
      log.error(sm.getString("accessLogValve.unsupportedEncoding",encoding),ex);
    }
  }
  if (charset == null) {
    charset=Charset.defaultCharset();
  }
  try {
    writer=new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(pathname,true),charset),128000),false);
    currentLogFile=pathname;
  }
 catch (  IOException e) {
    writer=null;
    currentLogFile=null;
    log.error(sm.getString("accessLogValve.openFail",pathname),e);
  }
}

ID 1111=========================================================================type: 1
Method:org.apache.catalina.valves.AccessLogValve#open()
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File, boolean)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Open the new log file for the date specified by <code>dateStamp</code>.
 */
protected synchronized void open(){
  File pathname=getLogFile(rotatable && !renameOnRotate);
  Charset charset=null;
  if (encoding != null) {
    try {
      charset=B2CConverter.getCharset(encoding);
    }
 catch (    UnsupportedEncodingException ex) {
      log.error(sm.getString("accessLogValve.unsupportedEncoding",encoding),ex);
    }
  }
  if (charset == null) {
    charset=Charset.defaultCharset();
  }
  try {
    writer=new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(pathname,true),charset),128000),false);
    currentLogFile=pathname;
  }
 catch (  IOException e) {
    writer=null;
    currentLogFile=null;
    log.error(sm.getString("accessLogValve.openFail",pathname),e);
  }
}

ID 1116=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#log(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, long)
Rmethod: org.apache.catalina.valves.JDBCAccessLogValve#open()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
@Override public void log(Request request,Response response,long time){
  if (!getState().isAvailable()) {
    return;
  }
  final String EMPTY="";
  String remoteHost;
  if (resolveHosts) {
    if (requestAttributesEnabled) {
      Object host=request.getAttribute(REMOTE_HOST_ATTRIBUTE);
      if (host == null) {
        remoteHost=request.getRemoteHost();
      }
 else {
        remoteHost=(String)host;
      }
    }
 else {
      remoteHost=request.getRemoteHost();
    }
  }
 else {
    if (requestAttributesEnabled) {
      Object addr=request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
      if (addr == null) {
        remoteHost=request.getRemoteAddr();
      }
 else {
        remoteHost=(String)addr;
      }
    }
 else {
      remoteHost=request.getRemoteAddr();
    }
  }
  String user=request.getRemoteUser();
  String query=request.getRequestURI();
  long bytes=response.getBytesWritten(true);
  if (bytes < 0) {
    bytes=0;
  }
  int status=response.getStatus();
  String virtualHost=EMPTY;
  String method=EMPTY;
  String referer=EMPTY;
  String userAgent=EMPTY;
  String logPattern=pattern;
  if (logPattern.equals("combined")) {
    virtualHost=request.getServerName();
    method=request.getMethod();
    referer=request.getHeader("referer");
    userAgent=request.getHeader("user-agent");
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      try {
        open();
        ps.setString(1,remoteHost);
        ps.setString(2,user);
        ps.setTimestamp(3,new Timestamp(getCurrentTimeMillis()));
        ps.setString(4,query);
        ps.setInt(5,status);
        if (useLongContentLength) {
          ps.setLong(6,bytes);
        }
 else {
          if (bytes > Integer.MAX_VALUE) {
            bytes=-1;
          }
          ps.setInt(6,(int)bytes);
        }
        if (logPattern.equals("combined")) {
          ps.setString(7,virtualHost);
          ps.setString(8,method);
          ps.setString(9,referer);
          ps.setString(10,userAgent);
        }
        ps.executeUpdate();
        return;
      }
 catch (      SQLException e) {
        container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"),e);
        if (conn != null) {
          close();
        }
      }
      numberOfTries--;
    }
  }
}

ID 1117=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#log(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, long)
Rmethod: java.sql.PreparedStatement#setString(int, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
@Override public void log(Request request,Response response,long time){
  if (!getState().isAvailable()) {
    return;
  }
  final String EMPTY="";
  String remoteHost;
  if (resolveHosts) {
    if (requestAttributesEnabled) {
      Object host=request.getAttribute(REMOTE_HOST_ATTRIBUTE);
      if (host == null) {
        remoteHost=request.getRemoteHost();
      }
 else {
        remoteHost=(String)host;
      }
    }
 else {
      remoteHost=request.getRemoteHost();
    }
  }
 else {
    if (requestAttributesEnabled) {
      Object addr=request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
      if (addr == null) {
        remoteHost=request.getRemoteAddr();
      }
 else {
        remoteHost=(String)addr;
      }
    }
 else {
      remoteHost=request.getRemoteAddr();
    }
  }
  String user=request.getRemoteUser();
  String query=request.getRequestURI();
  long bytes=response.getBytesWritten(true);
  if (bytes < 0) {
    bytes=0;
  }
  int status=response.getStatus();
  String virtualHost=EMPTY;
  String method=EMPTY;
  String referer=EMPTY;
  String userAgent=EMPTY;
  String logPattern=pattern;
  if (logPattern.equals("combined")) {
    virtualHost=request.getServerName();
    method=request.getMethod();
    referer=request.getHeader("referer");
    userAgent=request.getHeader("user-agent");
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      try {
        open();
        ps.setString(1,remoteHost);
        ps.setString(2,user);
        ps.setTimestamp(3,new Timestamp(getCurrentTimeMillis()));
        ps.setString(4,query);
        ps.setInt(5,status);
        if (useLongContentLength) {
          ps.setLong(6,bytes);
        }
 else {
          if (bytes > Integer.MAX_VALUE) {
            bytes=-1;
          }
          ps.setInt(6,(int)bytes);
        }
        if (logPattern.equals("combined")) {
          ps.setString(7,virtualHost);
          ps.setString(8,method);
          ps.setString(9,referer);
          ps.setString(10,userAgent);
        }
        ps.executeUpdate();
        return;
      }
 catch (      SQLException e) {
        container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"),e);
        if (conn != null) {
          close();
        }
      }
      numberOfTries--;
    }
  }
}

ID 1118=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#log(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, long)
Rmethod: java.sql.PreparedStatement#setTimestamp(int, java.sql.Timestamp)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
@Override public void log(Request request,Response response,long time){
  if (!getState().isAvailable()) {
    return;
  }
  final String EMPTY="";
  String remoteHost;
  if (resolveHosts) {
    if (requestAttributesEnabled) {
      Object host=request.getAttribute(REMOTE_HOST_ATTRIBUTE);
      if (host == null) {
        remoteHost=request.getRemoteHost();
      }
 else {
        remoteHost=(String)host;
      }
    }
 else {
      remoteHost=request.getRemoteHost();
    }
  }
 else {
    if (requestAttributesEnabled) {
      Object addr=request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
      if (addr == null) {
        remoteHost=request.getRemoteAddr();
      }
 else {
        remoteHost=(String)addr;
      }
    }
 else {
      remoteHost=request.getRemoteAddr();
    }
  }
  String user=request.getRemoteUser();
  String query=request.getRequestURI();
  long bytes=response.getBytesWritten(true);
  if (bytes < 0) {
    bytes=0;
  }
  int status=response.getStatus();
  String virtualHost=EMPTY;
  String method=EMPTY;
  String referer=EMPTY;
  String userAgent=EMPTY;
  String logPattern=pattern;
  if (logPattern.equals("combined")) {
    virtualHost=request.getServerName();
    method=request.getMethod();
    referer=request.getHeader("referer");
    userAgent=request.getHeader("user-agent");
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      try {
        open();
        ps.setString(1,remoteHost);
        ps.setString(2,user);
        ps.setTimestamp(3,new Timestamp(getCurrentTimeMillis()));
        ps.setString(4,query);
        ps.setInt(5,status);
        if (useLongContentLength) {
          ps.setLong(6,bytes);
        }
 else {
          if (bytes > Integer.MAX_VALUE) {
            bytes=-1;
          }
          ps.setInt(6,(int)bytes);
        }
        if (logPattern.equals("combined")) {
          ps.setString(7,virtualHost);
          ps.setString(8,method);
          ps.setString(9,referer);
          ps.setString(10,userAgent);
        }
        ps.executeUpdate();
        return;
      }
 catch (      SQLException e) {
        container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"),e);
        if (conn != null) {
          close();
        }
      }
      numberOfTries--;
    }
  }
}

ID 1119=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#log(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, long)
Rmethod: java.sql.PreparedStatement#setInt(int, int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
@Override public void log(Request request,Response response,long time){
  if (!getState().isAvailable()) {
    return;
  }
  final String EMPTY="";
  String remoteHost;
  if (resolveHosts) {
    if (requestAttributesEnabled) {
      Object host=request.getAttribute(REMOTE_HOST_ATTRIBUTE);
      if (host == null) {
        remoteHost=request.getRemoteHost();
      }
 else {
        remoteHost=(String)host;
      }
    }
 else {
      remoteHost=request.getRemoteHost();
    }
  }
 else {
    if (requestAttributesEnabled) {
      Object addr=request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
      if (addr == null) {
        remoteHost=request.getRemoteAddr();
      }
 else {
        remoteHost=(String)addr;
      }
    }
 else {
      remoteHost=request.getRemoteAddr();
    }
  }
  String user=request.getRemoteUser();
  String query=request.getRequestURI();
  long bytes=response.getBytesWritten(true);
  if (bytes < 0) {
    bytes=0;
  }
  int status=response.getStatus();
  String virtualHost=EMPTY;
  String method=EMPTY;
  String referer=EMPTY;
  String userAgent=EMPTY;
  String logPattern=pattern;
  if (logPattern.equals("combined")) {
    virtualHost=request.getServerName();
    method=request.getMethod();
    referer=request.getHeader("referer");
    userAgent=request.getHeader("user-agent");
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      try {
        open();
        ps.setString(1,remoteHost);
        ps.setString(2,user);
        ps.setTimestamp(3,new Timestamp(getCurrentTimeMillis()));
        ps.setString(4,query);
        ps.setInt(5,status);
        if (useLongContentLength) {
          ps.setLong(6,bytes);
        }
 else {
          if (bytes > Integer.MAX_VALUE) {
            bytes=-1;
          }
          ps.setInt(6,(int)bytes);
        }
        if (logPattern.equals("combined")) {
          ps.setString(7,virtualHost);
          ps.setString(8,method);
          ps.setString(9,referer);
          ps.setString(10,userAgent);
        }
        ps.executeUpdate();
        return;
      }
 catch (      SQLException e) {
        container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"),e);
        if (conn != null) {
          close();
        }
      }
      numberOfTries--;
    }
  }
}

ID 1120=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#log(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, long)
Rmethod: java.sql.PreparedStatement#setLong(int, long)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
@Override public void log(Request request,Response response,long time){
  if (!getState().isAvailable()) {
    return;
  }
  final String EMPTY="";
  String remoteHost;
  if (resolveHosts) {
    if (requestAttributesEnabled) {
      Object host=request.getAttribute(REMOTE_HOST_ATTRIBUTE);
      if (host == null) {
        remoteHost=request.getRemoteHost();
      }
 else {
        remoteHost=(String)host;
      }
    }
 else {
      remoteHost=request.getRemoteHost();
    }
  }
 else {
    if (requestAttributesEnabled) {
      Object addr=request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
      if (addr == null) {
        remoteHost=request.getRemoteAddr();
      }
 else {
        remoteHost=(String)addr;
      }
    }
 else {
      remoteHost=request.getRemoteAddr();
    }
  }
  String user=request.getRemoteUser();
  String query=request.getRequestURI();
  long bytes=response.getBytesWritten(true);
  if (bytes < 0) {
    bytes=0;
  }
  int status=response.getStatus();
  String virtualHost=EMPTY;
  String method=EMPTY;
  String referer=EMPTY;
  String userAgent=EMPTY;
  String logPattern=pattern;
  if (logPattern.equals("combined")) {
    virtualHost=request.getServerName();
    method=request.getMethod();
    referer=request.getHeader("referer");
    userAgent=request.getHeader("user-agent");
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      try {
        open();
        ps.setString(1,remoteHost);
        ps.setString(2,user);
        ps.setTimestamp(3,new Timestamp(getCurrentTimeMillis()));
        ps.setString(4,query);
        ps.setInt(5,status);
        if (useLongContentLength) {
          ps.setLong(6,bytes);
        }
 else {
          if (bytes > Integer.MAX_VALUE) {
            bytes=-1;
          }
          ps.setInt(6,(int)bytes);
        }
        if (logPattern.equals("combined")) {
          ps.setString(7,virtualHost);
          ps.setString(8,method);
          ps.setString(9,referer);
          ps.setString(10,userAgent);
        }
        ps.executeUpdate();
        return;
      }
 catch (      SQLException e) {
        container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"),e);
        if (conn != null) {
          close();
        }
      }
      numberOfTries--;
    }
  }
}

ID 1121=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#log(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response, long)
Rmethod: java.sql.PreparedStatement#executeUpdate()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
@Override public void log(Request request,Response response,long time){
  if (!getState().isAvailable()) {
    return;
  }
  final String EMPTY="";
  String remoteHost;
  if (resolveHosts) {
    if (requestAttributesEnabled) {
      Object host=request.getAttribute(REMOTE_HOST_ATTRIBUTE);
      if (host == null) {
        remoteHost=request.getRemoteHost();
      }
 else {
        remoteHost=(String)host;
      }
    }
 else {
      remoteHost=request.getRemoteHost();
    }
  }
 else {
    if (requestAttributesEnabled) {
      Object addr=request.getAttribute(REMOTE_ADDR_ATTRIBUTE);
      if (addr == null) {
        remoteHost=request.getRemoteAddr();
      }
 else {
        remoteHost=(String)addr;
      }
    }
 else {
      remoteHost=request.getRemoteAddr();
    }
  }
  String user=request.getRemoteUser();
  String query=request.getRequestURI();
  long bytes=response.getBytesWritten(true);
  if (bytes < 0) {
    bytes=0;
  }
  int status=response.getStatus();
  String virtualHost=EMPTY;
  String method=EMPTY;
  String referer=EMPTY;
  String userAgent=EMPTY;
  String logPattern=pattern;
  if (logPattern.equals("combined")) {
    virtualHost=request.getServerName();
    method=request.getMethod();
    referer=request.getHeader("referer");
    userAgent=request.getHeader("user-agent");
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      try {
        open();
        ps.setString(1,remoteHost);
        ps.setString(2,user);
        ps.setTimestamp(3,new Timestamp(getCurrentTimeMillis()));
        ps.setString(4,query);
        ps.setInt(5,status);
        if (useLongContentLength) {
          ps.setLong(6,bytes);
        }
 else {
          if (bytes > Integer.MAX_VALUE) {
            bytes=-1;
          }
          ps.setInt(6,(int)bytes);
        }
        if (logPattern.equals("combined")) {
          ps.setString(7,virtualHost);
          ps.setString(8,method);
          ps.setString(9,referer);
          ps.setString(10,userAgent);
        }
        ps.executeUpdate();
        return;
      }
 catch (      SQLException e) {
        container.getLogger().error(sm.getString("jdbcAccessLogValve.exception"),e);
        if (conn != null) {
          close();
        }
      }
      numberOfTries--;
    }
  }
}

ID 1129=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#close()
Rmethod: java.sql.Connection#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 */
protected void close(){
  if (conn == null) {
    return;
  }
  try {
    ps.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.ps=null;
  try {
    conn.close();
  }
 catch (  SQLException e) {
    container.getLogger().error(sm.getString("jdbcAccessLogValve.close"),e);
  }
 finally {
    this.conn=null;
  }
}

ID 1130=========================================================================type: 1
Method:org.apache.catalina.valves.JDBCAccessLogValve#startInternal()
Rmethod: org.apache.catalina.valves.JDBCAccessLogValve#open()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Start this component and implement the requirements of  {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected synchronized void startInternal() throws LifecycleException {
  try {
    open();
  }
 catch (  SQLException e) {
    throw new LifecycleException(e);
  }
  setState(LifecycleState.STARTING);
}

ID 1133=========================================================================type: 1
Method:org.apache.catalina.valves.RequestParameterElement#urlEncode(java.lang.String)
Rmethod: java.net.URLEncoder#encode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * urlEncode the given string. If null or empty, return null.
 */
private String urlEncode(String value){
  if (null == value || value.length() == 0) {
    return null;
  }
  try {
    return URLEncoder.encode(value,"UTF-8");
  }
 catch (  UnsupportedEncodingException e) {
    return null;
  }
}

ID 1176=========================================================================type: 1
Method:org.apache.catalina.util.LifecycleBase#destroy()
Rmethod: org.apache.catalina.util.LifecycleBase#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
@Override public final synchronized void destroy() throws LifecycleException {
  if (LifecycleState.FAILED.equals(state)) {
    try {
      stop();
    }
 catch (    LifecycleException e) {
      log.warn(sm.getString("lifecycleBase.destroyStopFail",toString()),e);
    }
  }
  if (LifecycleState.DESTROYING.equals(state) || LifecycleState.DESTROYED.equals(state)) {
    if (log.isDebugEnabled()) {
      Exception e=new LifecycleException();
      log.debug(sm.getString("lifecycleBase.alreadyDestroyed",toString()),e);
    }
 else     if (log.isInfoEnabled() && !(this instanceof Lifecycle.SingleUse)) {
      log.info(sm.getString("lifecycleBase.alreadyDestroyed",toString()));
    }
    return;
  }
  if (!state.equals(LifecycleState.STOPPED) && !state.equals(LifecycleState.FAILED) && !state.equals(LifecycleState.NEW)&& !state.equals(LifecycleState.INITIALIZED)) {
    invalidTransition(Lifecycle.BEFORE_DESTROY_EVENT);
  }
  try {
    setStateInternal(LifecycleState.DESTROYING,null,false);
    destroyInternal();
    setStateInternal(LifecycleState.DESTROYED,null,false);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    setStateInternal(LifecycleState.FAILED,null,false);
    throw new LifecycleException(sm.getString("lifecycleBase.destroyFail",toString()),t);
  }
}

ID 1183=========================================================================type: 1
Method:org.apache.catalina.util.LifecycleMBeanBase#register(java.lang.Object, java.lang.String)
Rmethod: javax.management.ObjectName#ObjectName(java.lang.String)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Utility method to enable sub-classes to easily register additional components that don't implement  {@link MBeanRegistration} withan MBean server.<br/> Note: This method should only be used once  {@link #initInternal()} hasbeen called and before  {@link #destroyInternal()} has been called. 
 * @param obj                       The object the register
 * @param objectNameKeyProperties   The key properties component of theobject name to use to register the object
 * @return  The name used to register the object
 */
protected final ObjectName register(Object obj,String objectNameKeyProperties){
  StringBuilder name=new StringBuilder(getDomain());
  name.append(':');
  name.append(objectNameKeyProperties);
  ObjectName on=null;
  try {
    on=new ObjectName(name.toString());
    Registry.getRegistry(null,null).registerComponent(obj,on,null);
  }
 catch (  MalformedObjectNameException e) {
    log.warn(sm.getString("lifecycleMBeanBase.registerFail",obj,name),e);
  }
catch (  Exception e) {
    log.warn(sm.getString("lifecycleMBeanBase.registerFail",obj,name),e);
  }
  return on;
}

ID 1184=========================================================================type: 1
Method:org.apache.catalina.util.LifecycleMBeanBase#register(java.lang.Object, java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Utility method to enable sub-classes to easily register additional components that don't implement  {@link MBeanRegistration} withan MBean server.<br/> Note: This method should only be used once  {@link #initInternal()} hasbeen called and before  {@link #destroyInternal()} has been called. 
 * @param obj                       The object the register
 * @param objectNameKeyProperties   The key properties component of theobject name to use to register the object
 * @return  The name used to register the object
 */
protected final ObjectName register(Object obj,String objectNameKeyProperties){
  StringBuilder name=new StringBuilder(getDomain());
  name.append(':');
  name.append(objectNameKeyProperties);
  ObjectName on=null;
  try {
    on=new ObjectName(name.toString());
    Registry.getRegistry(null,null).registerComponent(obj,on,null);
  }
 catch (  MalformedObjectNameException e) {
    log.warn(sm.getString("lifecycleMBeanBase.registerFail",obj,name),e);
  }
catch (  Exception e) {
    log.warn(sm.getString("lifecycleMBeanBase.registerFail",obj,name),e);
  }
  return on;
}

ID 1185=========================================================================type: 1
Method:org.apache.catalina.util.LifecycleMBeanBase#unregister(javax.management.ObjectName)
Rmethod: javax.management.MBeanServer#unregisterMBean(javax.management.ObjectName)
parentException: MBeanException JMException 
thrown: MBeanRegistrationException
exception comment: /** 
 * Wraps exceptions thrown by the preRegister(), preDeregister() methods of the <CODE>MBeanRegistration</CODE> interface.
 * @since 1.5
 */

block: 
/** 
 * Utility method to enable sub-classes to easily unregister additional components that don't implement  {@link MBeanRegistration} withan MBean server.<br/> Note: This method should only be used once  {@link #initInternal()} hasbeen called and before  {@link #destroyInternal()} has been called. 
 * @param on    The name of the component to unregister
 */
protected final void unregister(ObjectName on){
  if (on == null) {
    return;
  }
  if (mserver == null) {
    log.warn(sm.getString("lifecycleMBeanBase.unregisterNoServer",on));
    return;
  }
  try {
    mserver.unregisterMBean(on);
  }
 catch (  MBeanRegistrationException e) {
    log.warn(sm.getString("lifecycleMBeanBase.unregisterFail",on),e);
  }
catch (  InstanceNotFoundException e) {
    log.warn(sm.getString("lifecycleMBeanBase.unregisterFail",on),e);
  }
}

ID 1186=========================================================================type: 1
Method:org.apache.catalina.util.LifecycleMBeanBase#unregister(javax.management.ObjectName)
Rmethod: javax.management.MBeanServer#unregisterMBean(javax.management.ObjectName)
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Utility method to enable sub-classes to easily unregister additional components that don't implement  {@link MBeanRegistration} withan MBean server.<br/> Note: This method should only be used once  {@link #initInternal()} hasbeen called and before  {@link #destroyInternal()} has been called. 
 * @param on    The name of the component to unregister
 */
protected final void unregister(ObjectName on){
  if (on == null) {
    return;
  }
  if (mserver == null) {
    log.warn(sm.getString("lifecycleMBeanBase.unregisterNoServer",on));
    return;
  }
  try {
    mserver.unregisterMBean(on);
  }
 catch (  MBeanRegistrationException e) {
    log.warn(sm.getString("lifecycleMBeanBase.unregisterFail",on),e);
  }
catch (  InstanceNotFoundException e) {
    log.warn(sm.getString("lifecycleMBeanBase.unregisterFail",on),e);
  }
}

ID 1188=========================================================================type: 1
Method:org.apache.catalina.util.CustomObjectInputStream#resolveClass(java.io.ObjectStreamClass)
Rmethod: java.lang.Class#forName(java.lang.String, boolean, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Load the local class equivalent of the specified stream class description, by using the class loader assigned to this Context.
 * @param classDesc Class description from the input stream
 * @exception ClassNotFoundException if this class cannot be found
 * @exception IOException if an input/output error occurs
 */
@Override public Class<?> resolveClass(ObjectStreamClass classDesc) throws ClassNotFoundException, IOException {
  String name=classDesc.getName();
  if (allowedClassNamePattern != null) {
    boolean allowed=allowedClassNamePattern.matcher(name).matches();
    if (!allowed) {
      boolean doLog=warnOnFailure && reportedClasses.add(name);
      String msg=sm.getString("customObjectInputStream.nomatch",name,allowedClassNameFilter);
      if (doLog) {
        log.warn(msg);
      }
 else       if (log.isDebugEnabled()) {
        log.debug(msg);
      }
      throw new InvalidClassException(msg);
    }
  }
  try {
    return Class.forName(name,false,classLoader);
  }
 catch (  ClassNotFoundException e) {
    try {
      return super.resolveClass(classDesc);
    }
 catch (    ClassNotFoundException e2) {
      throw e;
    }
  }
}

ID 1190=========================================================================type: 1
Method:org.apache.catalina.util.CustomObjectInputStream#resolveProxyClass(java.lang.String[])
Rmethod: java.lang.reflect.Proxy#getProxyClass(java.lang.ClassLoader, Class<?>[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Return a proxy class that implements the interfaces named in a proxy class descriptor. Do this using the class loader assigned to this Context.
 */
@Override protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {
  Class<?>[] cinterfaces=new Class[interfaces.length];
  for (int i=0; i < interfaces.length; i++) {
    cinterfaces[i]=classLoader.loadClass(interfaces[i]);
  }
  try {
    return Proxy.getProxyClass(classLoader,cinterfaces);
  }
 catch (  IllegalArgumentException e) {
    throw new ClassNotFoundException(null,e);
  }
}

ID 1192=========================================================================type: 1
Method:org.apache.catalina.util.URLEncoder#encode(java.lang.String, java.lang.String)
Rmethod: java.io.OutputStreamWriter#write(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * URL encodes the provided path using the given encoding.
 * @param path      The path to encode
 * @param encoding  The encoding to use to convert the path to bytes
 * @return The encoded path
 */
public String encode(String path,String encoding){
  int maxBytesPerChar=10;
  StringBuilder rewrittenPath=new StringBuilder(path.length());
  ByteArrayOutputStream buf=new ByteArrayOutputStream(maxBytesPerChar);
  OutputStreamWriter writer=null;
  try {
    writer=new OutputStreamWriter(buf,encoding);
  }
 catch (  Exception e) {
    e.printStackTrace();
    writer=new OutputStreamWriter(buf);
  }
  for (int i=0; i < path.length(); i++) {
    int c=path.charAt(i);
    if (safeCharacters.get(c)) {
      rewrittenPath.append((char)c);
    }
 else {
      try {
        writer.write((char)c);
        writer.flush();
      }
 catch (      IOException e) {
        buf.reset();
        continue;
      }
      byte[] ba=buf.toByteArray();
      for (int j=0; j < ba.length; j++) {
        byte toEncode=ba[j];
        rewrittenPath.append('%');
        int low=toEncode & 0x0f;
        int high=(toEncode & 0xf0) >> 4;
        rewrittenPath.append(hexadecimal[high]);
        rewrittenPath.append(hexadecimal[low]);
      }
      buf.reset();
    }
  }
  return rewrittenPath.toString();
}

ID 1193=========================================================================type: 1
Method:org.apache.catalina.util.URLEncoder#encode(java.lang.String, java.lang.String)
Rmethod: java.io.OutputStreamWriter#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * URL encodes the provided path using the given encoding.
 * @param path      The path to encode
 * @param encoding  The encoding to use to convert the path to bytes
 * @return The encoded path
 */
public String encode(String path,String encoding){
  int maxBytesPerChar=10;
  StringBuilder rewrittenPath=new StringBuilder(path.length());
  ByteArrayOutputStream buf=new ByteArrayOutputStream(maxBytesPerChar);
  OutputStreamWriter writer=null;
  try {
    writer=new OutputStreamWriter(buf,encoding);
  }
 catch (  Exception e) {
    e.printStackTrace();
    writer=new OutputStreamWriter(buf);
  }
  for (int i=0; i < path.length(); i++) {
    int c=path.charAt(i);
    if (safeCharacters.get(c)) {
      rewrittenPath.append((char)c);
    }
 else {
      try {
        writer.write((char)c);
        writer.flush();
      }
 catch (      IOException e) {
        buf.reset();
        continue;
      }
      byte[] ba=buf.toByteArray();
      for (int j=0; j < ba.length; j++) {
        byte toEncode=ba[j];
        rewrittenPath.append('%');
        int low=toEncode & 0x0f;
        int high=(toEncode & 0xf0) >> 4;
        rewrittenPath.append(hexadecimal[high]);
        rewrittenPath.append(hexadecimal[low]);
      }
      buf.reset();
    }
  }
  return rewrittenPath.toString();
}

ID 1202=========================================================================type: 1
Method:org.apache.catalina.util.ExtensionValidator#validateApplication(javax.naming.directory.DirContext, org.apache.catalina.Context)
Rmethod: org.apache.naming.resources.Resource#streamContent()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Runtime validation of a Web Application. This method uses JNDI to look up the resources located under a  <code>DirContext</code>. It locates Web Application MANIFEST.MF  file in the /META-INF/ directory of the application and all  MANIFEST.MF files in each JAR file located in the WEB-INF/lib  directory and creates an <code>ArrayList</code> of  <code>ManifestResorce<code> objects. These objects are then passed  to the validateManifestResources method for validation.
 * @param dirContext The JNDI root of the Web Application
 * @param context The context from which the Logger and path to theapplication
 * @return true if all required extensions satisfied
 */
public static synchronized boolean validateApplication(DirContext dirContext,Context context) throws IOException {
  String appName=context.getName();
  ArrayList<ManifestResource> appManifestResources=new ArrayList<ManifestResource>();
  if (dirContext == null)   return false;
  InputStream inputStream=null;
  try {
    NamingEnumeration<Binding> wne=dirContext.listBindings("/META-INF/");
    Binding binding=wne.nextElement();
    if (binding.getName().toUpperCase(Locale.ENGLISH).equals("MANIFEST.MF")) {
      Resource resource=(Resource)dirContext.lookup("/META-INF/" + binding.getName());
      inputStream=resource.streamContent();
      Manifest manifest=new Manifest(inputStream);
      inputStream.close();
      inputStream=null;
      ManifestResource mre=new ManifestResource(sm.getString("extensionValidator.web-application-manifest"),manifest,ManifestResource.WAR);
      appManifestResources.add(mre);
    }
  }
 catch (  NamingException nex) {
  }
catch (  NoSuchElementException nse) {
  }
 finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
    }
  }
  NamingEnumeration<Binding> ne=null;
  String jarName=null;
  try {
    ne=dirContext.listBindings("WEB-INF/lib/");
    while ((ne != null) && ne.hasMoreElements()) {
      Binding binding=ne.nextElement();
      jarName=binding.getName();
      if (!jarName.toLowerCase(Locale.ENGLISH).endsWith(".jar")) {
        continue;
      }
      Object obj=dirContext.lookup("/WEB-INF/lib/" + jarName);
      if (!(obj instanceof Resource)) {
        continue;
      }
      Resource resource=(Resource)obj;
      inputStream=resource.streamContent();
      Manifest jmanifest=getManifest(inputStream);
      if (jmanifest != null) {
        ManifestResource mre=new ManifestResource(jarName,jmanifest,ManifestResource.APPLICATION);
        appManifestResources.add(mre);
      }
    }
  }
 catch (  NamingException nex) {
  }
catch (  IOException ioe) {
    throw new IOException("Jar: " + jarName,ioe);
  }
 finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
    }
  }
  return validateManifestResources(appName,appManifestResources);
}

ID 1203=========================================================================type: 1
Method:org.apache.catalina.util.ExtensionValidator#validateApplication(javax.naming.directory.DirContext, org.apache.catalina.Context)
Rmethod: org.apache.catalina.util.ExtensionValidator#getManifest(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Runtime validation of a Web Application. This method uses JNDI to look up the resources located under a  <code>DirContext</code>. It locates Web Application MANIFEST.MF  file in the /META-INF/ directory of the application and all  MANIFEST.MF files in each JAR file located in the WEB-INF/lib  directory and creates an <code>ArrayList</code> of  <code>ManifestResorce<code> objects. These objects are then passed  to the validateManifestResources method for validation.
 * @param dirContext The JNDI root of the Web Application
 * @param context The context from which the Logger and path to theapplication
 * @return true if all required extensions satisfied
 */
public static synchronized boolean validateApplication(DirContext dirContext,Context context) throws IOException {
  String appName=context.getName();
  ArrayList<ManifestResource> appManifestResources=new ArrayList<ManifestResource>();
  if (dirContext == null)   return false;
  InputStream inputStream=null;
  try {
    NamingEnumeration<Binding> wne=dirContext.listBindings("/META-INF/");
    Binding binding=wne.nextElement();
    if (binding.getName().toUpperCase(Locale.ENGLISH).equals("MANIFEST.MF")) {
      Resource resource=(Resource)dirContext.lookup("/META-INF/" + binding.getName());
      inputStream=resource.streamContent();
      Manifest manifest=new Manifest(inputStream);
      inputStream.close();
      inputStream=null;
      ManifestResource mre=new ManifestResource(sm.getString("extensionValidator.web-application-manifest"),manifest,ManifestResource.WAR);
      appManifestResources.add(mre);
    }
  }
 catch (  NamingException nex) {
  }
catch (  NoSuchElementException nse) {
  }
 finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
    }
  }
  NamingEnumeration<Binding> ne=null;
  String jarName=null;
  try {
    ne=dirContext.listBindings("WEB-INF/lib/");
    while ((ne != null) && ne.hasMoreElements()) {
      Binding binding=ne.nextElement();
      jarName=binding.getName();
      if (!jarName.toLowerCase(Locale.ENGLISH).endsWith(".jar")) {
        continue;
      }
      Object obj=dirContext.lookup("/WEB-INF/lib/" + jarName);
      if (!(obj instanceof Resource)) {
        continue;
      }
      Resource resource=(Resource)obj;
      inputStream=resource.streamContent();
      Manifest jmanifest=getManifest(inputStream);
      if (jmanifest != null) {
        ManifestResource mre=new ManifestResource(jarName,jmanifest,ManifestResource.APPLICATION);
        appManifestResources.add(mre);
      }
    }
  }
 catch (  NamingException nex) {
  }
catch (  IOException ioe) {
    throw new IOException("Jar: " + jarName,ioe);
  }
 finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
    }
  }
  return validateManifestResources(appName,appManifestResources);
}

ID 1209=========================================================================type: 1
Method:org.apache.catalina.util.ExtensionValidator#addFolderList(java.lang.String)
Rmethod: org.apache.catalina.util.ExtensionValidator#addSystemResource(java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Add the JARs specified to the extension list.
 */
private static void addFolderList(String property){
  String extensionsDir=System.getProperty(property);
  if (extensionsDir != null) {
    StringTokenizer extensionsTok=new StringTokenizer(extensionsDir,File.pathSeparator);
    while (extensionsTok.hasMoreTokens()) {
      File targetDir=new File(extensionsTok.nextToken());
      if (!targetDir.isDirectory()) {
        continue;
      }
      File[] files=targetDir.listFiles();
      if (files == null) {
        continue;
      }
      for (int i=0; i < files.length; i++) {
        if (files[i].getName().toLowerCase(Locale.ENGLISH).endsWith(".jar") && files[i].isFile()) {
          try {
            addSystemResource(files[i]);
          }
 catch (          IOException e) {
            log.error(sm.getString("extensionValidator.failload",files[i]),e);
          }
        }
      }
    }
  }
}

ID 1214=========================================================================type: 1
Method:org.apache.catalina.util.SessionIdGeneratorBase#createSecureRandom()
Rmethod: java.security.SecureRandom#getInstance(java.lang.String, java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * Create a new random number generator instance we should use for generating session identifiers.
 */
private SecureRandom createSecureRandom(){
  SecureRandom result=null;
  long t1=System.currentTimeMillis();
  if (secureRandomClass != null) {
    try {
      Class<?> clazz=Class.forName(secureRandomClass);
      result=(SecureRandom)clazz.newInstance();
    }
 catch (    Exception e) {
      log.error(sm.getString("sessionIdGeneratorBase.random",secureRandomClass),e);
    }
  }
  if (result == null) {
    try {
      if (secureRandomProvider != null && secureRandomProvider.length() > 0) {
        result=SecureRandom.getInstance(secureRandomAlgorithm,secureRandomProvider);
      }
 else       if (secureRandomAlgorithm != null && secureRandomAlgorithm.length() > 0) {
        result=SecureRandom.getInstance(secureRandomAlgorithm);
      }
    }
 catch (    NoSuchAlgorithmException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomAlgorithm",secureRandomAlgorithm),e);
    }
catch (    NoSuchProviderException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomProvider",secureRandomProvider),e);
    }
  }
  if (result == null) {
    try {
      result=SecureRandom.getInstance("SHA1PRNG");
    }
 catch (    NoSuchAlgorithmException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomAlgorithm",secureRandomAlgorithm),e);
    }
  }
  if (result == null) {
    result=new SecureRandom();
  }
  result.nextInt();
  long t2=System.currentTimeMillis();
  if ((t2 - t1) > 100)   log.info(sm.getString("sessionIdGeneratorBase.createRandom",result.getAlgorithm(),Long.valueOf(t2 - t1)));
  return result;
}

ID 1215=========================================================================type: 1
Method:org.apache.catalina.util.SessionIdGeneratorBase#createSecureRandom()
Rmethod: java.security.SecureRandom#getInstance(java.lang.String, java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchProviderException
exception comment: /** 
 * This exception is thrown when a particular security provider is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * Create a new random number generator instance we should use for generating session identifiers.
 */
private SecureRandom createSecureRandom(){
  SecureRandom result=null;
  long t1=System.currentTimeMillis();
  if (secureRandomClass != null) {
    try {
      Class<?> clazz=Class.forName(secureRandomClass);
      result=(SecureRandom)clazz.newInstance();
    }
 catch (    Exception e) {
      log.error(sm.getString("sessionIdGeneratorBase.random",secureRandomClass),e);
    }
  }
  if (result == null) {
    try {
      if (secureRandomProvider != null && secureRandomProvider.length() > 0) {
        result=SecureRandom.getInstance(secureRandomAlgorithm,secureRandomProvider);
      }
 else       if (secureRandomAlgorithm != null && secureRandomAlgorithm.length() > 0) {
        result=SecureRandom.getInstance(secureRandomAlgorithm);
      }
    }
 catch (    NoSuchAlgorithmException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomAlgorithm",secureRandomAlgorithm),e);
    }
catch (    NoSuchProviderException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomProvider",secureRandomProvider),e);
    }
  }
  if (result == null) {
    try {
      result=SecureRandom.getInstance("SHA1PRNG");
    }
 catch (    NoSuchAlgorithmException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomAlgorithm",secureRandomAlgorithm),e);
    }
  }
  if (result == null) {
    result=new SecureRandom();
  }
  result.nextInt();
  long t2=System.currentTimeMillis();
  if ((t2 - t1) > 100)   log.info(sm.getString("sessionIdGeneratorBase.createRandom",result.getAlgorithm(),Long.valueOf(t2 - t1)));
  return result;
}

ID 1216=========================================================================type: 1
Method:org.apache.catalina.util.SessionIdGeneratorBase#createSecureRandom()
Rmethod: java.security.SecureRandom#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * Create a new random number generator instance we should use for generating session identifiers.
 */
private SecureRandom createSecureRandom(){
  SecureRandom result=null;
  long t1=System.currentTimeMillis();
  if (secureRandomClass != null) {
    try {
      Class<?> clazz=Class.forName(secureRandomClass);
      result=(SecureRandom)clazz.newInstance();
    }
 catch (    Exception e) {
      log.error(sm.getString("sessionIdGeneratorBase.random",secureRandomClass),e);
    }
  }
  if (result == null) {
    try {
      if (secureRandomProvider != null && secureRandomProvider.length() > 0) {
        result=SecureRandom.getInstance(secureRandomAlgorithm,secureRandomProvider);
      }
 else       if (secureRandomAlgorithm != null && secureRandomAlgorithm.length() > 0) {
        result=SecureRandom.getInstance(secureRandomAlgorithm);
      }
    }
 catch (    NoSuchAlgorithmException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomAlgorithm",secureRandomAlgorithm),e);
    }
catch (    NoSuchProviderException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomProvider",secureRandomProvider),e);
    }
  }
  if (result == null) {
    try {
      result=SecureRandom.getInstance("SHA1PRNG");
    }
 catch (    NoSuchAlgorithmException e) {
      log.error(sm.getString("sessionIdGeneratorBase.randomAlgorithm",secureRandomAlgorithm),e);
    }
  }
  if (result == null) {
    result=new SecureRandom();
  }
  result.nextInt();
  long t2=System.currentTimeMillis();
  if ((t2 - t1) > 100)   log.info(sm.getString("sessionIdGeneratorBase.createRandom",result.getAlgorithm(),Long.valueOf(t2 - t1)));
  return result;
}

ID 1219=========================================================================type: 1
Method:org.apache.catalina.util.Introspection#loadClass(org.apache.catalina.Container, java.lang.String)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Attempt to load a class using the given Container's class loader. If the class cannot be loaded, a debug level log message will be written to the Container's log and null will be returned.
 */
public static Class<?> loadClass(Container container,String className){
  ClassLoader cl=container.getLoader().getClassLoader();
  Log log=container.getLogger();
  Class<?> clazz=null;
  try {
    clazz=cl.loadClass(className);
  }
 catch (  ClassNotFoundException e) {
    log.debug(sm.getString("introspection.classLoadFailed",className),e);
  }
catch (  NoClassDefFoundError e) {
    log.debug(sm.getString("introspection.classLoadFailed",className),e);
  }
catch (  ClassFormatError e) {
    log.debug(sm.getString("introspection.classLoadFailed",className),e);
  }
catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log.debug(sm.getString("introspection.classLoadFailed",className),t);
  }
  return clazz;
}

ID 1226=========================================================================type: 1
Method:org.apache.catalina.util.RequestUtil#parseParameters(Map<java.lang.String,java.lang.String[]>, java.lang.String, java.lang.String)
Rmethod: org.apache.tomcat.util.buf.B2CConverter#getCharset(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Append request parameters from the specified String to the specified Map.  It is presumed that the specified Map is not accessed from any other thread, so no synchronization is performed. <p> <strong>IMPLEMENTATION NOTE</strong>:  URL decoding is performed individually on the parsed name and value elements, rather than on the entire query string ahead of time, to properly deal with the case where the name or value includes an encoded "=" or "&" character that would otherwise be interpreted as a delimiter.
 * @param map Map that accumulates the resulting parameters
 * @param data Input string containing request parameters
 * @param encoding The encoding to use; encoding must not be null.If an unsupported encoding is specified the parameters will not be parsed and the map will not be modified
 */
public static void parseParameters(Map<String,String[]> map,String data,String encoding){
  if ((data != null) && (data.length() > 0)) {
    byte[] bytes=null;
    try {
      bytes=data.getBytes(B2CConverter.getCharset(encoding));
      parseParameters(map,bytes,encoding);
    }
 catch (    UnsupportedEncodingException uee) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("requestUtil.parseParameters.uee",encoding),uee);
      }
    }
  }
}

ID 1227=========================================================================type: 1
Method:org.apache.catalina.util.RequestUtil#parseParameters(Map<java.lang.String,java.lang.String[]>, java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.util.RequestUtil#parseParameters(Map<java.lang.String,java.lang.String[]>, byte[], java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Append request parameters from the specified String to the specified Map.  It is presumed that the specified Map is not accessed from any other thread, so no synchronization is performed. <p> <strong>IMPLEMENTATION NOTE</strong>:  URL decoding is performed individually on the parsed name and value elements, rather than on the entire query string ahead of time, to properly deal with the case where the name or value includes an encoded "=" or "&" character that would otherwise be interpreted as a delimiter.
 * @param map Map that accumulates the resulting parameters
 * @param data Input string containing request parameters
 * @param encoding The encoding to use; encoding must not be null.If an unsupported encoding is specified the parameters will not be parsed and the map will not be modified
 */
public static void parseParameters(Map<String,String[]> map,String data,String encoding){
  if ((data != null) && (data.length() > 0)) {
    byte[] bytes=null;
    try {
      bytes=data.getBytes(B2CConverter.getCharset(encoding));
      parseParameters(map,bytes,encoding);
    }
 catch (    UnsupportedEncodingException uee) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("requestUtil.parseParameters.uee",encoding),uee);
      }
    }
  }
}

ID 1228=========================================================================type: 1
Method:org.apache.catalina.util.RequestUtil#URLDecode(java.lang.String, java.lang.String, boolean)
Rmethod: org.apache.tomcat.util.buf.B2CConverter#getCharset(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Decode and return the specified URL-encoded String.
 * @param str The url-encoded string
 * @param enc The encoding to use; if null, the default encoding is used. Ifan unsupported encoding is specified null will be returned
 * @param isQuery Is this a query string being processed
 * @exception IllegalArgumentException if a '%' character is not followedby a valid 2-digit hexadecimal number
 */
public static String URLDecode(String str,String enc,boolean isQuery){
  if (str == null)   return (null);
  byte[] bytes=null;
  try {
    if (enc == null) {
      bytes=str.getBytes(Charset.defaultCharset());
    }
 else {
      bytes=str.getBytes(B2CConverter.getCharset(enc));
    }
  }
 catch (  UnsupportedEncodingException uee) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("requestUtil.urlDecode.uee",enc),uee);
    }
  }
  return URLDecode(bytes,enc,isQuery);
}

ID 1229=========================================================================type: 1
Method:org.apache.catalina.util.RequestUtil#URLDecode(byte[], java.lang.String, boolean)
Rmethod: org.apache.tomcat.util.buf.B2CConverter#getCharset(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Decode and return the specified URL-encoded byte array.
 * @param bytes The url-encoded byte array
 * @param enc The encoding to use; if null, the default encoding is used. Ifan unsupported encoding is specified null will be returned
 * @param isQuery Is this a query string being processed
 * @exception IllegalArgumentException if a '%' character is not followedby a valid 2-digit hexadecimal number
 */
public static String URLDecode(byte[] bytes,String enc,boolean isQuery){
  if (bytes == null)   return null;
  int len=bytes.length;
  int ix=0;
  int ox=0;
  while (ix < len) {
    byte b=bytes[ix++];
    if (b == '+' && isQuery) {
      b=(byte)' ';
    }
 else     if (b == '%') {
      if (ix + 2 > len) {
        throw new IllegalArgumentException(sm.getString("requestUtil.urlDecode.missingDigit"));
      }
      b=(byte)((convertHexDigit(bytes[ix++]) << 4) + convertHexDigit(bytes[ix++]));
    }
    bytes[ox++]=b;
  }
  if (enc != null) {
    try {
      return new String(bytes,0,ox,B2CConverter.getCharset(enc));
    }
 catch (    UnsupportedEncodingException uee) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("requestUtil.urlDecode.uee",enc),uee);
      }
      return null;
    }
  }
  return new String(bytes,0,ox);
}

ID 1242=========================================================================type: 1
Method:org.apache.catalina.security.SecurityUtil#execute(java.lang.reflect.Method, java.lang.Object, java.lang.Object[], java.security.Principal)
Rmethod: javax.security.auth.Subject#doAsPrivileged(javax.security.auth.Subject, PrivilegedExceptionAction<T>, java.security.AccessControlContext)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Perform work as a particular </code>Subject</code>. Here the work will be granted to a <code>null</code> subject.
 * @param method the method to apply the security restriction
 * @param targetObject the <code>Servlet</code> on which the method willbe called.
 * @param targetArguments <code>Object</code> array contains theruntime parameters instance.
 * @param principal the <code>Principal</code> to which the securityprivilege applies
 */
private static void execute(final Method method,final Object targetObject,final Object[] targetArguments,Principal principal) throws java.lang.Exception {
  try {
    Subject subject=null;
    PrivilegedExceptionAction<Void> pea=new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        method.invoke(targetObject,targetArguments);
        return null;
      }
    }
;
    if (targetArguments != null && targetArguments[0] instanceof HttpServletRequest) {
      HttpServletRequest request=(HttpServletRequest)targetArguments[0];
      boolean hasSubject=false;
      HttpSession session=request.getSession(false);
      if (session != null) {
        subject=(Subject)session.getAttribute(Globals.SUBJECT_ATTR);
        hasSubject=(subject != null);
      }
      if (subject == null) {
        subject=new Subject();
        if (principal != null) {
          subject.getPrincipals().add(principal);
        }
      }
      if (session != null && !hasSubject) {
        session.setAttribute(Globals.SUBJECT_ATTR,subject);
      }
    }
    Subject.doAsPrivileged(subject,pea,null);
  }
 catch (  PrivilegedActionException pe) {
    Throwable e;
    if (pe.getException() instanceof InvocationTargetException) {
      e=pe.getException().getCause();
      ExceptionUtils.handleThrowable(e);
    }
 else {
      e=pe;
    }
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("SecurityUtil.doAsPrivilege"),e);
    }
    if (e instanceof UnavailableException)     throw (UnavailableException)e;
 else     if (e instanceof ServletException)     throw (ServletException)e;
 else     if (e instanceof IOException)     throw (IOException)e;
 else     if (e instanceof RuntimeException)     throw (RuntimeException)e;
 else     throw new ServletException(e.getMessage(),e);
  }
}

ID 1248=========================================================================type: 1
Method:org.apache.catalina.security.SecurityListener#checkUmask()
Rmethod: java.lang.Integer#valueOf(java.lang.String, int)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
protected void checkUmask(){
  String prop=System.getProperty(UMASK_PROPERTY_NAME);
  Integer umask=null;
  if (prop != null) {
    try {
      umask=Integer.valueOf(prop,8);
    }
 catch (    NumberFormatException nfe) {
      log.warn(sm.getString("SecurityListener.checkUmaskParseFail",prop));
    }
  }
  if (umask == null) {
    if (Constants.CRLF.equals(Constants.LINE_SEP)) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("SecurityListener.checkUmaskSkip"));
      }
      return;
    }
 else {
      if (minimumUmask.intValue() > 0) {
        log.warn(sm.getString("SecurityListener.checkUmaskNone",UMASK_PROPERTY_NAME,getMinimumUmask()));
      }
      return;
    }
  }
  if ((umask.intValue() & minimumUmask.intValue()) != minimumUmask.intValue()) {
    throw new Error(sm.getString("SecurityListener.checkUmaskFail",String.format(UMASK_FORMAT,umask),getMinimumUmask()));
  }
}

ID 1275=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addConnector(java.lang.String, int, boolean, boolean)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Add a new Connector to the set of defined Connectors, and associate it with this Service's Container.
 * @param address The IP address on which to bind
 * @param port TCP port number to listen on
 * @param isAjp Create a AJP/1.3 Connector
 * @param isSSL Create a secure Connector
 * @throws MBeanException 
 */
public void addConnector(String address,int port,boolean isAjp,boolean isSSL) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Connector connector=new Connector();
  if ((address != null) && (address.length() > 0)) {
    connector.setProperty("address",address);
  }
  connector.setPort(port);
  connector.setProtocol(isAjp ? "AJP/1.3" : "HTTP/1.1");
  connector.setSecure(isSSL);
  connector.setScheme(isSSL ? "https" : "http");
  service.addConnector(connector);
}

ID 1276=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addConnector(java.lang.String, int, boolean, boolean)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Add a new Connector to the set of defined Connectors, and associate it with this Service's Container.
 * @param address The IP address on which to bind
 * @param port TCP port number to listen on
 * @param isAjp Create a AJP/1.3 Connector
 * @param isSSL Create a secure Connector
 * @throws MBeanException 
 */
public void addConnector(String address,int port,boolean isAjp,boolean isSSL) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Connector connector=new Connector();
  if ((address != null) && (address.length() > 0)) {
    connector.setProperty("address",address);
  }
  connector.setPort(port);
  connector.setProtocol(isAjp ? "AJP/1.3" : "HTTP/1.1");
  connector.setSecure(isSSL);
  connector.setScheme(isSSL ? "https" : "http");
  service.addConnector(connector);
}

ID 1278=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addConnector(java.lang.String, int, boolean, boolean)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Add a new Connector to the set of defined Connectors, and associate it with this Service's Container.
 * @param address The IP address on which to bind
 * @param port TCP port number to listen on
 * @param isAjp Create a AJP/1.3 Connector
 * @param isSSL Create a secure Connector
 * @throws MBeanException 
 */
public void addConnector(String address,int port,boolean isAjp,boolean isSSL) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Connector connector=new Connector();
  if ((address != null) && (address.length() > 0)) {
    connector.setProperty("address",address);
  }
  connector.setPort(port);
  connector.setProtocol(isAjp ? "AJP/1.3" : "HTTP/1.1");
  connector.setSecure(isSSL);
  connector.setScheme(isSSL ? "https" : "http");
  service.addConnector(connector);
}

ID 1279=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addExecutor(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Adds a named executor to the service
 * @param type Classname of the Executor to be added
 * @throws MBeanException 
 */
public void addExecutor(String type) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor;
  try {
    executor=(Executor)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  service.addExecutor(executor);
}

ID 1280=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addExecutor(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Adds a named executor to the service
 * @param type Classname of the Executor to be added
 * @throws MBeanException 
 */
public void addExecutor(String type) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor;
  try {
    executor=(Executor)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  service.addExecutor(executor);
}

ID 1282=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addExecutor(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Adds a named executor to the service
 * @param type Classname of the Executor to be added
 * @throws MBeanException 
 */
public void addExecutor(String type) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor;
  try {
    executor=(Executor)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  service.addExecutor(executor);
}

ID 1283=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addExecutor(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Adds a named executor to the service
 * @param type Classname of the Executor to be added
 * @throws MBeanException 
 */
public void addExecutor(String type) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor;
  try {
    executor=(Executor)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  service.addExecutor(executor);
}

ID 1284=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addExecutor(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Adds a named executor to the service
 * @param type Classname of the Executor to be added
 * @throws MBeanException 
 */
public void addExecutor(String type) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor;
  try {
    executor=(Executor)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  service.addExecutor(executor);
}

ID 1285=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#addExecutor(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Adds a named executor to the service
 * @param type Classname of the Executor to be added
 * @throws MBeanException 
 */
public void addExecutor(String type) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor;
  try {
    executor=(Executor)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  service.addExecutor(executor);
}

ID 1286=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#findConnectors()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Find and return the set of Connectors associated with this Service.
 * @throws MBeanException 
 */
public String[] findConnectors() throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Connector[] connectors=service.findConnectors();
  String[] str=new String[connectors.length];
  for (int i=0; i < connectors.length; i++) {
    str[i]=connectors[i].toString();
  }
  return str;
}

ID 1287=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#findConnectors()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Find and return the set of Connectors associated with this Service.
 * @throws MBeanException 
 */
public String[] findConnectors() throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Connector[] connectors=service.findConnectors();
  String[] str=new String[connectors.length];
  for (int i=0; i < connectors.length; i++) {
    str[i]=connectors[i].toString();
  }
  return str;
}

ID 1289=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#findConnectors()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Find and return the set of Connectors associated with this Service.
 * @throws MBeanException 
 */
public String[] findConnectors() throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Connector[] connectors=service.findConnectors();
  String[] str=new String[connectors.length];
  for (int i=0; i < connectors.length; i++) {
    str[i]=connectors[i].toString();
  }
  return str;
}

ID 1290=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#findExecutors()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Retrieves all executors
 * @throws MBeanException 
 */
public String[] findExecutors() throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor[] executors=service.findExecutors();
  String[] str=new String[executors.length];
  for (int i=0; i < executors.length; i++) {
    str[i]=executors[i].toString();
  }
  return str;
}

ID 1291=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#findExecutors()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Retrieves all executors
 * @throws MBeanException 
 */
public String[] findExecutors() throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor[] executors=service.findExecutors();
  String[] str=new String[executors.length];
  for (int i=0; i < executors.length; i++) {
    str[i]=executors[i].toString();
  }
  return str;
}

ID 1293=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#findExecutors()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Retrieves all executors
 * @throws MBeanException 
 */
public String[] findExecutors() throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor[] executors=service.findExecutors();
  String[] str=new String[executors.length];
  for (int i=0; i < executors.length; i++) {
    str[i]=executors[i].toString();
  }
  return str;
}

ID 1294=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#getExecutor(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Retrieves executor by name
 * @param name Name of the executor to be retrieved
 * @throws MBeanException 
 */
public String getExecutor(String name) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor=service.getExecutor(name);
  return executor.toString();
}

ID 1295=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#getExecutor(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Retrieves executor by name
 * @param name Name of the executor to be retrieved
 * @throws MBeanException 
 */
public String getExecutor(String name) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor=service.getExecutor(name);
  return executor.toString();
}

ID 1297=========================================================================type: 1
Method:org.apache.catalina.mbeans.ServiceMBean#getExecutor(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Retrieves executor by name
 * @param name Name of the executor to be retrieved
 * @throws MBeanException 
 */
public String getExecutor(String name) throws MBeanException {
  Service service;
  try {
    service=(Service)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  Executor executor=service.getExecutor(name);
  return executor.toString();
}

ID 1298=========================================================================type: 1
Method:org.apache.catalina.mbeans.UserMBean#getGroups()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.Group)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Names of all groups this user is a member of.
 */
public String[] getGroups(){
  User user=(User)this.resource;
  ArrayList<String> results=new ArrayList<String>();
  Iterator<Group> groups=user.getGroups();
  while (groups.hasNext()) {
    Group group=null;
    try {
      group=groups.next();
      ObjectName oname=MBeanUtils.createObjectName(managed.getDomain(),group);
      results.add(oname.toString());
    }
 catch (    MalformedObjectNameException e) {
      IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for group " + group);
      iae.initCause(e);
      throw iae;
    }
  }
  return results.toArray(new String[results.size()]);
}

ID 1299=========================================================================type: 1
Method:org.apache.catalina.mbeans.UserMBean#getRoles()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.Role)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Names of all roles assigned to this user.
 */
public String[] getRoles(){
  User user=(User)this.resource;
  ArrayList<String> results=new ArrayList<String>();
  Iterator<Role> roles=user.getRoles();
  while (roles.hasNext()) {
    Role role=null;
    try {
      role=roles.next();
      ObjectName oname=MBeanUtils.createObjectName(managed.getDomain(),role);
      results.add(oname.toString());
    }
 catch (    MalformedObjectNameException e) {
      IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for role " + role);
      iae.initCause(e);
      throw iae;
    }
  }
  return results.toArray(new String[results.size()]);
}

ID 1300=========================================================================type: 1
Method:org.apache.catalina.mbeans.NamingResourcesMBean#getEnvironments()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.deploy.ContextEnvironment)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Names of the set of defined environment entries for   this web application
 */
public String[] getEnvironments(){
  ContextEnvironment[] envs=((NamingResources)this.resource).findEnvironments();
  ArrayList<String> results=new ArrayList<String>();
  for (int i=0; i < envs.length; i++) {
    try {
      ObjectName oname=MBeanUtils.createObjectName(managed.getDomain(),envs[i]);
      results.add(oname.toString());
    }
 catch (    MalformedObjectNameException e) {
      IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for environment " + envs[i]);
      iae.initCause(e);
      throw iae;
    }
  }
  return results.toArray(new String[results.size()]);
}

ID 1301=========================================================================type: 1
Method:org.apache.catalina.mbeans.NamingResourcesMBean#getResources()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.deploy.ContextResource)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Names of all the defined resource references for this application.
 */
public String[] getResources(){
  ContextResource[] resources=((NamingResources)this.resource).findResources();
  ArrayList<String> results=new ArrayList<String>();
  for (int i=0; i < resources.length; i++) {
    try {
      ObjectName oname=MBeanUtils.createObjectName(managed.getDomain(),resources[i]);
      results.add(oname.toString());
    }
 catch (    MalformedObjectNameException e) {
      IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for resource " + resources[i]);
      iae.initCause(e);
      throw iae;
    }
  }
  return results.toArray(new String[results.size()]);
}

ID 1302=========================================================================type: 1
Method:org.apache.catalina.mbeans.NamingResourcesMBean#getResourceLinks()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.deploy.ContextResourceLink)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Names of all the defined resource link references for  this application.
 */
public String[] getResourceLinks(){
  ContextResourceLink[] resourceLinks=((NamingResources)this.resource).findResourceLinks();
  ArrayList<String> results=new ArrayList<String>();
  for (int i=0; i < resourceLinks.length; i++) {
    try {
      ObjectName oname=MBeanUtils.createObjectName(managed.getDomain(),resourceLinks[i]);
      results.add(oname.toString());
    }
 catch (    MalformedObjectNameException e) {
      IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for resource " + resourceLinks[i]);
      iae.initCause(e);
      throw iae;
    }
  }
  return results.toArray(new String[results.size()]);
}

ID 1306=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceLinkMBean#getAttribute(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Obtain and return the value of a specific attribute of this MBean.
 * @param name Name of the requested attribute
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResourceLink cl=null;
  try {
    cl=(ContextResourceLink)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  String value=null;
  if ("global".equals(name)) {
    return (cl.getGlobal());
  }
 else   if ("description".equals(name)) {
    return (cl.getDescription());
  }
 else   if ("name".equals(name)) {
    return (cl.getName());
  }
 else   if ("type".equals(name)) {
    return (cl.getType());
  }
 else {
    value=(String)cl.getProperty(name);
    if (value == null) {
      throw new AttributeNotFoundException("Cannot find attribute " + name);
    }
  }
  return value;
}

ID 1307=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceLinkMBean#getAttribute(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Obtain and return the value of a specific attribute of this MBean.
 * @param name Name of the requested attribute
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResourceLink cl=null;
  try {
    cl=(ContextResourceLink)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  String value=null;
  if ("global".equals(name)) {
    return (cl.getGlobal());
  }
 else   if ("description".equals(name)) {
    return (cl.getDescription());
  }
 else   if ("name".equals(name)) {
    return (cl.getName());
  }
 else   if ("type".equals(name)) {
    return (cl.getType());
  }
 else {
    value=(String)cl.getProperty(name);
    if (value == null) {
      throw new AttributeNotFoundException("Cannot find attribute " + name);
    }
  }
  return value;
}

ID 1310=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceLinkMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResourceLink crl=null;
  try {
    crl=(ContextResourceLink)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  if ("global".equals(name)) {
    crl.setGlobal((String)value);
  }
 else   if ("description".equals(name)) {
    crl.setDescription((String)value);
  }
 else   if ("name".equals(name)) {
    crl.setName((String)value);
  }
 else   if ("type".equals(name)) {
    crl.setType((String)value);
  }
 else {
    crl.setProperty(name,"" + value);
  }
  NamingResources nr=crl.getNamingResources();
  nr.removeResourceLink(crl.getName());
  nr.addResourceLink(crl);
}

ID 1311=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceLinkMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResourceLink crl=null;
  try {
    crl=(ContextResourceLink)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  if ("global".equals(name)) {
    crl.setGlobal((String)value);
  }
 else   if ("description".equals(name)) {
    crl.setDescription((String)value);
  }
 else   if ("name".equals(name)) {
    crl.setName((String)value);
  }
 else   if ("type".equals(name)) {
    crl.setType((String)value);
  }
 else {
    crl.setProperty(name,"" + value);
  }
  NamingResources nr=crl.getNamingResources();
  nr.removeResourceLink(crl.getName());
  nr.addResourceLink(crl);
}

ID 1314=========================================================================type: 1
Method:org.apache.catalina.mbeans.ConnectorMBean#getAttribute(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Obtain and return the value of a specific attribute of this MBean.
 * @param name Name of the requested attribute
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  Object result=null;
  try {
    Connector connector=(Connector)getManagedResource();
    result=IntrospectionUtils.getProperty(connector,name);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return result;
}

ID 1315=========================================================================type: 1
Method:org.apache.catalina.mbeans.ConnectorMBean#getAttribute(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Obtain and return the value of a specific attribute of this MBean.
 * @param name Name of the requested attribute
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  Object result=null;
  try {
    Connector connector=(Connector)getManagedResource();
    result=IntrospectionUtils.getProperty(connector,name);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return result;
}

ID 1318=========================================================================type: 1
Method:org.apache.catalina.mbeans.ConnectorMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  try {
    Connector connector=(Connector)getManagedResource();
    IntrospectionUtils.setProperty(connector,name,String.valueOf(value));
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
}

ID 1319=========================================================================type: 1
Method:org.apache.catalina.mbeans.ConnectorMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  try {
    Connector connector=(Connector)getManagedResource();
    IntrospectionUtils.setProperty(connector,name,String.valueOf(value));
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
}

ID 1322=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceMBean#getAttribute(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Obtain and return the value of a specific attribute of this MBean.
 * @param name Name of the requested attribute
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResource cr=null;
  try {
    cr=(ContextResource)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  String value=null;
  if ("auth".equals(name)) {
    return (cr.getAuth());
  }
 else   if ("description".equals(name)) {
    return (cr.getDescription());
  }
 else   if ("name".equals(name)) {
    return (cr.getName());
  }
 else   if ("scope".equals(name)) {
    return (cr.getScope());
  }
 else   if ("type".equals(name)) {
    return (cr.getType());
  }
 else {
    value=(String)cr.getProperty(name);
    if (value == null) {
      throw new AttributeNotFoundException("Cannot find attribute " + name);
    }
  }
  return value;
}

ID 1323=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceMBean#getAttribute(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Obtain and return the value of a specific attribute of this MBean.
 * @param name Name of the requested attribute
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResource cr=null;
  try {
    cr=(ContextResource)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  String value=null;
  if ("auth".equals(name)) {
    return (cr.getAuth());
  }
 else   if ("description".equals(name)) {
    return (cr.getDescription());
  }
 else   if ("name".equals(name)) {
    return (cr.getName());
  }
 else   if ("scope".equals(name)) {
    return (cr.getScope());
  }
 else   if ("type".equals(name)) {
    return (cr.getType());
  }
 else {
    value=(String)cr.getProperty(name);
    if (value == null) {
      throw new AttributeNotFoundException("Cannot find attribute " + name);
    }
  }
  return value;
}

ID 1326=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResource cr=null;
  try {
    cr=(ContextResource)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  if ("auth".equals(name)) {
    cr.setAuth((String)value);
  }
 else   if ("description".equals(name)) {
    cr.setDescription((String)value);
  }
 else   if ("name".equals(name)) {
    cr.setName((String)value);
  }
 else   if ("scope".equals(name)) {
    cr.setScope((String)value);
  }
 else   if ("type".equals(name)) {
    cr.setType((String)value);
  }
 else {
    cr.setProperty(name,"" + value);
  }
  NamingResources nr=cr.getNamingResources();
  nr.removeResource(cr.getName());
  nr.addResource(cr);
}

ID 1327=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextResourceMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  ContextResource cr=null;
  try {
    cr=(ContextResource)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  if ("auth".equals(name)) {
    cr.setAuth((String)value);
  }
 else   if ("description".equals(name)) {
    cr.setDescription((String)value);
  }
 else   if ("name".equals(name)) {
    cr.setName((String)value);
  }
 else   if ("scope".equals(name)) {
    cr.setScope((String)value);
  }
 else   if ("type".equals(name)) {
    cr.setType((String)value);
  }
 else {
    cr.setProperty(name,"" + value);
  }
  NamingResources nr=cr.getNamingResources();
  nr.removeResource(cr.getName());
  nr.addResource(cr);
}

ID 1568=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findApplicationParameters()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the set of application parameters for this application.
 */
public String[] findApplicationParameters() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ApplicationParameter[] params=context.findApplicationParameters();
  String[] stringParams=new String[params.length];
  for (int counter=0; counter < params.length; counter++) {
    stringParams[counter]=params[counter].toString();
  }
  return stringParams;
}

ID 1569=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findApplicationParameters()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the set of application parameters for this application.
 */
public String[] findApplicationParameters() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ApplicationParameter[] params=context.findApplicationParameters();
  String[] stringParams=new String[params.length];
  for (int counter=0; counter < params.length; counter++) {
    stringParams[counter]=params[counter].toString();
  }
  return stringParams;
}

ID 1571=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findApplicationParameters()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the set of application parameters for this application.
 */
public String[] findApplicationParameters() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ApplicationParameter[] params=context.findApplicationParameters();
  String[] stringParams=new String[params.length];
  for (int counter=0; counter < params.length; counter++) {
    stringParams[counter]=params[counter].toString();
  }
  return stringParams;
}

ID 1572=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findConstraints()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the security constraints for this web application. If there are none, a zero-length array is returned.
 */
public String[] findConstraints() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  SecurityConstraint[] constraints=context.findConstraints();
  String[] stringConstraints=new String[constraints.length];
  for (int counter=0; counter < constraints.length; counter++) {
    stringConstraints[counter]=constraints[counter].toString();
  }
  return stringConstraints;
}

ID 1573=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findConstraints()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the security constraints for this web application. If there are none, a zero-length array is returned.
 */
public String[] findConstraints() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  SecurityConstraint[] constraints=context.findConstraints();
  String[] stringConstraints=new String[constraints.length];
  for (int counter=0; counter < constraints.length; counter++) {
    stringConstraints[counter]=constraints[counter].toString();
  }
  return stringConstraints;
}

ID 1575=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findConstraints()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the security constraints for this web application. If there are none, a zero-length array is returned.
 */
public String[] findConstraints() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  SecurityConstraint[] constraints=context.findConstraints();
  String[] stringConstraints=new String[constraints.length];
  for (int counter=0; counter < constraints.length; counter++) {
    stringConstraints[counter]=constraints[counter].toString();
  }
  return stringConstraints;
}

ID 1576=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPage(int)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the error page entry for the specified HTTP error code, if any; otherwise return <code>null</code>.
 * @param errorCode Error code to look up
 */
public String findErrorPage(int errorCode) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return context.findErrorPage(errorCode).toString();
}

ID 1577=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPage(int)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the error page entry for the specified HTTP error code, if any; otherwise return <code>null</code>.
 * @param errorCode Error code to look up
 */
public String findErrorPage(int errorCode) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return context.findErrorPage(errorCode).toString();
}

ID 1579=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPage(int)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the error page entry for the specified HTTP error code, if any; otherwise return <code>null</code>.
 * @param errorCode Error code to look up
 */
public String findErrorPage(int errorCode) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return context.findErrorPage(errorCode).toString();
}

ID 1580=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPage(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the error page entry for the specified Java exception type, if any; otherwise return <code>null</code>.
 * @param exceptionType Exception type to look up
 */
public String findErrorPage(String exceptionType) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return context.findErrorPage(exceptionType).toString();
}

ID 1581=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPage(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the error page entry for the specified Java exception type, if any; otherwise return <code>null</code>.
 * @param exceptionType Exception type to look up
 */
public String findErrorPage(String exceptionType) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return context.findErrorPage(exceptionType).toString();
}

ID 1583=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPage(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the error page entry for the specified Java exception type, if any; otherwise return <code>null</code>.
 * @param exceptionType Exception type to look up
 */
public String findErrorPage(String exceptionType) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return context.findErrorPage(exceptionType).toString();
}

ID 1584=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPages()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the set of defined error pages for all specified error codes and exception types.
 */
public String[] findErrorPages() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ErrorPage[] pages=context.findErrorPages();
  String[] stringPages=new String[pages.length];
  for (int counter=0; counter < pages.length; counter++) {
    stringPages[counter]=pages[counter].toString();
  }
  return stringPages;
}

ID 1585=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPages()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the set of defined error pages for all specified error codes and exception types.
 */
public String[] findErrorPages() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ErrorPage[] pages=context.findErrorPages();
  String[] stringPages=new String[pages.length];
  for (int counter=0; counter < pages.length; counter++) {
    stringPages[counter]=pages[counter].toString();
  }
  return stringPages;
}

ID 1587=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findErrorPages()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the set of defined error pages for all specified error codes and exception types.
 */
public String[] findErrorPages() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ErrorPage[] pages=context.findErrorPages();
  String[] stringPages=new String[pages.length];
  for (int counter=0; counter < pages.length; counter++) {
    stringPages[counter]=pages[counter].toString();
  }
  return stringPages;
}

ID 1588=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterDef(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the filter definition for the specified filter name, if any; otherwise return <code>null</code>.
 * @param name Filter name to look up
 */
public String findFilterDef(String name) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterDef filterDef=context.findFilterDef(name);
  return filterDef.toString();
}

ID 1589=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterDef(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the filter definition for the specified filter name, if any; otherwise return <code>null</code>.
 * @param name Filter name to look up
 */
public String findFilterDef(String name) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterDef filterDef=context.findFilterDef(name);
  return filterDef.toString();
}

ID 1591=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterDef(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the filter definition for the specified filter name, if any; otherwise return <code>null</code>.
 * @param name Filter name to look up
 */
public String findFilterDef(String name) throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterDef filterDef=context.findFilterDef(name);
  return filterDef.toString();
}

ID 1592=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterDefs()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the set of defined filters for this Context.
 */
public String[] findFilterDefs() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterDef[] filterDefs=context.findFilterDefs();
  String[] stringFilters=new String[filterDefs.length];
  for (int counter=0; counter < filterDefs.length; counter++) {
    stringFilters[counter]=filterDefs[counter].toString();
  }
  return stringFilters;
}

ID 1593=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterDefs()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the set of defined filters for this Context.
 */
public String[] findFilterDefs() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterDef[] filterDefs=context.findFilterDefs();
  String[] stringFilters=new String[filterDefs.length];
  for (int counter=0; counter < filterDefs.length; counter++) {
    stringFilters[counter]=filterDefs[counter].toString();
  }
  return stringFilters;
}

ID 1595=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterDefs()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the set of defined filters for this Context.
 */
public String[] findFilterDefs() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterDef[] filterDefs=context.findFilterDefs();
  String[] stringFilters=new String[filterDefs.length];
  for (int counter=0; counter < filterDefs.length; counter++) {
    stringFilters[counter]=filterDefs[counter].toString();
  }
  return stringFilters;
}

ID 1596=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterMaps()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Return the set of filter mappings for this Context.
 */
public String[] findFilterMaps() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterMap[] maps=context.findFilterMaps();
  String[] stringMaps=new String[maps.length];
  for (int counter=0; counter < maps.length; counter++) {
    stringMaps[counter]=maps[counter].toString();
  }
  return stringMaps;
}

ID 1597=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterMaps()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Return the set of filter mappings for this Context.
 */
public String[] findFilterMaps() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterMap[] maps=context.findFilterMaps();
  String[] stringMaps=new String[maps.length];
  for (int counter=0; counter < maps.length; counter++) {
    stringMaps[counter]=maps[counter].toString();
  }
  return stringMaps;
}

ID 1599=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextMBean#findFilterMaps()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Return the set of filter mappings for this Context.
 */
public String[] findFilterMaps() throws MBeanException {
  Context context;
  try {
    context=(Context)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  FilterMap[] maps=context.findFilterMaps();
  String[] stringMaps=new String[maps.length];
  for (int counter=0; counter < maps.length; counter++) {
    stringMaps[counter]=maps[counter].toString();
  }
  return stringMaps;
}

ID 1600=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextEnvironmentMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  super.setAttribute(attribute);
  ContextEnvironment ce=null;
  try {
    ce=(ContextEnvironment)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  NamingResources nr=ce.getNamingResources();
  nr.removeEnvironment(ce.getName());
  nr.addEnvironment(ce);
}

ID 1601=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContextEnvironmentMBean#setAttribute(javax.management.Attribute)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  super.setAttribute(attribute);
  ContextEnvironment ce=null;
  try {
    ce=(ContextEnvironment)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  NamingResources nr=ce.getNamingResources();
  nr.removeEnvironment(ce.getName());
  nr.addEnvironment(ce);
}

ID 1614=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addChild(java.lang.String, java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Add a new child Container to those associated with this Container, if supported. Won't start the child yet. Has to be started with a call to Start method after necessary configurations are done.
 * @param type ClassName of the child to be added
 * @param name Name of the child to be added
 * @exception MBeanException if the child cannot be added
 */
public void addChild(String type,String name) throws MBeanException {
  Container contained=null;
  try {
    contained=(Container)Class.forName(type).newInstance();
    contained.setName(name);
    if (contained instanceof StandardHost) {
      HostConfig config=new HostConfig();
      contained.addLifecycleListener(config);
    }
 else     if (contained instanceof StandardContext) {
      ContextConfig config=new ContextConfig();
      contained.addLifecycleListener(config);
    }
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  boolean oldValue=true;
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
    oldValue=container.getStartChildren();
    container.setStartChildren(false);
    container.addChild(contained);
    contained.init();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
catch (  LifecycleException e) {
    throw new MBeanException(e);
  }
 finally {
    if (container != null) {
      container.setStartChildren(oldValue);
    }
  }
}

ID 1615=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addChild(java.lang.String, java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Add a new child Container to those associated with this Container, if supported. Won't start the child yet. Has to be started with a call to Start method after necessary configurations are done.
 * @param type ClassName of the child to be added
 * @param name Name of the child to be added
 * @exception MBeanException if the child cannot be added
 */
public void addChild(String type,String name) throws MBeanException {
  Container contained=null;
  try {
    contained=(Container)Class.forName(type).newInstance();
    contained.setName(name);
    if (contained instanceof StandardHost) {
      HostConfig config=new HostConfig();
      contained.addLifecycleListener(config);
    }
 else     if (contained instanceof StandardContext) {
      ContextConfig config=new ContextConfig();
      contained.addLifecycleListener(config);
    }
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  boolean oldValue=true;
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
    oldValue=container.getStartChildren();
    container.setStartChildren(false);
    container.addChild(contained);
    contained.init();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
catch (  LifecycleException e) {
    throw new MBeanException(e);
  }
 finally {
    if (container != null) {
      container.setStartChildren(oldValue);
    }
  }
}

ID 1616=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addChild(java.lang.String, java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Add a new child Container to those associated with this Container, if supported. Won't start the child yet. Has to be started with a call to Start method after necessary configurations are done.
 * @param type ClassName of the child to be added
 * @param name Name of the child to be added
 * @exception MBeanException if the child cannot be added
 */
public void addChild(String type,String name) throws MBeanException {
  Container contained=null;
  try {
    contained=(Container)Class.forName(type).newInstance();
    contained.setName(name);
    if (contained instanceof StandardHost) {
      HostConfig config=new HostConfig();
      contained.addLifecycleListener(config);
    }
 else     if (contained instanceof StandardContext) {
      ContextConfig config=new ContextConfig();
      contained.addLifecycleListener(config);
    }
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  boolean oldValue=true;
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
    oldValue=container.getStartChildren();
    container.setStartChildren(false);
    container.addChild(contained);
    contained.init();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
catch (  LifecycleException e) {
    throw new MBeanException(e);
  }
 finally {
    if (container != null) {
      container.setStartChildren(oldValue);
    }
  }
}

ID 1617=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addChild(java.lang.String, java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Add a new child Container to those associated with this Container, if supported. Won't start the child yet. Has to be started with a call to Start method after necessary configurations are done.
 * @param type ClassName of the child to be added
 * @param name Name of the child to be added
 * @exception MBeanException if the child cannot be added
 */
public void addChild(String type,String name) throws MBeanException {
  Container contained=null;
  try {
    contained=(Container)Class.forName(type).newInstance();
    contained.setName(name);
    if (contained instanceof StandardHost) {
      HostConfig config=new HostConfig();
      contained.addLifecycleListener(config);
    }
 else     if (contained instanceof StandardContext) {
      ContextConfig config=new ContextConfig();
      contained.addLifecycleListener(config);
    }
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  boolean oldValue=true;
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
    oldValue=container.getStartChildren();
    container.setStartChildren(false);
    container.addChild(contained);
    contained.init();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
catch (  LifecycleException e) {
    throw new MBeanException(e);
  }
 finally {
    if (container != null) {
      container.setStartChildren(oldValue);
    }
  }
}

ID 1618=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addChild(java.lang.String, java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Add a new child Container to those associated with this Container, if supported. Won't start the child yet. Has to be started with a call to Start method after necessary configurations are done.
 * @param type ClassName of the child to be added
 * @param name Name of the child to be added
 * @exception MBeanException if the child cannot be added
 */
public void addChild(String type,String name) throws MBeanException {
  Container contained=null;
  try {
    contained=(Container)Class.forName(type).newInstance();
    contained.setName(name);
    if (contained instanceof StandardHost) {
      HostConfig config=new HostConfig();
      contained.addLifecycleListener(config);
    }
 else     if (contained instanceof StandardContext) {
      ContextConfig config=new ContextConfig();
      contained.addLifecycleListener(config);
    }
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  boolean oldValue=true;
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
    oldValue=container.getStartChildren();
    container.setStartChildren(false);
    container.addChild(contained);
    contained.init();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
catch (  LifecycleException e) {
    throw new MBeanException(e);
  }
 finally {
    if (container != null) {
      container.setStartChildren(oldValue);
    }
  }
}

ID 1620=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addChild(java.lang.String, java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Add a new child Container to those associated with this Container, if supported. Won't start the child yet. Has to be started with a call to Start method after necessary configurations are done.
 * @param type ClassName of the child to be added
 * @param name Name of the child to be added
 * @exception MBeanException if the child cannot be added
 */
public void addChild(String type,String name) throws MBeanException {
  Container contained=null;
  try {
    contained=(Container)Class.forName(type).newInstance();
    contained.setName(name);
    if (contained instanceof StandardHost) {
      HostConfig config=new HostConfig();
      contained.addLifecycleListener(config);
    }
 else     if (contained instanceof StandardContext) {
      ContextConfig config=new ContextConfig();
      contained.addLifecycleListener(config);
    }
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  boolean oldValue=true;
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
    oldValue=container.getStartChildren();
    container.setStartChildren(false);
    container.addChild(contained);
    contained.init();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
catch (  LifecycleException e) {
    throw new MBeanException(e);
  }
 finally {
    if (container != null) {
      container.setStartChildren(oldValue);
    }
  }
}

ID 1621=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addChild(java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.Lifecycle#init()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Add a new child Container to those associated with this Container, if supported. Won't start the child yet. Has to be started with a call to Start method after necessary configurations are done.
 * @param type ClassName of the child to be added
 * @param name Name of the child to be added
 * @exception MBeanException if the child cannot be added
 */
public void addChild(String type,String name) throws MBeanException {
  Container contained=null;
  try {
    contained=(Container)Class.forName(type).newInstance();
    contained.setName(name);
    if (contained instanceof StandardHost) {
      HostConfig config=new HostConfig();
      contained.addLifecycleListener(config);
    }
 else     if (contained instanceof StandardContext) {
      ContextConfig config=new ContextConfig();
      contained.addLifecycleListener(config);
    }
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  boolean oldValue=true;
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
    oldValue=container.getStartChildren();
    container.setStartChildren(false);
    container.addChild(contained);
    contained.init();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
catch (  LifecycleException e) {
    throw new MBeanException(e);
  }
 finally {
    if (container != null) {
      container.setStartChildren(oldValue);
    }
  }
}

ID 1622=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeChild(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Remove an existing child Container from association with this parent Container.
 * @param name Name of the existing child Container to be removed
 */
public void removeChild(String name) throws MBeanException {
  if (name != null) {
    try {
      Container container=(Container)getManagedResource();
      Container contained=container.findChild(name);
      container.removeChild(contained);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1623=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeChild(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Remove an existing child Container from association with this parent Container.
 * @param name Name of the existing child Container to be removed
 */
public void removeChild(String name) throws MBeanException {
  if (name != null) {
    try {
      Container container=(Container)getManagedResource();
      Container contained=container.findChild(name);
      container.removeChild(contained);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1625=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeChild(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Remove an existing child Container from association with this parent Container.
 * @param name Name of the existing child Container to be removed
 */
public void removeChild(String name) throws MBeanException {
  if (name != null) {
    try {
      Container container=(Container)getManagedResource();
      Container contained=container.findChild(name);
      container.removeChild(contained);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1626=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addValve(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Adds a valve to this Container instance.
 * @param valveType ClassName of the valve to be added
 * @exception MBeanException if a component cannot be removed
 */
public String addValve(String valveType) throws MBeanException {
  Valve valve=null;
  try {
    valve=(Valve)Class.forName(valveType).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (valve == null) {
    return null;
  }
  try {
    ContainerBase container=(ContainerBase)getManagedResource();
    container.addValve(valve);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return ((LifecycleMBeanBase)valve).getObjectName().toString();
}

ID 1627=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addValve(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Adds a valve to this Container instance.
 * @param valveType ClassName of the valve to be added
 * @exception MBeanException if a component cannot be removed
 */
public String addValve(String valveType) throws MBeanException {
  Valve valve=null;
  try {
    valve=(Valve)Class.forName(valveType).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (valve == null) {
    return null;
  }
  try {
    ContainerBase container=(ContainerBase)getManagedResource();
    container.addValve(valve);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return ((LifecycleMBeanBase)valve).getObjectName().toString();
}

ID 1628=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addValve(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Adds a valve to this Container instance.
 * @param valveType ClassName of the valve to be added
 * @exception MBeanException if a component cannot be removed
 */
public String addValve(String valveType) throws MBeanException {
  Valve valve=null;
  try {
    valve=(Valve)Class.forName(valveType).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (valve == null) {
    return null;
  }
  try {
    ContainerBase container=(ContainerBase)getManagedResource();
    container.addValve(valve);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return ((LifecycleMBeanBase)valve).getObjectName().toString();
}

ID 1629=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addValve(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Adds a valve to this Container instance.
 * @param valveType ClassName of the valve to be added
 * @exception MBeanException if a component cannot be removed
 */
public String addValve(String valveType) throws MBeanException {
  Valve valve=null;
  try {
    valve=(Valve)Class.forName(valveType).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (valve == null) {
    return null;
  }
  try {
    ContainerBase container=(ContainerBase)getManagedResource();
    container.addValve(valve);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return ((LifecycleMBeanBase)valve).getObjectName().toString();
}

ID 1630=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addValve(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Adds a valve to this Container instance.
 * @param valveType ClassName of the valve to be added
 * @exception MBeanException if a component cannot be removed
 */
public String addValve(String valveType) throws MBeanException {
  Valve valve=null;
  try {
    valve=(Valve)Class.forName(valveType).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (valve == null) {
    return null;
  }
  try {
    ContainerBase container=(ContainerBase)getManagedResource();
    container.addValve(valve);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return ((LifecycleMBeanBase)valve).getObjectName().toString();
}

ID 1632=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addValve(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Adds a valve to this Container instance.
 * @param valveType ClassName of the valve to be added
 * @exception MBeanException if a component cannot be removed
 */
public String addValve(String valveType) throws MBeanException {
  Valve valve=null;
  try {
    valve=(Valve)Class.forName(valveType).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (valve == null) {
    return null;
  }
  try {
    ContainerBase container=(ContainerBase)getManagedResource();
    container.addValve(valve);
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  return ((LifecycleMBeanBase)valve).getObjectName().toString();
}

ID 1633=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeValve(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Remove an existing Valve.
 * @param valveName MBean Name of the Valve to remove
 * @exception MBeanException if a component cannot be removed
 */
public void removeValve(String valveName) throws MBeanException {
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ObjectName oname;
  try {
    oname=new ObjectName(valveName);
  }
 catch (  MalformedObjectNameException e) {
    throw new MBeanException(e);
  }
catch (  NullPointerException e) {
    throw new MBeanException(e);
  }
  if (container != null) {
    Valve[] valves=container.getPipeline().getValves();
    for (int i=0; i < valves.length; i++) {
      ObjectName voname=((ValveBase)valves[i]).getObjectName();
      if (voname.equals(oname)) {
        container.getPipeline().removeValve(valves[i]);
      }
    }
  }
}

ID 1634=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeValve(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Remove an existing Valve.
 * @param valveName MBean Name of the Valve to remove
 * @exception MBeanException if a component cannot be removed
 */
public void removeValve(String valveName) throws MBeanException {
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ObjectName oname;
  try {
    oname=new ObjectName(valveName);
  }
 catch (  MalformedObjectNameException e) {
    throw new MBeanException(e);
  }
catch (  NullPointerException e) {
    throw new MBeanException(e);
  }
  if (container != null) {
    Valve[] valves=container.getPipeline().getValves();
    for (int i=0; i < valves.length; i++) {
      ObjectName voname=((ValveBase)valves[i]).getObjectName();
      if (voname.equals(oname)) {
        container.getPipeline().removeValve(valves[i]);
      }
    }
  }
}

ID 1636=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeValve(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Remove an existing Valve.
 * @param valveName MBean Name of the Valve to remove
 * @exception MBeanException if a component cannot be removed
 */
public void removeValve(String valveName) throws MBeanException {
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ObjectName oname;
  try {
    oname=new ObjectName(valveName);
  }
 catch (  MalformedObjectNameException e) {
    throw new MBeanException(e);
  }
catch (  NullPointerException e) {
    throw new MBeanException(e);
  }
  if (container != null) {
    Valve[] valves=container.getPipeline().getValves();
    for (int i=0; i < valves.length; i++) {
      ObjectName voname=((ValveBase)valves[i]).getObjectName();
      if (voname.equals(oname)) {
        container.getPipeline().removeValve(valves[i]);
      }
    }
  }
}

ID 1637=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeValve(java.lang.String)
Rmethod: javax.management.ObjectName#ObjectName(java.lang.String)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Remove an existing Valve.
 * @param valveName MBean Name of the Valve to remove
 * @exception MBeanException if a component cannot be removed
 */
public void removeValve(String valveName) throws MBeanException {
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ObjectName oname;
  try {
    oname=new ObjectName(valveName);
  }
 catch (  MalformedObjectNameException e) {
    throw new MBeanException(e);
  }
catch (  NullPointerException e) {
    throw new MBeanException(e);
  }
  if (container != null) {
    Valve[] valves=container.getPipeline().getValves();
    for (int i=0; i < valves.length; i++) {
      ObjectName voname=((ValveBase)valves[i]).getObjectName();
      if (voname.equals(oname)) {
        container.getPipeline().removeValve(valves[i]);
      }
    }
  }
}

ID 1638=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addLifeCycleListener(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Add a LifecycleEvent listener to this component.
 * @param type ClassName of the listener to add
 */
public void addLifeCycleListener(String type) throws MBeanException {
  LifecycleListener listener=null;
  try {
    listener=(LifecycleListener)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (listener != null) {
    try {
      ContainerBase container=(ContainerBase)getManagedResource();
      container.addLifecycleListener(listener);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1639=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addLifeCycleListener(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Add a LifecycleEvent listener to this component.
 * @param type ClassName of the listener to add
 */
public void addLifeCycleListener(String type) throws MBeanException {
  LifecycleListener listener=null;
  try {
    listener=(LifecycleListener)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (listener != null) {
    try {
      ContainerBase container=(ContainerBase)getManagedResource();
      container.addLifecycleListener(listener);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1640=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addLifeCycleListener(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Add a LifecycleEvent listener to this component.
 * @param type ClassName of the listener to add
 */
public void addLifeCycleListener(String type) throws MBeanException {
  LifecycleListener listener=null;
  try {
    listener=(LifecycleListener)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (listener != null) {
    try {
      ContainerBase container=(ContainerBase)getManagedResource();
      container.addLifecycleListener(listener);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1641=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addLifeCycleListener(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Add a LifecycleEvent listener to this component.
 * @param type ClassName of the listener to add
 */
public void addLifeCycleListener(String type) throws MBeanException {
  LifecycleListener listener=null;
  try {
    listener=(LifecycleListener)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (listener != null) {
    try {
      ContainerBase container=(ContainerBase)getManagedResource();
      container.addLifecycleListener(listener);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1642=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addLifeCycleListener(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Add a LifecycleEvent listener to this component.
 * @param type ClassName of the listener to add
 */
public void addLifeCycleListener(String type) throws MBeanException {
  LifecycleListener listener=null;
  try {
    listener=(LifecycleListener)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (listener != null) {
    try {
      ContainerBase container=(ContainerBase)getManagedResource();
      container.addLifecycleListener(listener);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1644=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#addLifeCycleListener(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Add a LifecycleEvent listener to this component.
 * @param type ClassName of the listener to add
 */
public void addLifeCycleListener(String type) throws MBeanException {
  LifecycleListener listener=null;
  try {
    listener=(LifecycleListener)Class.forName(type).newInstance();
  }
 catch (  InstantiationException e) {
    throw new MBeanException(e);
  }
catch (  IllegalAccessException e) {
    throw new MBeanException(e);
  }
catch (  ClassNotFoundException e) {
    throw new MBeanException(e);
  }
  if (listener != null) {
    try {
      ContainerBase container=(ContainerBase)getManagedResource();
      container.addLifecycleListener(listener);
    }
 catch (    InstanceNotFoundException e) {
      throw new MBeanException(e);
    }
catch (    RuntimeOperationsException e) {
      throw new MBeanException(e);
    }
catch (    InvalidTargetObjectTypeException e) {
      throw new MBeanException(e);
    }
  }
}

ID 1645=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeLifeCycleListeners(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Remove a LifecycleEvent listeners from this component.
 * @param type The ClassName of the listeners to be removed. Note that all the listeners having given ClassName will be removed. 
 */
public void removeLifeCycleListeners(String type) throws MBeanException {
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  LifecycleListener[] listeners=container.findLifecycleListeners();
  for (  LifecycleListener listener : listeners) {
    if (listener.getClass().getName().equals(type)) {
      container.removeLifecycleListener(listener);
    }
  }
}

ID 1646=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeLifeCycleListeners(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * Remove a LifecycleEvent listeners from this component.
 * @param type The ClassName of the listeners to be removed. Note that all the listeners having given ClassName will be removed. 
 */
public void removeLifeCycleListeners(String type) throws MBeanException {
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  LifecycleListener[] listeners=container.findLifecycleListeners();
  for (  LifecycleListener listener : listeners) {
    if (listener.getClass().getName().equals(type)) {
      container.removeLifecycleListener(listener);
    }
  }
}

ID 1648=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#removeLifeCycleListeners(java.lang.String)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * Remove a LifecycleEvent listeners from this component.
 * @param type The ClassName of the listeners to be removed. Note that all the listeners having given ClassName will be removed. 
 */
public void removeLifeCycleListeners(String type) throws MBeanException {
  ContainerBase container=null;
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  LifecycleListener[] listeners=container.findLifecycleListeners();
  for (  LifecycleListener listener : listeners) {
    if (listener.getClass().getName().equals(type)) {
      container.removeLifecycleListener(listener);
    }
  }
}

ID 1649=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#findLifecycleListenerNames()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * List the class name of each of the lifecycle listeners added to this container.
 */
public String[] findLifecycleListenerNames() throws MBeanException {
  ContainerBase container=null;
  List<String> result=new ArrayList<String>();
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  LifecycleListener[] listeners=container.findLifecycleListeners();
  for (  LifecycleListener listener : listeners) {
    result.add(listener.getClass().getName());
  }
  return result.toArray(new String[result.size()]);
}

ID 1650=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#findLifecycleListenerNames()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * List the class name of each of the lifecycle listeners added to this container.
 */
public String[] findLifecycleListenerNames() throws MBeanException {
  ContainerBase container=null;
  List<String> result=new ArrayList<String>();
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  LifecycleListener[] listeners=container.findLifecycleListeners();
  for (  LifecycleListener listener : listeners) {
    result.add(listener.getClass().getName());
  }
  return result.toArray(new String[result.size()]);
}

ID 1652=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#findLifecycleListenerNames()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * List the class name of each of the lifecycle listeners added to this container.
 */
public String[] findLifecycleListenerNames() throws MBeanException {
  ContainerBase container=null;
  List<String> result=new ArrayList<String>();
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  LifecycleListener[] listeners=container.findLifecycleListeners();
  for (  LifecycleListener listener : listeners) {
    result.add(listener.getClass().getName());
  }
  return result.toArray(new String[result.size()]);
}

ID 1653=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#findContainerListenerNames()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * List the class name of each of the container listeners added to this container.
 */
public String[] findContainerListenerNames() throws MBeanException {
  ContainerBase container=null;
  List<String> result=new ArrayList<String>();
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ContainerListener[] listeners=container.findContainerListeners();
  for (  ContainerListener listener : listeners) {
    result.add(listener.getClass().getName());
  }
  return result.toArray(new String[result.size()]);
}

ID 1654=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#findContainerListenerNames()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: 
thrown: InvalidTargetObjectTypeException
exception comment: /** 
 * Exception thrown when an invalid target object type is specified. <p>The <b>serialVersionUID</b> of this class is <code>1190536278266811217L</code>.
 * @since 1.5
 */

block: 
/** 
 * List the class name of each of the container listeners added to this container.
 */
public String[] findContainerListenerNames() throws MBeanException {
  ContainerBase container=null;
  List<String> result=new ArrayList<String>();
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ContainerListener[] listeners=container.findContainerListeners();
  for (  ContainerListener listener : listeners) {
    result.add(listener.getClass().getName());
  }
  return result.toArray(new String[result.size()]);
}

ID 1656=========================================================================type: 1
Method:org.apache.catalina.mbeans.ContainerMBean#findContainerListenerNames()
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#getManagedResource()
parentException: JMRuntimeException RuntimeException 
thrown: RuntimeOperationsException
exception comment: /** 
 * Represents runtime exceptions thrown in the agent when performing operations on MBeans. It wraps the actual <CODE>java.lang.RuntimeException</CODE> thrown.
 * @since 1.5
 */

block: 
/** 
 * List the class name of each of the container listeners added to this container.
 */
public String[] findContainerListenerNames() throws MBeanException {
  ContainerBase container=null;
  List<String> result=new ArrayList<String>();
  try {
    container=(ContainerBase)getManagedResource();
  }
 catch (  InstanceNotFoundException e) {
    throw new MBeanException(e);
  }
catch (  RuntimeOperationsException e) {
    throw new MBeanException(e);
  }
catch (  InvalidTargetObjectTypeException e) {
    throw new MBeanException(e);
  }
  ContainerListener[] listeners=container.findContainerListeners();
  for (  ContainerListener listener : listeners) {
    result.add(listener.getClass().getName());
  }
  return result.toArray(new String[result.size()]);
}

ID 1657=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans()
Rmethod: javax.naming.InitialContext#InitialContext()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Create the MBeans for the interesting global JNDI resources.
 */
protected void createMBeans(){
  Context context=null;
  try {
    context=(Context)(new InitialContext()).lookup("java:/");
  }
 catch (  NamingException e) {
    log.error("No global naming context defined for server");
    return;
  }
  try {
    createMBeans("",context);
  }
 catch (  NamingException e) {
    log.error("Exception processing Global JNDI Resources",e);
  }
}

ID 1658=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans()
Rmethod: javax.naming.InitialContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Create the MBeans for the interesting global JNDI resources.
 */
protected void createMBeans(){
  Context context=null;
  try {
    context=(Context)(new InitialContext()).lookup("java:/");
  }
 catch (  NamingException e) {
    log.error("No global naming context defined for server");
    return;
  }
  try {
    createMBeans("",context);
  }
 catch (  NamingException e) {
    log.error("Exception processing Global JNDI Resources",e);
  }
}

ID 1659=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans()
Rmethod: org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans(java.lang.String, javax.naming.Context)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Create the MBeans for the interesting global JNDI resources.
 */
protected void createMBeans(){
  Context context=null;
  try {
    context=(Context)(new InitialContext()).lookup("java:/");
  }
 catch (  NamingException e) {
    log.error("No global naming context defined for server");
    return;
  }
  try {
    createMBeans("",context);
  }
 catch (  NamingException e) {
    log.error("Exception processing Global JNDI Resources",e);
  }
}

ID 1665=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans(java.lang.String, javax.naming.Context)
Rmethod: org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans(java.lang.String, org.apache.catalina.UserDatabase)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create the MBeans for the interesting global JNDI resources in the specified naming context.
 * @param prefix Prefix for complete object name paths
 * @param context Context to be scanned
 * @exception NamingException if a JNDI exception occurs
 */
protected void createMBeans(String prefix,Context context) throws NamingException {
  if (log.isDebugEnabled()) {
    log.debug("Creating MBeans for Global JNDI Resources in Context '" + prefix + "'");
  }
  try {
    NamingEnumeration<Binding> bindings=context.listBindings("");
    while (bindings.hasMore()) {
      Binding binding=bindings.next();
      String name=prefix + binding.getName();
      Object value=context.lookup(binding.getName());
      if (log.isDebugEnabled()) {
        log.debug("Checking resource " + name);
      }
      if (value instanceof Context) {
        createMBeans(name + "/",(Context)value);
      }
 else       if (value instanceof UserDatabase) {
        try {
          createMBeans(name,(UserDatabase)value);
        }
 catch (        Exception e) {
          log.error("Exception creating UserDatabase MBeans for " + name,e);
        }
      }
    }
  }
 catch (  RuntimeException ex) {
    log.error("RuntimeException " + ex);
  }
catch (  OperationNotSupportedException ex) {
    log.error("Operation not supported " + ex);
  }
}

ID 1666=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans(java.lang.String, org.apache.catalina.UserDatabase)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.UserDatabase)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create the MBeans for the specified UserDatabase and its contents.
 * @param name Complete resource name of this UserDatabase
 * @param database The UserDatabase to be processed
 * @exception Exception if an exception occurs while creating MBeans
 */
protected void createMBeans(String name,UserDatabase database) throws Exception {
  if (log.isDebugEnabled()) {
    log.debug("Creating UserDatabase MBeans for resource " + name);
    log.debug("Database=" + database);
  }
  try {
    MBeanUtils.createMBean(database);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException("Cannot create UserDatabase MBean for resource " + name,e);
  }
  Iterator<Role> roles=database.getRoles();
  while (roles.hasNext()) {
    Role role=roles.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Role MBean for role " + role);
    }
    try {
      MBeanUtils.createMBean(role);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Role MBean for role " + role,e);
    }
  }
  Iterator<Group> groups=database.getGroups();
  while (groups.hasNext()) {
    Group group=groups.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Group MBean for group " + group);
    }
    try {
      MBeanUtils.createMBean(group);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Group MBean for group " + group,e);
    }
  }
  Iterator<User> users=database.getUsers();
  while (users.hasNext()) {
    User user=users.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating User MBean for user " + user);
    }
    try {
      MBeanUtils.createMBean(user);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create User MBean for user " + user,e);
    }
  }
}

ID 1667=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans(java.lang.String, org.apache.catalina.UserDatabase)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.Role)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create the MBeans for the specified UserDatabase and its contents.
 * @param name Complete resource name of this UserDatabase
 * @param database The UserDatabase to be processed
 * @exception Exception if an exception occurs while creating MBeans
 */
protected void createMBeans(String name,UserDatabase database) throws Exception {
  if (log.isDebugEnabled()) {
    log.debug("Creating UserDatabase MBeans for resource " + name);
    log.debug("Database=" + database);
  }
  try {
    MBeanUtils.createMBean(database);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException("Cannot create UserDatabase MBean for resource " + name,e);
  }
  Iterator<Role> roles=database.getRoles();
  while (roles.hasNext()) {
    Role role=roles.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Role MBean for role " + role);
    }
    try {
      MBeanUtils.createMBean(role);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Role MBean for role " + role,e);
    }
  }
  Iterator<Group> groups=database.getGroups();
  while (groups.hasNext()) {
    Group group=groups.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Group MBean for group " + group);
    }
    try {
      MBeanUtils.createMBean(group);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Group MBean for group " + group,e);
    }
  }
  Iterator<User> users=database.getUsers();
  while (users.hasNext()) {
    User user=users.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating User MBean for user " + user);
    }
    try {
      MBeanUtils.createMBean(user);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create User MBean for user " + user,e);
    }
  }
}

ID 1668=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans(java.lang.String, org.apache.catalina.UserDatabase)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.Group)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create the MBeans for the specified UserDatabase and its contents.
 * @param name Complete resource name of this UserDatabase
 * @param database The UserDatabase to be processed
 * @exception Exception if an exception occurs while creating MBeans
 */
protected void createMBeans(String name,UserDatabase database) throws Exception {
  if (log.isDebugEnabled()) {
    log.debug("Creating UserDatabase MBeans for resource " + name);
    log.debug("Database=" + database);
  }
  try {
    MBeanUtils.createMBean(database);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException("Cannot create UserDatabase MBean for resource " + name,e);
  }
  Iterator<Role> roles=database.getRoles();
  while (roles.hasNext()) {
    Role role=roles.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Role MBean for role " + role);
    }
    try {
      MBeanUtils.createMBean(role);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Role MBean for role " + role,e);
    }
  }
  Iterator<Group> groups=database.getGroups();
  while (groups.hasNext()) {
    Group group=groups.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Group MBean for group " + group);
    }
    try {
      MBeanUtils.createMBean(group);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Group MBean for group " + group,e);
    }
  }
  Iterator<User> users=database.getUsers();
  while (users.hasNext()) {
    User user=users.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating User MBean for user " + user);
    }
    try {
      MBeanUtils.createMBean(user);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create User MBean for user " + user,e);
    }
  }
}

ID 1669=========================================================================type: 1
Method:org.apache.catalina.mbeans.GlobalResourcesLifecycleListener#createMBeans(java.lang.String, org.apache.catalina.UserDatabase)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.User)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create the MBeans for the specified UserDatabase and its contents.
 * @param name Complete resource name of this UserDatabase
 * @param database The UserDatabase to be processed
 * @exception Exception if an exception occurs while creating MBeans
 */
protected void createMBeans(String name,UserDatabase database) throws Exception {
  if (log.isDebugEnabled()) {
    log.debug("Creating UserDatabase MBeans for resource " + name);
    log.debug("Database=" + database);
  }
  try {
    MBeanUtils.createMBean(database);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException("Cannot create UserDatabase MBean for resource " + name,e);
  }
  Iterator<Role> roles=database.getRoles();
  while (roles.hasNext()) {
    Role role=roles.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Role MBean for role " + role);
    }
    try {
      MBeanUtils.createMBean(role);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Role MBean for role " + role,e);
    }
  }
  Iterator<Group> groups=database.getGroups();
  while (groups.hasNext()) {
    Group group=groups.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating Group MBean for group " + group);
    }
    try {
      MBeanUtils.createMBean(group);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create Group MBean for group " + group,e);
    }
  }
  Iterator<User> users=database.getUsers();
  while (users.hasNext()) {
    User user=users.next();
    if (log.isDebugEnabled()) {
      log.debug("  Creating User MBean for user " + user);
    }
    try {
      MBeanUtils.createMBean(user);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Cannot create User MBean for user " + user,e);
    }
  }
}

ID 1670=========================================================================type: 1
Method:org.apache.catalina.mbeans.GroupMBean#getRoles()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.Role)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Names of all authorized roles for this group.
 */
public String[] getRoles(){
  Group group=(Group)this.resource;
  ArrayList<String> results=new ArrayList<String>();
  Iterator<Role> roles=group.getRoles();
  while (roles.hasNext()) {
    Role role=null;
    try {
      role=roles.next();
      ObjectName oname=MBeanUtils.createObjectName(managed.getDomain(),role);
      results.add(oname.toString());
    }
 catch (    MalformedObjectNameException e) {
      IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for role " + role);
      iae.initCause(e);
      throw iae;
    }
  }
  return results.toArray(new String[results.size()]);
}

ID 1671=========================================================================type: 1
Method:org.apache.catalina.mbeans.GroupMBean#getUsers()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.User)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Names of all users that are members of this group.
 */
public String[] getUsers(){
  Group group=(Group)this.resource;
  ArrayList<String> results=new ArrayList<String>();
  Iterator<User> users=group.getUsers();
  while (users.hasNext()) {
    User user=null;
    try {
      user=users.next();
      ObjectName oname=MBeanUtils.createObjectName(managed.getDomain(),user);
      results.add(oname.toString());
    }
 catch (    MalformedObjectNameException e) {
      IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for user " + user);
      iae.initCause(e);
      throw iae;
    }
  }
  return results.toArray(new String[results.size()]);
}

ID 1672=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: java.rmi.registry.LocateRegistry#createRegistry(int, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
parentException: IOException 
thrown: RemoteException
exception comment: /** 
 * A <code>RemoteException</code> is the common superclass for a number of communication-related exceptions that may occur during the execution of a remote method call.  Each method of a remote interface, an interface that extends <code>java.rmi.Remote</code>, must list <code>RemoteException</code> in its throws clause. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "wrapped remote exception" that may be provided at construction time and accessed via the public  {@link #detail} field is now known as the <i>cause</i>, andmay be accessed via the  {@link Throwable#getCause()} method, as well asthe aforementioned "legacy field." <p>Invoking the method  {@link Throwable#initCause(Throwable)} on aninstance of <code>RemoteException</code> always throws  {@link IllegalStateException}.
 * @author  Ann Wollrath
 * @since   JDK1.1
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1673=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: javax.management.remote.JMXServiceURL#JMXServiceURL(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1674=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: javax.management.remote.rmi.RMIJRMPServerImpl#RMIJRMPServerImpl(int, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, Map<java.lang.String,?>)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1675=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: javax.management.remote.rmi.RMIConnectorServer#RMIConnectorServer(javax.management.remote.JMXServiceURL, Map<java.lang.String,?>, javax.management.remote.rmi.RMIServerImpl, javax.management.MBeanServer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1676=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: javax.management.remote.rmi.RMIConnectorServer#start()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1677=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: javax.management.remote.rmi.RMIJRMPServerImpl#toStub()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1678=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: java.rmi.registry.Registry#bind(java.lang.String, java.rmi.Remote)
parentException: IOException 
thrown: RemoteException
exception comment: /** 
 * A <code>RemoteException</code> is the common superclass for a number of communication-related exceptions that may occur during the execution of a remote method call.  Each method of a remote interface, an interface that extends <code>java.rmi.Remote</code>, must list <code>RemoteException</code> in its throws clause. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "wrapped remote exception" that may be provided at construction time and accessed via the public  {@link #detail} field is now known as the <i>cause</i>, andmay be accessed via the  {@link Throwable#getCause()} method, as well asthe aforementioned "legacy field." <p>Invoking the method  {@link Throwable#initCause(Throwable)} on aninstance of <code>RemoteException</code> always throws  {@link IllegalStateException}.
 * @author  Ann Wollrath
 * @since   JDK1.1
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1679=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: java.rmi.registry.Registry#bind(java.lang.String, java.rmi.Remote)
parentException: 
thrown: AlreadyBoundException
exception comment: /** 
 * An <code>AlreadyBoundException</code> is thrown if an attempt is made to bind an object in the registry to a name that already has an associated binding.
 * @since   JDK1.1
 * @author  Ann Wollrath
 * @author  Roger Riggs
 * @see java.rmi.Naming#bind(String,java.rmi.Remote)
 * @see java.rmi.registry.Registry#bind(String,java.rmi.Remote)
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1680=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#createServer(java.lang.String, java.lang.String, int, int, HashMap<java.lang.String,java.lang.Object>, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)
Rmethod: java.rmi.registry.Registry#bind(java.lang.String, java.rmi.Remote)
parentException: RemoteException IOException 
thrown: AccessException
exception comment: /** 
 * An <code>AccessException</code> is thrown by certain methods of the <code>java.rmi.Naming</code> class (specifically <code>bind</code>, <code>rebind</code>, and <code>unbind</code>) and methods of the <code>java.rmi.activation.ActivationSystem</code> interface to indicate that the caller does not have permission to perform the action requested by the method call.  If the method was invoked from a non-local host, then an <code>AccessException</code> is thrown.
 * @author  Ann Wollrath
 * @author  Roger Riggs
 * @since   JDK1.1
 * @see java.rmi.Naming
 * @see java.rmi.activation.ActivationSystem
 */

block: 
private JMXConnectorServer createServer(String serverName,String bindAddress,int theRmiRegistryPort,int theRmiServerPort,HashMap<String,Object> theEnv,RMIClientSocketFactory registryCsf,RMIServerSocketFactory registrySsf,RMIClientSocketFactory serverCsf,RMIServerSocketFactory serverSsf){
  Registry registry;
  try {
    registry=LocateRegistry.createRegistry(theRmiRegistryPort,registryCsf,registrySsf);
  }
 catch (  RemoteException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createRegistryFailed",serverName,Integer.toString(theRmiRegistryPort)),e);
    return null;
  }
  if (bindAddress == null) {
    bindAddress="localhost";
  }
  String url="service:jmx:rmi://" + bindAddress;
  JMXServiceURL serviceUrl;
  try {
    serviceUrl=new JMXServiceURL(url);
  }
 catch (  MalformedURLException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidURL",serverName,url),e);
    return null;
  }
  RMIConnectorServer cs=null;
  try {
    RMIJRMPServerImpl server=new RMIJRMPServerImpl(rmiServerPortPlatform,serverCsf,serverSsf,theEnv);
    cs=new RMIConnectorServer(serviceUrl,theEnv,server,ManagementFactory.getPlatformMBeanServer());
    cs.start();
    registry.bind("jmxrmi",server.toStub());
    log.info(sm.getString("jmxRemoteLifecycleListener.start",Integer.toString(theRmiRegistryPort),Integer.toString(theRmiServerPort),serverName));
  }
 catch (  IOException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
catch (  AlreadyBoundException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.createServerFailed",serverName),e);
  }
  return cs;
}

ID 1681=========================================================================type: 1
Method:org.apache.catalina.mbeans.JmxRemoteLifecycleListener#destroyServer(java.lang.String, javax.management.remote.JMXConnectorServer)
Rmethod: javax.management.remote.JMXConnectorServerMBean#stop()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void destroyServer(String serverName,JMXConnectorServer theConnectorServer){
  if (theConnectorServer != null) {
    try {
      theConnectorServer.stop();
    }
 catch (    IOException e) {
      log.error(sm.getString("jmxRemoteLifecycleListener.destroyServerFailed",serverName),e);
    }
  }
}

ID 1685=========================================================================type: 1
Method:org.apache.catalina.mbeans.RmiServerBindSocketFactory#RmiServerBindSocketFactory(java.lang.String)
Rmethod: java.net.InetAddress#getByName(java.lang.String)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
public RmiServerBindSocketFactory(String address){
  InetAddress bindAddress=null;
  try {
    bindAddress=InetAddress.getByName(address);
  }
 catch (  UnknownHostException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidRmiBindAddress",address),e);
  }
  this.bindAddress=bindAddress;
}

ID 1687=========================================================================type: 1
Method:org.apache.catalina.mbeans.SslRmiServerBindSocketFactory#SslRmiServerBindSocketFactory(java.lang.String[], java.lang.String[], boolean, java.lang.String)
Rmethod: java.net.InetAddress#getByName(java.lang.String)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
public SslRmiServerBindSocketFactory(String[] enabledCipherSuites,String[] enabledProtocols,boolean needClientAuth,String address){
  super(enabledCipherSuites,enabledProtocols,needClientAuth);
  InetAddress bindAddress=null;
  try {
    bindAddress=InetAddress.getByName(address);
  }
 catch (  UnknownHostException e) {
    log.error(sm.getString("jmxRemoteLifecycleListener.invalidRmiBindAddress",address),e);
  }
  this.bindAddress=bindAddress;
}

ID 1689=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#createGroup(java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.Group)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Group and return the corresponding MBean Name.
 * @param groupname Group name of the new group
 * @param description Description of the new group
 */
public String createGroup(String groupname,String description){
  UserDatabase database=(UserDatabase)this.resource;
  Group group=database.createGroup(groupname,description);
  try {
    MBeanUtils.createMBean(group);
  }
 catch (  Exception e) {
    IllegalArgumentException iae=new IllegalArgumentException("Exception creating group [" + groupname + "] MBean");
    iae.initCause(e);
    throw iae;
  }
  return (findGroup(groupname));
}

ID 1690=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#createRole(java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.Role)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Role and return the corresponding MBean Name.
 * @param rolename Group name of the new group
 * @param description Description of the new group
 */
public String createRole(String rolename,String description){
  UserDatabase database=(UserDatabase)this.resource;
  Role role=database.createRole(rolename,description);
  try {
    MBeanUtils.createMBean(role);
  }
 catch (  Exception e) {
    IllegalArgumentException iae=new IllegalArgumentException("Exception creating role [" + rolename + "] MBean");
    iae.initCause(e);
    throw iae;
  }
  return (findRole(rolename));
}

ID 1691=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#createUser(java.lang.String, java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.User)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new User and return the corresponding MBean Name.
 * @param username User name of the new user
 * @param password Password for the new user
 * @param fullName Full name for the new user
 */
public String createUser(String username,String password,String fullName){
  UserDatabase database=(UserDatabase)this.resource;
  User user=database.createUser(username,password,fullName);
  try {
    MBeanUtils.createMBean(user);
  }
 catch (  Exception e) {
    IllegalArgumentException iae=new IllegalArgumentException("Exception creating user [" + username + "] MBean");
    iae.initCause(e);
    throw iae;
  }
  return (findUser(username));
}

ID 1692=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#findGroup(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.Group)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Name for the specified group name (if any); otherwise return <code>null</code>.
 * @param groupname Group name to look up
 */
public String findGroup(String groupname){
  UserDatabase database=(UserDatabase)this.resource;
  Group group=database.findGroup(groupname);
  if (group == null) {
    return (null);
  }
  try {
    ObjectName oname=MBeanUtils.createObjectName(managedGroup.getDomain(),group);
    return (oname.toString());
  }
 catch (  MalformedObjectNameException e) {
    IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for group [" + groupname + "]");
    iae.initCause(e);
    throw iae;
  }
}

ID 1693=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#findRole(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.Role)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Name for the specified role name (if any); otherwise return <code>null</code>.
 * @param rolename Role name to look up
 */
public String findRole(String rolename){
  UserDatabase database=(UserDatabase)this.resource;
  Role role=database.findRole(rolename);
  if (role == null) {
    return (null);
  }
  try {
    ObjectName oname=MBeanUtils.createObjectName(managedRole.getDomain(),role);
    return (oname.toString());
  }
 catch (  MalformedObjectNameException e) {
    IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for role [" + rolename + "]");
    iae.initCause(e);
    throw iae;
  }
}

ID 1694=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#findUser(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createObjectName(java.lang.String, org.apache.catalina.User)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Return the MBean Name for the specified user name (if any); otherwise return <code>null</code>.
 * @param username User name to look up
 */
public String findUser(String username){
  UserDatabase database=(UserDatabase)this.resource;
  User user=database.findUser(username);
  if (user == null) {
    return (null);
  }
  try {
    ObjectName oname=MBeanUtils.createObjectName(managedUser.getDomain(),user);
    return (oname.toString());
  }
 catch (  MalformedObjectNameException e) {
    IllegalArgumentException iae=new IllegalArgumentException("Cannot create object name for user [" + username + "]");
    iae.initCause(e);
    throw iae;
  }
}

ID 1695=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#removeGroup(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.Group)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove an existing group and destroy the corresponding MBean.
 * @param groupname Group name to remove
 */
public void removeGroup(String groupname){
  UserDatabase database=(UserDatabase)this.resource;
  Group group=database.findGroup(groupname);
  if (group == null) {
    return;
  }
  try {
    MBeanUtils.destroyMBean(group);
    database.removeGroup(group);
  }
 catch (  Exception e) {
    IllegalArgumentException iae=new IllegalArgumentException("Exception destroying group [" + groupname + "] MBean");
    iae.initCause(e);
    throw iae;
  }
}

ID 1696=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#removeRole(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.Role)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove an existing role and destroy the corresponding MBean.
 * @param rolename Role name to remove
 */
public void removeRole(String rolename){
  UserDatabase database=(UserDatabase)this.resource;
  Role role=database.findRole(rolename);
  if (role == null) {
    return;
  }
  try {
    MBeanUtils.destroyMBean(role);
    database.removeRole(role);
  }
 catch (  Exception e) {
    IllegalArgumentException iae=new IllegalArgumentException("Exception destroying role [" + rolename + "] MBean");
    iae.initCause(e);
    throw iae;
  }
}

ID 1697=========================================================================type: 1
Method:org.apache.catalina.mbeans.MemoryUserDatabaseMBean#removeUser(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.User)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove an existing user and destroy the corresponding MBean.
 * @param username User name to remove
 */
public void removeUser(String username){
  UserDatabase database=(UserDatabase)this.resource;
  User user=database.findUser(username);
  if (user == null) {
    return;
  }
  try {
    MBeanUtils.destroyMBean(user);
    database.removeUser(user);
  }
 catch (  Exception e) {
    IllegalArgumentException iae=new IllegalArgumentException("Exception destroying user [" + username + "] MBean");
    iae.initCause(e);
    throw iae;
  }
}

ID 1699=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.ReplicatedMap#memberDisappeared(org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.Channel#send(org.apache.catalina.tribes.Member[], java.io.Serializable, int)
parentException: 
thrown: ChannelException
exception comment: null
block: 
@Override public void memberDisappeared(Member member){
  boolean removed=false;
synchronized (mapMembers) {
    removed=(mapMembers.remove(member) != null);
    if (!removed) {
      if (log.isDebugEnabled())       log.debug("Member[" + member + "] disappeared, but was not present in the map.");
      return;
    }
  }
  if (log.isInfoEnabled())   log.info("Member[" + member + "] disappeared. Related map entries will be relocated to the new node.");
  long start=System.currentTimeMillis();
  Iterator<Map.Entry<K,MapEntry<K,V>>> i=innerMap.entrySet().iterator();
  while (i.hasNext()) {
    Map.Entry<K,MapEntry<K,V>> e=i.next();
    MapEntry<K,V> entry=innerMap.get(e.getKey());
    if (entry == null)     continue;
    if (entry.isPrimary()) {
      try {
        Member[] backup=getMapMembers();
        if (backup.length > 0) {
          MapMessage msg=new MapMessage(getMapContextName(),MapMessage.MSG_NOTIFY_MAPMEMBER,false,(Serializable)entry.getKey(),null,null,channel.getLocalMember(false),backup);
          getChannel().send(backup,msg,getChannelSendOptions());
        }
        entry.setBackupNodes(backup);
        entry.setPrimary(channel.getLocalMember(false));
      }
 catch (      ChannelException x) {
        log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node",x);
      }
    }
 else     if (member.equals(entry.getPrimary())) {
      entry.setPrimary(null);
    }
    if (entry.getPrimary() == null && entry.isCopy() && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0 && entry.getBackupNodes()[0].equals(channel.getLocalMember(false))) {
      try {
        entry.setPrimary(channel.getLocalMember(false));
        entry.setBackup(false);
        entry.setProxy(false);
        entry.setCopy(false);
        Member[] backup=getMapMembers();
        if (backup.length > 0) {
          MapMessage msg=new MapMessage(getMapContextName(),MapMessage.MSG_NOTIFY_MAPMEMBER,false,(Serializable)entry.getKey(),null,null,channel.getLocalMember(false),backup);
          getChannel().send(backup,msg,getChannelSendOptions());
        }
        entry.setBackupNodes(backup);
        if (mapOwner != null)         mapOwner.objectMadePrimay(entry.getKey(),entry.getValue());
      }
 catch (      ChannelException x) {
        log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node",x);
      }
    }
  }
  long complete=System.currentTimeMillis() - start;
  if (log.isInfoEnabled())   log.info("Relocation of map entries was complete in " + complete + " ms.");
}

ID 1700=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.LazyReplicatedMap#publishEntryInfo(java.lang.Object, java.lang.Object)
Rmethod: org.apache.catalina.tribes.Channel#send(org.apache.catalina.tribes.Member[], java.io.Serializable, int)
parentException: 
thrown: ChannelException
exception comment: null
block: 
/** 
 * publish info about a map pair (key/value) to other nodes in the cluster
 * @param key Object
 * @param value Object
 * @return Member - the backup node
 * @throws ChannelException
 */
@Override protected Member[] publishEntryInfo(Object key,Object value) throws ChannelException {
  if (!(key instanceof Serializable && value instanceof Serializable))   return new Member[0];
  Member[] members=getMapMembers();
  int firstIdx=getNextBackupIndex();
  int nextIdx=firstIdx;
  Member[] backup=new Member[0];
  if (members.length == 0 || firstIdx == -1)   return backup;
  boolean success=false;
  do {
    Member next=members[nextIdx];
    nextIdx=nextIdx + 1;
    if (nextIdx >= members.length)     nextIdx=0;
    if (next == null) {
      continue;
    }
    MapMessage msg=null;
    try {
      Member[] tmpBackup=wrap(next);
      msg=new MapMessage(getMapContextName(),MapMessage.MSG_BACKUP,false,(Serializable)key,(Serializable)value,null,channel.getLocalMember(false),tmpBackup);
      if (log.isTraceEnabled())       log.trace("Publishing backup data:" + msg + " to: "+ next.getName());
      UniqueId id=getChannel().send(tmpBackup,msg,getChannelSendOptions());
      if (log.isTraceEnabled())       log.trace("Data published:" + msg + " msg Id:"+ id);
      success=true;
      backup=tmpBackup;
    }
 catch (    ChannelException x) {
      log.error("Unable to replicate backup key:" + key + " to backup:"+ next+ ". Reason:"+ x.getMessage(),x);
      continue;
    }
    try {
      Member[] proxies=excludeFromSet(backup,getMapMembers());
      if (success && proxies.length > 0) {
        msg=new MapMessage(getMapContextName(),MapMessage.MSG_PROXY,false,(Serializable)key,null,null,channel.getLocalMember(false),backup);
        if (log.isTraceEnabled())         log.trace("Publishing proxy data:" + msg + " to: "+ Arrays.toNameString(proxies));
        getChannel().send(proxies,msg,getChannelSendOptions());
      }
    }
 catch (    ChannelException x) {
      log.error("Unable to replicate proxy key:" + key + " to backup:"+ next+ ". Reason:"+ x.getMessage(),x);
    }
  }
 while (!success && (firstIdx != nextIdx));
  return backup;
}

ID 1701=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#init(org.apache.catalina.tribes.tipis.AbstractReplicatedMap.MapOwner, org.apache.catalina.tribes.Channel, java.lang.String, long, int, java.lang.ClassLoader[], boolean)
Rmethod: org.apache.catalina.tribes.tipis.AbstractReplicatedMap#broadcast(int, boolean)
parentException: 
thrown: ChannelException
exception comment: null
block: 
/** 
 * Initializes the map by creating the RPC channel, registering itself as a channel listener This method is also responsible for initiating the state transfer
 * @param owner Object
 * @param channel Channel
 * @param mapContextName String
 * @param timeout long
 * @param channelSendOptions int
 * @param cls ClassLoader[]
 * @param terminate - Flag for whether to terminate this map that failed to start.
 */
protected void init(MapOwner owner,Channel channel,String mapContextName,long timeout,int channelSendOptions,ClassLoader[] cls,boolean terminate){
  long start=System.currentTimeMillis();
  if (log.isInfoEnabled())   log.info("Initializing AbstractReplicatedMap with context name:" + mapContextName);
  this.mapOwner=owner;
  this.externalLoaders=cls;
  this.channelSendOptions=channelSendOptions;
  this.channel=channel;
  this.rpcTimeout=timeout;
  this.mapname=mapContextName;
  this.mapContextName=mapContextName.getBytes(CHARSET_ISO_8859_1);
  if (log.isTraceEnabled())   log.trace("Created Lazy Map with name:" + mapContextName + ", bytes:"+ Arrays.toString(this.mapContextName));
  this.rpcChannel=new RpcChannel(this.mapContextName,channel,this);
  this.channel.addChannelListener(this);
  this.channel.addMembershipListener(this);
  try {
    broadcast(MapMessage.MSG_INIT,true);
    transferState();
    broadcast(MapMessage.MSG_START,true);
  }
 catch (  ChannelException x) {
    log.warn("Unable to send map start message.");
    if (terminate) {
      breakdown();
      throw new RuntimeException("Unable to start replicated map.",x);
    }
  }
  this.state=State.INITIALIZED;
  long complete=System.currentTimeMillis() - start;
  if (log.isInfoEnabled())   log.info("AbstractReplicatedMap[" + mapContextName + "] initialization was completed in "+ complete+ " ms.");
}

ID 1702=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#ping(long)
Rmethod: org.apache.catalina.tribes.group.RpcChannel#send(org.apache.catalina.tribes.Member[], java.io.Serializable, int, int, long)
parentException: 
thrown: ChannelException
exception comment: null
block: 
/** 
 * Sends a ping out to all the members in the cluster, not just map members that this map is alive.
 * @param timeout long
 * @throws ChannelException
 */
protected void ping(long timeout) throws ChannelException {
  MapMessage msg=new MapMessage(this.mapContextName,MapMessage.MSG_PING,false,null,null,null,channel.getLocalMember(false),null);
  if (channel.getMembers().length > 0) {
    try {
      Response[] resp=rpcChannel.send(channel.getMembers(),msg,RpcChannel.ALL_REPLY,(channelSendOptions),(int)accessTimeout);
      for (int i=0; i < resp.length; i++) {
        MapMessage mapMsg=(MapMessage)resp[i].getMessage();
        try {
          mapMsg.deserialize(getExternalLoaders());
          State state=(State)mapMsg.getValue();
          if (state.isAvailable()) {
            memberAlive(resp[i].getSource());
          }
 else {
            if (log.isInfoEnabled())             log.info("Member[" + resp[i].getSource() + "] is not available yet.");
          }
        }
 catch (        IOException x) {
          log.error("Unable to deserialize MapMessage.",x);
          return;
        }
catch (        ClassNotFoundException x) {
          log.error("Unable to deserialize MapMessage.",x);
          return;
        }
      }
    }
 catch (    ChannelException ce) {
      FaultyMember[] faultyMembers=ce.getFaultyMembers();
      for (      FaultyMember faultyMember : faultyMembers) {
        memberDisappeared(faultyMember.getMember());
      }
      throw ce;
    }
  }
synchronized (mapMembers) {
    Member[] members=mapMembers.keySet().toArray(new Member[mapMembers.size()]);
    long now=System.currentTimeMillis();
    for (    Member member : members) {
      long access=mapMembers.get(member).longValue();
      if ((now - access) > timeout) {
        log.warn("Member[" + member + "] in the Map["+ mapname+ "] has timed-out in the ping processing.");
        memberDisappeared(member);
      }
    }
  }
}

ID 1703=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#ping(long)
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Sends a ping out to all the members in the cluster, not just map members that this map is alive.
 * @param timeout long
 * @throws ChannelException
 */
protected void ping(long timeout) throws ChannelException {
  MapMessage msg=new MapMessage(this.mapContextName,MapMessage.MSG_PING,false,null,null,null,channel.getLocalMember(false),null);
  if (channel.getMembers().length > 0) {
    try {
      Response[] resp=rpcChannel.send(channel.getMembers(),msg,RpcChannel.ALL_REPLY,(channelSendOptions),(int)accessTimeout);
      for (int i=0; i < resp.length; i++) {
        MapMessage mapMsg=(MapMessage)resp[i].getMessage();
        try {
          mapMsg.deserialize(getExternalLoaders());
          State state=(State)mapMsg.getValue();
          if (state.isAvailable()) {
            memberAlive(resp[i].getSource());
          }
 else {
            if (log.isInfoEnabled())             log.info("Member[" + resp[i].getSource() + "] is not available yet.");
          }
        }
 catch (        IOException x) {
          log.error("Unable to deserialize MapMessage.",x);
          return;
        }
catch (        ClassNotFoundException x) {
          log.error("Unable to deserialize MapMessage.",x);
          return;
        }
      }
    }
 catch (    ChannelException ce) {
      FaultyMember[] faultyMembers=ce.getFaultyMembers();
      for (      FaultyMember faultyMember : faultyMembers) {
        memberDisappeared(faultyMember.getMember());
      }
      throw ce;
    }
  }
synchronized (mapMembers) {
    Member[] members=mapMembers.keySet().toArray(new Member[mapMembers.size()]);
    long now=System.currentTimeMillis();
    for (    Member member : members) {
      long access=mapMembers.get(member).longValue();
      if ((now - access) > timeout) {
        log.warn("Member[" + member + "] in the Map["+ mapname+ "] has timed-out in the ping processing.");
        memberDisappeared(member);
      }
    }
  }
}

ID 1704=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#ping(long)
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Sends a ping out to all the members in the cluster, not just map members that this map is alive.
 * @param timeout long
 * @throws ChannelException
 */
protected void ping(long timeout) throws ChannelException {
  MapMessage msg=new MapMessage(this.mapContextName,MapMessage.MSG_PING,false,null,null,null,channel.getLocalMember(false),null);
  if (channel.getMembers().length > 0) {
    try {
      Response[] resp=rpcChannel.send(channel.getMembers(),msg,RpcChannel.ALL_REPLY,(channelSendOptions),(int)accessTimeout);
      for (int i=0; i < resp.length; i++) {
        MapMessage mapMsg=(MapMessage)resp[i].getMessage();
        try {
          mapMsg.deserialize(getExternalLoaders());
          State state=(State)mapMsg.getValue();
          if (state.isAvailable()) {
            memberAlive(resp[i].getSource());
          }
 else {
            if (log.isInfoEnabled())             log.info("Member[" + resp[i].getSource() + "] is not available yet.");
          }
        }
 catch (        IOException x) {
          log.error("Unable to deserialize MapMessage.",x);
          return;
        }
catch (        ClassNotFoundException x) {
          log.error("Unable to deserialize MapMessage.",x);
          return;
        }
      }
    }
 catch (    ChannelException ce) {
      FaultyMember[] faultyMembers=ce.getFaultyMembers();
      for (      FaultyMember faultyMember : faultyMembers) {
        memberDisappeared(faultyMember.getMember());
      }
      throw ce;
    }
  }
synchronized (mapMembers) {
    Member[] members=mapMembers.keySet().toArray(new Member[mapMembers.size()]);
    long now=System.currentTimeMillis();
    for (    Member member : members) {
      long access=mapMembers.get(member).longValue();
      if ((now - access) > timeout) {
        log.warn("Member[" + member + "] in the Map["+ mapname+ "] has timed-out in the ping processing.");
        memberDisappeared(member);
      }
    }
  }
}

ID 1708=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#replicate(java.lang.Object, boolean)
Rmethod: org.apache.catalina.tribes.tipis.ReplicatedMapEntry#getDiff()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Replicates any changes to the object since the last time The object has to be primary, ie, if the object is a proxy or a backup, it will not be replicated<br>
 * @param complete - if set to true, the object is replicated to its backupif set to false, only objects that implement ReplicatedMapEntry and the isDirty() returns true will be replicated
 */
public void replicate(Object key,boolean complete){
  if (log.isTraceEnabled())   log.trace("Replicate invoked on key:" + key);
  MapEntry<K,V> entry=innerMap.get(key);
  if (entry == null)   return;
  if (!entry.isSerializable())   return;
  if (entry.isPrimary() && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) {
    ReplicatedMapEntry rentry=null;
    if (entry.getValue() instanceof ReplicatedMapEntry)     rentry=(ReplicatedMapEntry)entry.getValue();
    boolean isDirty=rentry != null && rentry.isDirty();
    boolean isAccess=rentry != null && rentry.isAccessReplicate();
    boolean repl=complete || isDirty || isAccess;
    if (!repl) {
      if (log.isTraceEnabled())       log.trace("Not replicating:" + key + ", no change made");
      return;
    }
    MapMessage msg=null;
    if (rentry != null && rentry.isDiffable() && (isDirty || complete)) {
      rentry.lock();
      try {
        msg=new MapMessage(mapContextName,getReplicateMessageType(),true,(Serializable)entry.getKey(),null,rentry.getDiff(),entry.getPrimary(),entry.getBackupNodes());
        rentry.resetDiff();
      }
 catch (      IOException x) {
        log.error("Unable to diff object. Will replicate the entire object instead.",x);
      }
 finally {
        rentry.unlock();
      }
    }
    if (msg == null && complete) {
      msg=new MapMessage(mapContextName,getReplicateMessageType(),false,(Serializable)entry.getKey(),(Serializable)entry.getValue(),null,entry.getPrimary(),entry.getBackupNodes());
    }
    if (msg == null) {
      msg=new MapMessage(mapContextName,MapMessage.MSG_ACCESS,false,(Serializable)entry.getKey(),null,null,entry.getPrimary(),entry.getBackupNodes());
    }
    try {
      if (channel != null && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) {
        if (rentry != null)         rentry.setLastTimeReplicated(System.currentTimeMillis());
        channel.send(entry.getBackupNodes(),msg,channelSendOptions);
      }
    }
 catch (    ChannelException x) {
      log.error("Unable to replicate data.",x);
    }
  }
}

ID 1709=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#replicate(java.lang.Object, boolean)
Rmethod: org.apache.catalina.tribes.Channel#send(org.apache.catalina.tribes.Member[], java.io.Serializable, int)
parentException: 
thrown: ChannelException
exception comment: null
block: 
/** 
 * Replicates any changes to the object since the last time The object has to be primary, ie, if the object is a proxy or a backup, it will not be replicated<br>
 * @param complete - if set to true, the object is replicated to its backupif set to false, only objects that implement ReplicatedMapEntry and the isDirty() returns true will be replicated
 */
public void replicate(Object key,boolean complete){
  if (log.isTraceEnabled())   log.trace("Replicate invoked on key:" + key);
  MapEntry<K,V> entry=innerMap.get(key);
  if (entry == null)   return;
  if (!entry.isSerializable())   return;
  if (entry.isPrimary() && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) {
    ReplicatedMapEntry rentry=null;
    if (entry.getValue() instanceof ReplicatedMapEntry)     rentry=(ReplicatedMapEntry)entry.getValue();
    boolean isDirty=rentry != null && rentry.isDirty();
    boolean isAccess=rentry != null && rentry.isAccessReplicate();
    boolean repl=complete || isDirty || isAccess;
    if (!repl) {
      if (log.isTraceEnabled())       log.trace("Not replicating:" + key + ", no change made");
      return;
    }
    MapMessage msg=null;
    if (rentry != null && rentry.isDiffable() && (isDirty || complete)) {
      rentry.lock();
      try {
        msg=new MapMessage(mapContextName,getReplicateMessageType(),true,(Serializable)entry.getKey(),null,rentry.getDiff(),entry.getPrimary(),entry.getBackupNodes());
        rentry.resetDiff();
      }
 catch (      IOException x) {
        log.error("Unable to diff object. Will replicate the entire object instead.",x);
      }
 finally {
        rentry.unlock();
      }
    }
    if (msg == null && complete) {
      msg=new MapMessage(mapContextName,getReplicateMessageType(),false,(Serializable)entry.getKey(),(Serializable)entry.getValue(),null,entry.getPrimary(),entry.getBackupNodes());
    }
    if (msg == null) {
      msg=new MapMessage(mapContextName,MapMessage.MSG_ACCESS,false,(Serializable)entry.getKey(),null,null,entry.getPrimary(),entry.getBackupNodes());
    }
    try {
      if (channel != null && entry.getBackupNodes() != null && entry.getBackupNodes().length > 0) {
        if (rentry != null)         rentry.setLastTimeReplicated(System.currentTimeMillis());
        channel.send(entry.getBackupNodes(),msg,channelSendOptions);
      }
    }
 catch (    ChannelException x) {
      log.error("Unable to replicate data.",x);
    }
  }
}

ID 1710=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#transferState()
Rmethod: org.apache.catalina.tribes.group.RpcChannel#send(org.apache.catalina.tribes.Member[], java.io.Serializable, int, int, long)
parentException: 
thrown: ChannelException
exception comment: null
block: 
public void transferState(){
  try {
    Member[] members=getMapMembers();
    Member backup=members.length > 0 ? (Member)members[0] : null;
    if (backup != null) {
      MapMessage msg=new MapMessage(mapContextName,getStateMessageType(),false,null,null,null,null,null);
      Response[] resp=rpcChannel.send(new Member[]{backup},msg,RpcChannel.FIRST_REPLY,channelSendOptions,rpcTimeout);
      if (resp.length > 0) {
synchronized (stateMutex) {
          msg=(MapMessage)resp[0].getMessage();
          msg.deserialize(getExternalLoaders());
          ArrayList<?> list=(ArrayList<?>)msg.getValue();
          for (int i=0; i < list.size(); i++) {
            messageReceived((Serializable)list.get(i),resp[0].getSource());
          }
        }
        stateTransferred=true;
      }
 else {
        log.warn("Transfer state, 0 replies, probably a timeout.");
      }
    }
  }
 catch (  ChannelException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
catch (  IOException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
catch (  ClassNotFoundException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
}

ID 1711=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#transferState()
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void transferState(){
  try {
    Member[] members=getMapMembers();
    Member backup=members.length > 0 ? (Member)members[0] : null;
    if (backup != null) {
      MapMessage msg=new MapMessage(mapContextName,getStateMessageType(),false,null,null,null,null,null);
      Response[] resp=rpcChannel.send(new Member[]{backup},msg,RpcChannel.FIRST_REPLY,channelSendOptions,rpcTimeout);
      if (resp.length > 0) {
synchronized (stateMutex) {
          msg=(MapMessage)resp[0].getMessage();
          msg.deserialize(getExternalLoaders());
          ArrayList<?> list=(ArrayList<?>)msg.getValue();
          for (int i=0; i < list.size(); i++) {
            messageReceived((Serializable)list.get(i),resp[0].getSource());
          }
        }
        stateTransferred=true;
      }
 else {
        log.warn("Transfer state, 0 replies, probably a timeout.");
      }
    }
  }
 catch (  ChannelException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
catch (  IOException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
catch (  ClassNotFoundException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
}

ID 1712=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#transferState()
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
public void transferState(){
  try {
    Member[] members=getMapMembers();
    Member backup=members.length > 0 ? (Member)members[0] : null;
    if (backup != null) {
      MapMessage msg=new MapMessage(mapContextName,getStateMessageType(),false,null,null,null,null,null);
      Response[] resp=rpcChannel.send(new Member[]{backup},msg,RpcChannel.FIRST_REPLY,channelSendOptions,rpcTimeout);
      if (resp.length > 0) {
synchronized (stateMutex) {
          msg=(MapMessage)resp[0].getMessage();
          msg.deserialize(getExternalLoaders());
          ArrayList<?> list=(ArrayList<?>)msg.getValue();
          for (int i=0; i < list.size(); i++) {
            messageReceived((Serializable)list.get(i),resp[0].getSource());
          }
        }
        stateTransferred=true;
      }
 else {
        log.warn("Transfer state, 0 replies, probably a timeout.");
      }
    }
  }
 catch (  ChannelException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
catch (  IOException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
catch (  ClassNotFoundException x) {
    log.error("Unable to transfer AbstractReplicatedMap state.",x);
  }
}

ID 1713=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#leftOver(java.io.Serializable, org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * If the reply has already been sent to the requesting thread, the rpc callback can handle any data that comes in after the fact.
 * @param msg Serializable
 * @param sender Member
 */
@Override public void leftOver(Serializable msg,Member sender){
  if (!(msg instanceof MapMessage))   return;
  MapMessage mapmsg=(MapMessage)msg;
  try {
    mapmsg.deserialize(getExternalLoaders());
    if (mapmsg.getMsgType() == MapMessage.MSG_START) {
      mapMemberAdded(mapmsg.getPrimary());
    }
 else     if (mapmsg.getMsgType() == MapMessage.MSG_INIT || mapmsg.getMsgType() == MapMessage.MSG_PING) {
      memberAlive(mapmsg.getPrimary());
    }
 else {
      if (log.isInfoEnabled())       log.info("Message[" + mapmsg.getTypeDesc() + "] is ignored.");
    }
  }
 catch (  IOException x) {
    log.error("Unable to deserialize MapMessage.",x);
  }
catch (  ClassNotFoundException x) {
    log.error("Unable to deserialize MapMessage.",x);
  }
}

ID 1714=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#leftOver(java.io.Serializable, org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * If the reply has already been sent to the requesting thread, the rpc callback can handle any data that comes in after the fact.
 * @param msg Serializable
 * @param sender Member
 */
@Override public void leftOver(Serializable msg,Member sender){
  if (!(msg instanceof MapMessage))   return;
  MapMessage mapmsg=(MapMessage)msg;
  try {
    mapmsg.deserialize(getExternalLoaders());
    if (mapmsg.getMsgType() == MapMessage.MSG_START) {
      mapMemberAdded(mapmsg.getPrimary());
    }
 else     if (mapmsg.getMsgType() == MapMessage.MSG_INIT || mapmsg.getMsgType() == MapMessage.MSG_PING) {
      memberAlive(mapmsg.getPrimary());
    }
 else {
      if (log.isInfoEnabled())       log.info("Message[" + mapmsg.getTypeDesc() + "] is ignored.");
    }
  }
 catch (  IOException x) {
    log.error("Unable to deserialize MapMessage.",x);
  }
catch (  ClassNotFoundException x) {
    log.error("Unable to deserialize MapMessage.",x);
  }
}

ID 1715=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#messageReceived(java.io.Serializable, org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("unchecked") @Override public void messageReceived(Serializable msg,Member sender){
  if (!(msg instanceof MapMessage))   return;
  MapMessage mapmsg=(MapMessage)msg;
  if (log.isTraceEnabled()) {
    log.trace("Map[" + mapname + "] received message:"+ mapmsg);
  }
  try {
    mapmsg.deserialize(getExternalLoaders());
  }
 catch (  IOException x) {
    log.error("Unable to deserialize MapMessage.",x);
    return;
  }
catch (  ClassNotFoundException x) {
    log.error("Unable to deserialize MapMessage.",x);
    return;
  }
  if (log.isTraceEnabled())   log.trace("Map message received from:" + sender.getName() + " msg:"+ mapmsg);
  if (mapmsg.getMsgType() == MapMessage.MSG_START) {
    mapMemberAdded(mapmsg.getPrimary());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {
    memberDisappeared(mapmsg.getPrimary());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry == null) {
      entry=new MapEntry<K,V>((K)mapmsg.getKey(),(V)mapmsg.getValue());
      MapEntry<K,V> old=innerMap.putIfAbsent(entry.getKey(),entry);
      if (old != null) {
        entry=old;
      }
    }
    entry.setProxy(true);
    entry.setBackup(false);
    entry.setCopy(false);
    entry.setBackupNodes(mapmsg.getBackupNodes());
    entry.setPrimary(mapmsg.getPrimary());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) {
    innerMap.remove(mapmsg.getKey());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP || mapmsg.getMsgType() == MapMessage.MSG_COPY) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry == null) {
      entry=new MapEntry<K,V>((K)mapmsg.getKey(),(V)mapmsg.getValue());
      entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP);
      entry.setProxy(false);
      entry.setCopy(mapmsg.getMsgType() == MapMessage.MSG_COPY);
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
      if (mapmsg.getValue() != null && mapmsg.getValue() instanceof ReplicatedMapEntry) {
        ((ReplicatedMapEntry)mapmsg.getValue()).setOwner(getMapOwner());
      }
    }
 else {
      entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP);
      entry.setProxy(false);
      entry.setCopy(mapmsg.getMsgType() == MapMessage.MSG_COPY);
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
      if (entry.getValue() instanceof ReplicatedMapEntry) {
        ReplicatedMapEntry diff=(ReplicatedMapEntry)entry.getValue();
        if (mapmsg.isDiff()) {
          diff.lock();
          try {
            diff.applyDiff(mapmsg.getDiffValue(),0,mapmsg.getDiffValue().length);
          }
 catch (          Exception x) {
            log.error("Unable to apply diff to key:" + entry.getKey(),x);
          }
 finally {
            diff.unlock();
          }
        }
 else {
          if (mapmsg.getValue() != null) {
            if (mapmsg.getValue() instanceof ReplicatedMapEntry) {
              ReplicatedMapEntry re=(ReplicatedMapEntry)mapmsg.getValue();
              re.setOwner(getMapOwner());
              entry.setValue((V)re);
            }
 else {
              entry.setValue((V)mapmsg.getValue());
            }
          }
 else {
            ((ReplicatedMapEntry)entry.getValue()).setOwner(getMapOwner());
          }
        }
      }
 else       if (mapmsg.getValue() instanceof ReplicatedMapEntry) {
        ReplicatedMapEntry re=(ReplicatedMapEntry)mapmsg.getValue();
        re.setOwner(getMapOwner());
        entry.setValue((V)re);
      }
 else {
        if (mapmsg.getValue() != null)         entry.setValue((V)mapmsg.getValue());
      }
    }
    innerMap.put(entry.getKey(),entry);
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_ACCESS) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry != null) {
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
      if (entry.getValue() instanceof ReplicatedMapEntry) {
        ((ReplicatedMapEntry)entry.getValue()).accessEntry();
      }
    }
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_NOTIFY_MAPMEMBER) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry != null) {
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
    }
  }
}

ID 1716=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#messageReceived(java.io.Serializable, org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.tipis.MapMessage#deserialize(java.lang.ClassLoader[])
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("unchecked") @Override public void messageReceived(Serializable msg,Member sender){
  if (!(msg instanceof MapMessage))   return;
  MapMessage mapmsg=(MapMessage)msg;
  if (log.isTraceEnabled()) {
    log.trace("Map[" + mapname + "] received message:"+ mapmsg);
  }
  try {
    mapmsg.deserialize(getExternalLoaders());
  }
 catch (  IOException x) {
    log.error("Unable to deserialize MapMessage.",x);
    return;
  }
catch (  ClassNotFoundException x) {
    log.error("Unable to deserialize MapMessage.",x);
    return;
  }
  if (log.isTraceEnabled())   log.trace("Map message received from:" + sender.getName() + " msg:"+ mapmsg);
  if (mapmsg.getMsgType() == MapMessage.MSG_START) {
    mapMemberAdded(mapmsg.getPrimary());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {
    memberDisappeared(mapmsg.getPrimary());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_PROXY) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry == null) {
      entry=new MapEntry<K,V>((K)mapmsg.getKey(),(V)mapmsg.getValue());
      MapEntry<K,V> old=innerMap.putIfAbsent(entry.getKey(),entry);
      if (old != null) {
        entry=old;
      }
    }
    entry.setProxy(true);
    entry.setBackup(false);
    entry.setCopy(false);
    entry.setBackupNodes(mapmsg.getBackupNodes());
    entry.setPrimary(mapmsg.getPrimary());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_REMOVE) {
    innerMap.remove(mapmsg.getKey());
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_BACKUP || mapmsg.getMsgType() == MapMessage.MSG_COPY) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry == null) {
      entry=new MapEntry<K,V>((K)mapmsg.getKey(),(V)mapmsg.getValue());
      entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP);
      entry.setProxy(false);
      entry.setCopy(mapmsg.getMsgType() == MapMessage.MSG_COPY);
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
      if (mapmsg.getValue() != null && mapmsg.getValue() instanceof ReplicatedMapEntry) {
        ((ReplicatedMapEntry)mapmsg.getValue()).setOwner(getMapOwner());
      }
    }
 else {
      entry.setBackup(mapmsg.getMsgType() == MapMessage.MSG_BACKUP);
      entry.setProxy(false);
      entry.setCopy(mapmsg.getMsgType() == MapMessage.MSG_COPY);
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
      if (entry.getValue() instanceof ReplicatedMapEntry) {
        ReplicatedMapEntry diff=(ReplicatedMapEntry)entry.getValue();
        if (mapmsg.isDiff()) {
          diff.lock();
          try {
            diff.applyDiff(mapmsg.getDiffValue(),0,mapmsg.getDiffValue().length);
          }
 catch (          Exception x) {
            log.error("Unable to apply diff to key:" + entry.getKey(),x);
          }
 finally {
            diff.unlock();
          }
        }
 else {
          if (mapmsg.getValue() != null) {
            if (mapmsg.getValue() instanceof ReplicatedMapEntry) {
              ReplicatedMapEntry re=(ReplicatedMapEntry)mapmsg.getValue();
              re.setOwner(getMapOwner());
              entry.setValue((V)re);
            }
 else {
              entry.setValue((V)mapmsg.getValue());
            }
          }
 else {
            ((ReplicatedMapEntry)entry.getValue()).setOwner(getMapOwner());
          }
        }
      }
 else       if (mapmsg.getValue() instanceof ReplicatedMapEntry) {
        ReplicatedMapEntry re=(ReplicatedMapEntry)mapmsg.getValue();
        re.setOwner(getMapOwner());
        entry.setValue((V)re);
      }
 else {
        if (mapmsg.getValue() != null)         entry.setValue((V)mapmsg.getValue());
      }
    }
    innerMap.put(entry.getKey(),entry);
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_ACCESS) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry != null) {
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
      if (entry.getValue() instanceof ReplicatedMapEntry) {
        ((ReplicatedMapEntry)entry.getValue()).accessEntry();
      }
    }
  }
  if (mapmsg.getMsgType() == MapMessage.MSG_NOTIFY_MAPMEMBER) {
    MapEntry<K,V> entry=innerMap.get(mapmsg.getKey());
    if (entry != null) {
      entry.setBackupNodes(mapmsg.getBackupNodes());
      entry.setPrimary(mapmsg.getPrimary());
    }
  }
}

ID 1719=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#mapMemberAdded(org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.tipis.AbstractReplicatedMap#publishEntryInfo(java.lang.Object, java.lang.Object)
parentException: 
thrown: ChannelException
exception comment: null
block: 
public void mapMemberAdded(Member member){
  if (member.equals(getChannel().getLocalMember(false)))   return;
  boolean memberAdded=false;
  Member mapMember=getChannel().getMember(member);
  if (mapMember == null) {
    log.warn("Notified member is not registered in the membership:" + member);
    return;
  }
synchronized (mapMembers) {
    if (!mapMembers.containsKey(mapMember)) {
      if (log.isInfoEnabled())       log.info("Map member added:" + mapMember);
      mapMembers.put(mapMember,Long.valueOf(System.currentTimeMillis()));
      memberAdded=true;
    }
  }
  if (memberAdded) {
synchronized (stateMutex) {
      Iterator<Map.Entry<K,MapEntry<K,V>>> i=innerMap.entrySet().iterator();
      while (i.hasNext()) {
        Map.Entry<K,MapEntry<K,V>> e=i.next();
        MapEntry<K,V> entry=innerMap.get(e.getKey());
        if (entry == null)         continue;
        if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
          try {
            Member[] backup=publishEntryInfo(entry.getKey(),entry.getValue());
            entry.setBackupNodes(backup);
            entry.setPrimary(channel.getLocalMember(false));
          }
 catch (          ChannelException x) {
            log.error("Unable to select backup node.",x);
          }
        }
      }
    }
  }
}

ID 1720=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#memberDisappeared(org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.tipis.AbstractReplicatedMap#publishEntryInfo(java.lang.Object, java.lang.Object)
parentException: 
thrown: ChannelException
exception comment: null
block: 
@Override public void memberDisappeared(Member member){
  boolean removed=false;
synchronized (mapMembers) {
    removed=(mapMembers.remove(member) != null);
    if (!removed) {
      if (log.isDebugEnabled())       log.debug("Member[" + member + "] disappeared, but was not present in the map.");
      return;
    }
  }
  if (log.isInfoEnabled())   log.info("Member[" + member + "] disappeared. Related map entries will be relocated to the new node.");
  long start=System.currentTimeMillis();
  Iterator<Map.Entry<K,MapEntry<K,V>>> i=innerMap.entrySet().iterator();
  while (i.hasNext()) {
    Map.Entry<K,MapEntry<K,V>> e=i.next();
    MapEntry<K,V> entry=innerMap.get(e.getKey());
    if (entry == null)     continue;
    if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
      if (log.isDebugEnabled())       log.debug("[1] Primary choosing a new backup");
      try {
        Member[] backup=publishEntryInfo(entry.getKey(),entry.getValue());
        entry.setBackupNodes(backup);
        entry.setPrimary(channel.getLocalMember(false));
      }
 catch (      ChannelException x) {
        log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node",x);
      }
    }
 else     if (member.equals(entry.getPrimary())) {
      if (log.isDebugEnabled())       log.debug("[2] Primary disappeared");
      entry.setPrimary(null);
    }
    if (entry.isProxy() && entry.getPrimary() == null && entry.getBackupNodes() != null && entry.getBackupNodes().length == 1 && entry.getBackupNodes()[0].equals(member)) {
      if (log.isDebugEnabled())       log.debug("[3] Removing orphaned proxy");
      i.remove();
    }
 else     if (entry.getPrimary() == null && entry.isBackup() && entry.getBackupNodes() != null && entry.getBackupNodes().length == 1 && entry.getBackupNodes()[0].equals(channel.getLocalMember(false))) {
      try {
        if (log.isDebugEnabled())         log.debug("[4] Backup becoming primary");
        entry.setPrimary(channel.getLocalMember(false));
        entry.setBackup(false);
        entry.setProxy(false);
        entry.setCopy(false);
        Member[] backup=publishEntryInfo(entry.getKey(),entry.getValue());
        entry.setBackupNodes(backup);
        if (mapOwner != null)         mapOwner.objectMadePrimay(entry.getKey(),entry.getValue());
      }
 catch (      ChannelException x) {
        log.error("Unable to relocate[" + entry.getKey() + "] to a new backup node",x);
      }
    }
  }
  long complete=System.currentTimeMillis() - start;
  if (log.isInfoEnabled())   log.info("Relocation of map entries was complete in " + complete + " ms.");
}

ID 1722=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#remove(java.lang.Object, boolean)
Rmethod: org.apache.catalina.tribes.Channel#send(org.apache.catalina.tribes.Member[], java.io.Serializable, int)
parentException: 
thrown: ChannelException
exception comment: null
block: 
public V remove(Object key,boolean notify){
  MapEntry<K,V> entry=innerMap.remove(key);
  try {
    if (getMapMembers().length > 0 && notify) {
      MapMessage msg=new MapMessage(getMapContextName(),MapMessage.MSG_REMOVE,false,(Serializable)key,null,null,null,null);
      getChannel().send(getMapMembers(),msg,getChannelSendOptions());
    }
  }
 catch (  ChannelException x) {
    log.error("Unable to replicate out data for a AbstractReplicatedMap.remove operation",x);
  }
  return entry != null ? entry.getValue() : null;
}

ID 1728=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.AbstractReplicatedMap#put(K, V, boolean)
Rmethod: org.apache.catalina.tribes.tipis.AbstractReplicatedMap#publishEntryInfo(java.lang.Object, java.lang.Object)
parentException: 
thrown: ChannelException
exception comment: null
block: 
public V put(K key,V value,boolean notify){
  MapEntry<K,V> entry=new MapEntry<K,V>(key,value);
  entry.setBackup(false);
  entry.setProxy(false);
  entry.setCopy(false);
  entry.setPrimary(channel.getLocalMember(false));
  V old=null;
  if (containsKey(key))   old=remove(key);
  try {
    if (notify) {
      Member[] backup=publishEntryInfo(key,value);
      entry.setBackupNodes(backup);
    }
  }
 catch (  ChannelException x) {
    log.error("Unable to replicate out data for a AbstractReplicatedMap.put operation",x);
  }
  innerMap.put(key,entry);
  return old;
}

ID 1748=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.MapMessage#setValue(java.io.Serializable)
Rmethod: org.apache.catalina.tribes.io.XByteBuffer#serialize(java.io.Serializable)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void setValue(Serializable value){
  try {
    if (value != null)     valuedata=XByteBuffer.serialize(value);
    this.value=value;
  }
 catch (  IOException x) {
    throw new RuntimeException(x);
  }
}

ID 1749=========================================================================type: 1
Method:org.apache.catalina.tribes.tipis.MapMessage#setKey(java.io.Serializable)
Rmethod: org.apache.catalina.tribes.io.XByteBuffer#serialize(java.io.Serializable)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void setKey(Serializable key){
  try {
    if (key != null)     keydata=XByteBuffer.serialize(key);
    this.key=key;
  }
 catch (  IOException x) {
    throw new RuntimeException(x);
  }
}

ID 1756=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.util.SingleRemoveSynchronizedAddLock#lockAdd()
Rmethod: java.lang.Object#wait(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Acquires the lock by an add thread and sets the add flag. If any add thread or the remove thread already acquired the lock this add thread will block until the lock is released.
 */
public synchronized void lockAdd(){
  if (addLocked || removeLocked) {
    do {
      try {
        wait(addWaitTimeout);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
 while (addLocked || removeLocked);
  }
  addLocked=true;
}

ID 1757=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.util.SingleRemoveSynchronizedAddLock#lockRemove()
Rmethod: java.lang.Object#wait(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Acquires the lock by the remove thread and sets the remove flag. If any add thread already acquired the lock or the queue is empty, the remove thread will block until the lock is released and the queue is not empty.
 */
public synchronized boolean lockRemove(){
  removeLocked=false;
  removeEnabled=true;
  if ((addLocked || !dataAvailable) && removeEnabled) {
    remover=Thread.currentThread();
    do {
      try {
        wait(removeWaitTimeout);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
 while ((addLocked || !dataAvailable) && removeEnabled);
    remover=null;
  }
  if (removeEnabled) {
    removeLocked=true;
  }
  return removeLocked;
}

ID 1759=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioReceiver#start()
Rmethod: org.apache.catalina.tribes.transport.RxTaskPool#RxTaskPool(int, int, org.apache.catalina.tribes.transport.RxTaskPool.TaskCreator)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void start() throws IOException {
  super.start();
  try {
    setPool(new RxTaskPool(getMaxThreads(),getMinThreads(),this));
  }
 catch (  Exception x) {
    log.fatal("ThreadPool can initilzed. Listener not started",x);
    if (x instanceof IOException)     throw (IOException)x;
 else     throw new IOException(x.getMessage());
  }
  try {
    getBind();
    bind();
    String channelName="";
    if (getChannel() instanceof GroupChannel && ((GroupChannel)getChannel()).getName() != null) {
      channelName="[" + ((GroupChannel)getChannel()).getName() + "]";
    }
    Thread t=new Thread(this,"BioReceiver" + channelName);
    t.setDaemon(true);
    t.start();
  }
 catch (  Exception x) {
    log.fatal("Unable to start cluster receiver",x);
    if (x instanceof IOException)     throw (IOException)x;
 else     throw new IOException(x.getMessage());
  }
}

ID 1764=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioReceiver#run()
Rmethod: org.apache.catalina.tribes.transport.bio.BioReceiver#listen()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  try {
    listen();
  }
 catch (  Exception x) {
    log.error("Unable to run replication listener.",x);
  }
}

ID 1780=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioSender#sendMessage(byte[], boolean)
Rmethod: org.apache.catalina.tribes.transport.bio.BioSender#pushMessage(byte[], boolean, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send message.
 */
public void sendMessage(byte[] data,boolean waitForAck) throws IOException {
  IOException exception=null;
  setAttempt(0);
  try {
    pushMessage(data,false,waitForAck);
  }
 catch (  IOException x) {
    SenderState.getSenderState(getDestination()).setSuspect();
    exception=x;
    if (log.isTraceEnabled())     log.trace(sm.getString("IDataSender.send.again",getAddress().getHostAddress(),Integer.valueOf(getPort())),x);
    while (getAttempt() < getMaxRetryAttempts()) {
      try {
        setAttempt(getAttempt() + 1);
        pushMessage(data,true,waitForAck);
        exception=null;
      }
 catch (      IOException xx) {
        exception=xx;
        closeSocket();
      }
    }
  }
 finally {
    setRequestCount(getRequestCount() + 1);
    keepalive();
    if (exception != null)     throw exception;
  }
}

ID 1781=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioSender#sendMessage(byte[], boolean)
Rmethod: org.apache.catalina.tribes.transport.bio.BioSender#pushMessage(byte[], boolean, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send message.
 */
public void sendMessage(byte[] data,boolean waitForAck) throws IOException {
  IOException exception=null;
  setAttempt(0);
  try {
    pushMessage(data,false,waitForAck);
  }
 catch (  IOException x) {
    SenderState.getSenderState(getDestination()).setSuspect();
    exception=x;
    if (log.isTraceEnabled())     log.trace(sm.getString("IDataSender.send.again",getAddress().getHostAddress(),Integer.valueOf(getPort())),x);
    while (getAttempt() < getMaxRetryAttempts()) {
      try {
        setAttempt(getAttempt() + 1);
        pushMessage(data,true,waitForAck);
        exception=null;
      }
 catch (      IOException xx) {
        exception=xx;
        closeSocket();
      }
    }
  }
 finally {
    setRequestCount(getRequestCount() + 1);
    keepalive();
    if (exception != null)     throw exception;
  }
}

ID 1801=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioReplicationTask#run()
Rmethod: org.apache.catalina.tribes.transport.bio.BioReplicationTask#drainSocket()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public synchronized void run(){
  if (socket == null)   return;
  try {
    drainSocket();
  }
 catch (  Exception x) {
    log.error("Unable to service bio socket",x);
  }
 finally {
    try {
      socket.close();
    }
 catch (    Exception e) {
      if (log.isDebugEnabled()) {
        log.debug("Failed to close socket",e);
      }
    }
    try {
      reader.close();
    }
 catch (    Exception e) {
      if (log.isDebugEnabled()) {
        log.debug("Failed to close reader",e);
      }
    }
    reader=null;
    socket=null;
  }
  if (getTaskPool() != null)   getTaskPool().returnWorker(this);
}

ID 1809=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioReplicationTask#sendAck(byte[])
Rmethod: java.net.Socket#getOutputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * send a reply-acknowledgment (6,2,3)
 * @param command
 */
protected void sendAck(byte[] command){
  try {
    OutputStream out=socket.getOutputStream();
    out.write(command);
    out.flush();
    if (log.isTraceEnabled()) {
      log.trace("ACK sent to " + socket.getPort());
    }
  }
 catch (  java.io.IOException x) {
    log.warn("Unable to send ACK back through channel, channel disconnected?: " + x.getMessage());
  }
}

ID 1810=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioReplicationTask#sendAck(byte[])
Rmethod: java.io.OutputStream#write(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * send a reply-acknowledgment (6,2,3)
 * @param command
 */
protected void sendAck(byte[] command){
  try {
    OutputStream out=socket.getOutputStream();
    out.write(command);
    out.flush();
    if (log.isTraceEnabled()) {
      log.trace("ACK sent to " + socket.getPort());
    }
  }
 catch (  java.io.IOException x) {
    log.warn("Unable to send ACK back through channel, channel disconnected?: " + x.getMessage());
  }
}

ID 1811=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.bio.BioReplicationTask#sendAck(byte[])
Rmethod: java.io.OutputStream#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * send a reply-acknowledgment (6,2,3)
 * @param command
 */
protected void sendAck(byte[] command){
  try {
    OutputStream out=socket.getOutputStream();
    out.write(command);
    out.flush();
    if (log.isTraceEnabled()) {
      log.trace("ACK sent to " + socket.getPort());
    }
  }
 catch (  java.io.IOException x) {
    log.warn("Unable to send ACK back through channel, channel disconnected?: " + x.getMessage());
  }
}

ID 1813=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.ReceiverBase#getBind()
Rmethod: java.net.InetAddress#getLocalHost()
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
/** 
 * @return Returns the bind.
 */
public InetAddress getBind(){
  if (bind == null) {
    try {
      if ("auto".equals(host)) {
        host=java.net.InetAddress.getLocalHost().getHostAddress();
      }
      if (log.isDebugEnabled())       log.debug("Starting replication listener on address:" + host);
      bind=java.net.InetAddress.getByName(host);
    }
 catch (    IOException ioe) {
      log.error("Failed bind replication listener on address:" + host,ioe);
    }
  }
  return bind;
}

ID 1814=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.ReceiverBase#getBind()
Rmethod: java.net.InetAddress#getByName(java.lang.String)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
/** 
 * @return Returns the bind.
 */
public InetAddress getBind(){
  if (bind == null) {
    try {
      if ("auto".equals(host)) {
        host=java.net.InetAddress.getLocalHost().getHostAddress();
      }
      if (log.isDebugEnabled())       log.debug("Starting replication listener on address:" + host);
      bind=java.net.InetAddress.getByName(host);
    }
 catch (    IOException ioe) {
      log.error("Failed bind replication listener on address:" + host,ioe);
    }
  }
  return bind;
}

ID 1817=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.ReceiverBase#bindUdp(java.net.DatagramSocket, int, int)
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Same as bind() except it does it for the UDP port
 * @param socket
 * @param portstart
 * @param retries
 * @return int
 * @throws IOException
 */
protected int bindUdp(DatagramSocket socket,int portstart,int retries) throws IOException {
  InetSocketAddress addr=null;
  while (retries > 0) {
    try {
      addr=new InetSocketAddress(getBind(),portstart);
      socket.bind(addr);
      setUdpPort(portstart);
      log.info("UDP Receiver Server Socket bound to:" + addr);
      return 0;
    }
 catch (    IOException x) {
      retries--;
      if (retries <= 0) {
        log.info("Unable to bind UDP socket to:" + addr + " throwing error.");
        throw x;
      }
      portstart++;
      try {
        Thread.sleep(25);
      }
 catch (      InterruptedException ti) {
        Thread.currentThread().interrupt();
      }
      retries=bindUdp(socket,portstart,retries);
    }
  }
  return retries;
}

ID 1820=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.RxTaskPool#getRxTask()
Rmethod: java.lang.Object#wait()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Find an idle worker thread, if any.  Could return null.
 */
public AbstractRxTask getRxTask(){
  AbstractRxTask worker=null;
synchronized (mutex) {
    while (worker == null && running) {
      if (idle.size() > 0) {
        try {
          worker=idle.remove(0);
        }
 catch (        java.util.NoSuchElementException x) {
          worker=null;
        }
      }
 else       if (used.size() < this.maxTasks && creator != null) {
        worker=creator.createRxTask();
        configureTask(worker);
      }
 else {
        try {
          mutex.wait();
        }
 catch (        java.lang.InterruptedException x) {
          Thread.currentThread().interrupt();
        }
      }
    }
    if (worker != null)     used.add(worker);
  }
  return (worker);
}

ID 1821=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.PooledParallelSender#sendMessage(org.apache.catalina.tribes.Member[], org.apache.catalina.tribes.ChannelMessage)
Rmethod: org.apache.catalina.tribes.transport.nio.ParallelNioSender#sendMessage(org.apache.catalina.tribes.Member[], org.apache.catalina.tribes.ChannelMessage)
parentException: 
thrown: ChannelException
exception comment: null
block: 
@Override public void sendMessage(Member[] destination,ChannelMessage message) throws ChannelException {
  if (!connected)   throw new ChannelException("Sender not connected.");
  ParallelNioSender sender=(ParallelNioSender)getSender();
  if (sender == null) {
    ChannelException cx=new ChannelException("Unable to retrieve a data sender, time out(" + getMaxWait() + " ms) error.");
    for (int i=0; i < destination.length; i++)     cx.addFaultyMember(destination[i],new NullPointerException("Unable to retrieve a sender from the sender pool"));
    throw cx;
  }
 else {
    try {
      sender.sendMessage(destination,message);
      sender.keepalive();
    }
 catch (    ChannelException x) {
      sender.disconnect();
      throw x;
    }
 finally {
      returnSender(sender);
      if (!connected)       disconnect();
    }
  }
}

ID 1822=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.PooledParallelSender#getNewDataSender()
Rmethod: org.apache.catalina.tribes.transport.nio.ParallelNioSender#ParallelNioSender()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public DataSender getNewDataSender(){
  try {
    ParallelNioSender sender=new ParallelNioSender();
    AbstractSender.transferProperties(this,sender);
    return sender;
  }
 catch (  IOException x) {
    throw new RuntimeException("Unable to open NIO selector.",x);
  }
}

ID 1833=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.ParallelNioSender#connect(org.apache.catalina.tribes.transport.nio.NioSender[])
Rmethod: org.apache.catalina.tribes.transport.nio.NioSender#connect()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void connect(NioSender[] senders) throws ChannelException {
  ChannelException x=null;
  for (int i=0; i < senders.length; i++) {
    try {
      senders[i].connect();
    }
 catch (    IOException io) {
      if (x == null)       x=new ChannelException(io);
      x.addFaultyMember(senders[i].getDestination(),io);
    }
  }
  if (x != null)   throw x;
}

ID 1834=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.ParallelNioSender#setData(org.apache.catalina.tribes.transport.nio.NioSender[], byte[])
Rmethod: org.apache.catalina.tribes.transport.nio.NioSender#setMessage(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void setData(NioSender[] senders,byte[] data) throws ChannelException {
  ChannelException x=null;
  for (int i=0; i < senders.length; i++) {
    try {
      senders[i].setMessage(data);
    }
 catch (    IOException io) {
      if (x == null)       x=new ChannelException(io);
      x.addFaultyMember(senders[i].getDestination(),io);
    }
  }
  if (x != null)   throw x;
}

ID 1835=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.ParallelNioSender#setupForSend(org.apache.catalina.tribes.Member[])
Rmethod: org.apache.catalina.tribes.transport.AbstractSender#setDestination(org.apache.catalina.tribes.Member)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
private NioSender[] setupForSend(Member[] destination) throws ChannelException {
  ChannelException cx=null;
  NioSender[] result=new NioSender[destination.length];
  for (int i=0; i < destination.length; i++) {
    NioSender sender=nioSenders.get(destination[i]);
    try {
      if (sender == null) {
        sender=new NioSender();
        AbstractSender.transferProperties(this,sender);
        nioSenders.put(destination[i],sender);
      }
      sender.reset();
      sender.setDestination(destination[i]);
      sender.setSelector(selector);
      sender.setUdpBased(isUdpBased());
      result[i]=sender;
    }
 catch (    UnknownHostException x) {
      if (cx == null)       cx=new ChannelException("Unable to setup NioSender.",x);
      cx.addFaultyMember(destination[i],x);
    }
  }
  if (cx != null)   throw cx;
 else   return result;
}

ID 1838=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.ParallelNioSender#keepalive()
Rmethod: org.apache.catalina.tribes.transport.nio.NioSender#read(java.nio.channels.SelectionKey)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public boolean keepalive(){
  boolean result=false;
  for (Iterator<Entry<Member,NioSender>> i=nioSenders.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry<Member,NioSender> entry=i.next();
    NioSender sender=entry.getValue();
    if (sender.keepalive()) {
      i.remove();
      result=true;
    }
 else {
      try {
        sender.read(null);
      }
 catch (      IOException x) {
        sender.disconnect();
        sender.reset();
        i.remove();
        result=true;
      }
catch (      Exception x) {
        log.warn("Error during keepalive test for sender:" + sender,x);
      }
    }
  }
  if (result)   try {
    selector.selectNow();
  }
 catch (  Exception e) {
  }
  return result;
}

ID 1872=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReplicationTask#run()
Rmethod: org.apache.catalina.tribes.transport.nio.NioReplicationTask#drainChannel(java.nio.channels.SelectionKey, org.apache.catalina.tribes.io.ObjectReader)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public synchronized void run(){
  if (buffer == null) {
    int size=getRxBufSize();
    if (key.channel() instanceof DatagramChannel) {
      size=ChannelReceiver.MAX_UDP_SIZE;
    }
    if ((getOptions() & OPTION_DIRECT_BUFFER) == OPTION_DIRECT_BUFFER) {
      buffer=ByteBuffer.allocateDirect(size);
    }
 else {
      buffer=ByteBuffer.allocate(size);
    }
  }
 else {
    buffer.clear();
  }
  if (key == null) {
    return;
  }
  if (log.isTraceEnabled())   log.trace("Servicing key:" + key);
  try {
    ObjectReader reader=(ObjectReader)key.attachment();
    if (reader == null) {
      if (log.isTraceEnabled())       log.trace("No object reader, cancelling:" + key);
      cancelKey(key);
    }
 else {
      if (log.isTraceEnabled())       log.trace("Draining channel:" + key);
      drainChannel(key,reader);
    }
  }
 catch (  Exception e) {
    if (e instanceof CancelledKeyException) {
    }
 else     if (e instanceof IOException) {
      if (log.isDebugEnabled())       log.debug("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed[" + e.getMessage() + "].",e);
 else       log.warn("IOException in replication worker, unable to drain channel. Probable cause: Keep alive socket closed[" + e.getMessage() + "].");
    }
 else     if (log.isErrorEnabled()) {
      log.error("Exception caught in TcpReplicationThread.drainChannel.",e);
    }
    cancelKey(key);
  }
 finally {
  }
  key=null;
  getTaskPool().returnWorker(this);
}

ID 1880=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReplicationTask#sendAck(java.nio.channels.SelectionKey, java.nio.channels.WritableByteChannel, byte[], java.net.SocketAddress)
Rmethod: java.nio.channels.DatagramChannel#send(java.nio.ByteBuffer, java.net.SocketAddress)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * send a reply-acknowledgement (6,2,3), sends it doing a busy write, the ACK is so small that it should always go to the buffer
 * @param key
 * @param channel
 */
protected void sendAck(SelectionKey key,WritableByteChannel channel,byte[] command,SocketAddress udpaddr){
  try {
    ByteBuffer buf=ByteBuffer.wrap(command);
    int total=0;
    if (channel instanceof DatagramChannel) {
      DatagramChannel dchannel=(DatagramChannel)channel;
      while (total < command.length) {
        total+=dchannel.send(buf,udpaddr);
      }
    }
 else {
      while (total < command.length) {
        total+=channel.write(buf);
      }
    }
    if (log.isTraceEnabled()) {
      log.trace("ACK sent to " + ((channel instanceof SocketChannel) ? ((SocketChannel)channel).socket().getInetAddress() : ((DatagramChannel)channel).socket().getInetAddress()));
    }
  }
 catch (  java.io.IOException x) {
    log.warn("Unable to send ACK back through channel, channel disconnected?: " + x.getMessage());
  }
}

ID 1881=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReplicationTask#sendAck(java.nio.channels.SelectionKey, java.nio.channels.WritableByteChannel, byte[], java.net.SocketAddress)
Rmethod: java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * send a reply-acknowledgement (6,2,3), sends it doing a busy write, the ACK is so small that it should always go to the buffer
 * @param key
 * @param channel
 */
protected void sendAck(SelectionKey key,WritableByteChannel channel,byte[] command,SocketAddress udpaddr){
  try {
    ByteBuffer buf=ByteBuffer.wrap(command);
    int total=0;
    if (channel instanceof DatagramChannel) {
      DatagramChannel dchannel=(DatagramChannel)channel;
      while (total < command.length) {
        total+=dchannel.send(buf,udpaddr);
      }
    }
 else {
      while (total < command.length) {
        total+=channel.write(buf);
      }
    }
    if (log.isTraceEnabled()) {
      log.trace("ACK sent to " + ((channel instanceof SocketChannel) ? ((SocketChannel)channel).socket().getInetAddress() : ((DatagramChannel)channel).socket().getInetAddress()));
    }
  }
 catch (  java.io.IOException x) {
    log.warn("Unable to send ACK back through channel, channel disconnected?: " + x.getMessage());
  }
}

ID 1882=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReceiver#start()
Rmethod: org.apache.catalina.tribes.transport.RxTaskPool#RxTaskPool(int, int, org.apache.catalina.tribes.transport.RxTaskPool.TaskCreator)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * start cluster receiver
 * @throws IOException
 * @see org.apache.catalina.tribes.ChannelReceiver#start()
 */
@Override public void start() throws IOException {
  super.start();
  try {
    setPool(new RxTaskPool(getMaxThreads(),getMinThreads(),this));
  }
 catch (  Exception x) {
    log.fatal("ThreadPool can initilzed. Listener not started",x);
    if (x instanceof IOException)     throw (IOException)x;
 else     throw new IOException(x.getMessage());
  }
  try {
    getBind();
    bind();
    String channelName="";
    if (getChannel() instanceof GroupChannel && ((GroupChannel)getChannel()).getName() != null) {
      channelName="[" + ((GroupChannel)getChannel()).getName() + "]";
    }
    Thread t=new Thread(this,"NioReceiver" + channelName);
    t.setDaemon(true);
    t.start();
  }
 catch (  Exception x) {
    log.fatal("Unable to start cluster receiver",x);
    if (x instanceof IOException)     throw (IOException)x;
 else     throw new IOException(x.getMessage());
  }
}

ID 1898=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReceiver#cancelledKey(java.nio.channels.SelectionKey)
Rmethod: java.net.Socket#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public static void cancelledKey(SelectionKey key){
  ObjectReader reader=(ObjectReader)key.attachment();
  if (reader != null) {
    reader.setCancelled(true);
    reader.finish();
  }
  key.cancel();
  key.attach(null);
  if (key.channel() instanceof SocketChannel)   try {
    ((SocketChannel)key.channel()).socket().close();
  }
 catch (  IOException e) {
    if (log.isDebugEnabled())     log.debug("",e);
  }
  if (key.channel() instanceof DatagramChannel)   try {
    ((DatagramChannel)key.channel()).socket().close();
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debug("",e);
  }
  try {
    key.channel().close();
  }
 catch (  IOException e) {
    if (log.isDebugEnabled())     log.debug("",e);
  }
}

ID 1899=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReceiver#cancelledKey(java.nio.channels.SelectionKey)
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public static void cancelledKey(SelectionKey key){
  ObjectReader reader=(ObjectReader)key.attachment();
  if (reader != null) {
    reader.setCancelled(true);
    reader.finish();
  }
  key.cancel();
  key.attach(null);
  if (key.channel() instanceof SocketChannel)   try {
    ((SocketChannel)key.channel()).socket().close();
  }
 catch (  IOException e) {
    if (log.isDebugEnabled())     log.debug("",e);
  }
  if (key.channel() instanceof DatagramChannel)   try {
    ((DatagramChannel)key.channel()).socket().close();
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debug("",e);
  }
  try {
    key.channel().close();
  }
 catch (  IOException e) {
    if (log.isDebugEnabled())     log.debug("",e);
  }
}

ID 1917=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReceiver#closeSelector()
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void closeSelector() throws IOException {
  Selector selector=this.selector.getAndSet(null);
  if (selector == null)   return;
  try {
    Iterator<SelectionKey> it=selector.keys().iterator();
    while (it.hasNext()) {
      SelectionKey key=it.next();
      key.channel().close();
      key.attach(null);
      key.cancel();
    }
  }
 catch (  IOException ignore) {
    if (log.isWarnEnabled()) {
      log.warn("Unable to cleanup on selector close.",ignore);
    }
  }
catch (  ClosedSelectorException ignore) {
  }
  selector.close();
}

ID 1921=========================================================================type: 1
Method:org.apache.catalina.tribes.transport.nio.NioReceiver#run()
Rmethod: org.apache.catalina.tribes.transport.nio.NioReceiver#listen()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Start thread and listen
 */
@Override public void run(){
  running=true;
  try {
    listen();
  }
 catch (  Exception x) {
    log.error("Unable to run replication listener.",x);
  }
 finally {
    running=false;
  }
}

ID 1926=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.GzipInterceptor#sendMessage(org.apache.catalina.tribes.Member[], org.apache.catalina.tribes.ChannelMessage, org.apache.catalina.tribes.group.InterceptorPayload)
Rmethod: org.apache.catalina.tribes.group.interceptors.GzipInterceptor#compress(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void sendMessage(Member[] destination,ChannelMessage msg,InterceptorPayload payload) throws ChannelException {
  try {
    byte[] data=compress(msg.getMessage().getBytes());
    msg.getMessage().trim(msg.getMessage().getLength());
    msg.getMessage().append(data,0,data.length);
    getNext().sendMessage(destination,msg,payload);
  }
 catch (  IOException x) {
    log.error("Unable to compress byte contents");
    throw new ChannelException(x);
  }
}

ID 1928=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.GzipInterceptor#messageReceived(org.apache.catalina.tribes.ChannelMessage)
Rmethod: org.apache.catalina.tribes.group.interceptors.GzipInterceptor#decompress(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void messageReceived(ChannelMessage msg){
  try {
    byte[] data=decompress(msg.getMessage().getBytes());
    msg.getMessage().trim(msg.getMessage().getLength());
    msg.getMessage().append(data,0,data.length);
    getPrevious().messageReceived(msg);
  }
 catch (  IOException x) {
    log.error("Unable to decompress byte contents",x);
  }
}

ID 1938=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator#startElection(boolean)
Rmethod: java.lang.Object#wait(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
public void startElection(boolean force) throws ChannelException {
synchronized (electionMutex) {
    MemberImpl local=(MemberImpl)getLocalMember(false);
    MemberImpl[] others=membership.getMembers();
    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT,this,"Election initated"));
    if (others.length == 0) {
      this.viewId=new UniqueId(UUIDGenerator.randomUUID(false));
      this.view=new Membership(local,AbsoluteOrder.comp,true);
      this.handleViewConf(this.createElectionMsg(local,others,local),local,view);
      return;
    }
    if (suggestedviewId != null) {
      if (view != null && Arrays.diff(view,suggestedView,local).length == 0 && Arrays.diff(suggestedView,view,local).length == 0) {
        suggestedviewId=null;
        suggestedView=null;
        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, running election matches view"));
      }
 else {
        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, election running"));
      }
      return;
    }
    if (view != null && Arrays.diff(view,membership,local).length == 0 && Arrays.diff(membership,view,local).length == 0) {
      fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, view matches membership"));
      return;
    }
    int prio=AbsoluteOrder.comp.compare(local,others[0]);
    MemberImpl leader=(prio < 0) ? local : others[0];
    if (local.equals(leader) || force) {
      CoordinationMessage msg=createElectionMsg(local,others,leader);
      suggestedviewId=msg.getId();
      suggestedView=new Membership(local,AbsoluteOrder.comp,true);
      Arrays.fill(suggestedView,msg.getMembers());
      fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PROCESS_ELECT,this,"Election, sending request"));
      sendElectionMsg(local,others[0],msg);
    }
 else {
      try {
        coordMsgReceived.set(false);
        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_WAIT_FOR_MSG,this,"Election, waiting for request"));
        electionMutex.wait(waitForCoordMsgTimeout);
      }
 catch (      InterruptedException x) {
        Thread.interrupted();
      }
      if (suggestedviewId == null && (!coordMsgReceived.get())) {
        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, waiting timed out."));
      }
 else {
        fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_ELECT_ABANDONED,this,"Election abandoned, received a message"));
      }
    }
  }
}

ID 1949=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator#messageReceived(org.apache.catalina.tribes.ChannelMessage)
Rmethod: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator#processCoordMessage(org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator.CoordinationMessage, org.apache.catalina.tribes.Member)
parentException: 
thrown: ChannelException
exception comment: null
block: 
@Override public void messageReceived(ChannelMessage msg){
  if (Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_ALIVE,0,COORD_ALIVE.length)) {
    fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Alive Message"));
  }
 else   if (Arrays.contains(msg.getMessage().getBytesDirect(),0,COORD_HEADER,0,COORD_HEADER.length)) {
    try {
      CoordinationMessage cmsg=new CoordinationMessage(msg.getMessage());
      Member[] cmbr=cmsg.getMembers();
      fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Coord Msg Arrived(" + Arrays.toNameString(cmbr) + ")"));
      processCoordMessage(cmsg,msg.getAddress());
    }
 catch (    ChannelException x) {
      log.error("Error processing coordination message. Could be fatal.",x);
    }
  }
 else {
    super.messageReceived(msg);
  }
}

ID 1950=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator#memberAdded(org.apache.catalina.tribes.Member, boolean)
Rmethod: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator#startElection(boolean)
parentException: 
thrown: ChannelException
exception comment: null
block: 
public void memberAdded(Member member,boolean elect){
  try {
    if (membership == null)     setupMembership();
    if (membership.memberAlive((MemberImpl)member))     super.memberAdded(member);
    try {
      fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_ADD,this,"Member add(" + member.getName() + ")"));
      if (started && elect)       startElection(false);
    }
 catch (    ChannelException x) {
      log.error("Unable to start election when member was added.",x);
    }
  }
  finally {
  }
}

ID 1951=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator#memberDisappeared(org.apache.catalina.tribes.Member)
Rmethod: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator#startElection(boolean)
parentException: 
thrown: ChannelException
exception comment: null
block: 
@Override public void memberDisappeared(Member member){
  try {
    membership.removeMember((MemberImpl)member);
    super.memberDisappeared(member);
    try {
      fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove(" + member.getName() + ")"));
      if (started && (isCoordinator() || isHighest()))       startElection(true);
    }
 catch (    ChannelException x) {
      log.error("Unable to start election when member was removed.",x);
    }
  }
  finally {
  }
}

ID 1953=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.PingThread#run()
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  while (running) {
    try {
      sleep(interval);
      sendPing();
    }
 catch (    InterruptedException ix) {
      interrupted();
    }
catch (    Exception x) {
      log.warn("Unable to send ping from TCP ping thread.",x);
    }
  }
}

ID 1955=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.SimpleCoordinator#installViewWhenStable()
Rmethod: java.util.concurrent.TimeUnit#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
private void installViewWhenStable(){
  int stableCount=0;
  while (stableCount < 10) {
    if (membershipChanged.compareAndSet(true,false)) {
      stableCount=0;
    }
 else {
      stableCount++;
    }
    try {
      TimeUnit.MILLISECONDS.sleep(250);
    }
 catch (    final InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  final Member[] members=getMembers();
  final Member[] view=new Member[members.length + 1];
  System.arraycopy(members,0,view,0,members.length);
  view[members.length]=getLocalMember(false);
  Arrays.sort(view,AbsoluteOrder.comp);
  if (Arrays.equals(view,this.view)) {
    return;
  }
  this.view=view;
  viewChange(view);
}

ID 1965=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.StaticMembershipInterceptor#sendLocalMember(org.apache.catalina.tribes.Member[])
Rmethod: org.apache.catalina.tribes.group.interceptors.StaticMembershipInterceptor#sendMemberMessage(org.apache.catalina.tribes.Member[], byte[])
parentException: 
thrown: ChannelException
exception comment: null
block: 
protected void sendLocalMember(Member[] members){
  try {
    sendMemberMessage(members,MEMBER_START);
  }
 catch (  ChannelException cx) {
    log.warn("Local member notification failed.",cx);
  }
}

ID 1966=========================================================================type: 1
Method:org.apache.catalina.tribes.group.interceptors.StaticMembershipInterceptor#sendShutdown(org.apache.catalina.tribes.Member[])
Rmethod: org.apache.catalina.tribes.group.interceptors.StaticMembershipInterceptor#sendMemberMessage(org.apache.catalina.tribes.Member[], byte[])
parentException: 
thrown: ChannelException
exception comment: null
block: 
protected void sendShutdown(Member[] members){
  try {
    sendMemberMessage(members,MEMBER_STOP);
  }
 catch (  ChannelException cx) {
    log.warn("Shutdown notification failed.",cx);
  }
}

ID 1973=========================================================================type: 1
Method:org.apache.catalina.tribes.group.ChannelCoordinator#internalStart(int)
Rmethod: org.apache.catalina.tribes.MembershipService#start(int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Starts up the channel. This can be called multiple times for individual services to start The svc parameter can be the logical or value of any constants
 * @param svc int value of <BR>DEFAULT - will start all services <BR> MBR_RX_SEQ - starts the membership receiver <BR> MBR_TX_SEQ - starts the membership broadcaster <BR> SND_TX_SEQ - starts the replication transmitter<BR> SND_RX_SEQ - starts the replication receiver<BR>
 * @throws ChannelException if a startup error occurs or the service is already started.
 */
protected synchronized void internalStart(int svc) throws ChannelException {
  try {
    boolean valid=false;
    svc=svc & Channel.DEFAULT;
    if (startLevel == Channel.DEFAULT)     return;
    if (svc == 0)     return;
    if (svc == (svc & startLevel))     throw new ChannelException("Channel already started for level:" + svc);
    if (Channel.SND_RX_SEQ == (svc & Channel.SND_RX_SEQ)) {
      clusterReceiver.setMessageListener(this);
      if (clusterReceiver instanceof ReceiverBase) {
        ((ReceiverBase)clusterReceiver).setChannel(getChannel());
      }
      clusterReceiver.start();
      Member localMember=getChannel().getLocalMember(false);
      if (localMember instanceof StaticMember) {
        StaticMember staticMember=(StaticMember)localMember;
        staticMember.setHost(getClusterReceiver().getHost());
        staticMember.setPort(getClusterReceiver().getPort());
        staticMember.setSecurePort(getClusterReceiver().getSecurePort());
      }
 else {
        membershipService.setLocalMemberProperties(getClusterReceiver().getHost(),getClusterReceiver().getPort(),getClusterReceiver().getSecurePort(),getClusterReceiver().getUdpPort());
      }
      valid=true;
    }
    if (Channel.SND_TX_SEQ == (svc & Channel.SND_TX_SEQ)) {
      if (clusterSender instanceof ReplicationTransmitter) {
        ((ReplicationTransmitter)clusterSender).setChannel(getChannel());
      }
      valid=true;
      clusterSender.start();
    }
    if (Channel.MBR_RX_SEQ == (svc & Channel.MBR_RX_SEQ)) {
      membershipService.setMembershipListener(this);
      if (membershipService instanceof McastService) {
        ((McastService)membershipService).setMessageListener(this);
        ((McastService)membershipService).setChannel(getChannel());
      }
      membershipService.start(MembershipService.MBR_RX);
      valid=true;
    }
    if (Channel.MBR_TX_SEQ == (svc & Channel.MBR_TX_SEQ)) {
      if (membershipService instanceof McastService) {
        ((McastService)membershipService).setChannel(getChannel());
      }
      membershipService.start(MembershipService.MBR_TX);
      valid=true;
    }
    if (!valid) {
      throw new IllegalArgumentException("Invalid start level, valid levels are:SND_RX_SEQ,SND_TX_SEQ,MBR_TX_SEQ,MBR_RX_SEQ");
    }
    startLevel=(startLevel | svc);
  }
 catch (  ChannelException cx) {
    throw cx;
  }
catch (  Exception x) {
    throw new ChannelException(x);
  }
}

ID 1986=========================================================================type: 1
Method:org.apache.catalina.tribes.group.HeartbeatThread#run()
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  while (doRun) {
    try {
      Thread.sleep(sleepTime);
      channel.heartbeat();
    }
 catch (    InterruptedException x) {
      interrupted();
    }
catch (    Exception x) {
      log.error("Unable to send heartbeat through Tribes interceptor stack. Will try to sleep again.",x);
    }
  }
}

ID 2004=========================================================================type: 1
Method:org.apache.catalina.tribes.group.RpcChannel#send(org.apache.catalina.tribes.Member[], java.io.Serializable, int, int, long)
Rmethod: java.lang.Object#wait(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Send a message and wait for the response.
 * @param destination Member[] - the destination for the message, and the members you request a reply from
 * @param message Serializable - the message you are sending out
 * @param rpcOptions int - FIRST_REPLY, MAJORITY_REPLY or ALL_REPLY
 * @param channelOptions channel sender options
 * @param timeout long - timeout in milliseconds, if no reply is received within this time null is returned
 * @return Response[] - an array of response objects.
 * @throws ChannelException
 */
public Response[] send(Member[] destination,Serializable message,int rpcOptions,int channelOptions,long timeout) throws ChannelException {
  if (destination == null || destination.length == 0)   return new Response[0];
  int sendOptions=channelOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK;
  RpcCollectorKey key=new RpcCollectorKey(UUIDGenerator.randomUUID(false));
  RpcCollector collector=new RpcCollector(key,rpcOptions,destination.length);
  try {
synchronized (collector) {
      if (rpcOptions != NO_REPLY)       responseMap.put(key,collector);
      RpcMessage rmsg=new RpcMessage(rpcId,key.id,message);
      channel.send(destination,rmsg,sendOptions);
      if (rpcOptions != NO_REPLY)       collector.wait(timeout);
    }
  }
 catch (  InterruptedException ix) {
    Thread.currentThread().interrupt();
  }
 finally {
    responseMap.remove(key);
  }
  return collector.getResponses();
}

ID 2026=========================================================================type: 1
Method:org.apache.catalina.tribes.io.ReplicationStream#resolveClass(java.io.ObjectStreamClass)
Rmethod: org.apache.catalina.tribes.io.ReplicationStream#resolveClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Load the local class equivalent of the specified stream class description, by using the class loader assigned to this Context.
 * @param classDesc Class description from the input stream
 * @exception ClassNotFoundException if this class cannot be found
 * @exception IOException if an input/output error occurs
 */
@Override public Class<?> resolveClass(ObjectStreamClass classDesc) throws ClassNotFoundException, IOException {
  String name=classDesc.getName();
  try {
    return resolveClass(name);
  }
 catch (  ClassNotFoundException e) {
    return super.resolveClass(classDesc);
  }
}

ID 2033=========================================================================type: 1
Method:org.apache.catalina.tribes.io.ReplicationStream#resolveProxyClass(java.lang.String[])
Rmethod: java.lang.reflect.Proxy#getProxyClass(java.lang.ClassLoader, Class<?>[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * ObjectInputStream.resolveProxyClass has some funky way of using  the incorrect class loader to resolve proxy classes, let's do it our way instead
 */
@Override protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {
  ClassLoader latestLoader;
  if (classLoaders != null && classLoaders.length > 0) {
    latestLoader=classLoaders[0];
  }
 else {
    latestLoader=null;
  }
  ClassLoader nonPublicLoader=null;
  boolean hasNonPublicInterface=false;
  Class<?>[] classObjs=new Class[interfaces.length];
  for (int i=0; i < interfaces.length; i++) {
    Class<?> cl=this.resolveClass(interfaces[i]);
    if (latestLoader == null)     latestLoader=cl.getClassLoader();
    if ((cl.getModifiers() & Modifier.PUBLIC) == 0) {
      if (hasNonPublicInterface) {
        if (nonPublicLoader != cl.getClassLoader()) {
          throw new IllegalAccessError("conflicting non-public interface class loaders");
        }
      }
 else {
        nonPublicLoader=cl.getClassLoader();
        hasNonPublicInterface=true;
      }
    }
    classObjs[i]=cl;
  }
  try {
    return Proxy.getProxyClass(hasNonPublicInterface ? nonPublicLoader : latestLoader,classObjs);
  }
 catch (  IllegalArgumentException e) {
    throw new ClassNotFoundException(null,e);
  }
}

ID 2035=========================================================================type: 1
Method:org.apache.catalina.tribes.io.ReplicationStream#findExternalClass(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String, boolean, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
public Class<?> findExternalClass(String name) throws ClassNotFoundException {
  ClassNotFoundException cnfe=null;
  for (int i=0; i < classLoaders.length; i++) {
    try {
      Class<?> clazz=Class.forName(name,false,classLoaders[i]);
      return clazz;
    }
 catch (    ClassNotFoundException x) {
      cnfe=x;
    }
  }
  if (cnfe != null)   throw cnfe;
 else   throw new ClassNotFoundException(name);
}

ID 2036=========================================================================type: 1
Method:org.apache.catalina.tribes.io.ObjectReader#ObjectReader(java.net.Socket)
Rmethod: java.net.Socket#getReceiveBufferSize()
parentException: IOException 
thrown: SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

block: 
/** 
 * Creates an <code>ObjectReader</code> for a TCP socket
 * @param socket Socket
 */
public ObjectReader(Socket socket){
  try {
    this.buffer=new XByteBuffer(socket.getReceiveBufferSize(),true);
  }
 catch (  IOException x) {
    log.warn("Unable to retrieve the socket receiver buffer size, setting to default 43800 bytes.");
    this.buffer=new XByteBuffer(43800,true);
  }
}

ID 2038=========================================================================type: 1
Method:org.apache.catalina.tribes.membership.StaticMember#setHost(java.lang.String)
Rmethod: org.apache.catalina.tribes.membership.MemberImpl#setHostname(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @param host String, either in byte array string format, like {214,116,1,3}or as a regular hostname, 127.0.0.1 or tomcat01.mydomain.com
 */
public void setHost(String host){
  if (host == null)   return;
  if (host.startsWith("{"))   setHost(Arrays.fromString(host));
 else   try {
    setHostname(host);
  }
 catch (  IOException x) {
    throw new RuntimeException(x);
  }
}

ID 2040=========================================================================type: 1
Method:org.apache.catalina.tribes.membership.MemberImpl#getHostname()
Rmethod: java.net.InetAddress#getByAddress(byte[])
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
public String getHostname(){
  if (this.hostname != null)   return hostname;
 else {
    try {
      if (DO_DNS_LOOKUPS)       this.hostname=java.net.InetAddress.getByAddress(host).getHostName();
 else       this.hostname=org.apache.catalina.tribes.util.Arrays.toString(host,0,host.length,true);
      return this.hostname;
    }
 catch (    IOException x) {
      throw new RuntimeException("Unable to parse hostname.",x);
    }
  }
}

ID 2061=========================================================================type: 1
Method:org.apache.catalina.tribes.membership.McastServiceImpl#memberBroadcastsReceived(byte[])
Rmethod: org.apache.catalina.tribes.io.XByteBuffer#extractPackage(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void memberBroadcastsReceived(final byte[] b){
  if (log.isTraceEnabled())   log.trace("Mcast received broadcasts.");
  XByteBuffer buffer=new XByteBuffer(b,true);
  if (buffer.countPackages(true) > 0) {
    int count=buffer.countPackages();
    final ChannelData[] data=new ChannelData[count];
    for (int i=0; i < count; i++) {
      try {
        data[i]=buffer.extractPackage(true);
      }
 catch (      IllegalStateException ise) {
        log.debug("Unable to decode message.",ise);
      }
catch (      IOException x) {
        log.debug("Unable to decode message.",x);
      }
    }
    Runnable t=new Runnable(){
      @Override public void run(){
        String name=Thread.currentThread().getName();
        try {
          Thread.currentThread().setName("Membership-MemberAdded.");
          for (int i=0; i < data.length; i++) {
            try {
              if (data[i] != null && !member.equals(data[i].getAddress())) {
                msgservice.messageReceived(data[i]);
              }
            }
 catch (            Throwable t) {
              if (t instanceof ThreadDeath) {
                throw (ThreadDeath)t;
              }
              if (t instanceof VirtualMachineError) {
                throw (VirtualMachineError)t;
              }
              log.error("Unable to receive broadcast message.",t);
            }
          }
        }
  finally {
          Thread.currentThread().setName(name);
        }
      }
    }
;
    executor.execute(t);
  }
}

ID 2072=========================================================================type: 1
Method:org.apache.catalina.tribes.membership.McastService#setLocalMemberProperties(java.lang.String, int, int, int)
Rmethod: org.apache.catalina.tribes.membership.MemberImpl#setHostname(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Sets the local member properties for broadcasting
 */
@Override public void setLocalMemberProperties(String listenHost,int listenPort,int securePort,int udpPort){
  properties.setProperty("tcpListenHost",listenHost);
  properties.setProperty("tcpListenPort",String.valueOf(listenPort));
  properties.setProperty("udpListenPort",String.valueOf(udpPort));
  properties.setProperty("tcpSecurePort",String.valueOf(securePort));
  try {
    if (localMember != null) {
      localMember.setHostname(listenHost);
      localMember.setPort(listenPort);
    }
 else {
      localMember=new MemberImpl(listenHost,listenPort,0);
      localMember.setUniqueId(UUIDGenerator.randomUUID(true));
      localMember.setPayload(getPayload());
      localMember.setDomain(getDomain());
      localMember.setLocal(true);
    }
    localMember.setSecurePort(securePort);
    localMember.setUdpPort(udpPort);
    localMember.getData(true,true);
  }
 catch (  IOException x) {
    throw new IllegalArgumentException(x);
  }
}

ID 2073=========================================================================type: 1
Method:org.apache.catalina.tribes.membership.McastService#setLocalMemberProperties(java.lang.String, int, int, int)
Rmethod: org.apache.catalina.tribes.membership.MemberImpl#MemberImpl(java.lang.String, int, long)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Sets the local member properties for broadcasting
 */
@Override public void setLocalMemberProperties(String listenHost,int listenPort,int securePort,int udpPort){
  properties.setProperty("tcpListenHost",listenHost);
  properties.setProperty("tcpListenPort",String.valueOf(listenPort));
  properties.setProperty("udpListenPort",String.valueOf(udpPort));
  properties.setProperty("tcpSecurePort",String.valueOf(securePort));
  try {
    if (localMember != null) {
      localMember.setHostname(listenHost);
      localMember.setPort(listenPort);
    }
 else {
      localMember=new MemberImpl(listenHost,listenPort,0);
      localMember.setUniqueId(UUIDGenerator.randomUUID(true));
      localMember.setPayload(getPayload());
      localMember.setDomain(getDomain());
      localMember.setLocal(true);
    }
    localMember.setSecurePort(securePort);
    localMember.setUdpPort(udpPort);
    localMember.getData(true,true);
  }
 catch (  IOException x) {
    throw new IllegalArgumentException(x);
  }
}

ID 2088=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#addEnvironment(org.apache.catalina.deploy.ContextEnvironment)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.deploy.ContextEnvironment)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Add an environment entry for this web application.
 * @param environment New environment entry
 */
public void addEnvironment(ContextEnvironment environment){
  if (entries.contains(environment.getName())) {
    ContextEnvironment ce=findEnvironment(environment.getName());
    ContextResourceLink rl=findResourceLink(environment.getName());
    if (ce != null) {
      if (ce.getOverride()) {
        removeEnvironment(environment.getName());
      }
 else {
        return;
      }
    }
 else     if (rl != null) {
      NamingResources global=getServer().getGlobalNamingResources();
      if (global.findEnvironment(rl.getGlobal()) != null) {
        if (global.findEnvironment(rl.getGlobal()).getOverride()) {
          removeResourceLink(environment.getName());
        }
 else {
          return;
        }
      }
    }
 else {
      return;
    }
  }
  if (!checkResourceType(environment)) {
    throw new IllegalArgumentException(sm.getString("namingResources.resourceTypeFail",environment.getName(),environment.getType()));
  }
  entries.add(environment.getName());
synchronized (envs) {
    environment.setNamingResources(this);
    envs.put(environment.getName(),environment);
  }
  support.firePropertyChange("environment",null,environment);
  if (resourceRequireExplicitRegistration) {
    try {
      MBeanUtils.createMBean(environment);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",environment.getName()),e);
    }
  }
}

ID 2089=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#addResource(org.apache.catalina.deploy.ContextResource)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.deploy.ContextResource)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Add a resource reference for this web application.
 * @param resource New resource reference
 */
public void addResource(ContextResource resource){
  if (entries.contains(resource.getName())) {
    return;
  }
 else {
    if (!checkResourceType(resource)) {
      throw new IllegalArgumentException(sm.getString("namingResources.resourceTypeFail",resource.getName(),resource.getType()));
    }
    entries.add(resource.getName());
  }
synchronized (resources) {
    resource.setNamingResources(this);
    resources.put(resource.getName(),resource);
  }
  support.firePropertyChange("resource",null,resource);
  if (resourceRequireExplicitRegistration) {
    try {
      MBeanUtils.createMBean(resource);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",resource.getName()),e);
    }
  }
}

ID 2090=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#addResourceLink(org.apache.catalina.deploy.ContextResourceLink)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.deploy.ContextResourceLink)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Add a resource link for this web application.
 * @param resourceLink New resource link
 */
public void addResourceLink(ContextResourceLink resourceLink){
  if (entries.contains(resourceLink.getName())) {
    return;
  }
 else {
    entries.add(resourceLink.getName());
  }
synchronized (resourceLinks) {
    resourceLink.setNamingResources(this);
    resourceLinks.put(resourceLink.getName(),resourceLink);
  }
  support.firePropertyChange("resourceLink",null,resourceLink);
  if (resourceRequireExplicitRegistration) {
    try {
      MBeanUtils.createMBean(resourceLink);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",resourceLink.getName()),e);
    }
  }
}

ID 2091=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#removeEnvironment(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.deploy.ContextEnvironment)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove any environment entry with the specified name.
 * @param name Name of the environment entry to remove
 */
public void removeEnvironment(String name){
  entries.remove(name);
  ContextEnvironment environment=null;
synchronized (envs) {
    environment=envs.remove(name);
  }
  if (environment != null) {
    support.firePropertyChange("environment",environment,null);
    if (resourceRequireExplicitRegistration) {
      try {
        MBeanUtils.destroyMBean(environment);
      }
 catch (      Exception e) {
        log.warn(sm.getString("namingResources.mbeanDestroyFail",environment.getName()),e);
      }
    }
    environment.setNamingResources(null);
  }
}

ID 2092=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#removeResource(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.deploy.ContextResource)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove any resource reference with the specified name.
 * @param name Name of the resource reference to remove
 */
public void removeResource(String name){
  entries.remove(name);
  ContextResource resource=null;
synchronized (resources) {
    resource=resources.remove(name);
  }
  if (resource != null) {
    support.firePropertyChange("resource",resource,null);
    if (resourceRequireExplicitRegistration) {
      try {
        MBeanUtils.destroyMBean(resource);
      }
 catch (      Exception e) {
        log.warn(sm.getString("namingResources.mbeanDestroyFail",resource.getName()),e);
      }
    }
    resource.setNamingResources(null);
  }
}

ID 2093=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#removeResourceLink(java.lang.String)
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.deploy.ContextResourceLink)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove any resource link with the specified name.
 * @param name Name of the resource link to remove
 */
public void removeResourceLink(String name){
  entries.remove(name);
  ContextResourceLink resourceLink=null;
synchronized (resourceLinks) {
    resourceLink=resourceLinks.remove(name);
  }
  if (resourceLink != null) {
    support.firePropertyChange("resourceLink",resourceLink,null);
    if (resourceRequireExplicitRegistration) {
      try {
        MBeanUtils.destroyMBean(resourceLink);
      }
 catch (      Exception e) {
        log.warn(sm.getString("namingResources.mbeanDestroyFail",resourceLink.getName()),e);
      }
    }
    resourceLink.setNamingResources(null);
  }
}

ID 2094=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#initInternal()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.deploy.ContextResource)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void initInternal() throws LifecycleException {
  super.initInternal();
  resourceRequireExplicitRegistration=true;
  for (  ContextResource cr : resources.values()) {
    try {
      MBeanUtils.createMBean(cr);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",cr.getName()),e);
    }
  }
  for (  ContextEnvironment ce : envs.values()) {
    try {
      MBeanUtils.createMBean(ce);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",ce.getName()),e);
    }
  }
  for (  ContextResourceLink crl : resourceLinks.values()) {
    try {
      MBeanUtils.createMBean(crl);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",crl.getName()),e);
    }
  }
}

ID 2095=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#initInternal()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.deploy.ContextEnvironment)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void initInternal() throws LifecycleException {
  super.initInternal();
  resourceRequireExplicitRegistration=true;
  for (  ContextResource cr : resources.values()) {
    try {
      MBeanUtils.createMBean(cr);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",cr.getName()),e);
    }
  }
  for (  ContextEnvironment ce : envs.values()) {
    try {
      MBeanUtils.createMBean(ce);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",ce.getName()),e);
    }
  }
  for (  ContextResourceLink crl : resourceLinks.values()) {
    try {
      MBeanUtils.createMBean(crl);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",crl.getName()),e);
    }
  }
}

ID 2096=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#initInternal()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#createMBean(org.apache.catalina.deploy.ContextResourceLink)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void initInternal() throws LifecycleException {
  super.initInternal();
  resourceRequireExplicitRegistration=true;
  for (  ContextResource cr : resources.values()) {
    try {
      MBeanUtils.createMBean(cr);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",cr.getName()),e);
    }
  }
  for (  ContextEnvironment ce : envs.values()) {
    try {
      MBeanUtils.createMBean(ce);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",ce.getName()),e);
    }
  }
  for (  ContextResourceLink crl : resourceLinks.values()) {
    try {
      MBeanUtils.createMBean(crl);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanCreateFail",crl.getName()),e);
    }
  }
}

ID 2099=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#cleanUp()
Rmethod: org.apache.naming.ContextBindings#getClassLoader()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Close those resources that an explicit close may help clean-up faster.
 */
private void cleanUp(){
  if (resources.size() == 0) {
    return;
  }
  javax.naming.Context ctxt;
  try {
    if (container instanceof Server) {
      ctxt=((Server)container).getGlobalNamingContext();
    }
 else {
      ctxt=ContextBindings.getClassLoader();
      ctxt=(javax.naming.Context)ctxt.lookup("comp/env");
    }
  }
 catch (  NamingException e) {
    log.warn(sm.getString("namingResources.cleanupNoContext",container),e);
    return;
  }
  for (  ContextResource cr : resources.values()) {
    if (cr.getSingleton()) {
      String closeMethod=cr.getCloseMethod();
      if (closeMethod != null && closeMethod.length() > 0) {
        String name=cr.getName();
        Object resource;
        try {
          resource=ctxt.lookup(name);
        }
 catch (        NamingException e) {
          log.warn(sm.getString("namingResources.cleanupNoResource",cr.getName(),container),e);
          continue;
        }
        cleanUp(resource,name,closeMethod);
      }
    }
  }
}

ID 2100=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#cleanUp()
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Close those resources that an explicit close may help clean-up faster.
 */
private void cleanUp(){
  if (resources.size() == 0) {
    return;
  }
  javax.naming.Context ctxt;
  try {
    if (container instanceof Server) {
      ctxt=((Server)container).getGlobalNamingContext();
    }
 else {
      ctxt=ContextBindings.getClassLoader();
      ctxt=(javax.naming.Context)ctxt.lookup("comp/env");
    }
  }
 catch (  NamingException e) {
    log.warn(sm.getString("namingResources.cleanupNoContext",container),e);
    return;
  }
  for (  ContextResource cr : resources.values()) {
    if (cr.getSingleton()) {
      String closeMethod=cr.getCloseMethod();
      if (closeMethod != null && closeMethod.length() > 0) {
        String name=cr.getName();
        Object resource;
        try {
          resource=ctxt.lookup(name);
        }
 catch (        NamingException e) {
          log.warn(sm.getString("namingResources.cleanupNoResource",cr.getName(),container),e);
          continue;
        }
        cleanUp(resource,name,closeMethod);
      }
    }
  }
}

ID 2101=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#cleanUp(java.lang.Object, java.lang.String, java.lang.String)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
/** 
 * Clean up a resource by calling the defined close method. For example, closing a database connection pool will close it's open connections. This will happen on GC but that leaves db connections open that may cause issues.
 * @param resource  The resource to close.
 */
private void cleanUp(Object resource,String name,String closeMethod){
  Method m=null;
  try {
    m=resource.getClass().getMethod(closeMethod,(Class<?>[])null);
  }
 catch (  SecurityException e) {
    log.debug(sm.getString("namingResources.cleanupCloseSecurity",closeMethod,name,container));
    return;
  }
catch (  NoSuchMethodException e) {
    log.debug(sm.getString("namingResources.cleanupNoClose",name,container,closeMethod));
    return;
  }
  try {
    m.invoke(resource,(Object[])null);
  }
 catch (  IllegalArgumentException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  InvocationTargetException e) {
    Throwable t=ExceptionUtils.unwrapInvocationTargetException(e);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),t);
  }
}

ID 2102=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#cleanUp(java.lang.Object, java.lang.String, java.lang.String)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Clean up a resource by calling the defined close method. For example, closing a database connection pool will close it's open connections. This will happen on GC but that leaves db connections open that may cause issues.
 * @param resource  The resource to close.
 */
private void cleanUp(Object resource,String name,String closeMethod){
  Method m=null;
  try {
    m=resource.getClass().getMethod(closeMethod,(Class<?>[])null);
  }
 catch (  SecurityException e) {
    log.debug(sm.getString("namingResources.cleanupCloseSecurity",closeMethod,name,container));
    return;
  }
catch (  NoSuchMethodException e) {
    log.debug(sm.getString("namingResources.cleanupNoClose",name,container,closeMethod));
    return;
  }
  try {
    m.invoke(resource,(Object[])null);
  }
 catch (  IllegalArgumentException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  InvocationTargetException e) {
    Throwable t=ExceptionUtils.unwrapInvocationTargetException(e);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),t);
  }
}

ID 2103=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#cleanUp(java.lang.Object, java.lang.String, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Clean up a resource by calling the defined close method. For example, closing a database connection pool will close it's open connections. This will happen on GC but that leaves db connections open that may cause issues.
 * @param resource  The resource to close.
 */
private void cleanUp(Object resource,String name,String closeMethod){
  Method m=null;
  try {
    m=resource.getClass().getMethod(closeMethod,(Class<?>[])null);
  }
 catch (  SecurityException e) {
    log.debug(sm.getString("namingResources.cleanupCloseSecurity",closeMethod,name,container));
    return;
  }
catch (  NoSuchMethodException e) {
    log.debug(sm.getString("namingResources.cleanupNoClose",name,container,closeMethod));
    return;
  }
  try {
    m.invoke(resource,(Object[])null);
  }
 catch (  IllegalArgumentException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  InvocationTargetException e) {
    Throwable t=ExceptionUtils.unwrapInvocationTargetException(e);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),t);
  }
}

ID 2104=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#cleanUp(java.lang.Object, java.lang.String, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Clean up a resource by calling the defined close method. For example, closing a database connection pool will close it's open connections. This will happen on GC but that leaves db connections open that may cause issues.
 * @param resource  The resource to close.
 */
private void cleanUp(Object resource,String name,String closeMethod){
  Method m=null;
  try {
    m=resource.getClass().getMethod(closeMethod,(Class<?>[])null);
  }
 catch (  SecurityException e) {
    log.debug(sm.getString("namingResources.cleanupCloseSecurity",closeMethod,name,container));
    return;
  }
catch (  NoSuchMethodException e) {
    log.debug(sm.getString("namingResources.cleanupNoClose",name,container,closeMethod));
    return;
  }
  try {
    m.invoke(resource,(Object[])null);
  }
 catch (  IllegalArgumentException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  InvocationTargetException e) {
    Throwable t=ExceptionUtils.unwrapInvocationTargetException(e);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),t);
  }
}

ID 2105=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#cleanUp(java.lang.Object, java.lang.String, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Clean up a resource by calling the defined close method. For example, closing a database connection pool will close it's open connections. This will happen on GC but that leaves db connections open that may cause issues.
 * @param resource  The resource to close.
 */
private void cleanUp(Object resource,String name,String closeMethod){
  Method m=null;
  try {
    m=resource.getClass().getMethod(closeMethod,(Class<?>[])null);
  }
 catch (  SecurityException e) {
    log.debug(sm.getString("namingResources.cleanupCloseSecurity",closeMethod,name,container));
    return;
  }
catch (  NoSuchMethodException e) {
    log.debug(sm.getString("namingResources.cleanupNoClose",name,container,closeMethod));
    return;
  }
  try {
    m.invoke(resource,(Object[])null);
  }
 catch (  IllegalArgumentException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),e);
  }
catch (  InvocationTargetException e) {
    Throwable t=ExceptionUtils.unwrapInvocationTargetException(e);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("namingResources.cleanupCloseFailed",closeMethod,name,container),t);
  }
}

ID 2106=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#destroyInternal()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.deploy.ContextResourceLink)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void destroyInternal() throws LifecycleException {
  resourceRequireExplicitRegistration=false;
  for (  ContextResourceLink crl : resourceLinks.values()) {
    try {
      MBeanUtils.destroyMBean(crl);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",crl.getName()),e);
    }
  }
  for (  ContextEnvironment ce : envs.values()) {
    try {
      MBeanUtils.destroyMBean(ce);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",ce.getName()),e);
    }
  }
  for (  ContextResource cr : resources.values()) {
    try {
      MBeanUtils.destroyMBean(cr);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",cr.getName()),e);
    }
  }
  super.destroyInternal();
}

ID 2107=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#destroyInternal()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.deploy.ContextEnvironment)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void destroyInternal() throws LifecycleException {
  resourceRequireExplicitRegistration=false;
  for (  ContextResourceLink crl : resourceLinks.values()) {
    try {
      MBeanUtils.destroyMBean(crl);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",crl.getName()),e);
    }
  }
  for (  ContextEnvironment ce : envs.values()) {
    try {
      MBeanUtils.destroyMBean(ce);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",ce.getName()),e);
    }
  }
  for (  ContextResource cr : resources.values()) {
    try {
      MBeanUtils.destroyMBean(cr);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",cr.getName()),e);
    }
  }
  super.destroyInternal();
}

ID 2108=========================================================================type: 1
Method:org.apache.catalina.deploy.NamingResources#destroyInternal()
Rmethod: org.apache.catalina.mbeans.MBeanUtils#destroyMBean(org.apache.catalina.deploy.ContextResource)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void destroyInternal() throws LifecycleException {
  resourceRequireExplicitRegistration=false;
  for (  ContextResourceLink crl : resourceLinks.values()) {
    try {
      MBeanUtils.destroyMBean(crl);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",crl.getName()),e);
    }
  }
  for (  ContextEnvironment ce : envs.values()) {
    try {
      MBeanUtils.destroyMBean(ce);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",ce.getName()),e);
    }
  }
  for (  ContextResource cr : resources.values()) {
    try {
      MBeanUtils.destroyMBean(cr);
    }
 catch (    Exception e) {
      log.warn(sm.getString("namingResources.mbeanDestroyFail",cr.getName()),e);
    }
  }
  super.destroyInternal();
}

ID 2109=========================================================================type: 1
Method:org.apache.catalina.deploy.ErrorPage#setErrorCode(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the error code (hack for default XmlMapper data type).
 * @param errorCode The new error code
 */
public void setErrorCode(String errorCode){
  try {
    this.errorCode=Integer.parseInt(errorCode);
  }
 catch (  NumberFormatException nfe) {
    throw new IllegalArgumentException(nfe);
  }
}

ID 2124=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIEnvironment#expandCGIScript()
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Extracts requested resource from web app archive to context work directory to enable CGI script to be executed.
 */
protected void expandCGIScript(){
  StringBuilder srcPath=new StringBuilder();
  StringBuilder destPath=new StringBuilder();
  InputStream is=null;
  if (cgiPathPrefix == null) {
    srcPath.append(pathInfo);
    is=context.getResourceAsStream(srcPath.toString());
    destPath.append(tmpDir);
    destPath.append(pathInfo);
  }
 else {
    srcPath.append(cgiPathPrefix);
    StringTokenizer pathWalker=new StringTokenizer(pathInfo,"/");
    while (pathWalker.hasMoreElements() && (is == null)) {
      srcPath.append("/");
      srcPath.append(pathWalker.nextElement());
      is=context.getResourceAsStream(srcPath.toString());
    }
    destPath.append(tmpDir);
    destPath.append("/");
    destPath.append(srcPath);
  }
  if (is == null) {
    log.warn(sm.getString("cgiServlet.expandNotFound",srcPath));
    return;
  }
  File f=new File(destPath.toString());
  if (f.exists()) {
    try {
      is.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("cgiServlet.expandCloseFail",srcPath),e);
    }
    return;
  }
  File dir=f.getParentFile();
  if (!dir.mkdirs() && !dir.isDirectory()) {
    log.warn(sm.getString("cgiServlet.expandCreateDirFail",dir.getAbsolutePath()));
    return;
  }
  try {
synchronized (expandFileLock) {
      if (f.exists()) {
        return;
      }
      if (!f.createNewFile()) {
        return;
      }
      FileOutputStream fos=new FileOutputStream(f);
      try {
        IOTools.flow(is,fos);
      }
  finally {
        try {
          is.close();
        }
 catch (        IOException e) {
          log.warn(sm.getString("cgiServlet.expandError"),e);
        }
        fos.close();
      }
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("cgiServlet.expandOk",srcPath,destPath));
      }
    }
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("cgiServlet.expandFail",srcPath,destPath),ioe);
    if (f.exists()) {
      if (!f.delete()) {
        log.warn(sm.getString("cgiServlet.expandDeleteFail",f.getAbsolutePath()));
      }
    }
  }
}

ID 2125=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIEnvironment#expandCGIScript()
Rmethod: java.io.File#createNewFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Extracts requested resource from web app archive to context work directory to enable CGI script to be executed.
 */
protected void expandCGIScript(){
  StringBuilder srcPath=new StringBuilder();
  StringBuilder destPath=new StringBuilder();
  InputStream is=null;
  if (cgiPathPrefix == null) {
    srcPath.append(pathInfo);
    is=context.getResourceAsStream(srcPath.toString());
    destPath.append(tmpDir);
    destPath.append(pathInfo);
  }
 else {
    srcPath.append(cgiPathPrefix);
    StringTokenizer pathWalker=new StringTokenizer(pathInfo,"/");
    while (pathWalker.hasMoreElements() && (is == null)) {
      srcPath.append("/");
      srcPath.append(pathWalker.nextElement());
      is=context.getResourceAsStream(srcPath.toString());
    }
    destPath.append(tmpDir);
    destPath.append("/");
    destPath.append(srcPath);
  }
  if (is == null) {
    log.warn(sm.getString("cgiServlet.expandNotFound",srcPath));
    return;
  }
  File f=new File(destPath.toString());
  if (f.exists()) {
    try {
      is.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("cgiServlet.expandCloseFail",srcPath),e);
    }
    return;
  }
  File dir=f.getParentFile();
  if (!dir.mkdirs() && !dir.isDirectory()) {
    log.warn(sm.getString("cgiServlet.expandCreateDirFail",dir.getAbsolutePath()));
    return;
  }
  try {
synchronized (expandFileLock) {
      if (f.exists()) {
        return;
      }
      if (!f.createNewFile()) {
        return;
      }
      FileOutputStream fos=new FileOutputStream(f);
      try {
        IOTools.flow(is,fos);
      }
  finally {
        try {
          is.close();
        }
 catch (        IOException e) {
          log.warn(sm.getString("cgiServlet.expandError"),e);
        }
        fos.close();
      }
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("cgiServlet.expandOk",srcPath,destPath));
      }
    }
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("cgiServlet.expandFail",srcPath,destPath),ioe);
    if (f.exists()) {
      if (!f.delete()) {
        log.warn(sm.getString("cgiServlet.expandDeleteFail",f.getAbsolutePath()));
      }
    }
  }
}

ID 2126=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIEnvironment#expandCGIScript()
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Extracts requested resource from web app archive to context work directory to enable CGI script to be executed.
 */
protected void expandCGIScript(){
  StringBuilder srcPath=new StringBuilder();
  StringBuilder destPath=new StringBuilder();
  InputStream is=null;
  if (cgiPathPrefix == null) {
    srcPath.append(pathInfo);
    is=context.getResourceAsStream(srcPath.toString());
    destPath.append(tmpDir);
    destPath.append(pathInfo);
  }
 else {
    srcPath.append(cgiPathPrefix);
    StringTokenizer pathWalker=new StringTokenizer(pathInfo,"/");
    while (pathWalker.hasMoreElements() && (is == null)) {
      srcPath.append("/");
      srcPath.append(pathWalker.nextElement());
      is=context.getResourceAsStream(srcPath.toString());
    }
    destPath.append(tmpDir);
    destPath.append("/");
    destPath.append(srcPath);
  }
  if (is == null) {
    log.warn(sm.getString("cgiServlet.expandNotFound",srcPath));
    return;
  }
  File f=new File(destPath.toString());
  if (f.exists()) {
    try {
      is.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("cgiServlet.expandCloseFail",srcPath),e);
    }
    return;
  }
  File dir=f.getParentFile();
  if (!dir.mkdirs() && !dir.isDirectory()) {
    log.warn(sm.getString("cgiServlet.expandCreateDirFail",dir.getAbsolutePath()));
    return;
  }
  try {
synchronized (expandFileLock) {
      if (f.exists()) {
        return;
      }
      if (!f.createNewFile()) {
        return;
      }
      FileOutputStream fos=new FileOutputStream(f);
      try {
        IOTools.flow(is,fos);
      }
  finally {
        try {
          is.close();
        }
 catch (        IOException e) {
          log.warn(sm.getString("cgiServlet.expandError"),e);
        }
        fos.close();
      }
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("cgiServlet.expandOk",srcPath,destPath));
      }
    }
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("cgiServlet.expandFail",srcPath,destPath),ioe);
    if (f.exists()) {
      if (!f.delete()) {
        log.warn(sm.getString("cgiServlet.expandDeleteFail",f.getAbsolutePath()));
      }
    }
  }
}

ID 2140=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIRunner#run()
Rmethod: java.io.BufferedReader#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Executes a CGI script with the desired environment, current working directory, and input/output streams <p> This implements the following CGI specification recommedations: </p> <UL> <LI> Servers SHOULD provide the "<code>query</code>" component of the script-URI as command-line arguments to scripts if it does not contain any unencoded "=" characters and the command-line arguments can be generated in an unambiguous manner. <LI> Servers SHOULD set the AUTH_TYPE metavariable to the value of the "<code>auth-scheme</code>" token of the "<code>Authorization</code>" if it was supplied as part of the request header.  See <code>getCGIEnvironment</code> method. <LI> Where applicable, servers SHOULD set the current working directory to the directory in which the script is located before invoking it. <LI> Server implementations SHOULD define their behavior for the following cases: <ul> <LI> <u>Allowed characters in pathInfo</u>:  This implementation does not allow ASCII NUL nor any character which cannot be URL-encoded according to internet standards; <LI> <u>Allowed characters in path segments</u>: This implementation does not allow non-terminal NULL segments in the the path -- IOExceptions may be thrown; <LI> <u>"<code>.</code>" and "<code>..</code>" path segments</u>: This implementation does not allow "<code>.</code>" and "<code>..</code>" in the the path, and such characters will result in an IOException being thrown (this should never happen since Tomcat normalises the requestURI before determining the contextPath, servletPath and pathInfo); <LI> <u>Implementation limitations</u>: This implementation does not impose any limitations except as documented above.  This implementation may be limited by the servlet container used to house this implementation. In particular, all the primary CGI variable values are derived either directly or indirectly from the container's implementation of the Servlet API methods. </ul> </UL>
 * @exception IOException if problems during reading/writing occur
 * @see java.lang.Runtime#exec(String command,String[] envp,File dir)
 */
protected void run() throws IOException {
  if (!isReady()) {
    throw new IOException(this.getClass().getName() + ": not ready to run.");
  }
  if (log.isDebugEnabled()) {
    log.debug("envp: [" + env + "], command: ["+ command+ "]");
  }
  if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) {
    throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected.  Not "+ "running CGI ["+ command+ "].");
  }
  Runtime rt=null;
  BufferedReader cgiHeaderReader=null;
  InputStream cgiOutput=null;
  BufferedReader commandsStdErr=null;
  Thread errReaderThread=null;
  BufferedOutputStream commandsStdIn=null;
  Process proc=null;
  int bufRead=-1;
  List<String> cmdAndArgs=new ArrayList<String>();
  if (cgiExecutable.length() != 0) {
    cmdAndArgs.add(cgiExecutable);
  }
  if (cgiExecutableArgs != null) {
    cmdAndArgs.addAll(cgiExecutableArgs);
  }
  cmdAndArgs.add(command);
  cmdAndArgs.addAll(params);
  try {
    rt=Runtime.getRuntime();
    proc=rt.exec(cmdAndArgs.toArray(new String[cmdAndArgs.size()]),hashToStringArray(env),wd);
    String sContentLength=env.get("CONTENT_LENGTH");
    if (!"".equals(sContentLength)) {
      commandsStdIn=new BufferedOutputStream(proc.getOutputStream());
      IOTools.flow(stdin,commandsStdIn);
      commandsStdIn.flush();
      commandsStdIn.close();
    }
    boolean isRunning=true;
    commandsStdErr=new BufferedReader(new InputStreamReader(proc.getErrorStream()));
    final BufferedReader stdErrRdr=commandsStdErr;
    errReaderThread=new Thread(){
      @Override public void run(){
        sendToLog(stdErrRdr);
      }
    }
;
    errReaderThread.start();
    InputStream cgiHeaderStream=new HTTPHeaderInputStream(proc.getInputStream());
    cgiHeaderReader=new BufferedReader(new InputStreamReader(cgiHeaderStream));
    boolean skipBody=false;
    while (isRunning) {
      try {
        String line=null;
        while (((line=cgiHeaderReader.readLine()) != null) && !("".equals(line))) {
          if (log.isTraceEnabled()) {
            log.trace("addHeader(\"" + line + "\")");
          }
          if (line.startsWith("HTTP")) {
            skipBody=setStatus(response,getSCFromHttpStatusLine(line));
          }
 else           if (line.indexOf(':') >= 0) {
            String header=line.substring(0,line.indexOf(':')).trim();
            String value=line.substring(line.indexOf(':') + 1).trim();
            if (header.equalsIgnoreCase("status")) {
              skipBody=setStatus(response,getSCFromCGIStatusHeader(value));
            }
 else {
              response.addHeader(header,value);
            }
          }
 else {
            log.info(sm.getString("cgiServlet.runBadHeader",line));
          }
        }
        byte[] bBuf=new byte[2048];
        OutputStream out=response.getOutputStream();
        cgiOutput=proc.getInputStream();
        try {
          while (!skipBody && (bufRead=cgiOutput.read(bBuf)) != -1) {
            if (log.isTraceEnabled()) {
              log.trace("output " + bufRead + " bytes of data");
            }
            out.write(bBuf,0,bufRead);
          }
        }
  finally {
          if (bufRead != -1) {
            while ((bufRead=cgiOutput.read(bBuf)) != -1) {
            }
          }
        }
        proc.exitValue();
        isRunning=false;
      }
 catch (      IllegalThreadStateException e) {
        try {
          Thread.sleep(500);
        }
 catch (        InterruptedException ignored) {
        }
      }
    }
  }
 catch (  IOException e) {
    log.warn(sm.getString("cgiServlet.runFail"),e);
    throw e;
  }
 finally {
    if (cgiHeaderReader != null) {
      try {
        cgiHeaderReader.close();
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("cgiServlet.runHeaderReaderFail"),ioe);
      }
    }
    if (cgiOutput != null) {
      try {
        cgiOutput.close();
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("cgiServlet.runOutputStreamFail"),ioe);
      }
    }
    if (errReaderThread != null) {
      try {
        errReaderThread.join(stderrTimeout);
      }
 catch (      InterruptedException e) {
        log.warn(sm.getString("cgiServlet.runReaderInterupt"));
      }
    }
    if (proc != null) {
      proc.destroy();
      proc=null;
    }
  }
}

ID 2141=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIRunner#run()
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Executes a CGI script with the desired environment, current working directory, and input/output streams <p> This implements the following CGI specification recommedations: </p> <UL> <LI> Servers SHOULD provide the "<code>query</code>" component of the script-URI as command-line arguments to scripts if it does not contain any unencoded "=" characters and the command-line arguments can be generated in an unambiguous manner. <LI> Servers SHOULD set the AUTH_TYPE metavariable to the value of the "<code>auth-scheme</code>" token of the "<code>Authorization</code>" if it was supplied as part of the request header.  See <code>getCGIEnvironment</code> method. <LI> Where applicable, servers SHOULD set the current working directory to the directory in which the script is located before invoking it. <LI> Server implementations SHOULD define their behavior for the following cases: <ul> <LI> <u>Allowed characters in pathInfo</u>:  This implementation does not allow ASCII NUL nor any character which cannot be URL-encoded according to internet standards; <LI> <u>Allowed characters in path segments</u>: This implementation does not allow non-terminal NULL segments in the the path -- IOExceptions may be thrown; <LI> <u>"<code>.</code>" and "<code>..</code>" path segments</u>: This implementation does not allow "<code>.</code>" and "<code>..</code>" in the the path, and such characters will result in an IOException being thrown (this should never happen since Tomcat normalises the requestURI before determining the contextPath, servletPath and pathInfo); <LI> <u>Implementation limitations</u>: This implementation does not impose any limitations except as documented above.  This implementation may be limited by the servlet container used to house this implementation. In particular, all the primary CGI variable values are derived either directly or indirectly from the container's implementation of the Servlet API methods. </ul> </UL>
 * @exception IOException if problems during reading/writing occur
 * @see java.lang.Runtime#exec(String command,String[] envp,File dir)
 */
protected void run() throws IOException {
  if (!isReady()) {
    throw new IOException(this.getClass().getName() + ": not ready to run.");
  }
  if (log.isDebugEnabled()) {
    log.debug("envp: [" + env + "], command: ["+ command+ "]");
  }
  if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) {
    throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected.  Not "+ "running CGI ["+ command+ "].");
  }
  Runtime rt=null;
  BufferedReader cgiHeaderReader=null;
  InputStream cgiOutput=null;
  BufferedReader commandsStdErr=null;
  Thread errReaderThread=null;
  BufferedOutputStream commandsStdIn=null;
  Process proc=null;
  int bufRead=-1;
  List<String> cmdAndArgs=new ArrayList<String>();
  if (cgiExecutable.length() != 0) {
    cmdAndArgs.add(cgiExecutable);
  }
  if (cgiExecutableArgs != null) {
    cmdAndArgs.addAll(cgiExecutableArgs);
  }
  cmdAndArgs.add(command);
  cmdAndArgs.addAll(params);
  try {
    rt=Runtime.getRuntime();
    proc=rt.exec(cmdAndArgs.toArray(new String[cmdAndArgs.size()]),hashToStringArray(env),wd);
    String sContentLength=env.get("CONTENT_LENGTH");
    if (!"".equals(sContentLength)) {
      commandsStdIn=new BufferedOutputStream(proc.getOutputStream());
      IOTools.flow(stdin,commandsStdIn);
      commandsStdIn.flush();
      commandsStdIn.close();
    }
    boolean isRunning=true;
    commandsStdErr=new BufferedReader(new InputStreamReader(proc.getErrorStream()));
    final BufferedReader stdErrRdr=commandsStdErr;
    errReaderThread=new Thread(){
      @Override public void run(){
        sendToLog(stdErrRdr);
      }
    }
;
    errReaderThread.start();
    InputStream cgiHeaderStream=new HTTPHeaderInputStream(proc.getInputStream());
    cgiHeaderReader=new BufferedReader(new InputStreamReader(cgiHeaderStream));
    boolean skipBody=false;
    while (isRunning) {
      try {
        String line=null;
        while (((line=cgiHeaderReader.readLine()) != null) && !("".equals(line))) {
          if (log.isTraceEnabled()) {
            log.trace("addHeader(\"" + line + "\")");
          }
          if (line.startsWith("HTTP")) {
            skipBody=setStatus(response,getSCFromHttpStatusLine(line));
          }
 else           if (line.indexOf(':') >= 0) {
            String header=line.substring(0,line.indexOf(':')).trim();
            String value=line.substring(line.indexOf(':') + 1).trim();
            if (header.equalsIgnoreCase("status")) {
              skipBody=setStatus(response,getSCFromCGIStatusHeader(value));
            }
 else {
              response.addHeader(header,value);
            }
          }
 else {
            log.info(sm.getString("cgiServlet.runBadHeader",line));
          }
        }
        byte[] bBuf=new byte[2048];
        OutputStream out=response.getOutputStream();
        cgiOutput=proc.getInputStream();
        try {
          while (!skipBody && (bufRead=cgiOutput.read(bBuf)) != -1) {
            if (log.isTraceEnabled()) {
              log.trace("output " + bufRead + " bytes of data");
            }
            out.write(bBuf,0,bufRead);
          }
        }
  finally {
          if (bufRead != -1) {
            while ((bufRead=cgiOutput.read(bBuf)) != -1) {
            }
          }
        }
        proc.exitValue();
        isRunning=false;
      }
 catch (      IllegalThreadStateException e) {
        try {
          Thread.sleep(500);
        }
 catch (        InterruptedException ignored) {
        }
      }
    }
  }
 catch (  IOException e) {
    log.warn(sm.getString("cgiServlet.runFail"),e);
    throw e;
  }
 finally {
    if (cgiHeaderReader != null) {
      try {
        cgiHeaderReader.close();
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("cgiServlet.runHeaderReaderFail"),ioe);
      }
    }
    if (cgiOutput != null) {
      try {
        cgiOutput.close();
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("cgiServlet.runOutputStreamFail"),ioe);
      }
    }
    if (errReaderThread != null) {
      try {
        errReaderThread.join(stderrTimeout);
      }
 catch (      InterruptedException e) {
        log.warn(sm.getString("cgiServlet.runReaderInterupt"));
      }
    }
    if (proc != null) {
      proc.destroy();
      proc=null;
    }
  }
}

ID 2142=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIRunner#run()
Rmethod: java.lang.Thread#join(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Executes a CGI script with the desired environment, current working directory, and input/output streams <p> This implements the following CGI specification recommedations: </p> <UL> <LI> Servers SHOULD provide the "<code>query</code>" component of the script-URI as command-line arguments to scripts if it does not contain any unencoded "=" characters and the command-line arguments can be generated in an unambiguous manner. <LI> Servers SHOULD set the AUTH_TYPE metavariable to the value of the "<code>auth-scheme</code>" token of the "<code>Authorization</code>" if it was supplied as part of the request header.  See <code>getCGIEnvironment</code> method. <LI> Where applicable, servers SHOULD set the current working directory to the directory in which the script is located before invoking it. <LI> Server implementations SHOULD define their behavior for the following cases: <ul> <LI> <u>Allowed characters in pathInfo</u>:  This implementation does not allow ASCII NUL nor any character which cannot be URL-encoded according to internet standards; <LI> <u>Allowed characters in path segments</u>: This implementation does not allow non-terminal NULL segments in the the path -- IOExceptions may be thrown; <LI> <u>"<code>.</code>" and "<code>..</code>" path segments</u>: This implementation does not allow "<code>.</code>" and "<code>..</code>" in the the path, and such characters will result in an IOException being thrown (this should never happen since Tomcat normalises the requestURI before determining the contextPath, servletPath and pathInfo); <LI> <u>Implementation limitations</u>: This implementation does not impose any limitations except as documented above.  This implementation may be limited by the servlet container used to house this implementation. In particular, all the primary CGI variable values are derived either directly or indirectly from the container's implementation of the Servlet API methods. </ul> </UL>
 * @exception IOException if problems during reading/writing occur
 * @see java.lang.Runtime#exec(String command,String[] envp,File dir)
 */
protected void run() throws IOException {
  if (!isReady()) {
    throw new IOException(this.getClass().getName() + ": not ready to run.");
  }
  if (log.isDebugEnabled()) {
    log.debug("envp: [" + env + "], command: ["+ command+ "]");
  }
  if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) {
    throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected.  Not "+ "running CGI ["+ command+ "].");
  }
  Runtime rt=null;
  BufferedReader cgiHeaderReader=null;
  InputStream cgiOutput=null;
  BufferedReader commandsStdErr=null;
  Thread errReaderThread=null;
  BufferedOutputStream commandsStdIn=null;
  Process proc=null;
  int bufRead=-1;
  List<String> cmdAndArgs=new ArrayList<String>();
  if (cgiExecutable.length() != 0) {
    cmdAndArgs.add(cgiExecutable);
  }
  if (cgiExecutableArgs != null) {
    cmdAndArgs.addAll(cgiExecutableArgs);
  }
  cmdAndArgs.add(command);
  cmdAndArgs.addAll(params);
  try {
    rt=Runtime.getRuntime();
    proc=rt.exec(cmdAndArgs.toArray(new String[cmdAndArgs.size()]),hashToStringArray(env),wd);
    String sContentLength=env.get("CONTENT_LENGTH");
    if (!"".equals(sContentLength)) {
      commandsStdIn=new BufferedOutputStream(proc.getOutputStream());
      IOTools.flow(stdin,commandsStdIn);
      commandsStdIn.flush();
      commandsStdIn.close();
    }
    boolean isRunning=true;
    commandsStdErr=new BufferedReader(new InputStreamReader(proc.getErrorStream()));
    final BufferedReader stdErrRdr=commandsStdErr;
    errReaderThread=new Thread(){
      @Override public void run(){
        sendToLog(stdErrRdr);
      }
    }
;
    errReaderThread.start();
    InputStream cgiHeaderStream=new HTTPHeaderInputStream(proc.getInputStream());
    cgiHeaderReader=new BufferedReader(new InputStreamReader(cgiHeaderStream));
    boolean skipBody=false;
    while (isRunning) {
      try {
        String line=null;
        while (((line=cgiHeaderReader.readLine()) != null) && !("".equals(line))) {
          if (log.isTraceEnabled()) {
            log.trace("addHeader(\"" + line + "\")");
          }
          if (line.startsWith("HTTP")) {
            skipBody=setStatus(response,getSCFromHttpStatusLine(line));
          }
 else           if (line.indexOf(':') >= 0) {
            String header=line.substring(0,line.indexOf(':')).trim();
            String value=line.substring(line.indexOf(':') + 1).trim();
            if (header.equalsIgnoreCase("status")) {
              skipBody=setStatus(response,getSCFromCGIStatusHeader(value));
            }
 else {
              response.addHeader(header,value);
            }
          }
 else {
            log.info(sm.getString("cgiServlet.runBadHeader",line));
          }
        }
        byte[] bBuf=new byte[2048];
        OutputStream out=response.getOutputStream();
        cgiOutput=proc.getInputStream();
        try {
          while (!skipBody && (bufRead=cgiOutput.read(bBuf)) != -1) {
            if (log.isTraceEnabled()) {
              log.trace("output " + bufRead + " bytes of data");
            }
            out.write(bBuf,0,bufRead);
          }
        }
  finally {
          if (bufRead != -1) {
            while ((bufRead=cgiOutput.read(bBuf)) != -1) {
            }
          }
        }
        proc.exitValue();
        isRunning=false;
      }
 catch (      IllegalThreadStateException e) {
        try {
          Thread.sleep(500);
        }
 catch (        InterruptedException ignored) {
        }
      }
    }
  }
 catch (  IOException e) {
    log.warn(sm.getString("cgiServlet.runFail"),e);
    throw e;
  }
 finally {
    if (cgiHeaderReader != null) {
      try {
        cgiHeaderReader.close();
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("cgiServlet.runHeaderReaderFail"),ioe);
      }
    }
    if (cgiOutput != null) {
      try {
        cgiOutput.close();
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("cgiServlet.runOutputStreamFail"),ioe);
      }
    }
    if (errReaderThread != null) {
      try {
        errReaderThread.join(stderrTimeout);
      }
 catch (      InterruptedException e) {
        log.warn(sm.getString("cgiServlet.runReaderInterupt"));
      }
    }
    if (proc != null) {
      proc.destroy();
      proc=null;
    }
  }
}

ID 2143=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIRunner#getSCFromHttpStatusLine(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parses the Status-Line and extracts the status code.
 * @param line The HTTP Status-Line (RFC2616, section 6.1)
 * @return The extracted status code or the code representing aninternal error if a valid status code cannot be extracted.
 */
private int getSCFromHttpStatusLine(String line){
  int statusStart=line.indexOf(' ') + 1;
  if (statusStart < 1 || line.length() < statusStart + 3) {
    log.warn(sm.getString("cgiServlet.runInvalidStatus",line));
    return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
  }
  String status=line.substring(statusStart,statusStart + 3);
  int statusCode;
  try {
    statusCode=Integer.parseInt(status);
  }
 catch (  NumberFormatException nfe) {
    log.warn(sm.getString("cgiServlet.runInvalidStatus",status));
    return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
  }
  return statusCode;
}

ID 2144=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIRunner#getSCFromCGIStatusHeader(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parses the CGI Status Header value and extracts the status code.
 * @param value The CGI Status value of the form <code>digit digit digit SP reason-phrase</code>
 * @return The extracted status code or the code representing aninternal error if a valid status code cannot be extracted.
 */
private int getSCFromCGIStatusHeader(String value){
  if (value.length() < 3) {
    log.warn(sm.getString("cgiServlet.runInvalidStatus",value));
    return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
  }
  String status=value.substring(0,3);
  int statusCode;
  try {
    statusCode=Integer.parseInt(status);
  }
 catch (  NumberFormatException nfe) {
    log.warn(sm.getString("cgiServlet.runInvalidStatus",status));
    return HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
  }
  return statusCode;
}

ID 2145=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIRunner#sendToLog(java.io.BufferedReader)
Rmethod: java.io.BufferedReader#readLine()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void sendToLog(BufferedReader rdr){
  String line=null;
  int lineCount=0;
  try {
    while ((line=rdr.readLine()) != null) {
      log.warn(sm.getString("cgiServlet.runStdErr",line));
      lineCount++;
    }
  }
 catch (  IOException e) {
    log.warn(sm.getString("cgiServlet.runStdErrFail"),e);
  }
 finally {
    try {
      rdr.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("cgiServlet.runStdErrFail"),e);
    }
  }
  if (lineCount > 0) {
    log.warn(sm.getString("cgiServlet.runStdErrCount",Integer.valueOf(lineCount)));
  }
}

ID 2146=========================================================================type: 1
Method:org.apache.catalina.servlets.CGIRunner#sendToLog(java.io.BufferedReader)
Rmethod: java.io.BufferedReader#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void sendToLog(BufferedReader rdr){
  String line=null;
  int lineCount=0;
  try {
    while ((line=rdr.readLine()) != null) {
      log.warn(sm.getString("cgiServlet.runStdErr",line));
      lineCount++;
    }
  }
 catch (  IOException e) {
    log.warn(sm.getString("cgiServlet.runStdErrFail"),e);
  }
 finally {
    try {
      rdr.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("cgiServlet.runStdErrFail"),e);
    }
  }
  if (lineCount > 0) {
    log.warn(sm.getString("cgiServlet.runStdErrCount",Integer.valueOf(lineCount)));
  }
}

ID 2149=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#init()
Rmethod: javax.naming.InitialContext#InitialContext()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Initialize this servlet.
 */
@Override public void init() throws ServletException {
  if (getServletConfig().getInitParameter("debug") != null)   debug=Integer.parseInt(getServletConfig().getInitParameter("debug"));
  if (getServletConfig().getInitParameter("input") != null)   input=Integer.parseInt(getServletConfig().getInitParameter("input"));
  if (getServletConfig().getInitParameter("output") != null)   output=Integer.parseInt(getServletConfig().getInitParameter("output"));
  listings=Boolean.parseBoolean(getServletConfig().getInitParameter("listings"));
  if (getServletConfig().getInitParameter("readonly") != null)   readOnly=Boolean.parseBoolean(getServletConfig().getInitParameter("readonly"));
  if (getServletConfig().getInitParameter("sendfileSize") != null)   sendfileSize=Integer.parseInt(getServletConfig().getInitParameter("sendfileSize")) * 1024;
  fileEncoding=getServletConfig().getInitParameter("fileEncoding");
  globalXsltFile=getServletConfig().getInitParameter("globalXsltFile");
  contextXsltFile=getServletConfig().getInitParameter("contextXsltFile");
  localXsltFile=getServletConfig().getInitParameter("localXsltFile");
  readmeFile=getServletConfig().getInitParameter("readmeFile");
  if (getServletConfig().getInitParameter("useAcceptRanges") != null)   useAcceptRanges=Boolean.parseBoolean(getServletConfig().getInitParameter("useAcceptRanges"));
  if (input < 256)   input=256;
  if (output < 256)   output=256;
  if (debug > 0) {
    log("DefaultServlet.init:  input buffer size=" + input + ", output buffer size="+ output);
  }
  resources=(ProxyDirContext)getServletContext().getAttribute(Globals.RESOURCES_ATTR);
  if (resources == null) {
    try {
      resources=(ProxyDirContext)new InitialContext().lookup(RESOURCES_JNDI_NAME);
    }
 catch (    NamingException e) {
      throw new ServletException("No resources",e);
    }
  }
  if (resources == null) {
    throw new UnavailableException("No resources");
  }
  if (getServletConfig().getInitParameter("showServerInfo") != null) {
    showServerInfo=Boolean.parseBoolean(getServletConfig().getInitParameter("showServerInfo"));
  }
}

ID 2150=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#init()
Rmethod: javax.naming.InitialContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Initialize this servlet.
 */
@Override public void init() throws ServletException {
  if (getServletConfig().getInitParameter("debug") != null)   debug=Integer.parseInt(getServletConfig().getInitParameter("debug"));
  if (getServletConfig().getInitParameter("input") != null)   input=Integer.parseInt(getServletConfig().getInitParameter("input"));
  if (getServletConfig().getInitParameter("output") != null)   output=Integer.parseInt(getServletConfig().getInitParameter("output"));
  listings=Boolean.parseBoolean(getServletConfig().getInitParameter("listings"));
  if (getServletConfig().getInitParameter("readonly") != null)   readOnly=Boolean.parseBoolean(getServletConfig().getInitParameter("readonly"));
  if (getServletConfig().getInitParameter("sendfileSize") != null)   sendfileSize=Integer.parseInt(getServletConfig().getInitParameter("sendfileSize")) * 1024;
  fileEncoding=getServletConfig().getInitParameter("fileEncoding");
  globalXsltFile=getServletConfig().getInitParameter("globalXsltFile");
  contextXsltFile=getServletConfig().getInitParameter("contextXsltFile");
  localXsltFile=getServletConfig().getInitParameter("localXsltFile");
  readmeFile=getServletConfig().getInitParameter("readmeFile");
  if (getServletConfig().getInitParameter("useAcceptRanges") != null)   useAcceptRanges=Boolean.parseBoolean(getServletConfig().getInitParameter("useAcceptRanges"));
  if (input < 256)   input=256;
  if (output < 256)   output=256;
  if (debug > 0) {
    log("DefaultServlet.init:  input buffer size=" + input + ", output buffer size="+ output);
  }
  resources=(ProxyDirContext)getServletContext().getAttribute(Globals.RESOURCES_ATTR);
  if (resources == null) {
    try {
      resources=(ProxyDirContext)new InitialContext().lookup(RESOURCES_JNDI_NAME);
    }
 catch (    NamingException e) {
      throw new ServletException("No resources",e);
    }
  }
  if (resources == null) {
    throw new UnavailableException("No resources");
  }
  if (getServletConfig().getInitParameter("showServerInfo") != null) {
    showServerInfo=Boolean.parseBoolean(getServletConfig().getInitParameter("showServerInfo"));
  }
}

ID 2158=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#doPut(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Process a PUT request for the specified resource.
 * @param req The servlet request we are processing
 * @param resp The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override protected void doPut(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(HttpServletResponse.SC_FORBIDDEN);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  boolean result=true;
  File contentFile=null;
  Range range=parseContentRange(req,resp);
  InputStream resourceInputStream=null;
  if (range != null) {
    contentFile=executePartialPut(req,range,path);
    resourceInputStream=new FileInputStream(contentFile);
  }
 else {
    resourceInputStream=req.getInputStream();
  }
  try {
    Resource newResource=new Resource(resourceInputStream);
    if (exists) {
      resources.rebind(path,newResource);
    }
 else {
      resources.bind(path,newResource);
    }
  }
 catch (  NamingException e) {
    result=false;
  }
  if (result) {
    if (exists) {
      resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
    }
 else {
      resp.setStatus(HttpServletResponse.SC_CREATED);
    }
  }
 else {
    resp.sendError(HttpServletResponse.SC_CONFLICT);
  }
}

ID 2163=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#doPut(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#rebind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Process a PUT request for the specified resource.
 * @param req The servlet request we are processing
 * @param resp The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override protected void doPut(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(HttpServletResponse.SC_FORBIDDEN);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  boolean result=true;
  File contentFile=null;
  Range range=parseContentRange(req,resp);
  InputStream resourceInputStream=null;
  if (range != null) {
    contentFile=executePartialPut(req,range,path);
    resourceInputStream=new FileInputStream(contentFile);
  }
 else {
    resourceInputStream=req.getInputStream();
  }
  try {
    Resource newResource=new Resource(resourceInputStream);
    if (exists) {
      resources.rebind(path,newResource);
    }
 else {
      resources.bind(path,newResource);
    }
  }
 catch (  NamingException e) {
    result=false;
  }
  if (result) {
    if (exists) {
      resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
    }
 else {
      resp.setStatus(HttpServletResponse.SC_CREATED);
    }
  }
 else {
    resp.sendError(HttpServletResponse.SC_CONFLICT);
  }
}

ID 2164=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#doPut(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Process a PUT request for the specified resource.
 * @param req The servlet request we are processing
 * @param resp The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override protected void doPut(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(HttpServletResponse.SC_FORBIDDEN);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  boolean result=true;
  File contentFile=null;
  Range range=parseContentRange(req,resp);
  InputStream resourceInputStream=null;
  if (range != null) {
    contentFile=executePartialPut(req,range,path);
    resourceInputStream=new FileInputStream(contentFile);
  }
 else {
    resourceInputStream=req.getInputStream();
  }
  try {
    Resource newResource=new Resource(resourceInputStream);
    if (exists) {
      resources.rebind(path,newResource);
    }
 else {
      resources.bind(path,newResource);
    }
  }
 catch (  NamingException e) {
    result=false;
  }
  if (result) {
    if (exists) {
      resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
    }
 else {
      resp.setStatus(HttpServletResponse.SC_CREATED);
    }
  }
 else {
    resp.sendError(HttpServletResponse.SC_CONFLICT);
  }
}

ID 2177=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#doDelete(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Process a DELETE request for the specified resource.
 * @param req The servlet request we are processing
 * @param resp The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override protected void doDelete(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(HttpServletResponse.SC_FORBIDDEN);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (exists) {
    boolean result=true;
    try {
      resources.unbind(path);
    }
 catch (    NamingException e) {
      result=false;
    }
    if (result) {
      resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
    }
 else {
      resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
  }
 else {
    resp.sendError(HttpServletResponse.SC_NOT_FOUND);
  }
}

ID 2178=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#doDelete(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Process a DELETE request for the specified resource.
 * @param req The servlet request we are processing
 * @param resp The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override protected void doDelete(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(HttpServletResponse.SC_FORBIDDEN);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (exists) {
    boolean result=true;
    try {
      resources.unbind(path);
    }
 catch (    NamingException e) {
      result=false;
    }
    if (result) {
      resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
    }
 else {
      resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
    }
  }
 else {
    resp.sendError(HttpServletResponse.SC_NOT_FOUND);
  }
}

ID 2196=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#parseContentRange(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parse the content-range header.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @return Range
 */
protected Range parseContentRange(HttpServletRequest request,HttpServletResponse response) throws IOException {
  String rangeHeader=request.getHeader("Content-Range");
  if (rangeHeader == null)   return null;
  if (!rangeHeader.startsWith("bytes")) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return null;
  }
  rangeHeader=rangeHeader.substring(6).trim();
  int dashPos=rangeHeader.indexOf('-');
  int slashPos=rangeHeader.indexOf('/');
  if (dashPos == -1) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return null;
  }
  if (slashPos == -1) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return null;
  }
  Range range=new Range();
  try {
    range.start=Long.parseLong(rangeHeader.substring(0,dashPos));
    range.end=Long.parseLong(rangeHeader.substring(dashPos + 1,slashPos));
    range.length=Long.parseLong(rangeHeader.substring(slashPos + 1,rangeHeader.length()));
  }
 catch (  NumberFormatException e) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return null;
  }
  if (!range.validate()) {
    response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return null;
  }
  return range;
}

ID 2199=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#parseRange(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, org.apache.naming.resources.ResourceAttributes)
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parse the range header.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @return Vector of ranges
 */
protected ArrayList<Range> parseRange(HttpServletRequest request,HttpServletResponse response,ResourceAttributes resourceAttributes) throws IOException {
  String headerValue=request.getHeader("If-Range");
  if (headerValue != null) {
    long headerValueTime=(-1L);
    try {
      headerValueTime=request.getDateHeader("If-Range");
    }
 catch (    IllegalArgumentException e) {
    }
    String eTag=resourceAttributes.getETag();
    long lastModified=resourceAttributes.getLastModified();
    if (headerValueTime == (-1L)) {
      if (!eTag.equals(headerValue.trim()))       return FULL;
    }
 else {
      if (lastModified > (headerValueTime + 1000))       return FULL;
    }
  }
  long fileLength=resourceAttributes.getContentLength();
  if (fileLength == 0)   return null;
  String rangeHeader=request.getHeader("Range");
  if (rangeHeader == null)   return null;
  if (!rangeHeader.startsWith("bytes")) {
    response.addHeader("Content-Range","bytes */" + fileLength);
    response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
    return null;
  }
  rangeHeader=rangeHeader.substring(6);
  ArrayList<Range> result=new ArrayList<Range>();
  StringTokenizer commaTokenizer=new StringTokenizer(rangeHeader,",");
  while (commaTokenizer.hasMoreTokens()) {
    String rangeDefinition=commaTokenizer.nextToken().trim();
    Range currentRange=new Range();
    currentRange.length=fileLength;
    int dashPos=rangeDefinition.indexOf('-');
    if (dashPos == -1) {
      response.addHeader("Content-Range","bytes */" + fileLength);
      response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
      return null;
    }
    if (dashPos == 0) {
      try {
        long offset=Long.parseLong(rangeDefinition);
        currentRange.start=fileLength + offset;
        currentRange.end=fileLength - 1;
      }
 catch (      NumberFormatException e) {
        response.addHeader("Content-Range","bytes */" + fileLength);
        response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
        return null;
      }
    }
 else {
      try {
        currentRange.start=Long.parseLong(rangeDefinition.substring(0,dashPos));
        if (dashPos < rangeDefinition.length() - 1)         currentRange.end=Long.parseLong(rangeDefinition.substring(dashPos + 1,rangeDefinition.length()));
 else         currentRange.end=fileLength - 1;
      }
 catch (      NumberFormatException e) {
        response.addHeader("Content-Range","bytes */" + fileLength);
        response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
        return null;
      }
    }
    if (!currentRange.validate()) {
      response.addHeader("Content-Range","bytes */" + fileLength);
      response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
      return null;
    }
    result.add(currentRange);
  }
  return result;
}

ID 2205=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#renderXml(java.lang.String, org.apache.naming.resources.CacheEntry, javax.xml.transform.Source)
Rmethod: org.apache.naming.resources.ProxyDirContext#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Return an InputStream to an HTML representation of the contents of this directory.
 * @param contextPath Context path to which our internal paths arerelative
 */
protected InputStream renderXml(String contextPath,CacheEntry cacheEntry,Source xsltSource) throws IOException, ServletException {
  StringBuilder sb=new StringBuilder();
  sb.append("<?xml version=\"1.0\"?>");
  sb.append("<listing ");
  sb.append(" contextPath='");
  sb.append(contextPath);
  sb.append("'");
  sb.append(" directory='");
  sb.append(cacheEntry.name);
  sb.append("' ");
  sb.append(" hasParent='").append(!cacheEntry.name.equals("/"));
  sb.append("'>");
  sb.append("<entries>");
  try {
    NamingEnumeration<NameClassPair> enumeration=resources.list(cacheEntry.name);
    String rewrittenContextPath=rewriteUrl(contextPath);
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String resourceName=ncPair.getName();
      String trimmed=resourceName;
      if (trimmed.equalsIgnoreCase("WEB-INF") || trimmed.equalsIgnoreCase("META-INF") || trimmed.equalsIgnoreCase(localXsltFile))       continue;
      if ((cacheEntry.name + trimmed).equals(contextXsltFile))       continue;
      CacheEntry childCacheEntry=resources.lookupCache(cacheEntry.name + resourceName);
      if (!childCacheEntry.exists) {
        continue;
      }
      sb.append("<entry");
      sb.append(" type='").append((childCacheEntry.context != null) ? "dir" : "file").append("'");
      sb.append(" urlPath='").append(rewrittenContextPath).append(rewriteUrl(cacheEntry.name + resourceName)).append((childCacheEntry.context != null) ? "/" : "").append("'");
      if (childCacheEntry.resource != null) {
        sb.append(" size='").append(renderSize(childCacheEntry.attributes.getContentLength())).append("'");
      }
      sb.append(" date='").append(childCacheEntry.attributes.getLastModifiedHttp()).append("'");
      sb.append(">");
      sb.append(RequestUtil.filter(trimmed));
      if (childCacheEntry.context != null)       sb.append("/");
      sb.append("</entry>");
    }
  }
 catch (  NamingException e) {
    throw new ServletException("Error accessing resource",e);
  }
  sb.append("</entries>");
  String readme=getReadme(cacheEntry.context);
  if (readme != null) {
    sb.append("<readme><![CDATA[");
    sb.append(readme);
    sb.append("]]></readme>");
  }
  sb.append("</listing>");
  ClassLoader original;
  if (Globals.IS_SECURITY_ENABLED) {
    PrivilegedGetTccl pa=new PrivilegedGetTccl();
    original=AccessController.doPrivileged(pa);
  }
 else {
    original=Thread.currentThread().getContextClassLoader();
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(DefaultServlet.class.getClassLoader());
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(DefaultServlet.class.getClassLoader());
    }
    TransformerFactory tFactory=TransformerFactory.newInstance();
    Source xmlSource=new StreamSource(new StringReader(sb.toString()));
    Transformer transformer=tFactory.newTransformer(xsltSource);
    ByteArrayOutputStream stream=new ByteArrayOutputStream();
    OutputStreamWriter osWriter=new OutputStreamWriter(stream,"UTF8");
    StreamResult out=new StreamResult(osWriter);
    transformer.transform(xmlSource,out);
    osWriter.flush();
    return (new ByteArrayInputStream(stream.toByteArray()));
  }
 catch (  TransformerException e) {
    throw new ServletException("XSL transformer error",e);
  }
 finally {
    if (Globals.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(original);
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(original);
    }
  }
}

ID 2208=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#renderXml(java.lang.String, org.apache.naming.resources.CacheEntry, javax.xml.transform.Source)
Rmethod: javax.xml.transform.TransformerFactory#newTransformer(javax.xml.transform.Source)
parentException: TransformerException 
thrown: TransformerConfigurationException
exception comment: /** 
 * Create a new <code>TransformerConfigurationException</code> with the <code>String </code> specified as an error message.
 * @param msg The error message for the exception.
 */

block: 
/** 
 * Return an InputStream to an HTML representation of the contents of this directory.
 * @param contextPath Context path to which our internal paths arerelative
 */
protected InputStream renderXml(String contextPath,CacheEntry cacheEntry,Source xsltSource) throws IOException, ServletException {
  StringBuilder sb=new StringBuilder();
  sb.append("<?xml version=\"1.0\"?>");
  sb.append("<listing ");
  sb.append(" contextPath='");
  sb.append(contextPath);
  sb.append("'");
  sb.append(" directory='");
  sb.append(cacheEntry.name);
  sb.append("' ");
  sb.append(" hasParent='").append(!cacheEntry.name.equals("/"));
  sb.append("'>");
  sb.append("<entries>");
  try {
    NamingEnumeration<NameClassPair> enumeration=resources.list(cacheEntry.name);
    String rewrittenContextPath=rewriteUrl(contextPath);
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String resourceName=ncPair.getName();
      String trimmed=resourceName;
      if (trimmed.equalsIgnoreCase("WEB-INF") || trimmed.equalsIgnoreCase("META-INF") || trimmed.equalsIgnoreCase(localXsltFile))       continue;
      if ((cacheEntry.name + trimmed).equals(contextXsltFile))       continue;
      CacheEntry childCacheEntry=resources.lookupCache(cacheEntry.name + resourceName);
      if (!childCacheEntry.exists) {
        continue;
      }
      sb.append("<entry");
      sb.append(" type='").append((childCacheEntry.context != null) ? "dir" : "file").append("'");
      sb.append(" urlPath='").append(rewrittenContextPath).append(rewriteUrl(cacheEntry.name + resourceName)).append((childCacheEntry.context != null) ? "/" : "").append("'");
      if (childCacheEntry.resource != null) {
        sb.append(" size='").append(renderSize(childCacheEntry.attributes.getContentLength())).append("'");
      }
      sb.append(" date='").append(childCacheEntry.attributes.getLastModifiedHttp()).append("'");
      sb.append(">");
      sb.append(RequestUtil.filter(trimmed));
      if (childCacheEntry.context != null)       sb.append("/");
      sb.append("</entry>");
    }
  }
 catch (  NamingException e) {
    throw new ServletException("Error accessing resource",e);
  }
  sb.append("</entries>");
  String readme=getReadme(cacheEntry.context);
  if (readme != null) {
    sb.append("<readme><![CDATA[");
    sb.append(readme);
    sb.append("]]></readme>");
  }
  sb.append("</listing>");
  ClassLoader original;
  if (Globals.IS_SECURITY_ENABLED) {
    PrivilegedGetTccl pa=new PrivilegedGetTccl();
    original=AccessController.doPrivileged(pa);
  }
 else {
    original=Thread.currentThread().getContextClassLoader();
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(DefaultServlet.class.getClassLoader());
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(DefaultServlet.class.getClassLoader());
    }
    TransformerFactory tFactory=TransformerFactory.newInstance();
    Source xmlSource=new StreamSource(new StringReader(sb.toString()));
    Transformer transformer=tFactory.newTransformer(xsltSource);
    ByteArrayOutputStream stream=new ByteArrayOutputStream();
    OutputStreamWriter osWriter=new OutputStreamWriter(stream,"UTF8");
    StreamResult out=new StreamResult(osWriter);
    transformer.transform(xmlSource,out);
    osWriter.flush();
    return (new ByteArrayInputStream(stream.toByteArray()));
  }
 catch (  TransformerException e) {
    throw new ServletException("XSL transformer error",e);
  }
 finally {
    if (Globals.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(original);
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(original);
    }
  }
}

ID 2210=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#renderXml(java.lang.String, org.apache.naming.resources.CacheEntry, javax.xml.transform.Source)
Rmethod: javax.xml.transform.Transformer#transform(javax.xml.transform.Source, javax.xml.transform.Result)
parentException: 
thrown: TransformerException
exception comment: /** 
 * Method getLocator retrieves an instance of a SourceLocator object that specifies where an error occurred.
 * @return A SourceLocator object, or null if none was specified.
 */

block: 
/** 
 * Return an InputStream to an HTML representation of the contents of this directory.
 * @param contextPath Context path to which our internal paths arerelative
 */
protected InputStream renderXml(String contextPath,CacheEntry cacheEntry,Source xsltSource) throws IOException, ServletException {
  StringBuilder sb=new StringBuilder();
  sb.append("<?xml version=\"1.0\"?>");
  sb.append("<listing ");
  sb.append(" contextPath='");
  sb.append(contextPath);
  sb.append("'");
  sb.append(" directory='");
  sb.append(cacheEntry.name);
  sb.append("' ");
  sb.append(" hasParent='").append(!cacheEntry.name.equals("/"));
  sb.append("'>");
  sb.append("<entries>");
  try {
    NamingEnumeration<NameClassPair> enumeration=resources.list(cacheEntry.name);
    String rewrittenContextPath=rewriteUrl(contextPath);
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String resourceName=ncPair.getName();
      String trimmed=resourceName;
      if (trimmed.equalsIgnoreCase("WEB-INF") || trimmed.equalsIgnoreCase("META-INF") || trimmed.equalsIgnoreCase(localXsltFile))       continue;
      if ((cacheEntry.name + trimmed).equals(contextXsltFile))       continue;
      CacheEntry childCacheEntry=resources.lookupCache(cacheEntry.name + resourceName);
      if (!childCacheEntry.exists) {
        continue;
      }
      sb.append("<entry");
      sb.append(" type='").append((childCacheEntry.context != null) ? "dir" : "file").append("'");
      sb.append(" urlPath='").append(rewrittenContextPath).append(rewriteUrl(cacheEntry.name + resourceName)).append((childCacheEntry.context != null) ? "/" : "").append("'");
      if (childCacheEntry.resource != null) {
        sb.append(" size='").append(renderSize(childCacheEntry.attributes.getContentLength())).append("'");
      }
      sb.append(" date='").append(childCacheEntry.attributes.getLastModifiedHttp()).append("'");
      sb.append(">");
      sb.append(RequestUtil.filter(trimmed));
      if (childCacheEntry.context != null)       sb.append("/");
      sb.append("</entry>");
    }
  }
 catch (  NamingException e) {
    throw new ServletException("Error accessing resource",e);
  }
  sb.append("</entries>");
  String readme=getReadme(cacheEntry.context);
  if (readme != null) {
    sb.append("<readme><![CDATA[");
    sb.append(readme);
    sb.append("]]></readme>");
  }
  sb.append("</listing>");
  ClassLoader original;
  if (Globals.IS_SECURITY_ENABLED) {
    PrivilegedGetTccl pa=new PrivilegedGetTccl();
    original=AccessController.doPrivileged(pa);
  }
 else {
    original=Thread.currentThread().getContextClassLoader();
  }
  try {
    if (Globals.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(DefaultServlet.class.getClassLoader());
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(DefaultServlet.class.getClassLoader());
    }
    TransformerFactory tFactory=TransformerFactory.newInstance();
    Source xmlSource=new StreamSource(new StringReader(sb.toString()));
    Transformer transformer=tFactory.newTransformer(xsltSource);
    ByteArrayOutputStream stream=new ByteArrayOutputStream();
    OutputStreamWriter osWriter=new OutputStreamWriter(stream,"UTF8");
    StreamResult out=new StreamResult(osWriter);
    transformer.transform(xmlSource,out);
    osWriter.flush();
    return (new ByteArrayInputStream(stream.toByteArray()));
  }
 catch (  TransformerException e) {
    throw new ServletException("XSL transformer error",e);
  }
 finally {
    if (Globals.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(original);
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(original);
    }
  }
}

ID 2213=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#renderHtml(java.lang.String, org.apache.naming.resources.CacheEntry)
Rmethod: org.apache.naming.resources.ProxyDirContext#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Return an InputStream to an HTML representation of the contents of this directory.
 * @param contextPath Context path to which our internal paths arerelative
 */
protected InputStream renderHtml(String contextPath,CacheEntry cacheEntry) throws IOException, ServletException {
  String name=cacheEntry.name;
  ByteArrayOutputStream stream=new ByteArrayOutputStream();
  OutputStreamWriter osWriter=new OutputStreamWriter(stream,"UTF8");
  PrintWriter writer=new PrintWriter(osWriter);
  StringBuilder sb=new StringBuilder();
  String rewrittenContextPath=rewriteUrl(contextPath);
  sb.append("<html>\r\n");
  sb.append("<head>\r\n");
  sb.append("<title>");
  sb.append(sm.getString("directory.title",name));
  sb.append("</title>\r\n");
  sb.append("<STYLE><!--");
  sb.append(org.apache.catalina.util.TomcatCSS.TOMCAT_CSS);
  sb.append("--></STYLE> ");
  sb.append("</head>\r\n");
  sb.append("<body>");
  sb.append("<h1>");
  sb.append(sm.getString("directory.title",name));
  String parentDirectory=name;
  if (parentDirectory.endsWith("/")) {
    parentDirectory=parentDirectory.substring(0,parentDirectory.length() - 1);
  }
  int slash=parentDirectory.lastIndexOf('/');
  if (slash >= 0) {
    String parent=name.substring(0,slash);
    sb.append(" - <a href=\"");
    sb.append(rewrittenContextPath);
    if (parent.equals(""))     parent="/";
    sb.append(rewriteUrl(parent));
    if (!parent.endsWith("/"))     sb.append("/");
    sb.append("\">");
    sb.append("<b>");
    sb.append(sm.getString("directory.parent",parent));
    sb.append("</b>");
    sb.append("</a>");
  }
  sb.append("</h1>");
  sb.append("<HR size=\"1\" noshade=\"noshade\">");
  sb.append("<table width=\"100%\" cellspacing=\"0\"" + " cellpadding=\"5\" align=\"center\">\r\n");
  sb.append("<tr>\r\n");
  sb.append("<td align=\"left\"><font size=\"+1\"><strong>");
  sb.append(sm.getString("directory.filename"));
  sb.append("</strong></font></td>\r\n");
  sb.append("<td align=\"center\"><font size=\"+1\"><strong>");
  sb.append(sm.getString("directory.size"));
  sb.append("</strong></font></td>\r\n");
  sb.append("<td align=\"right\"><font size=\"+1\"><strong>");
  sb.append(sm.getString("directory.lastModified"));
  sb.append("</strong></font></td>\r\n");
  sb.append("</tr>");
  try {
    NamingEnumeration<NameClassPair> enumeration=resources.list(cacheEntry.name);
    boolean shade=false;
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String resourceName=ncPair.getName();
      String trimmed=resourceName;
      if (trimmed.equalsIgnoreCase("WEB-INF") || trimmed.equalsIgnoreCase("META-INF"))       continue;
      CacheEntry childCacheEntry=resources.lookupCache(cacheEntry.name + resourceName);
      if (!childCacheEntry.exists) {
        continue;
      }
      sb.append("<tr");
      if (shade)       sb.append(" bgcolor=\"#eeeeee\"");
      sb.append(">\r\n");
      shade=!shade;
      sb.append("<td align=\"left\">&nbsp;&nbsp;\r\n");
      sb.append("<a href=\"");
      sb.append(rewrittenContextPath);
      resourceName=rewriteUrl(name + resourceName);
      sb.append(resourceName);
      if (childCacheEntry.context != null)       sb.append("/");
      sb.append("\"><tt>");
      sb.append(RequestUtil.filter(trimmed));
      if (childCacheEntry.context != null)       sb.append("/");
      sb.append("</tt></a></td>\r\n");
      sb.append("<td align=\"right\"><tt>");
      if (childCacheEntry.context != null)       sb.append("&nbsp;");
 else       sb.append(renderSize(childCacheEntry.attributes.getContentLength()));
      sb.append("</tt></td>\r\n");
      sb.append("<td align=\"right\"><tt>");
      sb.append(childCacheEntry.attributes.getLastModifiedHttp());
      sb.append("</tt></td>\r\n");
      sb.append("</tr>\r\n");
    }
  }
 catch (  NamingException e) {
    throw new ServletException("Error accessing resource",e);
  }
  sb.append("</table>\r\n");
  sb.append("<HR size=\"1\" noshade=\"noshade\">");
  String readme=getReadme(cacheEntry.context);
  if (readme != null) {
    sb.append(readme);
    sb.append("<HR size=\"1\" noshade=\"noshade\">");
  }
  if (showServerInfo) {
    sb.append("<h3>").append(ServerInfo.getServerInfo()).append("</h3>");
  }
  sb.append("</body>\r\n");
  sb.append("</html>\r\n");
  writer.write(sb.toString());
  writer.flush();
  return (new ByteArrayInputStream(stream.toByteArray()));
}

ID 2215=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#getReadme(javax.naming.directory.DirContext)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Get the readme file as a string.
 */
protected String getReadme(DirContext directory) throws IOException {
  if (readmeFile != null) {
    try {
      Object obj=directory.lookup(readmeFile);
      if ((obj != null) && (obj instanceof Resource)) {
        StringWriter buffer=new StringWriter();
        InputStream is=null;
        Reader reader=null;
        try {
          is=((Resource)obj).streamContent();
          if (fileEncoding != null) {
            reader=new InputStreamReader(is,fileEncoding);
          }
 else {
            reader=new InputStreamReader(is);
          }
          copyRange(reader,new PrintWriter(buffer));
        }
  finally {
          if (reader != null) {
            try {
              reader.close();
            }
 catch (            IOException e) {
              log("Could not close reader",e);
            }
          }
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException e) {
              log("Could not close is",e);
            }
          }
        }
        return buffer.toString();
      }
    }
 catch (    NamingException e) {
      if (debug > 10) {
        log("readme '" + readmeFile + "' not found",e);
      }
      return null;
    }
  }
  return null;
}

ID 2218=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#getReadme(javax.naming.directory.DirContext)
Rmethod: java.io.Reader#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Get the readme file as a string.
 */
protected String getReadme(DirContext directory) throws IOException {
  if (readmeFile != null) {
    try {
      Object obj=directory.lookup(readmeFile);
      if ((obj != null) && (obj instanceof Resource)) {
        StringWriter buffer=new StringWriter();
        InputStream is=null;
        Reader reader=null;
        try {
          is=((Resource)obj).streamContent();
          if (fileEncoding != null) {
            reader=new InputStreamReader(is,fileEncoding);
          }
 else {
            reader=new InputStreamReader(is);
          }
          copyRange(reader,new PrintWriter(buffer));
        }
  finally {
          if (reader != null) {
            try {
              reader.close();
            }
 catch (            IOException e) {
              log("Could not close reader",e);
            }
          }
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException e) {
              log("Could not close is",e);
            }
          }
        }
        return buffer.toString();
      }
    }
 catch (    NamingException e) {
      if (debug > 10) {
        log("readme '" + readmeFile + "' not found",e);
      }
      return null;
    }
  }
  return null;
}

ID 2219=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#getReadme(javax.naming.directory.DirContext)
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Get the readme file as a string.
 */
protected String getReadme(DirContext directory) throws IOException {
  if (readmeFile != null) {
    try {
      Object obj=directory.lookup(readmeFile);
      if ((obj != null) && (obj instanceof Resource)) {
        StringWriter buffer=new StringWriter();
        InputStream is=null;
        Reader reader=null;
        try {
          is=((Resource)obj).streamContent();
          if (fileEncoding != null) {
            reader=new InputStreamReader(is,fileEncoding);
          }
 else {
            reader=new InputStreamReader(is);
          }
          copyRange(reader,new PrintWriter(buffer));
        }
  finally {
          if (reader != null) {
            try {
              reader.close();
            }
 catch (            IOException e) {
              log("Could not close reader",e);
            }
          }
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException e) {
              log("Could not close is",e);
            }
          }
        }
        return buffer.toString();
      }
    }
 catch (    NamingException e) {
      if (debug > 10) {
        log("readme '" + readmeFile + "' not found",e);
      }
      return null;
    }
  }
  return null;
}

ID 2220=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#findXsltInputStream(javax.naming.directory.DirContext)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Return a Source for the xsl template (if possible)
 */
protected Source findXsltInputStream(DirContext directory) throws IOException {
  if (localXsltFile != null) {
    try {
      Object obj=directory.lookup(localXsltFile);
      if ((obj != null) && (obj instanceof Resource)) {
        InputStream is=((Resource)obj).streamContent();
        if (is != null) {
          if (Globals.IS_SECURITY_ENABLED) {
            return secureXslt(is);
          }
 else {
            return new StreamSource(is);
          }
        }
      }
    }
 catch (    NamingException e) {
      if (debug > 10)       log("localXsltFile '" + localXsltFile + "' not found",e);
    }
  }
  if (contextXsltFile != null) {
    InputStream is=getServletContext().getResourceAsStream(contextXsltFile);
    if (is != null) {
      if (Globals.IS_SECURITY_ENABLED) {
        return secureXslt(is);
      }
 else {
        return new StreamSource(is);
      }
    }
    if (debug > 10)     log("contextXsltFile '" + contextXsltFile + "' not found");
  }
  if (globalXsltFile != null) {
    File f=validateGlobalXsltFile();
    if (f != null) {
      FileInputStream fis=null;
      try {
        fis=new FileInputStream(f);
        byte b[]=new byte[(int)f.length()];
        fis.read(b);
        return new StreamSource(new ByteArrayInputStream(b));
      }
  finally {
        if (fis != null) {
          try {
            fis.close();
          }
 catch (          IOException ioe) {
          }
        }
      }
    }
  }
  return null;
}

ID 2226=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#secureXslt(java.io.InputStream)
Rmethod: javax.xml.parsers.DocumentBuilderFactory#newDocumentBuilder()
parentException: 
thrown: ParserConfigurationException
exception comment: /** 
 * Indicates a serious configuration error.
 * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
 */

block: 
private Source secureXslt(InputStream is){
  Source result=null;
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setEntityResolver(secureEntityResolver);
    Document document=builder.parse(is);
    result=new DOMSource(document);
  }
 catch (  ParserConfigurationException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
catch (  SAXException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
catch (  IOException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return result;
}

ID 2227=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#secureXslt(java.io.InputStream)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(java.io.InputStream)
parentException: 
thrown: SAXException
exception comment: /** 
 * Encapsulate a general SAX error or warning. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>This class can contain basic error or warning information from either the XML parser or the application: a parser writer or application writer can subclass it to provide additional functionality.  SAX handlers may throw this exception or any exception subclassed from it.</p> <p>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</p> <p>If the parser or application needs to include information about a specific location in an XML document, it should use the {@link org.xml.sax.SAXParseException SAXParseException} subclass.</p>
 * @since SAX 1.0
 * @author David Megginson
 * @version 2.0.1 (sax2r2)
 * @see org.xml.sax.SAXParseException
 */

block: 
private Source secureXslt(InputStream is){
  Source result=null;
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setEntityResolver(secureEntityResolver);
    Document document=builder.parse(is);
    result=new DOMSource(document);
  }
 catch (  ParserConfigurationException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
catch (  SAXException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
catch (  IOException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return result;
}

ID 2228=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#secureXslt(java.io.InputStream)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private Source secureXslt(InputStream is){
  Source result=null;
  try {
    DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setEntityResolver(secureEntityResolver);
    Document document=builder.parse(is);
    result=new DOMSource(document);
  }
 catch (  ParserConfigurationException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
catch (  SAXException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
catch (  IOException e) {
    if (debug > 0) {
      log(e.getMessage(),e);
    }
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return result;
}

ID 2247=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#copyRange(java.io.InputStream, javax.servlet.ServletOutputStream)
Rmethod: java.io.InputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the contents of the specified input stream to the specified output stream, and ensure that both streams are closed before returning (even in the face of an exception).
 * @param istream The input stream to read from
 * @param ostream The output stream to write to
 * @return Exception which occurred during processing
 */
protected IOException copyRange(InputStream istream,ServletOutputStream ostream){
  IOException exception=null;
  byte buffer[]=new byte[input];
  int len=buffer.length;
  while (true) {
    try {
      len=istream.read(buffer);
      if (len == -1)       break;
      ostream.write(buffer,0,len);
    }
 catch (    IOException e) {
      exception=e;
      len=-1;
      break;
    }
  }
  return exception;
}

ID 2248=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#copyRange(java.io.InputStream, javax.servlet.ServletOutputStream)
Rmethod: java.io.OutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the contents of the specified input stream to the specified output stream, and ensure that both streams are closed before returning (even in the face of an exception).
 * @param istream The input stream to read from
 * @param ostream The output stream to write to
 * @return Exception which occurred during processing
 */
protected IOException copyRange(InputStream istream,ServletOutputStream ostream){
  IOException exception=null;
  byte buffer[]=new byte[input];
  int len=buffer.length;
  while (true) {
    try {
      len=istream.read(buffer);
      if (len == -1)       break;
      ostream.write(buffer,0,len);
    }
 catch (    IOException e) {
      exception=e;
      len=-1;
      break;
    }
  }
  return exception;
}

ID 2249=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#copyRange(java.io.Reader, java.io.PrintWriter)
Rmethod: java.io.Reader#read(char[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the contents of the specified input stream to the specified output stream, and ensure that both streams are closed before returning (even in the face of an exception).
 * @param reader The reader to read from
 * @param writer The writer to write to
 * @return Exception which occurred during processing
 */
protected IOException copyRange(Reader reader,PrintWriter writer){
  IOException exception=null;
  char buffer[]=new char[input];
  int len=buffer.length;
  while (true) {
    try {
      len=reader.read(buffer);
      if (len == -1)       break;
      writer.write(buffer,0,len);
    }
 catch (    IOException e) {
      exception=e;
      len=-1;
      break;
    }
  }
  return exception;
}

ID 2250=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#copyRange(java.io.InputStream, javax.servlet.ServletOutputStream, long, long)
Rmethod: java.io.InputStream#skip(long)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the contents of the specified input stream to the specified output stream, and ensure that both streams are closed before returning (even in the face of an exception).
 * @param istream The input stream to read from
 * @param ostream The output stream to write to
 * @param start Start of the range which will be copied
 * @param end End of the range which will be copied
 * @return Exception which occurred during processing
 */
protected IOException copyRange(InputStream istream,ServletOutputStream ostream,long start,long end){
  if (debug > 10)   log("Serving bytes:" + start + "-"+ end);
  long skipped=0;
  try {
    skipped=istream.skip(start);
  }
 catch (  IOException e) {
    return e;
  }
  if (skipped < start) {
    return new IOException(sm.getString("defaultservlet.skipfail",Long.valueOf(skipped),Long.valueOf(start)));
  }
  IOException exception=null;
  long bytesToRead=end - start + 1;
  byte buffer[]=new byte[input];
  int len=buffer.length;
  while ((bytesToRead > 0) && (len >= buffer.length)) {
    try {
      len=istream.read(buffer);
      if (bytesToRead >= len) {
        ostream.write(buffer,0,len);
        bytesToRead-=len;
      }
 else {
        ostream.write(buffer,0,(int)bytesToRead);
        bytesToRead=0;
      }
    }
 catch (    IOException e) {
      exception=e;
      len=-1;
    }
    if (len < buffer.length)     break;
  }
  return exception;
}

ID 2251=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#copyRange(java.io.InputStream, javax.servlet.ServletOutputStream, long, long)
Rmethod: java.io.InputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the contents of the specified input stream to the specified output stream, and ensure that both streams are closed before returning (even in the face of an exception).
 * @param istream The input stream to read from
 * @param ostream The output stream to write to
 * @param start Start of the range which will be copied
 * @param end End of the range which will be copied
 * @return Exception which occurred during processing
 */
protected IOException copyRange(InputStream istream,ServletOutputStream ostream,long start,long end){
  if (debug > 10)   log("Serving bytes:" + start + "-"+ end);
  long skipped=0;
  try {
    skipped=istream.skip(start);
  }
 catch (  IOException e) {
    return e;
  }
  if (skipped < start) {
    return new IOException(sm.getString("defaultservlet.skipfail",Long.valueOf(skipped),Long.valueOf(start)));
  }
  IOException exception=null;
  long bytesToRead=end - start + 1;
  byte buffer[]=new byte[input];
  int len=buffer.length;
  while ((bytesToRead > 0) && (len >= buffer.length)) {
    try {
      len=istream.read(buffer);
      if (bytesToRead >= len) {
        ostream.write(buffer,0,len);
        bytesToRead-=len;
      }
 else {
        ostream.write(buffer,0,(int)bytesToRead);
        bytesToRead=0;
      }
    }
 catch (    IOException e) {
      exception=e;
      len=-1;
    }
    if (len < buffer.length)     break;
  }
  return exception;
}

ID 2252=========================================================================type: 1
Method:org.apache.catalina.servlets.DefaultServlet#copyRange(java.io.InputStream, javax.servlet.ServletOutputStream, long, long)
Rmethod: java.io.OutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the contents of the specified input stream to the specified output stream, and ensure that both streams are closed before returning (even in the face of an exception).
 * @param istream The input stream to read from
 * @param ostream The output stream to write to
 * @param start Start of the range which will be copied
 * @param end End of the range which will be copied
 * @return Exception which occurred during processing
 */
protected IOException copyRange(InputStream istream,ServletOutputStream ostream,long start,long end){
  if (debug > 10)   log("Serving bytes:" + start + "-"+ end);
  long skipped=0;
  try {
    skipped=istream.skip(start);
  }
 catch (  IOException e) {
    return e;
  }
  if (skipped < start) {
    return new IOException(sm.getString("defaultservlet.skipfail",Long.valueOf(skipped),Long.valueOf(start)));
  }
  IOException exception=null;
  long bytesToRead=end - start + 1;
  byte buffer[]=new byte[input];
  int len=buffer.length;
  while ((bytesToRead > 0) && (len >= buffer.length)) {
    try {
      len=istream.read(buffer);
      if (bytesToRead >= len) {
        ostream.write(buffer,0,len);
        bytesToRead-=len;
      }
 else {
        ostream.write(buffer,0,(int)bytesToRead);
        bytesToRead=0;
      }
    }
 catch (    IOException e) {
      exception=e;
      len=-1;
    }
    if (len < buffer.length)     break;
  }
  return exception;
}

ID 2254=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#init()
Rmethod: java.security.MessageDigest#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * Initialize this servlet.
 */
@Override public void init() throws ServletException {
  super.init();
  if (getServletConfig().getInitParameter("secret") != null)   secret=getServletConfig().getInitParameter("secret");
  if (getServletConfig().getInitParameter("maxDepth") != null)   maxDepth=Integer.parseInt(getServletConfig().getInitParameter("maxDepth"));
  if (getServletConfig().getInitParameter("allowSpecialPaths") != null)   allowSpecialPaths=Boolean.parseBoolean(getServletConfig().getInitParameter("allowSpecialPaths"));
  try {
    md5Helper=MessageDigest.getInstance("MD5");
  }
 catch (  NoSuchAlgorithmException e) {
    throw new UnavailableException("No MD5");
  }
}

ID 2255=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#getDocumentBuilder()
Rmethod: javax.xml.parsers.DocumentBuilderFactory#newDocumentBuilder()
parentException: 
thrown: ParserConfigurationException
exception comment: /** 
 * Indicates a serious configuration error.
 * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
 */

block: 
/** 
 * Return JAXP document builder instance.
 */
protected DocumentBuilder getDocumentBuilder() throws ServletException {
  DocumentBuilder documentBuilder=null;
  DocumentBuilderFactory documentBuilderFactory=null;
  try {
    documentBuilderFactory=DocumentBuilderFactory.newInstance();
    documentBuilderFactory.setNamespaceAware(true);
    documentBuilderFactory.setExpandEntityReferences(false);
    documentBuilder=documentBuilderFactory.newDocumentBuilder();
    documentBuilder.setEntityResolver(new WebdavResolver(this.getServletContext()));
  }
 catch (  ParserConfigurationException e) {
    throw new ServletException(sm.getString("webdavservlet.jaxpfailed"));
  }
  return documentBuilder;
}

ID 2269=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doPropfind(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.servlet.ServletRequest#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * PROPFIND Method.
 */
protected void doPropfind(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (!listings) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  String path=getRelativePath(req);
  if (path.endsWith("/"))   path=path.substring(0,path.length() - 1);
  Vector<String> properties=null;
  int depth=maxDepth;
  int type=FIND_ALL_PROP;
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      depth=0;
    }
 else     if (depthStr.equals("1")) {
      depth=1;
    }
 else     if (depthStr.equals("infinity")) {
      depth=maxDepth;
    }
  }
  Node propNode=null;
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
      Element rootElement=document.getDocumentElement();
      NodeList childList=rootElement.getChildNodes();
      for (int i=0; i < childList.getLength(); i++) {
        Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
          break;
case Node.ELEMENT_NODE:
        if (currentNode.getNodeName().endsWith("prop")) {
          type=FIND_BY_PROPERTY;
          propNode=currentNode;
        }
      if (currentNode.getNodeName().endsWith("propname")) {
        type=FIND_PROPERTY_NAMES;
      }
    if (currentNode.getNodeName().endsWith("allprop")) {
      type=FIND_ALL_PROP;
    }
  break;
}
}
}
 catch (SAXException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
catch (IOException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
}
if (type == FIND_BY_PROPERTY) {
properties=new Vector<String>();
@SuppressWarnings("null") NodeList childList=propNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String nodeName=currentNode.getNodeName();
String propertyName=null;
if (nodeName.indexOf(':') != -1) {
propertyName=nodeName.substring(nodeName.indexOf(':') + 1);
}
 else {
propertyName=nodeName;
}
properties.addElement(propertyName);
break;
}
}
}
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
int slash=path.lastIndexOf('/');
if (slash != -1) {
String parentPath=path.substring(0,slash);
Vector<String> currentLockNullResources=lockNullResources.get(parentPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
if (lockNullPath.equals(path)) {
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
return;
}
}
}
}
}
if (!exists) {
resp.sendError(HttpServletResponse.SC_NOT_FOUND,path);
return;
}
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
if (depth == 0) {
parseProperties(req,generatedXML,path,type,properties);
}
 else {
Stack<String> stack=new Stack<String>();
stack.push(path);
Stack<String> stackBelow=new Stack<String>();
while ((!stack.isEmpty()) && (depth >= 0)) {
String currentPath=stack.pop();
parseProperties(req,generatedXML,currentPath,type,properties);
try {
object=resources.lookup(currentPath);
}
 catch (NamingException e) {
continue;
}
if ((object instanceof DirContext) && (depth > 0)) {
try {
NamingEnumeration<NameClassPair> enumeration=resources.list(currentPath);
while (enumeration.hasMoreElements()) {
NameClassPair ncPair=enumeration.nextElement();
String newPath=currentPath;
if (!(newPath.endsWith("/"))) newPath+="/";
newPath+=ncPair.getName();
stackBelow.push(newPath);
}
}
 catch (NamingException e) {
resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,path);
return;
}
String lockPath=currentPath;
if (lockPath.endsWith("/")) lockPath=lockPath.substring(0,lockPath.length() - 1);
Vector<String> currentLockNullResources=lockNullResources.get(lockPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
}
}
}
if (stack.isEmpty()) {
depth--;
stack=stackBelow;
stackBelow=new Stack<String>();
}
generatedXML.sendData();
}
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
}

ID 2270=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doPropfind(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(org.xml.sax.InputSource)
parentException: 
thrown: SAXException
exception comment: /** 
 * Encapsulate a general SAX error or warning. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>This class can contain basic error or warning information from either the XML parser or the application: a parser writer or application writer can subclass it to provide additional functionality.  SAX handlers may throw this exception or any exception subclassed from it.</p> <p>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</p> <p>If the parser or application needs to include information about a specific location in an XML document, it should use the {@link org.xml.sax.SAXParseException SAXParseException} subclass.</p>
 * @since SAX 1.0
 * @author David Megginson
 * @version 2.0.1 (sax2r2)
 * @see org.xml.sax.SAXParseException
 */

block: 
/** 
 * PROPFIND Method.
 */
protected void doPropfind(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (!listings) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  String path=getRelativePath(req);
  if (path.endsWith("/"))   path=path.substring(0,path.length() - 1);
  Vector<String> properties=null;
  int depth=maxDepth;
  int type=FIND_ALL_PROP;
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      depth=0;
    }
 else     if (depthStr.equals("1")) {
      depth=1;
    }
 else     if (depthStr.equals("infinity")) {
      depth=maxDepth;
    }
  }
  Node propNode=null;
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
      Element rootElement=document.getDocumentElement();
      NodeList childList=rootElement.getChildNodes();
      for (int i=0; i < childList.getLength(); i++) {
        Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
          break;
case Node.ELEMENT_NODE:
        if (currentNode.getNodeName().endsWith("prop")) {
          type=FIND_BY_PROPERTY;
          propNode=currentNode;
        }
      if (currentNode.getNodeName().endsWith("propname")) {
        type=FIND_PROPERTY_NAMES;
      }
    if (currentNode.getNodeName().endsWith("allprop")) {
      type=FIND_ALL_PROP;
    }
  break;
}
}
}
 catch (SAXException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
catch (IOException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
}
if (type == FIND_BY_PROPERTY) {
properties=new Vector<String>();
@SuppressWarnings("null") NodeList childList=propNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String nodeName=currentNode.getNodeName();
String propertyName=null;
if (nodeName.indexOf(':') != -1) {
propertyName=nodeName.substring(nodeName.indexOf(':') + 1);
}
 else {
propertyName=nodeName;
}
properties.addElement(propertyName);
break;
}
}
}
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
int slash=path.lastIndexOf('/');
if (slash != -1) {
String parentPath=path.substring(0,slash);
Vector<String> currentLockNullResources=lockNullResources.get(parentPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
if (lockNullPath.equals(path)) {
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
return;
}
}
}
}
}
if (!exists) {
resp.sendError(HttpServletResponse.SC_NOT_FOUND,path);
return;
}
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
if (depth == 0) {
parseProperties(req,generatedXML,path,type,properties);
}
 else {
Stack<String> stack=new Stack<String>();
stack.push(path);
Stack<String> stackBelow=new Stack<String>();
while ((!stack.isEmpty()) && (depth >= 0)) {
String currentPath=stack.pop();
parseProperties(req,generatedXML,currentPath,type,properties);
try {
object=resources.lookup(currentPath);
}
 catch (NamingException e) {
continue;
}
if ((object instanceof DirContext) && (depth > 0)) {
try {
NamingEnumeration<NameClassPair> enumeration=resources.list(currentPath);
while (enumeration.hasMoreElements()) {
NameClassPair ncPair=enumeration.nextElement();
String newPath=currentPath;
if (!(newPath.endsWith("/"))) newPath+="/";
newPath+=ncPair.getName();
stackBelow.push(newPath);
}
}
 catch (NamingException e) {
resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,path);
return;
}
String lockPath=currentPath;
if (lockPath.endsWith("/")) lockPath=lockPath.substring(0,lockPath.length() - 1);
Vector<String> currentLockNullResources=lockNullResources.get(lockPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
}
}
}
if (stack.isEmpty()) {
depth--;
stack=stackBelow;
stackBelow=new Stack<String>();
}
generatedXML.sendData();
}
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
}

ID 2271=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doPropfind(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(org.xml.sax.InputSource)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * PROPFIND Method.
 */
protected void doPropfind(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (!listings) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  String path=getRelativePath(req);
  if (path.endsWith("/"))   path=path.substring(0,path.length() - 1);
  Vector<String> properties=null;
  int depth=maxDepth;
  int type=FIND_ALL_PROP;
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      depth=0;
    }
 else     if (depthStr.equals("1")) {
      depth=1;
    }
 else     if (depthStr.equals("infinity")) {
      depth=maxDepth;
    }
  }
  Node propNode=null;
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
      Element rootElement=document.getDocumentElement();
      NodeList childList=rootElement.getChildNodes();
      for (int i=0; i < childList.getLength(); i++) {
        Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
          break;
case Node.ELEMENT_NODE:
        if (currentNode.getNodeName().endsWith("prop")) {
          type=FIND_BY_PROPERTY;
          propNode=currentNode;
        }
      if (currentNode.getNodeName().endsWith("propname")) {
        type=FIND_PROPERTY_NAMES;
      }
    if (currentNode.getNodeName().endsWith("allprop")) {
      type=FIND_ALL_PROP;
    }
  break;
}
}
}
 catch (SAXException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
catch (IOException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
}
if (type == FIND_BY_PROPERTY) {
properties=new Vector<String>();
@SuppressWarnings("null") NodeList childList=propNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String nodeName=currentNode.getNodeName();
String propertyName=null;
if (nodeName.indexOf(':') != -1) {
propertyName=nodeName.substring(nodeName.indexOf(':') + 1);
}
 else {
propertyName=nodeName;
}
properties.addElement(propertyName);
break;
}
}
}
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
int slash=path.lastIndexOf('/');
if (slash != -1) {
String parentPath=path.substring(0,slash);
Vector<String> currentLockNullResources=lockNullResources.get(parentPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
if (lockNullPath.equals(path)) {
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
return;
}
}
}
}
}
if (!exists) {
resp.sendError(HttpServletResponse.SC_NOT_FOUND,path);
return;
}
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
if (depth == 0) {
parseProperties(req,generatedXML,path,type,properties);
}
 else {
Stack<String> stack=new Stack<String>();
stack.push(path);
Stack<String> stackBelow=new Stack<String>();
while ((!stack.isEmpty()) && (depth >= 0)) {
String currentPath=stack.pop();
parseProperties(req,generatedXML,currentPath,type,properties);
try {
object=resources.lookup(currentPath);
}
 catch (NamingException e) {
continue;
}
if ((object instanceof DirContext) && (depth > 0)) {
try {
NamingEnumeration<NameClassPair> enumeration=resources.list(currentPath);
while (enumeration.hasMoreElements()) {
NameClassPair ncPair=enumeration.nextElement();
String newPath=currentPath;
if (!(newPath.endsWith("/"))) newPath+="/";
newPath+=ncPair.getName();
stackBelow.push(newPath);
}
}
 catch (NamingException e) {
resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,path);
return;
}
String lockPath=currentPath;
if (lockPath.endsWith("/")) lockPath=lockPath.substring(0,lockPath.length() - 1);
Vector<String> currentLockNullResources=lockNullResources.get(lockPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
}
}
}
if (stack.isEmpty()) {
depth--;
stack=stackBelow;
stackBelow=new Stack<String>();
}
generatedXML.sendData();
}
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
}

ID 2272=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doPropfind(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.servlet.http.HttpServletResponse#sendError(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * PROPFIND Method.
 */
protected void doPropfind(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (!listings) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  String path=getRelativePath(req);
  if (path.endsWith("/"))   path=path.substring(0,path.length() - 1);
  Vector<String> properties=null;
  int depth=maxDepth;
  int type=FIND_ALL_PROP;
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      depth=0;
    }
 else     if (depthStr.equals("1")) {
      depth=1;
    }
 else     if (depthStr.equals("infinity")) {
      depth=maxDepth;
    }
  }
  Node propNode=null;
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
      Element rootElement=document.getDocumentElement();
      NodeList childList=rootElement.getChildNodes();
      for (int i=0; i < childList.getLength(); i++) {
        Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
          break;
case Node.ELEMENT_NODE:
        if (currentNode.getNodeName().endsWith("prop")) {
          type=FIND_BY_PROPERTY;
          propNode=currentNode;
        }
      if (currentNode.getNodeName().endsWith("propname")) {
        type=FIND_PROPERTY_NAMES;
      }
    if (currentNode.getNodeName().endsWith("allprop")) {
      type=FIND_ALL_PROP;
    }
  break;
}
}
}
 catch (SAXException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
catch (IOException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
}
if (type == FIND_BY_PROPERTY) {
properties=new Vector<String>();
@SuppressWarnings("null") NodeList childList=propNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String nodeName=currentNode.getNodeName();
String propertyName=null;
if (nodeName.indexOf(':') != -1) {
propertyName=nodeName.substring(nodeName.indexOf(':') + 1);
}
 else {
propertyName=nodeName;
}
properties.addElement(propertyName);
break;
}
}
}
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
int slash=path.lastIndexOf('/');
if (slash != -1) {
String parentPath=path.substring(0,slash);
Vector<String> currentLockNullResources=lockNullResources.get(parentPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
if (lockNullPath.equals(path)) {
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
return;
}
}
}
}
}
if (!exists) {
resp.sendError(HttpServletResponse.SC_NOT_FOUND,path);
return;
}
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
if (depth == 0) {
parseProperties(req,generatedXML,path,type,properties);
}
 else {
Stack<String> stack=new Stack<String>();
stack.push(path);
Stack<String> stackBelow=new Stack<String>();
while ((!stack.isEmpty()) && (depth >= 0)) {
String currentPath=stack.pop();
parseProperties(req,generatedXML,currentPath,type,properties);
try {
object=resources.lookup(currentPath);
}
 catch (NamingException e) {
continue;
}
if ((object instanceof DirContext) && (depth > 0)) {
try {
NamingEnumeration<NameClassPair> enumeration=resources.list(currentPath);
while (enumeration.hasMoreElements()) {
NameClassPair ncPair=enumeration.nextElement();
String newPath=currentPath;
if (!(newPath.endsWith("/"))) newPath+="/";
newPath+=ncPair.getName();
stackBelow.push(newPath);
}
}
 catch (NamingException e) {
resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,path);
return;
}
String lockPath=currentPath;
if (lockPath.endsWith("/")) lockPath=lockPath.substring(0,lockPath.length() - 1);
Vector<String> currentLockNullResources=lockNullResources.get(lockPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
}
}
}
if (stack.isEmpty()) {
depth--;
stack=stackBelow;
stackBelow=new Stack<String>();
}
generatedXML.sendData();
}
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
}

ID 2273=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doPropfind(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * PROPFIND Method.
 */
protected void doPropfind(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (!listings) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  String path=getRelativePath(req);
  if (path.endsWith("/"))   path=path.substring(0,path.length() - 1);
  Vector<String> properties=null;
  int depth=maxDepth;
  int type=FIND_ALL_PROP;
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      depth=0;
    }
 else     if (depthStr.equals("1")) {
      depth=1;
    }
 else     if (depthStr.equals("infinity")) {
      depth=maxDepth;
    }
  }
  Node propNode=null;
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
      Element rootElement=document.getDocumentElement();
      NodeList childList=rootElement.getChildNodes();
      for (int i=0; i < childList.getLength(); i++) {
        Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
          break;
case Node.ELEMENT_NODE:
        if (currentNode.getNodeName().endsWith("prop")) {
          type=FIND_BY_PROPERTY;
          propNode=currentNode;
        }
      if (currentNode.getNodeName().endsWith("propname")) {
        type=FIND_PROPERTY_NAMES;
      }
    if (currentNode.getNodeName().endsWith("allprop")) {
      type=FIND_ALL_PROP;
    }
  break;
}
}
}
 catch (SAXException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
catch (IOException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
}
if (type == FIND_BY_PROPERTY) {
properties=new Vector<String>();
@SuppressWarnings("null") NodeList childList=propNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String nodeName=currentNode.getNodeName();
String propertyName=null;
if (nodeName.indexOf(':') != -1) {
propertyName=nodeName.substring(nodeName.indexOf(':') + 1);
}
 else {
propertyName=nodeName;
}
properties.addElement(propertyName);
break;
}
}
}
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
int slash=path.lastIndexOf('/');
if (slash != -1) {
String parentPath=path.substring(0,slash);
Vector<String> currentLockNullResources=lockNullResources.get(parentPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
if (lockNullPath.equals(path)) {
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
return;
}
}
}
}
}
if (!exists) {
resp.sendError(HttpServletResponse.SC_NOT_FOUND,path);
return;
}
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
if (depth == 0) {
parseProperties(req,generatedXML,path,type,properties);
}
 else {
Stack<String> stack=new Stack<String>();
stack.push(path);
Stack<String> stackBelow=new Stack<String>();
while ((!stack.isEmpty()) && (depth >= 0)) {
String currentPath=stack.pop();
parseProperties(req,generatedXML,currentPath,type,properties);
try {
object=resources.lookup(currentPath);
}
 catch (NamingException e) {
continue;
}
if ((object instanceof DirContext) && (depth > 0)) {
try {
NamingEnumeration<NameClassPair> enumeration=resources.list(currentPath);
while (enumeration.hasMoreElements()) {
NameClassPair ncPair=enumeration.nextElement();
String newPath=currentPath;
if (!(newPath.endsWith("/"))) newPath+="/";
newPath+=ncPair.getName();
stackBelow.push(newPath);
}
}
 catch (NamingException e) {
resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,path);
return;
}
String lockPath=currentPath;
if (lockPath.endsWith("/")) lockPath=lockPath.substring(0,lockPath.length() - 1);
Vector<String> currentLockNullResources=lockNullResources.get(lockPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
}
}
}
if (stack.isEmpty()) {
depth--;
stack=stackBelow;
stackBelow=new Stack<String>();
}
generatedXML.sendData();
}
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
}

ID 2278=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doPropfind(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * PROPFIND Method.
 */
protected void doPropfind(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (!listings) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  String path=getRelativePath(req);
  if (path.endsWith("/"))   path=path.substring(0,path.length() - 1);
  Vector<String> properties=null;
  int depth=maxDepth;
  int type=FIND_ALL_PROP;
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      depth=0;
    }
 else     if (depthStr.equals("1")) {
      depth=1;
    }
 else     if (depthStr.equals("infinity")) {
      depth=maxDepth;
    }
  }
  Node propNode=null;
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
      Element rootElement=document.getDocumentElement();
      NodeList childList=rootElement.getChildNodes();
      for (int i=0; i < childList.getLength(); i++) {
        Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
          break;
case Node.ELEMENT_NODE:
        if (currentNode.getNodeName().endsWith("prop")) {
          type=FIND_BY_PROPERTY;
          propNode=currentNode;
        }
      if (currentNode.getNodeName().endsWith("propname")) {
        type=FIND_PROPERTY_NAMES;
      }
    if (currentNode.getNodeName().endsWith("allprop")) {
      type=FIND_ALL_PROP;
    }
  break;
}
}
}
 catch (SAXException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
catch (IOException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
}
if (type == FIND_BY_PROPERTY) {
properties=new Vector<String>();
@SuppressWarnings("null") NodeList childList=propNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String nodeName=currentNode.getNodeName();
String propertyName=null;
if (nodeName.indexOf(':') != -1) {
propertyName=nodeName.substring(nodeName.indexOf(':') + 1);
}
 else {
propertyName=nodeName;
}
properties.addElement(propertyName);
break;
}
}
}
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
int slash=path.lastIndexOf('/');
if (slash != -1) {
String parentPath=path.substring(0,slash);
Vector<String> currentLockNullResources=lockNullResources.get(parentPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
if (lockNullPath.equals(path)) {
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
return;
}
}
}
}
}
if (!exists) {
resp.sendError(HttpServletResponse.SC_NOT_FOUND,path);
return;
}
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
if (depth == 0) {
parseProperties(req,generatedXML,path,type,properties);
}
 else {
Stack<String> stack=new Stack<String>();
stack.push(path);
Stack<String> stackBelow=new Stack<String>();
while ((!stack.isEmpty()) && (depth >= 0)) {
String currentPath=stack.pop();
parseProperties(req,generatedXML,currentPath,type,properties);
try {
object=resources.lookup(currentPath);
}
 catch (NamingException e) {
continue;
}
if ((object instanceof DirContext) && (depth > 0)) {
try {
NamingEnumeration<NameClassPair> enumeration=resources.list(currentPath);
while (enumeration.hasMoreElements()) {
NameClassPair ncPair=enumeration.nextElement();
String newPath=currentPath;
if (!(newPath.endsWith("/"))) newPath+="/";
newPath+=ncPair.getName();
stackBelow.push(newPath);
}
}
 catch (NamingException e) {
resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,path);
return;
}
String lockPath=currentPath;
if (lockPath.endsWith("/")) lockPath=lockPath.substring(0,lockPath.length() - 1);
Vector<String> currentLockNullResources=lockNullResources.get(lockPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
}
}
}
if (stack.isEmpty()) {
depth--;
stack=stackBelow;
stackBelow=new Stack<String>();
}
generatedXML.sendData();
}
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
}

ID 2279=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doPropfind(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * PROPFIND Method.
 */
protected void doPropfind(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (!listings) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  String path=getRelativePath(req);
  if (path.endsWith("/"))   path=path.substring(0,path.length() - 1);
  Vector<String> properties=null;
  int depth=maxDepth;
  int type=FIND_ALL_PROP;
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      depth=0;
    }
 else     if (depthStr.equals("1")) {
      depth=1;
    }
 else     if (depthStr.equals("infinity")) {
      depth=maxDepth;
    }
  }
  Node propNode=null;
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
      Element rootElement=document.getDocumentElement();
      NodeList childList=rootElement.getChildNodes();
      for (int i=0; i < childList.getLength(); i++) {
        Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
          break;
case Node.ELEMENT_NODE:
        if (currentNode.getNodeName().endsWith("prop")) {
          type=FIND_BY_PROPERTY;
          propNode=currentNode;
        }
      if (currentNode.getNodeName().endsWith("propname")) {
        type=FIND_PROPERTY_NAMES;
      }
    if (currentNode.getNodeName().endsWith("allprop")) {
      type=FIND_ALL_PROP;
    }
  break;
}
}
}
 catch (SAXException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
catch (IOException e) {
resp.sendError(WebdavStatus.SC_BAD_REQUEST);
return;
}
}
if (type == FIND_BY_PROPERTY) {
properties=new Vector<String>();
@SuppressWarnings("null") NodeList childList=propNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String nodeName=currentNode.getNodeName();
String propertyName=null;
if (nodeName.indexOf(':') != -1) {
propertyName=nodeName.substring(nodeName.indexOf(':') + 1);
}
 else {
propertyName=nodeName;
}
properties.addElement(propertyName);
break;
}
}
}
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
int slash=path.lastIndexOf('/');
if (slash != -1) {
String parentPath=path.substring(0,slash);
Vector<String> currentLockNullResources=lockNullResources.get(parentPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
if (lockNullPath.equals(path)) {
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
return;
}
}
}
}
}
if (!exists) {
resp.sendError(HttpServletResponse.SC_NOT_FOUND,path);
return;
}
resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
resp.setContentType("text/xml; charset=UTF-8");
XMLWriter generatedXML=new XMLWriter(resp.getWriter());
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
if (depth == 0) {
parseProperties(req,generatedXML,path,type,properties);
}
 else {
Stack<String> stack=new Stack<String>();
stack.push(path);
Stack<String> stackBelow=new Stack<String>();
while ((!stack.isEmpty()) && (depth >= 0)) {
String currentPath=stack.pop();
parseProperties(req,generatedXML,currentPath,type,properties);
try {
object=resources.lookup(currentPath);
}
 catch (NamingException e) {
continue;
}
if ((object instanceof DirContext) && (depth > 0)) {
try {
NamingEnumeration<NameClassPair> enumeration=resources.list(currentPath);
while (enumeration.hasMoreElements()) {
NameClassPair ncPair=enumeration.nextElement();
String newPath=currentPath;
if (!(newPath.endsWith("/"))) newPath+="/";
newPath+=ncPair.getName();
stackBelow.push(newPath);
}
}
 catch (NamingException e) {
resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,path);
return;
}
String lockPath=currentPath;
if (lockPath.endsWith("/")) lockPath=lockPath.substring(0,lockPath.length() - 1);
Vector<String> currentLockNullResources=lockNullResources.get(lockPath);
if (currentLockNullResources != null) {
Enumeration<String> lockNullResourcesList=currentLockNullResources.elements();
while (lockNullResourcesList.hasMoreElements()) {
String lockNullPath=lockNullResourcesList.nextElement();
parseLockNullProperties(req,generatedXML,lockNullPath,type,properties);
}
}
}
if (stack.isEmpty()) {
depth--;
stack=stackBelow;
stackBelow=new Stack<String>();
}
generatedXML.sendData();
}
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
generatedXML.sendData();
}

ID 2284=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doMkcol(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * MKCOL Method.
 */
protected void doMkcol(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (exists) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      documentBuilder.parse(new InputSource(req.getInputStream()));
      resp.sendError(WebdavStatus.SC_NOT_IMPLEMENTED);
      return;
    }
 catch (    SAXException saxe) {
      resp.sendError(WebdavStatus.SC_UNSUPPORTED_MEDIA_TYPE);
      return;
    }
  }
  boolean result=true;
  try {
    resources.createSubcontext(path);
  }
 catch (  NamingException e) {
    result=false;
  }
  if (!result) {
    resp.sendError(WebdavStatus.SC_CONFLICT,WebdavStatus.getStatusText(WebdavStatus.SC_CONFLICT));
  }
 else {
    resp.setStatus(WebdavStatus.SC_CREATED);
    lockNullResources.remove(path);
  }
}

ID 2287=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doMkcol(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(org.xml.sax.InputSource)
parentException: 
thrown: SAXException
exception comment: /** 
 * Encapsulate a general SAX error or warning. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>This class can contain basic error or warning information from either the XML parser or the application: a parser writer or application writer can subclass it to provide additional functionality.  SAX handlers may throw this exception or any exception subclassed from it.</p> <p>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</p> <p>If the parser or application needs to include information about a specific location in an XML document, it should use the {@link org.xml.sax.SAXParseException SAXParseException} subclass.</p>
 * @since SAX 1.0
 * @author David Megginson
 * @version 2.0.1 (sax2r2)
 * @see org.xml.sax.SAXParseException
 */

block: 
/** 
 * MKCOL Method.
 */
protected void doMkcol(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (exists) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      documentBuilder.parse(new InputSource(req.getInputStream()));
      resp.sendError(WebdavStatus.SC_NOT_IMPLEMENTED);
      return;
    }
 catch (    SAXException saxe) {
      resp.sendError(WebdavStatus.SC_UNSUPPORTED_MEDIA_TYPE);
      return;
    }
  }
  boolean result=true;
  try {
    resources.createSubcontext(path);
  }
 catch (  NamingException e) {
    result=false;
  }
  if (!result) {
    resp.sendError(WebdavStatus.SC_CONFLICT,WebdavStatus.getStatusText(WebdavStatus.SC_CONFLICT));
  }
 else {
    resp.setStatus(WebdavStatus.SC_CREATED);
    lockNullResources.remove(path);
  }
}

ID 2289=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doMkcol(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#createSubcontext(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * MKCOL Method.
 */
protected void doMkcol(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  String path=getRelativePath(req);
  boolean exists=true;
  try {
    resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (exists) {
    StringBuilder methodsAllowed=determineMethodsAllowed(resources,req);
    resp.addHeader("Allow",methodsAllowed.toString());
    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
    return;
  }
  if (req.getContentLength() > 0) {
    DocumentBuilder documentBuilder=getDocumentBuilder();
    try {
      documentBuilder.parse(new InputSource(req.getInputStream()));
      resp.sendError(WebdavStatus.SC_NOT_IMPLEMENTED);
      return;
    }
 catch (    SAXException saxe) {
      resp.sendError(WebdavStatus.SC_UNSUPPORTED_MEDIA_TYPE);
      return;
    }
  }
  boolean result=true;
  try {
    resources.createSubcontext(path);
  }
 catch (  NamingException e) {
    result=false;
  }
  if (!result) {
    resp.sendError(WebdavStatus.SC_CONFLICT,WebdavStatus.getStatusText(WebdavStatus.SC_CONFLICT));
  }
 else {
    resp.setStatus(WebdavStatus.SC_CREATED);
    lockNullResources.remove(path);
  }
}

ID 2301=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doLock(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * LOCK Method.
 */
protected void doLock(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  LockInfo lock=new LockInfo();
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    lock.depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      lock.depth=0;
    }
 else {
      lock.depth=maxDepth;
    }
  }
  int lockDuration=DEFAULT_TIMEOUT;
  String lockDurationStr=req.getHeader("Timeout");
  if (lockDurationStr == null) {
    lockDuration=DEFAULT_TIMEOUT;
  }
 else {
    int commaPos=lockDurationStr.indexOf(',');
    if (commaPos != -1) {
      lockDurationStr=lockDurationStr.substring(0,commaPos);
    }
    if (lockDurationStr.startsWith("Second-")) {
      lockDuration=Integer.parseInt(lockDurationStr.substring(7));
    }
 else {
      if (lockDurationStr.equalsIgnoreCase("infinity")) {
        lockDuration=MAX_TIMEOUT;
      }
 else {
        try {
          lockDuration=Integer.parseInt(lockDurationStr);
        }
 catch (        NumberFormatException e) {
          lockDuration=MAX_TIMEOUT;
        }
      }
    }
    if (lockDuration == 0) {
      lockDuration=DEFAULT_TIMEOUT;
    }
    if (lockDuration > MAX_TIMEOUT) {
      lockDuration=MAX_TIMEOUT;
    }
  }
  lock.expiresAt=System.currentTimeMillis() + (lockDuration * 1000);
  int lockRequestType=LOCK_CREATION;
  Node lockInfoNode=null;
  DocumentBuilder documentBuilder=getDocumentBuilder();
  try {
    Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
    Element rootElement=document.getDocumentElement();
    lockInfoNode=rootElement;
  }
 catch (  IOException e) {
    lockRequestType=LOCK_REFRESH;
  }
catch (  SAXException e) {
    lockRequestType=LOCK_REFRESH;
  }
  if (lockInfoNode != null) {
    NodeList childList=lockInfoNode.getChildNodes();
    StringWriter strWriter=null;
    DOMWriter domWriter=null;
    Node lockScopeNode=null;
    Node lockTypeNode=null;
    Node lockOwnerNode=null;
    for (int i=0; i < childList.getLength(); i++) {
      Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
        break;
case Node.ELEMENT_NODE:
      String nodeName=currentNode.getNodeName();
    if (nodeName.endsWith("lockscope")) {
      lockScopeNode=currentNode;
    }
  if (nodeName.endsWith("locktype")) {
    lockTypeNode=currentNode;
  }
if (nodeName.endsWith("owner")) {
  lockOwnerNode=currentNode;
}
break;
}
}
if (lockScopeNode != null) {
childList=lockScopeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempScope=currentNode.getNodeName();
if (tempScope.indexOf(':') != -1) {
lock.scope=tempScope.substring(tempScope.indexOf(':') + 1);
}
 else {
lock.scope=tempScope;
}
break;
}
}
if (lock.scope == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockTypeNode != null) {
childList=lockTypeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempType=currentNode.getNodeName();
if (tempType.indexOf(':') != -1) {
lock.type=tempType.substring(tempType.indexOf(':') + 1);
}
 else {
lock.type=tempType;
}
break;
}
}
if (lock.type == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockOwnerNode != null) {
childList=lockOwnerNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
lock.owner+=currentNode.getNodeValue();
break;
case Node.ELEMENT_NODE:
strWriter=new StringWriter();
domWriter=new DOMWriter(strWriter,true);
domWriter.setQualifiedNames(false);
domWriter.print(currentNode);
lock.owner+=strWriter.toString();
break;
}
}
if (lock.owner == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
lock.owner="";
}
}
String path=getRelativePath(req);
lock.path=path;
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
Enumeration<LockInfo> locksList=null;
if (lockRequestType == LOCK_CREATION) {
String lockTokenStr=req.getServletPath() + "-" + lock.type+ "-"+ lock.scope+ "-"+ req.getUserPrincipal()+ "-"+ lock.depth+ "-"+ lock.owner+ "-"+ lock.tokens+ "-"+ lock.expiresAt+ "-"+ System.currentTimeMillis()+ "-"+ secret;
String lockToken=MD5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes(Charset.defaultCharset())));
if ((exists) && (object instanceof DirContext) && (lock.depth == maxDepth)) {
Vector<String> lockPaths=new Vector<String>();
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
locksList=resourceLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
if (!lockPaths.isEmpty()) {
Enumeration<String> lockPathsList=lockPaths.elements();
resp.setStatus(WebdavStatus.SC_CONFLICT);
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
while (lockPathsList.hasMoreElements()) {
generatedXML.writeElement("D","response",XMLWriter.OPENING);
generatedXML.writeElement("D","href",XMLWriter.OPENING);
generatedXML.writeText(lockPathsList.nextElement());
generatedXML.writeElement("D","href",XMLWriter.CLOSING);
generatedXML.writeElement("D","status",XMLWriter.OPENING);
generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " "+ WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED));
generatedXML.writeElement("D","status",XMLWriter.CLOSING);
generatedXML.writeElement("D","response",XMLWriter.CLOSING);
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
return;
}
boolean addLock=true;
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.path.equals(lock.path)) {
if (currentLock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
 else {
if (lock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
}
currentLock.tokens.addElement(lockToken);
lock=currentLock;
addLock=false;
}
}
if (addLock) {
lock.tokens.addElement(lockToken);
collectionLocks.addElement(lock);
}
}
 else {
LockInfo presentLock=resourceLocks.get(lock.path);
if (presentLock != null) {
if ((presentLock.isExclusive()) || (lock.isExclusive())) {
resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
return;
}
 else {
presentLock.tokens.addElement(lockToken);
lock=presentLock;
}
}
 else {
lock.tokens.addElement(lockToken);
resourceLocks.put(lock.path,lock);
exists=true;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
if (!exists) {
int slash=lock.path.lastIndexOf('/');
String parentPath=lock.path.substring(0,slash);
Vector<String> lockNulls=lockNullResources.get(parentPath);
if (lockNulls == null) {
lockNulls=new Vector<String>();
lockNullResources.put(parentPath,lockNulls);
}
lockNulls.addElement(lock.path);
}
resp.addHeader("Lock-Token","<opaquelocktoken:" + lockToken + ">");
}
}
}
if (lockRequestType == LOCK_REFRESH) {
String ifHeader=req.getHeader("If");
if (ifHeader == null) ifHeader="";
LockInfo toRenew=resourceLocks.get(path);
Enumeration<String> tokenList=null;
if (toRenew != null) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
Enumeration<LockInfo> collectionLocksList=collectionLocks.elements();
while (collectionLocksList.hasMoreElements()) {
toRenew=collectionLocksList.nextElement();
if (path.equals(toRenew.path)) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
}
}
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"prop",XMLWriter.OPENING);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.OPENING);
lock.toXML(generatedXML);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.CLOSING);
generatedXML.writeElement("D","prop",XMLWriter.CLOSING);
resp.setStatus(WebdavStatus.SC_OK);
resp.setContentType("text/xml; charset=UTF-8");
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
}

ID 2303=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doLock(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.servlet.ServletRequest#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * LOCK Method.
 */
protected void doLock(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  LockInfo lock=new LockInfo();
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    lock.depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      lock.depth=0;
    }
 else {
      lock.depth=maxDepth;
    }
  }
  int lockDuration=DEFAULT_TIMEOUT;
  String lockDurationStr=req.getHeader("Timeout");
  if (lockDurationStr == null) {
    lockDuration=DEFAULT_TIMEOUT;
  }
 else {
    int commaPos=lockDurationStr.indexOf(',');
    if (commaPos != -1) {
      lockDurationStr=lockDurationStr.substring(0,commaPos);
    }
    if (lockDurationStr.startsWith("Second-")) {
      lockDuration=Integer.parseInt(lockDurationStr.substring(7));
    }
 else {
      if (lockDurationStr.equalsIgnoreCase("infinity")) {
        lockDuration=MAX_TIMEOUT;
      }
 else {
        try {
          lockDuration=Integer.parseInt(lockDurationStr);
        }
 catch (        NumberFormatException e) {
          lockDuration=MAX_TIMEOUT;
        }
      }
    }
    if (lockDuration == 0) {
      lockDuration=DEFAULT_TIMEOUT;
    }
    if (lockDuration > MAX_TIMEOUT) {
      lockDuration=MAX_TIMEOUT;
    }
  }
  lock.expiresAt=System.currentTimeMillis() + (lockDuration * 1000);
  int lockRequestType=LOCK_CREATION;
  Node lockInfoNode=null;
  DocumentBuilder documentBuilder=getDocumentBuilder();
  try {
    Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
    Element rootElement=document.getDocumentElement();
    lockInfoNode=rootElement;
  }
 catch (  IOException e) {
    lockRequestType=LOCK_REFRESH;
  }
catch (  SAXException e) {
    lockRequestType=LOCK_REFRESH;
  }
  if (lockInfoNode != null) {
    NodeList childList=lockInfoNode.getChildNodes();
    StringWriter strWriter=null;
    DOMWriter domWriter=null;
    Node lockScopeNode=null;
    Node lockTypeNode=null;
    Node lockOwnerNode=null;
    for (int i=0; i < childList.getLength(); i++) {
      Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
        break;
case Node.ELEMENT_NODE:
      String nodeName=currentNode.getNodeName();
    if (nodeName.endsWith("lockscope")) {
      lockScopeNode=currentNode;
    }
  if (nodeName.endsWith("locktype")) {
    lockTypeNode=currentNode;
  }
if (nodeName.endsWith("owner")) {
  lockOwnerNode=currentNode;
}
break;
}
}
if (lockScopeNode != null) {
childList=lockScopeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempScope=currentNode.getNodeName();
if (tempScope.indexOf(':') != -1) {
lock.scope=tempScope.substring(tempScope.indexOf(':') + 1);
}
 else {
lock.scope=tempScope;
}
break;
}
}
if (lock.scope == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockTypeNode != null) {
childList=lockTypeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempType=currentNode.getNodeName();
if (tempType.indexOf(':') != -1) {
lock.type=tempType.substring(tempType.indexOf(':') + 1);
}
 else {
lock.type=tempType;
}
break;
}
}
if (lock.type == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockOwnerNode != null) {
childList=lockOwnerNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
lock.owner+=currentNode.getNodeValue();
break;
case Node.ELEMENT_NODE:
strWriter=new StringWriter();
domWriter=new DOMWriter(strWriter,true);
domWriter.setQualifiedNames(false);
domWriter.print(currentNode);
lock.owner+=strWriter.toString();
break;
}
}
if (lock.owner == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
lock.owner="";
}
}
String path=getRelativePath(req);
lock.path=path;
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
Enumeration<LockInfo> locksList=null;
if (lockRequestType == LOCK_CREATION) {
String lockTokenStr=req.getServletPath() + "-" + lock.type+ "-"+ lock.scope+ "-"+ req.getUserPrincipal()+ "-"+ lock.depth+ "-"+ lock.owner+ "-"+ lock.tokens+ "-"+ lock.expiresAt+ "-"+ System.currentTimeMillis()+ "-"+ secret;
String lockToken=MD5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes(Charset.defaultCharset())));
if ((exists) && (object instanceof DirContext) && (lock.depth == maxDepth)) {
Vector<String> lockPaths=new Vector<String>();
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
locksList=resourceLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
if (!lockPaths.isEmpty()) {
Enumeration<String> lockPathsList=lockPaths.elements();
resp.setStatus(WebdavStatus.SC_CONFLICT);
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
while (lockPathsList.hasMoreElements()) {
generatedXML.writeElement("D","response",XMLWriter.OPENING);
generatedXML.writeElement("D","href",XMLWriter.OPENING);
generatedXML.writeText(lockPathsList.nextElement());
generatedXML.writeElement("D","href",XMLWriter.CLOSING);
generatedXML.writeElement("D","status",XMLWriter.OPENING);
generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " "+ WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED));
generatedXML.writeElement("D","status",XMLWriter.CLOSING);
generatedXML.writeElement("D","response",XMLWriter.CLOSING);
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
return;
}
boolean addLock=true;
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.path.equals(lock.path)) {
if (currentLock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
 else {
if (lock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
}
currentLock.tokens.addElement(lockToken);
lock=currentLock;
addLock=false;
}
}
if (addLock) {
lock.tokens.addElement(lockToken);
collectionLocks.addElement(lock);
}
}
 else {
LockInfo presentLock=resourceLocks.get(lock.path);
if (presentLock != null) {
if ((presentLock.isExclusive()) || (lock.isExclusive())) {
resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
return;
}
 else {
presentLock.tokens.addElement(lockToken);
lock=presentLock;
}
}
 else {
lock.tokens.addElement(lockToken);
resourceLocks.put(lock.path,lock);
exists=true;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
if (!exists) {
int slash=lock.path.lastIndexOf('/');
String parentPath=lock.path.substring(0,slash);
Vector<String> lockNulls=lockNullResources.get(parentPath);
if (lockNulls == null) {
lockNulls=new Vector<String>();
lockNullResources.put(parentPath,lockNulls);
}
lockNulls.addElement(lock.path);
}
resp.addHeader("Lock-Token","<opaquelocktoken:" + lockToken + ">");
}
}
}
if (lockRequestType == LOCK_REFRESH) {
String ifHeader=req.getHeader("If");
if (ifHeader == null) ifHeader="";
LockInfo toRenew=resourceLocks.get(path);
Enumeration<String> tokenList=null;
if (toRenew != null) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
Enumeration<LockInfo> collectionLocksList=collectionLocks.elements();
while (collectionLocksList.hasMoreElements()) {
toRenew=collectionLocksList.nextElement();
if (path.equals(toRenew.path)) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
}
}
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"prop",XMLWriter.OPENING);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.OPENING);
lock.toXML(generatedXML);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.CLOSING);
generatedXML.writeElement("D","prop",XMLWriter.CLOSING);
resp.setStatus(WebdavStatus.SC_OK);
resp.setContentType("text/xml; charset=UTF-8");
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
}

ID 2304=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doLock(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(org.xml.sax.InputSource)
parentException: 
thrown: SAXException
exception comment: /** 
 * Encapsulate a general SAX error or warning. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>This class can contain basic error or warning information from either the XML parser or the application: a parser writer or application writer can subclass it to provide additional functionality.  SAX handlers may throw this exception or any exception subclassed from it.</p> <p>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</p> <p>If the parser or application needs to include information about a specific location in an XML document, it should use the {@link org.xml.sax.SAXParseException SAXParseException} subclass.</p>
 * @since SAX 1.0
 * @author David Megginson
 * @version 2.0.1 (sax2r2)
 * @see org.xml.sax.SAXParseException
 */

block: 
/** 
 * LOCK Method.
 */
protected void doLock(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  LockInfo lock=new LockInfo();
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    lock.depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      lock.depth=0;
    }
 else {
      lock.depth=maxDepth;
    }
  }
  int lockDuration=DEFAULT_TIMEOUT;
  String lockDurationStr=req.getHeader("Timeout");
  if (lockDurationStr == null) {
    lockDuration=DEFAULT_TIMEOUT;
  }
 else {
    int commaPos=lockDurationStr.indexOf(',');
    if (commaPos != -1) {
      lockDurationStr=lockDurationStr.substring(0,commaPos);
    }
    if (lockDurationStr.startsWith("Second-")) {
      lockDuration=Integer.parseInt(lockDurationStr.substring(7));
    }
 else {
      if (lockDurationStr.equalsIgnoreCase("infinity")) {
        lockDuration=MAX_TIMEOUT;
      }
 else {
        try {
          lockDuration=Integer.parseInt(lockDurationStr);
        }
 catch (        NumberFormatException e) {
          lockDuration=MAX_TIMEOUT;
        }
      }
    }
    if (lockDuration == 0) {
      lockDuration=DEFAULT_TIMEOUT;
    }
    if (lockDuration > MAX_TIMEOUT) {
      lockDuration=MAX_TIMEOUT;
    }
  }
  lock.expiresAt=System.currentTimeMillis() + (lockDuration * 1000);
  int lockRequestType=LOCK_CREATION;
  Node lockInfoNode=null;
  DocumentBuilder documentBuilder=getDocumentBuilder();
  try {
    Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
    Element rootElement=document.getDocumentElement();
    lockInfoNode=rootElement;
  }
 catch (  IOException e) {
    lockRequestType=LOCK_REFRESH;
  }
catch (  SAXException e) {
    lockRequestType=LOCK_REFRESH;
  }
  if (lockInfoNode != null) {
    NodeList childList=lockInfoNode.getChildNodes();
    StringWriter strWriter=null;
    DOMWriter domWriter=null;
    Node lockScopeNode=null;
    Node lockTypeNode=null;
    Node lockOwnerNode=null;
    for (int i=0; i < childList.getLength(); i++) {
      Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
        break;
case Node.ELEMENT_NODE:
      String nodeName=currentNode.getNodeName();
    if (nodeName.endsWith("lockscope")) {
      lockScopeNode=currentNode;
    }
  if (nodeName.endsWith("locktype")) {
    lockTypeNode=currentNode;
  }
if (nodeName.endsWith("owner")) {
  lockOwnerNode=currentNode;
}
break;
}
}
if (lockScopeNode != null) {
childList=lockScopeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempScope=currentNode.getNodeName();
if (tempScope.indexOf(':') != -1) {
lock.scope=tempScope.substring(tempScope.indexOf(':') + 1);
}
 else {
lock.scope=tempScope;
}
break;
}
}
if (lock.scope == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockTypeNode != null) {
childList=lockTypeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempType=currentNode.getNodeName();
if (tempType.indexOf(':') != -1) {
lock.type=tempType.substring(tempType.indexOf(':') + 1);
}
 else {
lock.type=tempType;
}
break;
}
}
if (lock.type == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockOwnerNode != null) {
childList=lockOwnerNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
lock.owner+=currentNode.getNodeValue();
break;
case Node.ELEMENT_NODE:
strWriter=new StringWriter();
domWriter=new DOMWriter(strWriter,true);
domWriter.setQualifiedNames(false);
domWriter.print(currentNode);
lock.owner+=strWriter.toString();
break;
}
}
if (lock.owner == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
lock.owner="";
}
}
String path=getRelativePath(req);
lock.path=path;
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
Enumeration<LockInfo> locksList=null;
if (lockRequestType == LOCK_CREATION) {
String lockTokenStr=req.getServletPath() + "-" + lock.type+ "-"+ lock.scope+ "-"+ req.getUserPrincipal()+ "-"+ lock.depth+ "-"+ lock.owner+ "-"+ lock.tokens+ "-"+ lock.expiresAt+ "-"+ System.currentTimeMillis()+ "-"+ secret;
String lockToken=MD5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes(Charset.defaultCharset())));
if ((exists) && (object instanceof DirContext) && (lock.depth == maxDepth)) {
Vector<String> lockPaths=new Vector<String>();
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
locksList=resourceLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
if (!lockPaths.isEmpty()) {
Enumeration<String> lockPathsList=lockPaths.elements();
resp.setStatus(WebdavStatus.SC_CONFLICT);
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
while (lockPathsList.hasMoreElements()) {
generatedXML.writeElement("D","response",XMLWriter.OPENING);
generatedXML.writeElement("D","href",XMLWriter.OPENING);
generatedXML.writeText(lockPathsList.nextElement());
generatedXML.writeElement("D","href",XMLWriter.CLOSING);
generatedXML.writeElement("D","status",XMLWriter.OPENING);
generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " "+ WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED));
generatedXML.writeElement("D","status",XMLWriter.CLOSING);
generatedXML.writeElement("D","response",XMLWriter.CLOSING);
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
return;
}
boolean addLock=true;
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.path.equals(lock.path)) {
if (currentLock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
 else {
if (lock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
}
currentLock.tokens.addElement(lockToken);
lock=currentLock;
addLock=false;
}
}
if (addLock) {
lock.tokens.addElement(lockToken);
collectionLocks.addElement(lock);
}
}
 else {
LockInfo presentLock=resourceLocks.get(lock.path);
if (presentLock != null) {
if ((presentLock.isExclusive()) || (lock.isExclusive())) {
resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
return;
}
 else {
presentLock.tokens.addElement(lockToken);
lock=presentLock;
}
}
 else {
lock.tokens.addElement(lockToken);
resourceLocks.put(lock.path,lock);
exists=true;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
if (!exists) {
int slash=lock.path.lastIndexOf('/');
String parentPath=lock.path.substring(0,slash);
Vector<String> lockNulls=lockNullResources.get(parentPath);
if (lockNulls == null) {
lockNulls=new Vector<String>();
lockNullResources.put(parentPath,lockNulls);
}
lockNulls.addElement(lock.path);
}
resp.addHeader("Lock-Token","<opaquelocktoken:" + lockToken + ">");
}
}
}
if (lockRequestType == LOCK_REFRESH) {
String ifHeader=req.getHeader("If");
if (ifHeader == null) ifHeader="";
LockInfo toRenew=resourceLocks.get(path);
Enumeration<String> tokenList=null;
if (toRenew != null) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
Enumeration<LockInfo> collectionLocksList=collectionLocks.elements();
while (collectionLocksList.hasMoreElements()) {
toRenew=collectionLocksList.nextElement();
if (path.equals(toRenew.path)) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
}
}
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"prop",XMLWriter.OPENING);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.OPENING);
lock.toXML(generatedXML);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.CLOSING);
generatedXML.writeElement("D","prop",XMLWriter.CLOSING);
resp.setStatus(WebdavStatus.SC_OK);
resp.setContentType("text/xml; charset=UTF-8");
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
}

ID 2305=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doLock(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(org.xml.sax.InputSource)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * LOCK Method.
 */
protected void doLock(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  LockInfo lock=new LockInfo();
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    lock.depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      lock.depth=0;
    }
 else {
      lock.depth=maxDepth;
    }
  }
  int lockDuration=DEFAULT_TIMEOUT;
  String lockDurationStr=req.getHeader("Timeout");
  if (lockDurationStr == null) {
    lockDuration=DEFAULT_TIMEOUT;
  }
 else {
    int commaPos=lockDurationStr.indexOf(',');
    if (commaPos != -1) {
      lockDurationStr=lockDurationStr.substring(0,commaPos);
    }
    if (lockDurationStr.startsWith("Second-")) {
      lockDuration=Integer.parseInt(lockDurationStr.substring(7));
    }
 else {
      if (lockDurationStr.equalsIgnoreCase("infinity")) {
        lockDuration=MAX_TIMEOUT;
      }
 else {
        try {
          lockDuration=Integer.parseInt(lockDurationStr);
        }
 catch (        NumberFormatException e) {
          lockDuration=MAX_TIMEOUT;
        }
      }
    }
    if (lockDuration == 0) {
      lockDuration=DEFAULT_TIMEOUT;
    }
    if (lockDuration > MAX_TIMEOUT) {
      lockDuration=MAX_TIMEOUT;
    }
  }
  lock.expiresAt=System.currentTimeMillis() + (lockDuration * 1000);
  int lockRequestType=LOCK_CREATION;
  Node lockInfoNode=null;
  DocumentBuilder documentBuilder=getDocumentBuilder();
  try {
    Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
    Element rootElement=document.getDocumentElement();
    lockInfoNode=rootElement;
  }
 catch (  IOException e) {
    lockRequestType=LOCK_REFRESH;
  }
catch (  SAXException e) {
    lockRequestType=LOCK_REFRESH;
  }
  if (lockInfoNode != null) {
    NodeList childList=lockInfoNode.getChildNodes();
    StringWriter strWriter=null;
    DOMWriter domWriter=null;
    Node lockScopeNode=null;
    Node lockTypeNode=null;
    Node lockOwnerNode=null;
    for (int i=0; i < childList.getLength(); i++) {
      Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
        break;
case Node.ELEMENT_NODE:
      String nodeName=currentNode.getNodeName();
    if (nodeName.endsWith("lockscope")) {
      lockScopeNode=currentNode;
    }
  if (nodeName.endsWith("locktype")) {
    lockTypeNode=currentNode;
  }
if (nodeName.endsWith("owner")) {
  lockOwnerNode=currentNode;
}
break;
}
}
if (lockScopeNode != null) {
childList=lockScopeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempScope=currentNode.getNodeName();
if (tempScope.indexOf(':') != -1) {
lock.scope=tempScope.substring(tempScope.indexOf(':') + 1);
}
 else {
lock.scope=tempScope;
}
break;
}
}
if (lock.scope == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockTypeNode != null) {
childList=lockTypeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempType=currentNode.getNodeName();
if (tempType.indexOf(':') != -1) {
lock.type=tempType.substring(tempType.indexOf(':') + 1);
}
 else {
lock.type=tempType;
}
break;
}
}
if (lock.type == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockOwnerNode != null) {
childList=lockOwnerNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
lock.owner+=currentNode.getNodeValue();
break;
case Node.ELEMENT_NODE:
strWriter=new StringWriter();
domWriter=new DOMWriter(strWriter,true);
domWriter.setQualifiedNames(false);
domWriter.print(currentNode);
lock.owner+=strWriter.toString();
break;
}
}
if (lock.owner == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
lock.owner="";
}
}
String path=getRelativePath(req);
lock.path=path;
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
Enumeration<LockInfo> locksList=null;
if (lockRequestType == LOCK_CREATION) {
String lockTokenStr=req.getServletPath() + "-" + lock.type+ "-"+ lock.scope+ "-"+ req.getUserPrincipal()+ "-"+ lock.depth+ "-"+ lock.owner+ "-"+ lock.tokens+ "-"+ lock.expiresAt+ "-"+ System.currentTimeMillis()+ "-"+ secret;
String lockToken=MD5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes(Charset.defaultCharset())));
if ((exists) && (object instanceof DirContext) && (lock.depth == maxDepth)) {
Vector<String> lockPaths=new Vector<String>();
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
locksList=resourceLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
if (!lockPaths.isEmpty()) {
Enumeration<String> lockPathsList=lockPaths.elements();
resp.setStatus(WebdavStatus.SC_CONFLICT);
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
while (lockPathsList.hasMoreElements()) {
generatedXML.writeElement("D","response",XMLWriter.OPENING);
generatedXML.writeElement("D","href",XMLWriter.OPENING);
generatedXML.writeText(lockPathsList.nextElement());
generatedXML.writeElement("D","href",XMLWriter.CLOSING);
generatedXML.writeElement("D","status",XMLWriter.OPENING);
generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " "+ WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED));
generatedXML.writeElement("D","status",XMLWriter.CLOSING);
generatedXML.writeElement("D","response",XMLWriter.CLOSING);
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
return;
}
boolean addLock=true;
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.path.equals(lock.path)) {
if (currentLock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
 else {
if (lock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
}
currentLock.tokens.addElement(lockToken);
lock=currentLock;
addLock=false;
}
}
if (addLock) {
lock.tokens.addElement(lockToken);
collectionLocks.addElement(lock);
}
}
 else {
LockInfo presentLock=resourceLocks.get(lock.path);
if (presentLock != null) {
if ((presentLock.isExclusive()) || (lock.isExclusive())) {
resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
return;
}
 else {
presentLock.tokens.addElement(lockToken);
lock=presentLock;
}
}
 else {
lock.tokens.addElement(lockToken);
resourceLocks.put(lock.path,lock);
exists=true;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
if (!exists) {
int slash=lock.path.lastIndexOf('/');
String parentPath=lock.path.substring(0,slash);
Vector<String> lockNulls=lockNullResources.get(parentPath);
if (lockNulls == null) {
lockNulls=new Vector<String>();
lockNullResources.put(parentPath,lockNulls);
}
lockNulls.addElement(lock.path);
}
resp.addHeader("Lock-Token","<opaquelocktoken:" + lockToken + ">");
}
}
}
if (lockRequestType == LOCK_REFRESH) {
String ifHeader=req.getHeader("If");
if (ifHeader == null) ifHeader="";
LockInfo toRenew=resourceLocks.get(path);
Enumeration<String> tokenList=null;
if (toRenew != null) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
Enumeration<LockInfo> collectionLocksList=collectionLocks.elements();
while (collectionLocksList.hasMoreElements()) {
toRenew=collectionLocksList.nextElement();
if (path.equals(toRenew.path)) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
}
}
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"prop",XMLWriter.OPENING);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.OPENING);
lock.toXML(generatedXML);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.CLOSING);
generatedXML.writeElement("D","prop",XMLWriter.CLOSING);
resp.setStatus(WebdavStatus.SC_OK);
resp.setContentType("text/xml; charset=UTF-8");
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
}

ID 2307=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#doLock(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * LOCK Method.
 */
protected void doLock(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (readOnly) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return;
  }
  if (isLocked(req)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return;
  }
  LockInfo lock=new LockInfo();
  String depthStr=req.getHeader("Depth");
  if (depthStr == null) {
    lock.depth=maxDepth;
  }
 else {
    if (depthStr.equals("0")) {
      lock.depth=0;
    }
 else {
      lock.depth=maxDepth;
    }
  }
  int lockDuration=DEFAULT_TIMEOUT;
  String lockDurationStr=req.getHeader("Timeout");
  if (lockDurationStr == null) {
    lockDuration=DEFAULT_TIMEOUT;
  }
 else {
    int commaPos=lockDurationStr.indexOf(',');
    if (commaPos != -1) {
      lockDurationStr=lockDurationStr.substring(0,commaPos);
    }
    if (lockDurationStr.startsWith("Second-")) {
      lockDuration=Integer.parseInt(lockDurationStr.substring(7));
    }
 else {
      if (lockDurationStr.equalsIgnoreCase("infinity")) {
        lockDuration=MAX_TIMEOUT;
      }
 else {
        try {
          lockDuration=Integer.parseInt(lockDurationStr);
        }
 catch (        NumberFormatException e) {
          lockDuration=MAX_TIMEOUT;
        }
      }
    }
    if (lockDuration == 0) {
      lockDuration=DEFAULT_TIMEOUT;
    }
    if (lockDuration > MAX_TIMEOUT) {
      lockDuration=MAX_TIMEOUT;
    }
  }
  lock.expiresAt=System.currentTimeMillis() + (lockDuration * 1000);
  int lockRequestType=LOCK_CREATION;
  Node lockInfoNode=null;
  DocumentBuilder documentBuilder=getDocumentBuilder();
  try {
    Document document=documentBuilder.parse(new InputSource(req.getInputStream()));
    Element rootElement=document.getDocumentElement();
    lockInfoNode=rootElement;
  }
 catch (  IOException e) {
    lockRequestType=LOCK_REFRESH;
  }
catch (  SAXException e) {
    lockRequestType=LOCK_REFRESH;
  }
  if (lockInfoNode != null) {
    NodeList childList=lockInfoNode.getChildNodes();
    StringWriter strWriter=null;
    DOMWriter domWriter=null;
    Node lockScopeNode=null;
    Node lockTypeNode=null;
    Node lockOwnerNode=null;
    for (int i=0; i < childList.getLength(); i++) {
      Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
        break;
case Node.ELEMENT_NODE:
      String nodeName=currentNode.getNodeName();
    if (nodeName.endsWith("lockscope")) {
      lockScopeNode=currentNode;
    }
  if (nodeName.endsWith("locktype")) {
    lockTypeNode=currentNode;
  }
if (nodeName.endsWith("owner")) {
  lockOwnerNode=currentNode;
}
break;
}
}
if (lockScopeNode != null) {
childList=lockScopeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempScope=currentNode.getNodeName();
if (tempScope.indexOf(':') != -1) {
lock.scope=tempScope.substring(tempScope.indexOf(':') + 1);
}
 else {
lock.scope=tempScope;
}
break;
}
}
if (lock.scope == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockTypeNode != null) {
childList=lockTypeNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
break;
case Node.ELEMENT_NODE:
String tempType=currentNode.getNodeName();
if (tempType.indexOf(':') != -1) {
lock.type=tempType.substring(tempType.indexOf(':') + 1);
}
 else {
lock.type=tempType;
}
break;
}
}
if (lock.type == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
if (lockOwnerNode != null) {
childList=lockOwnerNode.getChildNodes();
for (int i=0; i < childList.getLength(); i++) {
Node currentNode=childList.item(i);
switch (currentNode.getNodeType()) {
case Node.TEXT_NODE:
lock.owner+=currentNode.getNodeValue();
break;
case Node.ELEMENT_NODE:
strWriter=new StringWriter();
domWriter=new DOMWriter(strWriter,true);
domWriter.setQualifiedNames(false);
domWriter.print(currentNode);
lock.owner+=strWriter.toString();
break;
}
}
if (lock.owner == null) {
resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
}
}
 else {
lock.owner="";
}
}
String path=getRelativePath(req);
lock.path=path;
boolean exists=true;
Object object=null;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
Enumeration<LockInfo> locksList=null;
if (lockRequestType == LOCK_CREATION) {
String lockTokenStr=req.getServletPath() + "-" + lock.type+ "-"+ lock.scope+ "-"+ req.getUserPrincipal()+ "-"+ lock.depth+ "-"+ lock.owner+ "-"+ lock.tokens+ "-"+ lock.expiresAt+ "-"+ System.currentTimeMillis()+ "-"+ secret;
String lockToken=MD5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes(Charset.defaultCharset())));
if ((exists) && (object instanceof DirContext) && (lock.depth == maxDepth)) {
Vector<String> lockPaths=new Vector<String>();
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
locksList=resourceLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.hasExpired()) {
resourceLocks.remove(currentLock.path);
continue;
}
if ((currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive()))) {
lockPaths.addElement(currentLock.path);
}
}
if (!lockPaths.isEmpty()) {
Enumeration<String> lockPathsList=lockPaths.elements();
resp.setStatus(WebdavStatus.SC_CONFLICT);
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"multistatus",XMLWriter.OPENING);
while (lockPathsList.hasMoreElements()) {
generatedXML.writeElement("D","response",XMLWriter.OPENING);
generatedXML.writeElement("D","href",XMLWriter.OPENING);
generatedXML.writeText(lockPathsList.nextElement());
generatedXML.writeElement("D","href",XMLWriter.CLOSING);
generatedXML.writeElement("D","status",XMLWriter.OPENING);
generatedXML.writeText("HTTP/1.1 " + WebdavStatus.SC_LOCKED + " "+ WebdavStatus.getStatusText(WebdavStatus.SC_LOCKED));
generatedXML.writeElement("D","status",XMLWriter.CLOSING);
generatedXML.writeElement("D","response",XMLWriter.CLOSING);
}
generatedXML.writeElement("D","multistatus",XMLWriter.CLOSING);
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
return;
}
boolean addLock=true;
locksList=collectionLocks.elements();
while (locksList.hasMoreElements()) {
LockInfo currentLock=locksList.nextElement();
if (currentLock.path.equals(lock.path)) {
if (currentLock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
 else {
if (lock.isExclusive()) {
resp.sendError(WebdavStatus.SC_LOCKED);
return;
}
}
currentLock.tokens.addElement(lockToken);
lock=currentLock;
addLock=false;
}
}
if (addLock) {
lock.tokens.addElement(lockToken);
collectionLocks.addElement(lock);
}
}
 else {
LockInfo presentLock=resourceLocks.get(lock.path);
if (presentLock != null) {
if ((presentLock.isExclusive()) || (lock.isExclusive())) {
resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
return;
}
 else {
presentLock.tokens.addElement(lockToken);
lock=presentLock;
}
}
 else {
lock.tokens.addElement(lockToken);
resourceLocks.put(lock.path,lock);
exists=true;
try {
object=resources.lookup(path);
}
 catch (NamingException e) {
exists=false;
}
if (!exists) {
int slash=lock.path.lastIndexOf('/');
String parentPath=lock.path.substring(0,slash);
Vector<String> lockNulls=lockNullResources.get(parentPath);
if (lockNulls == null) {
lockNulls=new Vector<String>();
lockNullResources.put(parentPath,lockNulls);
}
lockNulls.addElement(lock.path);
}
resp.addHeader("Lock-Token","<opaquelocktoken:" + lockToken + ">");
}
}
}
if (lockRequestType == LOCK_REFRESH) {
String ifHeader=req.getHeader("If");
if (ifHeader == null) ifHeader="";
LockInfo toRenew=resourceLocks.get(path);
Enumeration<String> tokenList=null;
if (toRenew != null) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
Enumeration<LockInfo> collectionLocksList=collectionLocks.elements();
while (collectionLocksList.hasMoreElements()) {
toRenew=collectionLocksList.nextElement();
if (path.equals(toRenew.path)) {
tokenList=toRenew.tokens.elements();
while (tokenList.hasMoreElements()) {
String token=tokenList.nextElement();
if (ifHeader.indexOf(token) != -1) {
toRenew.expiresAt=lock.expiresAt;
lock=toRenew;
}
}
}
}
}
XMLWriter generatedXML=new XMLWriter();
generatedXML.writeXMLHeader();
generatedXML.writeElement("D",DEFAULT_NAMESPACE,"prop",XMLWriter.OPENING);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.OPENING);
lock.toXML(generatedXML);
generatedXML.writeElement("D","lockdiscovery",XMLWriter.CLOSING);
generatedXML.writeElement("D","prop",XMLWriter.CLOSING);
resp.setStatus(WebdavStatus.SC_OK);
resp.setContentType("text/xml; charset=UTF-8");
Writer writer=resp.getWriter();
writer.write(generatedXML.toString());
writer.close();
}

ID 2314=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#copyResource(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Copy a resource.
 * @param req Servlet request
 * @param resp Servlet response
 * @return boolean true if the copy is successful
 */
private boolean copyResource(HttpServletRequest req,HttpServletResponse resp) throws IOException {
  String destinationPath=req.getHeader("Destination");
  if (destinationPath == null) {
    resp.sendError(WebdavStatus.SC_BAD_REQUEST);
    return false;
  }
  destinationPath=org.apache.catalina.util.RequestUtil.URLDecode(destinationPath,"UTF8");
  int protocolIndex=destinationPath.indexOf("://");
  if (protocolIndex >= 0) {
    int firstSeparator=destinationPath.indexOf('/',protocolIndex + 4);
    if (firstSeparator < 0) {
      destinationPath="/";
    }
 else {
      destinationPath=destinationPath.substring(firstSeparator);
    }
  }
 else {
    String hostName=req.getServerName();
    if ((hostName != null) && (destinationPath.startsWith(hostName))) {
      destinationPath=destinationPath.substring(hostName.length());
    }
    int portIndex=destinationPath.indexOf(':');
    if (portIndex >= 0) {
      destinationPath=destinationPath.substring(portIndex);
    }
    if (destinationPath.startsWith(":")) {
      int firstSeparator=destinationPath.indexOf('/');
      if (firstSeparator < 0) {
        destinationPath="/";
      }
 else {
        destinationPath=destinationPath.substring(firstSeparator);
      }
    }
  }
  destinationPath=RequestUtil.normalize(destinationPath);
  String contextPath=req.getContextPath();
  if ((contextPath != null) && (destinationPath.startsWith(contextPath))) {
    destinationPath=destinationPath.substring(contextPath.length());
  }
  String pathInfo=req.getPathInfo();
  if (pathInfo != null) {
    String servletPath=req.getServletPath();
    if ((servletPath != null) && (destinationPath.startsWith(servletPath))) {
      destinationPath=destinationPath.substring(servletPath.length());
    }
  }
  if (debug > 0)   log("Dest path :" + destinationPath);
  if (isSpecialPath(destinationPath)) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return false;
  }
  String path=getRelativePath(req);
  if (destinationPath.equals(path)) {
    resp.sendError(WebdavStatus.SC_FORBIDDEN);
    return false;
  }
  boolean overwrite=true;
  String overwriteHeader=req.getHeader("Overwrite");
  if (overwriteHeader != null) {
    if (overwriteHeader.equalsIgnoreCase("T")) {
      overwrite=true;
    }
 else {
      overwrite=false;
    }
  }
  boolean exists=true;
  try {
    resources.lookup(destinationPath);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (overwrite) {
    if (exists) {
      if (!deleteResource(destinationPath,req,resp,true)) {
        return false;
      }
    }
 else {
      resp.setStatus(WebdavStatus.SC_CREATED);
    }
  }
 else {
    if (exists) {
      resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
      return false;
    }
  }
  Hashtable<String,Integer> errorList=new Hashtable<String,Integer>();
  boolean result=copyResource(resources,errorList,path,destinationPath);
  if ((!result) || (!errorList.isEmpty())) {
    if (errorList.size() == 1) {
      resp.sendError(errorList.elements().nextElement().intValue());
    }
 else {
      sendReport(req,resp,errorList);
    }
    return false;
  }
  if (exists) {
    resp.setStatus(WebdavStatus.SC_NO_CONTENT);
  }
 else {
    resp.setStatus(WebdavStatus.SC_CREATED);
  }
  lockNullResources.remove(destinationPath);
  return true;
}

ID 2318=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#copyResource(javax.naming.directory.DirContext, Hashtable<java.lang.String,java.lang.Integer>, java.lang.String, java.lang.String)
Rmethod: javax.naming.Context#createSubcontext(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Copy a collection.
 * @param dirContext Resources implementation to be used
 * @param errorList Hashtable containing the list of errors which occurredduring the copy operation
 * @param source Path of the resource to be copied
 * @param dest Destination path
 */
private boolean copyResource(DirContext dirContext,Hashtable<String,Integer> errorList,String source,String dest){
  if (debug > 1)   log("Copy: " + source + " To: "+ dest);
  Object object=null;
  try {
    object=dirContext.lookup(source);
  }
 catch (  NamingException e) {
  }
  if (object instanceof DirContext) {
    try {
      dirContext.createSubcontext(dest);
    }
 catch (    NamingException e) {
      errorList.put(dest,Integer.valueOf(WebdavStatus.SC_CONFLICT));
      return false;
    }
    try {
      NamingEnumeration<NameClassPair> enumeration=dirContext.list(source);
      while (enumeration.hasMoreElements()) {
        NameClassPair ncPair=enumeration.nextElement();
        String childDest=dest;
        if (!childDest.equals("/"))         childDest+="/";
        childDest+=ncPair.getName();
        String childSrc=source;
        if (!childSrc.equals("/"))         childSrc+="/";
        childSrc+=ncPair.getName();
        copyResource(dirContext,errorList,childSrc,childDest);
      }
    }
 catch (    NamingException e) {
      errorList.put(dest,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      return false;
    }
  }
 else {
    if (object instanceof Resource) {
      try {
        dirContext.bind(dest,object);
      }
 catch (      NamingException e) {
        if (e.getCause() instanceof FileNotFoundException) {
          errorList.put(source,Integer.valueOf(WebdavStatus.SC_CONFLICT));
        }
 else {
          errorList.put(source,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
        }
        return false;
      }
    }
 else {
      errorList.put(source,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      return false;
    }
  }
  return true;
}

ID 2319=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#copyResource(javax.naming.directory.DirContext, Hashtable<java.lang.String,java.lang.Integer>, java.lang.String, java.lang.String)
Rmethod: javax.naming.Context#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Copy a collection.
 * @param dirContext Resources implementation to be used
 * @param errorList Hashtable containing the list of errors which occurredduring the copy operation
 * @param source Path of the resource to be copied
 * @param dest Destination path
 */
private boolean copyResource(DirContext dirContext,Hashtable<String,Integer> errorList,String source,String dest){
  if (debug > 1)   log("Copy: " + source + " To: "+ dest);
  Object object=null;
  try {
    object=dirContext.lookup(source);
  }
 catch (  NamingException e) {
  }
  if (object instanceof DirContext) {
    try {
      dirContext.createSubcontext(dest);
    }
 catch (    NamingException e) {
      errorList.put(dest,Integer.valueOf(WebdavStatus.SC_CONFLICT));
      return false;
    }
    try {
      NamingEnumeration<NameClassPair> enumeration=dirContext.list(source);
      while (enumeration.hasMoreElements()) {
        NameClassPair ncPair=enumeration.nextElement();
        String childDest=dest;
        if (!childDest.equals("/"))         childDest+="/";
        childDest+=ncPair.getName();
        String childSrc=source;
        if (!childSrc.equals("/"))         childSrc+="/";
        childSrc+=ncPair.getName();
        copyResource(dirContext,errorList,childSrc,childDest);
      }
    }
 catch (    NamingException e) {
      errorList.put(dest,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      return false;
    }
  }
 else {
    if (object instanceof Resource) {
      try {
        dirContext.bind(dest,object);
      }
 catch (      NamingException e) {
        if (e.getCause() instanceof FileNotFoundException) {
          errorList.put(source,Integer.valueOf(WebdavStatus.SC_CONFLICT));
        }
 else {
          errorList.put(source,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
        }
        return false;
      }
    }
 else {
      errorList.put(source,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      return false;
    }
  }
  return true;
}

ID 2320=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#copyResource(javax.naming.directory.DirContext, Hashtable<java.lang.String,java.lang.Integer>, java.lang.String, java.lang.String)
Rmethod: javax.naming.Context#bind(java.lang.String, java.lang.Object)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Copy a collection.
 * @param dirContext Resources implementation to be used
 * @param errorList Hashtable containing the list of errors which occurredduring the copy operation
 * @param source Path of the resource to be copied
 * @param dest Destination path
 */
private boolean copyResource(DirContext dirContext,Hashtable<String,Integer> errorList,String source,String dest){
  if (debug > 1)   log("Copy: " + source + " To: "+ dest);
  Object object=null;
  try {
    object=dirContext.lookup(source);
  }
 catch (  NamingException e) {
  }
  if (object instanceof DirContext) {
    try {
      dirContext.createSubcontext(dest);
    }
 catch (    NamingException e) {
      errorList.put(dest,Integer.valueOf(WebdavStatus.SC_CONFLICT));
      return false;
    }
    try {
      NamingEnumeration<NameClassPair> enumeration=dirContext.list(source);
      while (enumeration.hasMoreElements()) {
        NameClassPair ncPair=enumeration.nextElement();
        String childDest=dest;
        if (!childDest.equals("/"))         childDest+="/";
        childDest+=ncPair.getName();
        String childSrc=source;
        if (!childSrc.equals("/"))         childSrc+="/";
        childSrc+=ncPair.getName();
        copyResource(dirContext,errorList,childSrc,childDest);
      }
    }
 catch (    NamingException e) {
      errorList.put(dest,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      return false;
    }
  }
 else {
    if (object instanceof Resource) {
      try {
        dirContext.bind(dest,object);
      }
 catch (      NamingException e) {
        if (e.getCause() instanceof FileNotFoundException) {
          errorList.put(source,Integer.valueOf(WebdavStatus.SC_CONFLICT));
        }
 else {
          errorList.put(source,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
        }
        return false;
      }
    }
 else {
      errorList.put(source,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      return false;
    }
  }
  return true;
}

ID 2323=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#deleteResource(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: org.apache.naming.resources.ProxyDirContext#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Delete a resource.
 * @param path Path of the resource which is to be deleted
 * @param req Servlet request
 * @param resp Servlet response
 * @param setStatus Should the response status be set on successfulcompletion
 */
private boolean deleteResource(String path,HttpServletRequest req,HttpServletResponse resp,boolean setStatus) throws IOException {
  String ifHeader=req.getHeader("If");
  if (ifHeader == null)   ifHeader="";
  String lockTokenHeader=req.getHeader("Lock-Token");
  if (lockTokenHeader == null)   lockTokenHeader="";
  if (isLocked(path,ifHeader + lockTokenHeader)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return false;
  }
  boolean exists=true;
  Object object=null;
  try {
    object=resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (!exists) {
    resp.sendError(WebdavStatus.SC_NOT_FOUND);
    return false;
  }
  boolean collection=(object instanceof DirContext);
  if (!collection) {
    try {
      resources.unbind(path);
    }
 catch (    NamingException e) {
      resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
      return false;
    }
  }
 else {
    Hashtable<String,Integer> errorList=new Hashtable<String,Integer>();
    deleteCollection(req,resources,path,errorList);
    try {
      resources.unbind(path);
    }
 catch (    NamingException e) {
      errorList.put(path,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
    }
    if (!errorList.isEmpty()) {
      sendReport(req,resp,errorList);
      return false;
    }
  }
  if (setStatus) {
    resp.setStatus(WebdavStatus.SC_NO_CONTENT);
  }
  return true;
}

ID 2324=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#deleteResource(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: org.apache.naming.resources.ProxyDirContext#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Delete a resource.
 * @param path Path of the resource which is to be deleted
 * @param req Servlet request
 * @param resp Servlet response
 * @param setStatus Should the response status be set on successfulcompletion
 */
private boolean deleteResource(String path,HttpServletRequest req,HttpServletResponse resp,boolean setStatus) throws IOException {
  String ifHeader=req.getHeader("If");
  if (ifHeader == null)   ifHeader="";
  String lockTokenHeader=req.getHeader("Lock-Token");
  if (lockTokenHeader == null)   lockTokenHeader="";
  if (isLocked(path,ifHeader + lockTokenHeader)) {
    resp.sendError(WebdavStatus.SC_LOCKED);
    return false;
  }
  boolean exists=true;
  Object object=null;
  try {
    object=resources.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (!exists) {
    resp.sendError(WebdavStatus.SC_NOT_FOUND);
    return false;
  }
  boolean collection=(object instanceof DirContext);
  if (!collection) {
    try {
      resources.unbind(path);
    }
 catch (    NamingException e) {
      resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
      return false;
    }
  }
 else {
    Hashtable<String,Integer> errorList=new Hashtable<String,Integer>();
    deleteCollection(req,resources,path,errorList);
    try {
      resources.unbind(path);
    }
 catch (    NamingException e) {
      errorList.put(path,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
    }
    if (!errorList.isEmpty()) {
      sendReport(req,resp,errorList);
      return false;
    }
  }
  if (setStatus) {
    resp.setStatus(WebdavStatus.SC_NO_CONTENT);
  }
  return true;
}

ID 2326=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#deleteCollection(javax.servlet.http.HttpServletRequest, javax.naming.directory.DirContext, java.lang.String, Hashtable<java.lang.String,java.lang.Integer>)
Rmethod: javax.naming.Context#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Deletes a collection.
 * @param dirContext Resources implementation associated with the context
 * @param path Path to the collection to be deleted
 * @param errorList Contains the list of the errors which occurred
 */
private void deleteCollection(HttpServletRequest req,DirContext dirContext,String path,Hashtable<String,Integer> errorList){
  if (debug > 1)   log("Delete:" + path);
  if (isSpecialPath(path)) {
    errorList.put(path,Integer.valueOf(WebdavStatus.SC_FORBIDDEN));
    return;
  }
  String ifHeader=req.getHeader("If");
  if (ifHeader == null)   ifHeader="";
  String lockTokenHeader=req.getHeader("Lock-Token");
  if (lockTokenHeader == null)   lockTokenHeader="";
  Enumeration<NameClassPair> enumeration=null;
  try {
    enumeration=dirContext.list(path);
  }
 catch (  NamingException e) {
    errorList.put(path,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
    return;
  }
  while (enumeration.hasMoreElements()) {
    NameClassPair ncPair=enumeration.nextElement();
    String childName=path;
    if (!childName.equals("/"))     childName+="/";
    childName+=ncPair.getName();
    if (isLocked(childName,ifHeader + lockTokenHeader)) {
      errorList.put(childName,Integer.valueOf(WebdavStatus.SC_LOCKED));
    }
 else {
      try {
        Object object=dirContext.lookup(childName);
        if (object instanceof DirContext) {
          deleteCollection(req,dirContext,childName,errorList);
        }
        try {
          dirContext.unbind(childName);
        }
 catch (        NamingException e) {
          if (!(object instanceof DirContext)) {
            errorList.put(childName,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
          }
        }
      }
 catch (      NamingException e) {
        errorList.put(childName,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      }
    }
  }
}

ID 2327=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#deleteCollection(javax.servlet.http.HttpServletRequest, javax.naming.directory.DirContext, java.lang.String, Hashtable<java.lang.String,java.lang.Integer>)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Deletes a collection.
 * @param dirContext Resources implementation associated with the context
 * @param path Path to the collection to be deleted
 * @param errorList Contains the list of the errors which occurred
 */
private void deleteCollection(HttpServletRequest req,DirContext dirContext,String path,Hashtable<String,Integer> errorList){
  if (debug > 1)   log("Delete:" + path);
  if (isSpecialPath(path)) {
    errorList.put(path,Integer.valueOf(WebdavStatus.SC_FORBIDDEN));
    return;
  }
  String ifHeader=req.getHeader("If");
  if (ifHeader == null)   ifHeader="";
  String lockTokenHeader=req.getHeader("Lock-Token");
  if (lockTokenHeader == null)   lockTokenHeader="";
  Enumeration<NameClassPair> enumeration=null;
  try {
    enumeration=dirContext.list(path);
  }
 catch (  NamingException e) {
    errorList.put(path,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
    return;
  }
  while (enumeration.hasMoreElements()) {
    NameClassPair ncPair=enumeration.nextElement();
    String childName=path;
    if (!childName.equals("/"))     childName+="/";
    childName+=ncPair.getName();
    if (isLocked(childName,ifHeader + lockTokenHeader)) {
      errorList.put(childName,Integer.valueOf(WebdavStatus.SC_LOCKED));
    }
 else {
      try {
        Object object=dirContext.lookup(childName);
        if (object instanceof DirContext) {
          deleteCollection(req,dirContext,childName,errorList);
        }
        try {
          dirContext.unbind(childName);
        }
 catch (        NamingException e) {
          if (!(object instanceof DirContext)) {
            errorList.put(childName,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
          }
        }
      }
 catch (      NamingException e) {
        errorList.put(childName,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      }
    }
  }
}

ID 2328=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#deleteCollection(javax.servlet.http.HttpServletRequest, javax.naming.directory.DirContext, java.lang.String, Hashtable<java.lang.String,java.lang.Integer>)
Rmethod: javax.naming.Context#unbind(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Deletes a collection.
 * @param dirContext Resources implementation associated with the context
 * @param path Path to the collection to be deleted
 * @param errorList Contains the list of the errors which occurred
 */
private void deleteCollection(HttpServletRequest req,DirContext dirContext,String path,Hashtable<String,Integer> errorList){
  if (debug > 1)   log("Delete:" + path);
  if (isSpecialPath(path)) {
    errorList.put(path,Integer.valueOf(WebdavStatus.SC_FORBIDDEN));
    return;
  }
  String ifHeader=req.getHeader("If");
  if (ifHeader == null)   ifHeader="";
  String lockTokenHeader=req.getHeader("Lock-Token");
  if (lockTokenHeader == null)   lockTokenHeader="";
  Enumeration<NameClassPair> enumeration=null;
  try {
    enumeration=dirContext.list(path);
  }
 catch (  NamingException e) {
    errorList.put(path,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
    return;
  }
  while (enumeration.hasMoreElements()) {
    NameClassPair ncPair=enumeration.nextElement();
    String childName=path;
    if (!childName.equals("/"))     childName+="/";
    childName+=ncPair.getName();
    if (isLocked(childName,ifHeader + lockTokenHeader)) {
      errorList.put(childName,Integer.valueOf(WebdavStatus.SC_LOCKED));
    }
 else {
      try {
        Object object=dirContext.lookup(childName);
        if (object instanceof DirContext) {
          deleteCollection(req,dirContext,childName,errorList);
        }
        try {
          dirContext.unbind(childName);
        }
 catch (        NamingException e) {
          if (!(object instanceof DirContext)) {
            errorList.put(childName,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
          }
        }
      }
 catch (      NamingException e) {
        errorList.put(childName,Integer.valueOf(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
      }
    }
  }
}

ID 2332=========================================================================type: 1
Method:org.apache.catalina.servlets.WebdavServlet#determineMethodsAllowed(javax.naming.directory.DirContext, javax.servlet.http.HttpServletRequest)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Determines the methods normally allowed for the resource.
 */
private StringBuilder determineMethodsAllowed(DirContext dirContext,HttpServletRequest req){
  StringBuilder methodsAllowed=new StringBuilder();
  boolean exists=true;
  Object object=null;
  try {
    String path=getRelativePath(req);
    object=dirContext.lookup(path);
  }
 catch (  NamingException e) {
    exists=false;
  }
  if (!exists) {
    methodsAllowed.append("OPTIONS, MKCOL, PUT, LOCK");
    return methodsAllowed;
  }
  methodsAllowed.append("OPTIONS, GET, HEAD, POST, DELETE, TRACE");
  methodsAllowed.append(", PROPPATCH, COPY, MOVE, LOCK, UNLOCK");
  if (listings) {
    methodsAllowed.append(", PROPFIND");
  }
  if (!(object instanceof DirContext)) {
    methodsAllowed.append(", PUT");
  }
  return methodsAllowed;
}

ID 2338=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIFlastmod#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: org.apache.catalina.ssi.SSIMediator#getFileLastModified(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  for (int i=0; i < paramNames.length; i++) {
    String paramName=paramNames[i];
    String paramValue=paramValues[i];
    String substitutedValue=ssiMediator.substituteVariables(paramValue);
    try {
      if (paramName.equalsIgnoreCase("file") || paramName.equalsIgnoreCase("virtual")) {
        boolean virtual=paramName.equalsIgnoreCase("virtual");
        lastModified=ssiMediator.getFileLastModified(substitutedValue,virtual);
        Date date=new Date(lastModified);
        String configTimeFmt=ssiMediator.getConfigTimeFmt();
        writer.write(formatDate(date,configTimeFmt));
      }
 else {
        ssiMediator.log("#flastmod--Invalid attribute: " + paramName);
        writer.write(configErrMsg);
      }
    }
 catch (    IOException e) {
      ssiMediator.log("#flastmod--Couldn't get last modified for file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
  }
  return lastModified;
}

ID 2339=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIInclude#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: org.apache.catalina.ssi.SSIMediator#getFileLastModified(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  for (int i=0; i < paramNames.length; i++) {
    String paramName=paramNames[i];
    String paramValue=paramValues[i];
    String substitutedValue=ssiMediator.substituteVariables(paramValue);
    try {
      if (paramName.equalsIgnoreCase("file") || paramName.equalsIgnoreCase("virtual")) {
        boolean virtual=paramName.equalsIgnoreCase("virtual");
        lastModified=ssiMediator.getFileLastModified(substitutedValue,virtual);
        String text=ssiMediator.getFileText(substitutedValue,virtual);
        writer.write(text);
      }
 else {
        ssiMediator.log("#include--Invalid attribute: " + paramName);
        writer.write(configErrMsg);
      }
    }
 catch (    IOException e) {
      ssiMediator.log("#include--Couldn't include file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
  }
  return lastModified;
}

ID 2340=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIInclude#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: org.apache.catalina.ssi.SSIMediator#getFileText(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  for (int i=0; i < paramNames.length; i++) {
    String paramName=paramNames[i];
    String paramValue=paramValues[i];
    String substitutedValue=ssiMediator.substituteVariables(paramValue);
    try {
      if (paramName.equalsIgnoreCase("file") || paramName.equalsIgnoreCase("virtual")) {
        boolean virtual=paramName.equalsIgnoreCase("virtual");
        lastModified=ssiMediator.getFileLastModified(substitutedValue,virtual);
        String text=ssiMediator.getFileText(substitutedValue,virtual);
        writer.write(text);
      }
 else {
        ssiMediator.log("#include--Invalid attribute: " + paramName);
        writer.write(configErrMsg);
      }
    }
 catch (    IOException e) {
      ssiMediator.log("#include--Couldn't include file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
  }
  return lastModified;
}

ID 2344=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIExec#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: java.lang.Runtime#exec(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  String paramName=paramNames[0];
  String paramValue=paramValues[0];
  String substitutedValue=ssiMediator.substituteVariables(paramValue);
  if (paramName.equalsIgnoreCase("cgi")) {
    lastModified=ssiInclude.process(ssiMediator,"include",new String[]{"virtual"},new String[]{substitutedValue},writer);
  }
 else   if (paramName.equalsIgnoreCase("cmd")) {
    boolean foundProgram=false;
    try {
      Runtime rt=Runtime.getRuntime();
      Process proc=rt.exec(substitutedValue);
      foundProgram=true;
      BufferedReader stdOutReader=new BufferedReader(new InputStreamReader(proc.getInputStream()));
      BufferedReader stdErrReader=new BufferedReader(new InputStreamReader(proc.getErrorStream()));
      char[] buf=new char[BUFFER_SIZE];
      IOTools.flow(stdErrReader,writer,buf);
      IOTools.flow(stdOutReader,writer,buf);
      proc.waitFor();
      lastModified=System.currentTimeMillis();
    }
 catch (    InterruptedException e) {
      ssiMediator.log("Couldn't exec file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
catch (    IOException e) {
      if (!foundProgram) {
      }
      ssiMediator.log("Couldn't exec file: " + substitutedValue,e);
    }
  }
  return lastModified;
}

ID 2345=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIExec#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: org.apache.catalina.util.IOTools#flow(java.io.Reader, java.io.Writer, char[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  String paramName=paramNames[0];
  String paramValue=paramValues[0];
  String substitutedValue=ssiMediator.substituteVariables(paramValue);
  if (paramName.equalsIgnoreCase("cgi")) {
    lastModified=ssiInclude.process(ssiMediator,"include",new String[]{"virtual"},new String[]{substitutedValue},writer);
  }
 else   if (paramName.equalsIgnoreCase("cmd")) {
    boolean foundProgram=false;
    try {
      Runtime rt=Runtime.getRuntime();
      Process proc=rt.exec(substitutedValue);
      foundProgram=true;
      BufferedReader stdOutReader=new BufferedReader(new InputStreamReader(proc.getInputStream()));
      BufferedReader stdErrReader=new BufferedReader(new InputStreamReader(proc.getErrorStream()));
      char[] buf=new char[BUFFER_SIZE];
      IOTools.flow(stdErrReader,writer,buf);
      IOTools.flow(stdOutReader,writer,buf);
      proc.waitFor();
      lastModified=System.currentTimeMillis();
    }
 catch (    InterruptedException e) {
      ssiMediator.log("Couldn't exec file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
catch (    IOException e) {
      if (!foundProgram) {
      }
      ssiMediator.log("Couldn't exec file: " + substitutedValue,e);
    }
  }
  return lastModified;
}

ID 2346=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIExec#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: java.lang.Process#waitFor()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  String paramName=paramNames[0];
  String paramValue=paramValues[0];
  String substitutedValue=ssiMediator.substituteVariables(paramValue);
  if (paramName.equalsIgnoreCase("cgi")) {
    lastModified=ssiInclude.process(ssiMediator,"include",new String[]{"virtual"},new String[]{substitutedValue},writer);
  }
 else   if (paramName.equalsIgnoreCase("cmd")) {
    boolean foundProgram=false;
    try {
      Runtime rt=Runtime.getRuntime();
      Process proc=rt.exec(substitutedValue);
      foundProgram=true;
      BufferedReader stdOutReader=new BufferedReader(new InputStreamReader(proc.getInputStream()));
      BufferedReader stdErrReader=new BufferedReader(new InputStreamReader(proc.getErrorStream()));
      char[] buf=new char[BUFFER_SIZE];
      IOTools.flow(stdErrReader,writer,buf);
      IOTools.flow(stdOutReader,writer,buf);
      proc.waitFor();
      lastModified=System.currentTimeMillis();
    }
 catch (    InterruptedException e) {
      ssiMediator.log("Couldn't exec file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
catch (    IOException e) {
      if (!foundProgram) {
      }
      ssiMediator.log("Couldn't exec file: " + substitutedValue,e);
    }
  }
  return lastModified;
}

ID 2348=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIConditional#evaluateArguments(java.lang.String[], java.lang.String[], org.apache.catalina.ssi.SSIMediator)
Rmethod: org.apache.catalina.ssi.ExpressionParseTree#ExpressionParseTree(java.lang.String, org.apache.catalina.ssi.SSIMediator)
parentException: 
thrown: ParseException
exception comment: /** 
 * Signals that an error has been reached unexpectedly while parsing.
 * @see java.lang.Exception
 * @see java.text.Format
 * @see java.text.FieldPosition
 * @author      Mark Davis
 */

block: 
/** 
 * Retrieves the expression from the specified arguments and peforms the necessary evaluation steps.
 */
private boolean evaluateArguments(String[] names,String[] values,SSIMediator ssiMediator) throws SSIStopProcessingException {
  String expr=getExpression(names,values);
  if (expr == null) {
    throw new SSIStopProcessingException();
  }
  try {
    ExpressionParseTree tree=new ExpressionParseTree(expr,ssiMediator);
    return tree.evaluateTree();
  }
 catch (  ParseException e) {
    throw new SSIStopProcessingException();
  }
}

ID 2364=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIFsize#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: org.apache.catalina.ssi.SSIMediator#getFileLastModified(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  for (int i=0; i < paramNames.length; i++) {
    String paramName=paramNames[i];
    String paramValue=paramValues[i];
    String substitutedValue=ssiMediator.substituteVariables(paramValue);
    try {
      if (paramName.equalsIgnoreCase("file") || paramName.equalsIgnoreCase("virtual")) {
        boolean virtual=paramName.equalsIgnoreCase("virtual");
        lastModified=ssiMediator.getFileLastModified(substitutedValue,virtual);
        long size=ssiMediator.getFileSize(substitutedValue,virtual);
        String configSizeFmt=ssiMediator.getConfigSizeFmt();
        writer.write(formatSize(size,configSizeFmt));
      }
 else {
        ssiMediator.log("#fsize--Invalid attribute: " + paramName);
        writer.write(configErrMsg);
      }
    }
 catch (    IOException e) {
      ssiMediator.log("#fsize--Couldn't get size for file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
  }
  return lastModified;
}

ID 2365=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIFsize#process(org.apache.catalina.ssi.SSIMediator, java.lang.String, java.lang.String[], java.lang.String[], java.io.PrintWriter)
Rmethod: org.apache.catalina.ssi.SSIMediator#getFileSize(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @see SSICommand
 */
@Override public long process(SSIMediator ssiMediator,String commandName,String[] paramNames,String[] paramValues,PrintWriter writer){
  long lastModified=0;
  String configErrMsg=ssiMediator.getConfigErrMsg();
  for (int i=0; i < paramNames.length; i++) {
    String paramName=paramNames[i];
    String paramValue=paramValues[i];
    String substitutedValue=ssiMediator.substituteVariables(paramValue);
    try {
      if (paramName.equalsIgnoreCase("file") || paramName.equalsIgnoreCase("virtual")) {
        boolean virtual=paramName.equalsIgnoreCase("virtual");
        lastModified=ssiMediator.getFileLastModified(substitutedValue,virtual);
        long size=ssiMediator.getFileSize(substitutedValue,virtual);
        String configSizeFmt=ssiMediator.getConfigSizeFmt();
        writer.write(formatSize(size,configSizeFmt));
      }
 else {
        ssiMediator.log("#fsize--Invalid attribute: " + paramName);
        writer.write(configErrMsg);
      }
    }
 catch (    IOException e) {
      ssiMediator.log("#fsize--Couldn't get size for file: " + substitutedValue,e);
      writer.write(configErrMsg);
    }
  }
  return lastModified;
}

ID 2366=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIServletExternalResolver#getCGIVariable(java.lang.String)
Rmethod: java.net.URLDecoder#decode(java.lang.String, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
protected String getCGIVariable(String name){
  String retVal=null;
  String[] nameParts=name.toUpperCase(Locale.ENGLISH).split("_");
  int requiredParts=2;
  if (nameParts.length == 1) {
    if (nameParts[0].equals("PATH")) {
      requiredParts=1;
    }
  }
 else   if (nameParts[0].equals("AUTH")) {
    if (nameParts[1].equals("TYPE")) {
      retVal=req.getAuthType();
    }
  }
 else   if (nameParts[0].equals("CONTENT")) {
    if (nameParts[1].equals("LENGTH")) {
      int contentLength=req.getContentLength();
      if (contentLength >= 0) {
        retVal=Integer.toString(contentLength);
      }
    }
 else     if (nameParts[1].equals("TYPE")) {
      retVal=req.getContentType();
    }
  }
 else   if (nameParts[0].equals("DOCUMENT")) {
    if (nameParts[1].equals("NAME")) {
      String requestURI=req.getRequestURI();
      retVal=requestURI.substring(requestURI.lastIndexOf('/') + 1);
    }
 else     if (nameParts[1].equals("URI")) {
      retVal=req.getRequestURI();
    }
  }
 else   if (name.equalsIgnoreCase("GATEWAY_INTERFACE")) {
    retVal="CGI/1.1";
  }
 else   if (nameParts[0].equals("HTTP")) {
    if (nameParts[1].equals("ACCEPT")) {
      String accept=null;
      if (nameParts.length == 2) {
        accept="Accept";
      }
 else       if (nameParts[2].equals("ENCODING")) {
        requiredParts=3;
        accept="Accept-Encoding";
      }
 else       if (nameParts[2].equals("LANGUAGE")) {
        requiredParts=3;
        accept="Accept-Language";
      }
      if (accept != null) {
        Enumeration<String> acceptHeaders=req.getHeaders(accept);
        if (acceptHeaders != null)         if (acceptHeaders.hasMoreElements()) {
          StringBuilder rv=new StringBuilder(acceptHeaders.nextElement());
          while (acceptHeaders.hasMoreElements()) {
            rv.append(", ");
            rv.append(acceptHeaders.nextElement());
          }
          retVal=rv.toString();
        }
      }
    }
 else     if (nameParts[1].equals("CONNECTION")) {
      retVal=req.getHeader("Connection");
    }
 else     if (nameParts[1].equals("HOST")) {
      retVal=req.getHeader("Host");
    }
 else     if (nameParts[1].equals("REFERER")) {
      retVal=req.getHeader("Referer");
    }
 else     if (nameParts[1].equals("USER"))     if (nameParts.length == 3)     if (nameParts[2].equals("AGENT")) {
      requiredParts=3;
      retVal=req.getHeader("User-Agent");
    }
  }
 else   if (nameParts[0].equals("PATH")) {
    if (nameParts[1].equals("INFO")) {
      retVal=req.getPathInfo();
    }
 else     if (nameParts[1].equals("TRANSLATED")) {
      retVal=req.getPathTranslated();
    }
  }
 else   if (nameParts[0].equals("QUERY")) {
    if (nameParts[1].equals("STRING")) {
      String queryString=req.getQueryString();
      if (nameParts.length == 2) {
        retVal=nullToEmptyString(queryString);
      }
 else       if (nameParts[2].equals("UNESCAPED")) {
        requiredParts=3;
        if (queryString != null) {
          String queryStringEncoding=Constants.DEFAULT_CHARACTER_ENCODING;
          String uriEncoding=null;
          boolean useBodyEncodingForURI=false;
          String requestEncoding=req.getCharacterEncoding();
          if (req instanceof Request) {
            uriEncoding=((Request)req).getConnector().getURIEncoding();
            useBodyEncodingForURI=((Request)req).getConnector().getUseBodyEncodingForURI();
          }
          if (uriEncoding != null) {
            queryStringEncoding=uriEncoding;
          }
 else           if (useBodyEncodingForURI) {
            if (requestEncoding != null) {
              queryStringEncoding=requestEncoding;
            }
          }
          try {
            retVal=URLDecoder.decode(queryString,queryStringEncoding);
          }
 catch (          UnsupportedEncodingException e) {
            retVal=queryString;
          }
        }
      }
    }
  }
 else   if (nameParts[0].equals("REMOTE")) {
    if (nameParts[1].equals("ADDR")) {
      retVal=req.getRemoteAddr();
    }
 else     if (nameParts[1].equals("HOST")) {
      retVal=req.getRemoteHost();
    }
 else     if (nameParts[1].equals("IDENT")) {
    }
 else     if (nameParts[1].equals("PORT")) {
      retVal=Integer.toString(req.getRemotePort());
    }
 else     if (nameParts[1].equals("USER")) {
      retVal=req.getRemoteUser();
    }
  }
 else   if (nameParts[0].equals("REQUEST")) {
    if (nameParts[1].equals("METHOD")) {
      retVal=req.getMethod();
    }
 else     if (nameParts[1].equals("URI")) {
      retVal=(String)req.getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);
      if (retVal == null)       retVal=req.getRequestURI();
    }
  }
 else   if (nameParts[0].equals("SCRIPT")) {
    String scriptName=req.getServletPath();
    if (nameParts[1].equals("FILENAME")) {
      retVal=context.getRealPath(scriptName);
    }
 else     if (nameParts[1].equals("NAME")) {
      retVal=scriptName;
    }
  }
 else   if (nameParts[0].equals("SERVER")) {
    if (nameParts[1].equals("ADDR")) {
      retVal=req.getLocalAddr();
    }
    if (nameParts[1].equals("NAME")) {
      retVal=req.getServerName();
    }
 else     if (nameParts[1].equals("PORT")) {
      retVal=Integer.toString(req.getServerPort());
    }
 else     if (nameParts[1].equals("PROTOCOL")) {
      retVal=req.getProtocol();
    }
 else     if (nameParts[1].equals("SOFTWARE")) {
      StringBuilder rv=new StringBuilder(context.getServerInfo());
      rv.append(" ");
      rv.append(System.getProperty("java.vm.name"));
      rv.append("/");
      rv.append(System.getProperty("java.vm.version"));
      rv.append(" ");
      rv.append(System.getProperty("os.name"));
      retVal=rv.toString();
    }
  }
 else   if (name.equalsIgnoreCase("UNIQUE_ID")) {
    retVal=req.getRequestedSessionId();
  }
  if (requiredParts != nameParts.length)   return null;
  return retVal;
}

ID 2377=========================================================================type: 1
Method:org.apache.catalina.ssi.SSIServletExternalResolver#getFileText(java.lang.String, boolean)
Rmethod: javax.servlet.RequestDispatcher#include(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: ServletException
exception comment: null
block: 
@Override public String getFileText(String originalPath,boolean virtual) throws IOException {
  try {
    ServletContextAndPath csAndP=getServletContextAndPath(originalPath,virtual);
    ServletContext context=csAndP.getServletContext();
    String path=csAndP.getPath();
    RequestDispatcher rd=context.getRequestDispatcher(path);
    if (rd == null) {
      throw new IOException("Couldn't get request dispatcher for path: " + path);
    }
    ByteArrayServletOutputStream basos=new ByteArrayServletOutputStream();
    ResponseIncludeWrapper responseIncludeWrapper=new ResponseIncludeWrapper(context,req,res,basos);
    rd.include(req,responseIncludeWrapper);
    responseIncludeWrapper.flushOutputStreamOrWriter();
    byte[] bytes=basos.toByteArray();
    String retVal;
    if (inputEncoding == null) {
      retVal=new String(bytes);
    }
 else {
      retVal=new String(bytes,B2CConverter.getCharset(inputEncoding));
    }
    if (retVal.equals("") && !req.getMethod().equalsIgnoreCase(org.apache.coyote.http11.Constants.HEAD)) {
      throw new IOException("Couldn't find file: " + path);
    }
    return retVal;
  }
 catch (  ServletException e) {
    throw new IOException("Couldn't include file: " + originalPath + " because of ServletException: "+ e.getMessage());
  }
}

ID 2400=========================================================================type: 1
Method:org.apache.catalina.manager.host.HostManagerServlet#add(java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String, boolean, boolean, boolean, boolean, boolean, boolean, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.File#getCanonicalFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Add a host using the specified parameters.
 * @param writer Writer to render results to
 * @param name host name
 * @param aliases comma separated alias list
 * @param appBase application base for the host
 * @param manager should the manager webapp be deployed to the new host ?
 */
protected synchronized void add(PrintWriter writer,String name,String aliases,String appBase,boolean manager,boolean autoDeploy,boolean deployOnStartup,boolean deployXML,boolean unpackWARs,boolean copyXML,StringManager smClient){
  if (debug >= 1) {
    log(sm.getString("hostManagerServlet.add",name));
  }
  if ((name == null) || name.length() == 0) {
    writer.println(smClient.getString("hostManagerServlet.invalidHostName",name));
    return;
  }
  if (engine.findChild(name) != null) {
    writer.println(smClient.getString("hostManagerServlet.alreadyHost",name));
    return;
  }
  File appBaseFile=null;
  File file=null;
  String applicationBase=appBase;
  if (applicationBase == null || applicationBase.length() == 0) {
    applicationBase=name;
  }
  file=new File(applicationBase);
  if (!file.isAbsolute())   file=new File(System.getProperty(Globals.CATALINA_BASE_PROP),file.getPath());
  try {
    appBaseFile=file.getCanonicalFile();
  }
 catch (  IOException e) {
    appBaseFile=file;
  }
  if (!appBaseFile.mkdirs() && !appBaseFile.isDirectory()) {
    writer.println(smClient.getString("hostManagerServlet.appBaseCreateFail",appBaseFile.toString(),name));
    return;
  }
  File configBaseFile=getConfigBase(name);
  if (manager) {
    if (configBaseFile == null) {
      writer.println(smClient.getString("hostManagerServlet.configBaseCreateFail",name));
      return;
    }
    InputStream is=null;
    OutputStream os=null;
    try {
      is=getServletContext().getResourceAsStream("/manager.xml");
      os=new FileOutputStream(new File(configBaseFile,"manager.xml"));
      byte buffer[]=new byte[512];
      int len=buffer.length;
      while (true) {
        len=is.read(buffer);
        if (len == -1)         break;
        os.write(buffer,0,len);
      }
    }
 catch (    IOException e) {
      writer.println(smClient.getString("hostManagerServlet.managerXml"));
      return;
    }
 finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
        }
      }
      if (os != null) {
        try {
          os.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  StandardHost host=new StandardHost();
  host.setAppBase(applicationBase);
  host.setName(name);
  host.addLifecycleListener(new HostConfig());
  if ((aliases != null) && !("".equals(aliases))) {
    StringTokenizer tok=new StringTokenizer(aliases,", ");
    while (tok.hasMoreTokens()) {
      host.addAlias(tok.nextToken());
    }
  }
  host.setAutoDeploy(autoDeploy);
  host.setDeployOnStartup(deployOnStartup);
  host.setDeployXML(deployXML);
  host.setUnpackWARs(unpackWARs);
  host.setCopyXML(copyXML);
  try {
    engine.addChild(host);
  }
 catch (  Exception e) {
    writer.println(smClient.getString("hostManagerServlet.exception",e.toString()));
    return;
  }
  host=(StandardHost)engine.findChild(name);
  if (host != null) {
    writer.println(smClient.getString("hostManagerServlet.add",name));
  }
 else {
    writer.println(smClient.getString("hostManagerServlet.addFailed",name));
  }
}

ID 2401=========================================================================type: 1
Method:org.apache.catalina.manager.host.HostManagerServlet#add(java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String, boolean, boolean, boolean, boolean, boolean, boolean, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Add a host using the specified parameters.
 * @param writer Writer to render results to
 * @param name host name
 * @param aliases comma separated alias list
 * @param appBase application base for the host
 * @param manager should the manager webapp be deployed to the new host ?
 */
protected synchronized void add(PrintWriter writer,String name,String aliases,String appBase,boolean manager,boolean autoDeploy,boolean deployOnStartup,boolean deployXML,boolean unpackWARs,boolean copyXML,StringManager smClient){
  if (debug >= 1) {
    log(sm.getString("hostManagerServlet.add",name));
  }
  if ((name == null) || name.length() == 0) {
    writer.println(smClient.getString("hostManagerServlet.invalidHostName",name));
    return;
  }
  if (engine.findChild(name) != null) {
    writer.println(smClient.getString("hostManagerServlet.alreadyHost",name));
    return;
  }
  File appBaseFile=null;
  File file=null;
  String applicationBase=appBase;
  if (applicationBase == null || applicationBase.length() == 0) {
    applicationBase=name;
  }
  file=new File(applicationBase);
  if (!file.isAbsolute())   file=new File(System.getProperty(Globals.CATALINA_BASE_PROP),file.getPath());
  try {
    appBaseFile=file.getCanonicalFile();
  }
 catch (  IOException e) {
    appBaseFile=file;
  }
  if (!appBaseFile.mkdirs() && !appBaseFile.isDirectory()) {
    writer.println(smClient.getString("hostManagerServlet.appBaseCreateFail",appBaseFile.toString(),name));
    return;
  }
  File configBaseFile=getConfigBase(name);
  if (manager) {
    if (configBaseFile == null) {
      writer.println(smClient.getString("hostManagerServlet.configBaseCreateFail",name));
      return;
    }
    InputStream is=null;
    OutputStream os=null;
    try {
      is=getServletContext().getResourceAsStream("/manager.xml");
      os=new FileOutputStream(new File(configBaseFile,"manager.xml"));
      byte buffer[]=new byte[512];
      int len=buffer.length;
      while (true) {
        len=is.read(buffer);
        if (len == -1)         break;
        os.write(buffer,0,len);
      }
    }
 catch (    IOException e) {
      writer.println(smClient.getString("hostManagerServlet.managerXml"));
      return;
    }
 finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
        }
      }
      if (os != null) {
        try {
          os.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  StandardHost host=new StandardHost();
  host.setAppBase(applicationBase);
  host.setName(name);
  host.addLifecycleListener(new HostConfig());
  if ((aliases != null) && !("".equals(aliases))) {
    StringTokenizer tok=new StringTokenizer(aliases,", ");
    while (tok.hasMoreTokens()) {
      host.addAlias(tok.nextToken());
    }
  }
  host.setAutoDeploy(autoDeploy);
  host.setDeployOnStartup(deployOnStartup);
  host.setDeployXML(deployXML);
  host.setUnpackWARs(unpackWARs);
  host.setCopyXML(copyXML);
  try {
    engine.addChild(host);
  }
 catch (  Exception e) {
    writer.println(smClient.getString("hostManagerServlet.exception",e.toString()));
    return;
  }
  host=(StandardHost)engine.findChild(name);
  if (host != null) {
    writer.println(smClient.getString("hostManagerServlet.add",name));
  }
 else {
    writer.println(smClient.getString("hostManagerServlet.addFailed",name));
  }
}

ID 2402=========================================================================type: 1
Method:org.apache.catalina.manager.host.HostManagerServlet#add(java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String, boolean, boolean, boolean, boolean, boolean, boolean, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.InputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Add a host using the specified parameters.
 * @param writer Writer to render results to
 * @param name host name
 * @param aliases comma separated alias list
 * @param appBase application base for the host
 * @param manager should the manager webapp be deployed to the new host ?
 */
protected synchronized void add(PrintWriter writer,String name,String aliases,String appBase,boolean manager,boolean autoDeploy,boolean deployOnStartup,boolean deployXML,boolean unpackWARs,boolean copyXML,StringManager smClient){
  if (debug >= 1) {
    log(sm.getString("hostManagerServlet.add",name));
  }
  if ((name == null) || name.length() == 0) {
    writer.println(smClient.getString("hostManagerServlet.invalidHostName",name));
    return;
  }
  if (engine.findChild(name) != null) {
    writer.println(smClient.getString("hostManagerServlet.alreadyHost",name));
    return;
  }
  File appBaseFile=null;
  File file=null;
  String applicationBase=appBase;
  if (applicationBase == null || applicationBase.length() == 0) {
    applicationBase=name;
  }
  file=new File(applicationBase);
  if (!file.isAbsolute())   file=new File(System.getProperty(Globals.CATALINA_BASE_PROP),file.getPath());
  try {
    appBaseFile=file.getCanonicalFile();
  }
 catch (  IOException e) {
    appBaseFile=file;
  }
  if (!appBaseFile.mkdirs() && !appBaseFile.isDirectory()) {
    writer.println(smClient.getString("hostManagerServlet.appBaseCreateFail",appBaseFile.toString(),name));
    return;
  }
  File configBaseFile=getConfigBase(name);
  if (manager) {
    if (configBaseFile == null) {
      writer.println(smClient.getString("hostManagerServlet.configBaseCreateFail",name));
      return;
    }
    InputStream is=null;
    OutputStream os=null;
    try {
      is=getServletContext().getResourceAsStream("/manager.xml");
      os=new FileOutputStream(new File(configBaseFile,"manager.xml"));
      byte buffer[]=new byte[512];
      int len=buffer.length;
      while (true) {
        len=is.read(buffer);
        if (len == -1)         break;
        os.write(buffer,0,len);
      }
    }
 catch (    IOException e) {
      writer.println(smClient.getString("hostManagerServlet.managerXml"));
      return;
    }
 finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
        }
      }
      if (os != null) {
        try {
          os.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  StandardHost host=new StandardHost();
  host.setAppBase(applicationBase);
  host.setName(name);
  host.addLifecycleListener(new HostConfig());
  if ((aliases != null) && !("".equals(aliases))) {
    StringTokenizer tok=new StringTokenizer(aliases,", ");
    while (tok.hasMoreTokens()) {
      host.addAlias(tok.nextToken());
    }
  }
  host.setAutoDeploy(autoDeploy);
  host.setDeployOnStartup(deployOnStartup);
  host.setDeployXML(deployXML);
  host.setUnpackWARs(unpackWARs);
  host.setCopyXML(copyXML);
  try {
    engine.addChild(host);
  }
 catch (  Exception e) {
    writer.println(smClient.getString("hostManagerServlet.exception",e.toString()));
    return;
  }
  host=(StandardHost)engine.findChild(name);
  if (host != null) {
    writer.println(smClient.getString("hostManagerServlet.add",name));
  }
 else {
    writer.println(smClient.getString("hostManagerServlet.addFailed",name));
  }
}

ID 2403=========================================================================type: 1
Method:org.apache.catalina.manager.host.HostManagerServlet#add(java.io.PrintWriter, java.lang.String, java.lang.String, java.lang.String, boolean, boolean, boolean, boolean, boolean, boolean, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.OutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Add a host using the specified parameters.
 * @param writer Writer to render results to
 * @param name host name
 * @param aliases comma separated alias list
 * @param appBase application base for the host
 * @param manager should the manager webapp be deployed to the new host ?
 */
protected synchronized void add(PrintWriter writer,String name,String aliases,String appBase,boolean manager,boolean autoDeploy,boolean deployOnStartup,boolean deployXML,boolean unpackWARs,boolean copyXML,StringManager smClient){
  if (debug >= 1) {
    log(sm.getString("hostManagerServlet.add",name));
  }
  if ((name == null) || name.length() == 0) {
    writer.println(smClient.getString("hostManagerServlet.invalidHostName",name));
    return;
  }
  if (engine.findChild(name) != null) {
    writer.println(smClient.getString("hostManagerServlet.alreadyHost",name));
    return;
  }
  File appBaseFile=null;
  File file=null;
  String applicationBase=appBase;
  if (applicationBase == null || applicationBase.length() == 0) {
    applicationBase=name;
  }
  file=new File(applicationBase);
  if (!file.isAbsolute())   file=new File(System.getProperty(Globals.CATALINA_BASE_PROP),file.getPath());
  try {
    appBaseFile=file.getCanonicalFile();
  }
 catch (  IOException e) {
    appBaseFile=file;
  }
  if (!appBaseFile.mkdirs() && !appBaseFile.isDirectory()) {
    writer.println(smClient.getString("hostManagerServlet.appBaseCreateFail",appBaseFile.toString(),name));
    return;
  }
  File configBaseFile=getConfigBase(name);
  if (manager) {
    if (configBaseFile == null) {
      writer.println(smClient.getString("hostManagerServlet.configBaseCreateFail",name));
      return;
    }
    InputStream is=null;
    OutputStream os=null;
    try {
      is=getServletContext().getResourceAsStream("/manager.xml");
      os=new FileOutputStream(new File(configBaseFile,"manager.xml"));
      byte buffer[]=new byte[512];
      int len=buffer.length;
      while (true) {
        len=is.read(buffer);
        if (len == -1)         break;
        os.write(buffer,0,len);
      }
    }
 catch (    IOException e) {
      writer.println(smClient.getString("hostManagerServlet.managerXml"));
      return;
    }
 finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
        }
      }
      if (os != null) {
        try {
          os.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  StandardHost host=new StandardHost();
  host.setAppBase(applicationBase);
  host.setName(name);
  host.addLifecycleListener(new HostConfig());
  if ((aliases != null) && !("".equals(aliases))) {
    StringTokenizer tok=new StringTokenizer(aliases,", ");
    while (tok.hasMoreTokens()) {
      host.addAlias(tok.nextToken());
    }
  }
  host.setAutoDeploy(autoDeploy);
  host.setDeployOnStartup(deployOnStartup);
  host.setDeployXML(deployXML);
  host.setUnpackWARs(unpackWARs);
  host.setCopyXML(copyXML);
  try {
    engine.addChild(host);
  }
 catch (  Exception e) {
    writer.println(smClient.getString("hostManagerServlet.exception",e.toString()));
    return;
  }
  host=(StandardHost)engine.findChild(name);
  if (host != null) {
    writer.println(smClient.getString("hostManagerServlet.add",name));
  }
 else {
    writer.println(smClient.getString("hostManagerServlet.addFailed",name));
  }
}

ID 2423=========================================================================type: 1
Method:org.apache.catalina.manager.HTMLManagerServlet#upload(javax.servlet.http.HttpServletRequest, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isDeployed(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
protected String upload(HttpServletRequest request,StringManager smClient){
  String message="";
  try {
    while (true) {
      Part warPart=request.getPart("deployWar");
      if (warPart == null) {
        message=smClient.getString("htmlManagerServlet.deployUploadNoFile");
        break;
      }
      String filename=extractFilename(warPart.getHeader("Content-Disposition"));
      if (!filename.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
        message=smClient.getString("htmlManagerServlet.deployUploadNotWar",filename);
        break;
      }
      if (filename.lastIndexOf('\\') >= 0) {
        filename=filename.substring(filename.lastIndexOf('\\') + 1);
      }
      if (filename.lastIndexOf('/') >= 0) {
        filename=filename.substring(filename.lastIndexOf('/') + 1);
      }
      File file=new File(deployed,filename);
      if (file.exists()) {
        message=smClient.getString("htmlManagerServlet.deployUploadWarExists",filename);
        break;
      }
      ContextName cn=new ContextName(filename,true);
      String name=cn.getName();
      if ((host.findChild(name) != null) && !isDeployed(name)) {
        message=smClient.getString("htmlManagerServlet.deployUploadInServerXml",filename);
        break;
      }
      if (isServiced(name)) {
        message=smClient.getString("managerServlet.inService",name);
      }
 else {
        addServiced(name);
        try {
          warPart.write(file.getAbsolutePath());
          check(name);
        }
  finally {
          removeServiced(name);
        }
      }
      break;
    }
  }
 catch (  Exception e) {
    message=smClient.getString("htmlManagerServlet.deployUploadFail",e.getMessage());
    log(message,e);
  }
  return message;
}

ID 2424=========================================================================type: 1
Method:org.apache.catalina.manager.HTMLManagerServlet#upload(javax.servlet.http.HttpServletRequest, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
protected String upload(HttpServletRequest request,StringManager smClient){
  String message="";
  try {
    while (true) {
      Part warPart=request.getPart("deployWar");
      if (warPart == null) {
        message=smClient.getString("htmlManagerServlet.deployUploadNoFile");
        break;
      }
      String filename=extractFilename(warPart.getHeader("Content-Disposition"));
      if (!filename.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
        message=smClient.getString("htmlManagerServlet.deployUploadNotWar",filename);
        break;
      }
      if (filename.lastIndexOf('\\') >= 0) {
        filename=filename.substring(filename.lastIndexOf('\\') + 1);
      }
      if (filename.lastIndexOf('/') >= 0) {
        filename=filename.substring(filename.lastIndexOf('/') + 1);
      }
      File file=new File(deployed,filename);
      if (file.exists()) {
        message=smClient.getString("htmlManagerServlet.deployUploadWarExists",filename);
        break;
      }
      ContextName cn=new ContextName(filename,true);
      String name=cn.getName();
      if ((host.findChild(name) != null) && !isDeployed(name)) {
        message=smClient.getString("htmlManagerServlet.deployUploadInServerXml",filename);
        break;
      }
      if (isServiced(name)) {
        message=smClient.getString("managerServlet.inService",name);
      }
 else {
        addServiced(name);
        try {
          warPart.write(file.getAbsolutePath());
          check(name);
        }
  finally {
          removeServiced(name);
        }
      }
      break;
    }
  }
 catch (  Exception e) {
    message=smClient.getString("htmlManagerServlet.deployUploadFail",e.getMessage());
    log(message,e);
  }
  return message;
}

ID 2425=========================================================================type: 1
Method:org.apache.catalina.manager.HTMLManagerServlet#upload(javax.servlet.http.HttpServletRequest, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
protected String upload(HttpServletRequest request,StringManager smClient){
  String message="";
  try {
    while (true) {
      Part warPart=request.getPart("deployWar");
      if (warPart == null) {
        message=smClient.getString("htmlManagerServlet.deployUploadNoFile");
        break;
      }
      String filename=extractFilename(warPart.getHeader("Content-Disposition"));
      if (!filename.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
        message=smClient.getString("htmlManagerServlet.deployUploadNotWar",filename);
        break;
      }
      if (filename.lastIndexOf('\\') >= 0) {
        filename=filename.substring(filename.lastIndexOf('\\') + 1);
      }
      if (filename.lastIndexOf('/') >= 0) {
        filename=filename.substring(filename.lastIndexOf('/') + 1);
      }
      File file=new File(deployed,filename);
      if (file.exists()) {
        message=smClient.getString("htmlManagerServlet.deployUploadWarExists",filename);
        break;
      }
      ContextName cn=new ContextName(filename,true);
      String name=cn.getName();
      if ((host.findChild(name) != null) && !isDeployed(name)) {
        message=smClient.getString("htmlManagerServlet.deployUploadInServerXml",filename);
        break;
      }
      if (isServiced(name)) {
        message=smClient.getString("managerServlet.inService",name);
      }
 else {
        addServiced(name);
        try {
          warPart.write(file.getAbsolutePath());
          check(name);
        }
  finally {
          removeServiced(name);
        }
      }
      break;
    }
  }
 catch (  Exception e) {
    message=smClient.getString("htmlManagerServlet.deployUploadFail",e.getMessage());
    log(message,e);
  }
  return message;
}

ID 2430=========================================================================type: 1
Method:org.apache.catalina.manager.HTMLManagerServlet#list(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isDeployed(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Render a HTML list of the currently active Contexts in our virtual host, and memory and server status information.
 * @param request The request
 * @param response The response
 * @param message a message to display
 */
protected void list(HttpServletRequest request,HttpServletResponse response,String message,StringManager smClient) throws IOException {
  if (debug >= 1)   log("list: Listing contexts for virtual host '" + host.getName() + "'");
  PrintWriter writer=response.getWriter();
  writer.print(Constants.HTML_HEADER_SECTION);
  Object[] args=new Object[2];
  args[0]=request.getContextPath();
  args[1]=smClient.getString("htmlManagerServlet.title");
  writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION,args));
  args=new Object[3];
  args[0]=smClient.getString("htmlManagerServlet.messageLabel");
  if (message == null || message.length() == 0) {
    args[1]="OK";
  }
 else {
    args[1]=RequestUtil.filter(message);
  }
  writer.print(MessageFormat.format(Constants.MESSAGE_SECTION,args));
  args=new Object[9];
  args[0]=smClient.getString("htmlManagerServlet.manager");
  args[1]=response.encodeURL(request.getContextPath() + "/html/list");
  args[2]=smClient.getString("htmlManagerServlet.list");
  args[3]=response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpHtmlManagerFile"));
  args[4]=smClient.getString("htmlManagerServlet.helpHtmlManager");
  args[5]=response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpManagerFile"));
  args[6]=smClient.getString("htmlManagerServlet.helpManager");
  args[7]=response.encodeURL(request.getContextPath() + "/status");
  args[8]=smClient.getString("statusServlet.title");
  writer.print(MessageFormat.format(Constants.MANAGER_SECTION,args));
  args=new Object[7];
  args[0]=smClient.getString("htmlManagerServlet.appsTitle");
  args[1]=smClient.getString("htmlManagerServlet.appsPath");
  args[2]=smClient.getString("htmlManagerServlet.appsVersion");
  args[3]=smClient.getString("htmlManagerServlet.appsName");
  args[4]=smClient.getString("htmlManagerServlet.appsAvailable");
  args[5]=smClient.getString("htmlManagerServlet.appsSessions");
  args[6]=smClient.getString("htmlManagerServlet.appsTasks");
  writer.print(MessageFormat.format(APPS_HEADER_SECTION,args));
  Container children[]=host.findChildren();
  String contextNames[]=new String[children.length];
  for (int i=0; i < children.length; i++)   contextNames[i]=children[i].getName();
  Arrays.sort(contextNames);
  String appsStart=smClient.getString("htmlManagerServlet.appsStart");
  String appsStop=smClient.getString("htmlManagerServlet.appsStop");
  String appsReload=smClient.getString("htmlManagerServlet.appsReload");
  String appsUndeploy=smClient.getString("htmlManagerServlet.appsUndeploy");
  String appsExpire=smClient.getString("htmlManagerServlet.appsExpire");
  String noVersion="<i>" + smClient.getString("htmlManagerServlet.noVersion") + "</i>";
  boolean isHighlighted=true;
  boolean isDeployed=true;
  String highlightColor=null;
  for (  String contextName : contextNames) {
    Context ctxt=(Context)host.findChild(contextName);
    if (ctxt != null) {
      isHighlighted=!isHighlighted;
      if (isHighlighted) {
        highlightColor="#C3F3C3";
      }
 else {
        highlightColor="#FFFFFF";
      }
      String contextPath=ctxt.getPath();
      String displayPath=contextPath;
      if (displayPath.equals("")) {
        displayPath="/";
      }
      StringBuilder tmp=new StringBuilder();
      tmp.append("path=");
      tmp.append(URL_ENCODER.encode(displayPath,"UTF-8"));
      if (ctxt.getWebappVersion().length() > 0) {
        tmp.append("&version=");
        tmp.append(URL_ENCODER.encode(ctxt.getWebappVersion(),"UTF-8"));
      }
      String pathVersion=tmp.toString();
      try {
        isDeployed=isDeployed(contextName);
      }
 catch (      Exception e) {
        isDeployed=false;
      }
      args=new Object[7];
      args[0]="<a href=\"" + URL_ENCODER.encode(contextPath + "/","UTF-8") + "\">"+ RequestUtil.filter(displayPath)+ "</a>";
      if ("".equals(ctxt.getWebappVersion())) {
        args[1]=noVersion;
      }
 else {
        args[1]=RequestUtil.filter(ctxt.getWebappVersion());
      }
      if (ctxt.getDisplayName() == null) {
        args[2]="&nbsp;";
      }
 else {
        args[2]=RequestUtil.filter(ctxt.getDisplayName());
      }
      args[3]=Boolean.valueOf(ctxt.getState().isAvailable());
      args[4]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/sessions?" + pathVersion));
      Manager manager=ctxt.getManager();
      if (manager instanceof DistributedManager && showProxySessions) {
        args[5]=Integer.valueOf(((DistributedManager)manager).getActiveSessionsFull());
      }
 else       if (manager != null) {
        args[5]=Integer.valueOf(manager.getActiveSessions());
      }
 else {
        args[5]=Integer.valueOf(0);
      }
      args[6]=highlightColor;
      writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION,args));
      args=new Object[14];
      args[0]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/start?" + pathVersion));
      args[1]=appsStart;
      args[2]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/stop?" + pathVersion));
      args[3]=appsStop;
      args[4]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/reload?" + pathVersion));
      args[5]=appsReload;
      args[6]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/undeploy?" + pathVersion));
      args[7]=appsUndeploy;
      args[8]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/expire?" + pathVersion));
      args[9]=appsExpire;
      args[10]=smClient.getString("htmlManagerServlet.expire.explain");
      if (manager == null) {
        args[11]=smClient.getString("htmlManagerServlet.noManager");
      }
 else {
        args[11]=Integer.valueOf(ctxt.getSessionTimeout());
      }
      args[12]=smClient.getString("htmlManagerServlet.expire.unit");
      args[13]=highlightColor;
      if (ctxt.getName().equals(this.context.getName())) {
        writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION,args));
      }
 else       if (ctxt.getState().isAvailable() && isDeployed) {
        writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
 else       if (ctxt.getState().isAvailable() && !isDeployed) {
        writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
 else       if (!ctxt.getState().isAvailable() && isDeployed) {
        writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
 else {
        writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
    }
  }
  args=new Object[7];
  args[0]=smClient.getString("htmlManagerServlet.deployTitle");
  args[1]=smClient.getString("htmlManagerServlet.deployServer");
  args[2]=response.encodeURL(request.getContextPath() + "/html/deploy");
  args[3]=smClient.getString("htmlManagerServlet.deployPath");
  args[4]=smClient.getString("htmlManagerServlet.deployConfig");
  args[5]=smClient.getString("htmlManagerServlet.deployWar");
  args[6]=smClient.getString("htmlManagerServlet.deployButton");
  writer.print(MessageFormat.format(DEPLOY_SECTION,args));
  args=new Object[4];
  args[0]=smClient.getString("htmlManagerServlet.deployUpload");
  args[1]=response.encodeURL(request.getContextPath() + "/html/upload");
  args[2]=smClient.getString("htmlManagerServlet.deployUploadFile");
  args[3]=smClient.getString("htmlManagerServlet.deployButton");
  writer.print(MessageFormat.format(UPLOAD_SECTION,args));
  args=new Object[5];
  args[0]=smClient.getString("htmlManagerServlet.diagnosticsTitle");
  args[1]=smClient.getString("htmlManagerServlet.diagnosticsLeak");
  args[2]=response.encodeURL(request.getContextPath() + "/html/findleaks");
  args[3]=smClient.getString("htmlManagerServlet.diagnosticsLeakWarning");
  args[4]=smClient.getString("htmlManagerServlet.diagnosticsLeakButton");
  writer.print(MessageFormat.format(DIAGNOSTICS_SECTION,args));
  args=new Object[9];
  args[0]=smClient.getString("htmlManagerServlet.serverTitle");
  args[1]=smClient.getString("htmlManagerServlet.serverVersion");
  args[2]=smClient.getString("htmlManagerServlet.serverJVMVersion");
  args[3]=smClient.getString("htmlManagerServlet.serverJVMVendor");
  args[4]=smClient.getString("htmlManagerServlet.serverOSName");
  args[5]=smClient.getString("htmlManagerServlet.serverOSVersion");
  args[6]=smClient.getString("htmlManagerServlet.serverOSArch");
  args[7]=smClient.getString("htmlManagerServlet.serverHostname");
  args[8]=smClient.getString("htmlManagerServlet.serverIPAddress");
  writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION,args));
  args=new Object[8];
  args[0]=ServerInfo.getServerInfo();
  args[1]=System.getProperty("java.runtime.version");
  args[2]=System.getProperty("java.vm.vendor");
  args[3]=System.getProperty("os.name");
  args[4]=System.getProperty("os.version");
  args[5]=System.getProperty("os.arch");
  try {
    InetAddress address=InetAddress.getLocalHost();
    args[6]=address.getHostName();
    args[7]=address.getHostAddress();
  }
 catch (  UnknownHostException e) {
    args[6]="-";
    args[7]="-";
  }
  writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION,args));
  writer.print(Constants.HTML_TAIL_SECTION);
  writer.flush();
  writer.close();
}

ID 2431=========================================================================type: 1
Method:org.apache.catalina.manager.HTMLManagerServlet#list(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, org.apache.tomcat.util.res.StringManager)
Rmethod: java.net.InetAddress#getLocalHost()
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
/** 
 * Render a HTML list of the currently active Contexts in our virtual host, and memory and server status information.
 * @param request The request
 * @param response The response
 * @param message a message to display
 */
protected void list(HttpServletRequest request,HttpServletResponse response,String message,StringManager smClient) throws IOException {
  if (debug >= 1)   log("list: Listing contexts for virtual host '" + host.getName() + "'");
  PrintWriter writer=response.getWriter();
  writer.print(Constants.HTML_HEADER_SECTION);
  Object[] args=new Object[2];
  args[0]=request.getContextPath();
  args[1]=smClient.getString("htmlManagerServlet.title");
  writer.print(MessageFormat.format(Constants.BODY_HEADER_SECTION,args));
  args=new Object[3];
  args[0]=smClient.getString("htmlManagerServlet.messageLabel");
  if (message == null || message.length() == 0) {
    args[1]="OK";
  }
 else {
    args[1]=RequestUtil.filter(message);
  }
  writer.print(MessageFormat.format(Constants.MESSAGE_SECTION,args));
  args=new Object[9];
  args[0]=smClient.getString("htmlManagerServlet.manager");
  args[1]=response.encodeURL(request.getContextPath() + "/html/list");
  args[2]=smClient.getString("htmlManagerServlet.list");
  args[3]=response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpHtmlManagerFile"));
  args[4]=smClient.getString("htmlManagerServlet.helpHtmlManager");
  args[5]=response.encodeURL(request.getContextPath() + "/" + smClient.getString("htmlManagerServlet.helpManagerFile"));
  args[6]=smClient.getString("htmlManagerServlet.helpManager");
  args[7]=response.encodeURL(request.getContextPath() + "/status");
  args[8]=smClient.getString("statusServlet.title");
  writer.print(MessageFormat.format(Constants.MANAGER_SECTION,args));
  args=new Object[7];
  args[0]=smClient.getString("htmlManagerServlet.appsTitle");
  args[1]=smClient.getString("htmlManagerServlet.appsPath");
  args[2]=smClient.getString("htmlManagerServlet.appsVersion");
  args[3]=smClient.getString("htmlManagerServlet.appsName");
  args[4]=smClient.getString("htmlManagerServlet.appsAvailable");
  args[5]=smClient.getString("htmlManagerServlet.appsSessions");
  args[6]=smClient.getString("htmlManagerServlet.appsTasks");
  writer.print(MessageFormat.format(APPS_HEADER_SECTION,args));
  Container children[]=host.findChildren();
  String contextNames[]=new String[children.length];
  for (int i=0; i < children.length; i++)   contextNames[i]=children[i].getName();
  Arrays.sort(contextNames);
  String appsStart=smClient.getString("htmlManagerServlet.appsStart");
  String appsStop=smClient.getString("htmlManagerServlet.appsStop");
  String appsReload=smClient.getString("htmlManagerServlet.appsReload");
  String appsUndeploy=smClient.getString("htmlManagerServlet.appsUndeploy");
  String appsExpire=smClient.getString("htmlManagerServlet.appsExpire");
  String noVersion="<i>" + smClient.getString("htmlManagerServlet.noVersion") + "</i>";
  boolean isHighlighted=true;
  boolean isDeployed=true;
  String highlightColor=null;
  for (  String contextName : contextNames) {
    Context ctxt=(Context)host.findChild(contextName);
    if (ctxt != null) {
      isHighlighted=!isHighlighted;
      if (isHighlighted) {
        highlightColor="#C3F3C3";
      }
 else {
        highlightColor="#FFFFFF";
      }
      String contextPath=ctxt.getPath();
      String displayPath=contextPath;
      if (displayPath.equals("")) {
        displayPath="/";
      }
      StringBuilder tmp=new StringBuilder();
      tmp.append("path=");
      tmp.append(URL_ENCODER.encode(displayPath,"UTF-8"));
      if (ctxt.getWebappVersion().length() > 0) {
        tmp.append("&version=");
        tmp.append(URL_ENCODER.encode(ctxt.getWebappVersion(),"UTF-8"));
      }
      String pathVersion=tmp.toString();
      try {
        isDeployed=isDeployed(contextName);
      }
 catch (      Exception e) {
        isDeployed=false;
      }
      args=new Object[7];
      args[0]="<a href=\"" + URL_ENCODER.encode(contextPath + "/","UTF-8") + "\">"+ RequestUtil.filter(displayPath)+ "</a>";
      if ("".equals(ctxt.getWebappVersion())) {
        args[1]=noVersion;
      }
 else {
        args[1]=RequestUtil.filter(ctxt.getWebappVersion());
      }
      if (ctxt.getDisplayName() == null) {
        args[2]="&nbsp;";
      }
 else {
        args[2]=RequestUtil.filter(ctxt.getDisplayName());
      }
      args[3]=Boolean.valueOf(ctxt.getState().isAvailable());
      args[4]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/sessions?" + pathVersion));
      Manager manager=ctxt.getManager();
      if (manager instanceof DistributedManager && showProxySessions) {
        args[5]=Integer.valueOf(((DistributedManager)manager).getActiveSessionsFull());
      }
 else       if (manager != null) {
        args[5]=Integer.valueOf(manager.getActiveSessions());
      }
 else {
        args[5]=Integer.valueOf(0);
      }
      args[6]=highlightColor;
      writer.print(MessageFormat.format(APPS_ROW_DETAILS_SECTION,args));
      args=new Object[14];
      args[0]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/start?" + pathVersion));
      args[1]=appsStart;
      args[2]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/stop?" + pathVersion));
      args[3]=appsStop;
      args[4]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/reload?" + pathVersion));
      args[5]=appsReload;
      args[6]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/undeploy?" + pathVersion));
      args[7]=appsUndeploy;
      args[8]=RequestUtil.filter(response.encodeURL(request.getContextPath() + "/html/expire?" + pathVersion));
      args[9]=appsExpire;
      args[10]=smClient.getString("htmlManagerServlet.expire.explain");
      if (manager == null) {
        args[11]=smClient.getString("htmlManagerServlet.noManager");
      }
 else {
        args[11]=Integer.valueOf(ctxt.getSessionTimeout());
      }
      args[12]=smClient.getString("htmlManagerServlet.expire.unit");
      args[13]=highlightColor;
      if (ctxt.getName().equals(this.context.getName())) {
        writer.print(MessageFormat.format(MANAGER_APP_ROW_BUTTON_SECTION,args));
      }
 else       if (ctxt.getState().isAvailable() && isDeployed) {
        writer.print(MessageFormat.format(STARTED_DEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
 else       if (ctxt.getState().isAvailable() && !isDeployed) {
        writer.print(MessageFormat.format(STARTED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
 else       if (!ctxt.getState().isAvailable() && isDeployed) {
        writer.print(MessageFormat.format(STOPPED_DEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
 else {
        writer.print(MessageFormat.format(STOPPED_NONDEPLOYED_APPS_ROW_BUTTON_SECTION,args));
      }
    }
  }
  args=new Object[7];
  args[0]=smClient.getString("htmlManagerServlet.deployTitle");
  args[1]=smClient.getString("htmlManagerServlet.deployServer");
  args[2]=response.encodeURL(request.getContextPath() + "/html/deploy");
  args[3]=smClient.getString("htmlManagerServlet.deployPath");
  args[4]=smClient.getString("htmlManagerServlet.deployConfig");
  args[5]=smClient.getString("htmlManagerServlet.deployWar");
  args[6]=smClient.getString("htmlManagerServlet.deployButton");
  writer.print(MessageFormat.format(DEPLOY_SECTION,args));
  args=new Object[4];
  args[0]=smClient.getString("htmlManagerServlet.deployUpload");
  args[1]=response.encodeURL(request.getContextPath() + "/html/upload");
  args[2]=smClient.getString("htmlManagerServlet.deployUploadFile");
  args[3]=smClient.getString("htmlManagerServlet.deployButton");
  writer.print(MessageFormat.format(UPLOAD_SECTION,args));
  args=new Object[5];
  args[0]=smClient.getString("htmlManagerServlet.diagnosticsTitle");
  args[1]=smClient.getString("htmlManagerServlet.diagnosticsLeak");
  args[2]=response.encodeURL(request.getContextPath() + "/html/findleaks");
  args[3]=smClient.getString("htmlManagerServlet.diagnosticsLeakWarning");
  args[4]=smClient.getString("htmlManagerServlet.diagnosticsLeakButton");
  writer.print(MessageFormat.format(DIAGNOSTICS_SECTION,args));
  args=new Object[9];
  args[0]=smClient.getString("htmlManagerServlet.serverTitle");
  args[1]=smClient.getString("htmlManagerServlet.serverVersion");
  args[2]=smClient.getString("htmlManagerServlet.serverJVMVersion");
  args[3]=smClient.getString("htmlManagerServlet.serverJVMVendor");
  args[4]=smClient.getString("htmlManagerServlet.serverOSName");
  args[5]=smClient.getString("htmlManagerServlet.serverOSVersion");
  args[6]=smClient.getString("htmlManagerServlet.serverOSArch");
  args[7]=smClient.getString("htmlManagerServlet.serverHostname");
  args[8]=smClient.getString("htmlManagerServlet.serverIPAddress");
  writer.print(MessageFormat.format(Constants.SERVER_HEADER_SECTION,args));
  args=new Object[8];
  args[0]=ServerInfo.getServerInfo();
  args[1]=System.getProperty("java.runtime.version");
  args[2]=System.getProperty("java.vm.vendor");
  args[3]=System.getProperty("os.name");
  args[4]=System.getProperty("os.version");
  args[5]=System.getProperty("os.arch");
  try {
    InetAddress address=InetAddress.getLocalHost();
    args[6]=address.getHostName();
    args[7]=address.getHostAddress();
  }
 catch (  UnknownHostException e) {
    args[6]="-";
    args[7]="-";
  }
  writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION,args));
  writer.print(Constants.HTML_TAIL_SECTION);
  writer.flush();
  writer.close();
}

ID 2432=========================================================================type: 1
Method:org.apache.catalina.manager.HTMLManagerServlet#expireSessions(org.apache.catalina.util.ContextName, javax.servlet.http.HttpServletRequest, org.apache.tomcat.util.res.StringManager)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Extract the expiration request parameter
 * @param cn Name of the application from which to expire sessions
 * @param req
 * @param smClient  StringManager for the client's locale
 */
protected String expireSessions(ContextName cn,HttpServletRequest req,StringManager smClient){
  int idle=-1;
  String idleParam=req.getParameter("idle");
  if (idleParam != null) {
    try {
      idle=Integer.parseInt(idleParam);
    }
 catch (    NumberFormatException e) {
      log("Could not parse idle parameter to an int: " + idleParam);
    }
  }
  return sessions(cn,idle,smClient);
}

ID 2449=========================================================================type: 1
Method:org.apache.catalina.manager.StatusManagerServlet#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: java.net.InetAddress#getLocalHost()
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
/** 
 * Process a GET request for the specified resource.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  int mode=0;
  if (request.getParameter("XML") != null && request.getParameter("XML").equals("true")) {
    mode=1;
  }
  StatusTransformer.setContentType(response,mode);
  PrintWriter writer=response.getWriter();
  boolean completeStatus=false;
  if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
    completeStatus=true;
  }
  Object[] args=new Object[1];
  args[0]=request.getContextPath();
  StatusTransformer.writeHeader(writer,args,mode);
  args=new Object[2];
  args[0]=request.getContextPath();
  if (completeStatus) {
    args[1]=sm.getString("statusServlet.complete");
  }
 else {
    args[1]=sm.getString("statusServlet.title");
  }
  StatusTransformer.writeBody(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.manager");
  args[1]=response.encodeURL(request.getContextPath() + "/html/list");
  args[2]=sm.getString("htmlManagerServlet.list");
  args[3]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile"));
  args[4]=sm.getString("htmlManagerServlet.helpHtmlManager");
  args[5]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile"));
  args[6]=sm.getString("htmlManagerServlet.helpManager");
  if (completeStatus) {
    args[7]=response.encodeURL(request.getContextPath() + "/status");
    args[8]=sm.getString("statusServlet.title");
  }
 else {
    args[7]=response.encodeURL(request.getContextPath() + "/status/all");
    args[8]=sm.getString("statusServlet.complete");
  }
  StatusTransformer.writeManager(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.serverTitle");
  args[1]=sm.getString("htmlManagerServlet.serverVersion");
  args[2]=sm.getString("htmlManagerServlet.serverJVMVersion");
  args[3]=sm.getString("htmlManagerServlet.serverJVMVendor");
  args[4]=sm.getString("htmlManagerServlet.serverOSName");
  args[5]=sm.getString("htmlManagerServlet.serverOSVersion");
  args[6]=sm.getString("htmlManagerServlet.serverOSArch");
  args[7]=sm.getString("htmlManagerServlet.serverHostname");
  args[8]=sm.getString("htmlManagerServlet.serverIPAddress");
  StatusTransformer.writePageHeading(writer,args,mode);
  args=new Object[8];
  args[0]=ServerInfo.getServerInfo();
  args[1]=System.getProperty("java.runtime.version");
  args[2]=System.getProperty("java.vm.vendor");
  args[3]=System.getProperty("os.name");
  args[4]=System.getProperty("os.version");
  args[5]=System.getProperty("os.arch");
  try {
    InetAddress address=InetAddress.getLocalHost();
    args[6]=address.getHostName();
    args[7]=address.getHostAddress();
  }
 catch (  UnknownHostException e) {
    args[6]="-";
    args[7]="-";
  }
  StatusTransformer.writeServerInfo(writer,args,mode);
  try {
    StatusTransformer.writeOSState(writer,mode);
    StatusTransformer.writeVMState(writer,mode);
    Enumeration<ObjectName> enumeration=threadPools.elements();
    while (enumeration.hasMoreElements()) {
      ObjectName objectName=enumeration.nextElement();
      String name=objectName.getKeyProperty("name");
      StatusTransformer.writeConnectorState(writer,objectName,name,mBeanServer,globalRequestProcessors,requestProcessors,mode);
    }
    if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
      StatusTransformer.writeDetailedState(writer,mBeanServer,mode);
    }
  }
 catch (  Exception e) {
    throw new ServletException(e);
  }
  StatusTransformer.writeFooter(writer,mode);
}

ID 2450=========================================================================type: 1
Method:org.apache.catalina.manager.StatusManagerServlet#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.catalina.manager.StatusTransformer#writeVMState(java.io.PrintWriter, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process a GET request for the specified resource.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  int mode=0;
  if (request.getParameter("XML") != null && request.getParameter("XML").equals("true")) {
    mode=1;
  }
  StatusTransformer.setContentType(response,mode);
  PrintWriter writer=response.getWriter();
  boolean completeStatus=false;
  if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
    completeStatus=true;
  }
  Object[] args=new Object[1];
  args[0]=request.getContextPath();
  StatusTransformer.writeHeader(writer,args,mode);
  args=new Object[2];
  args[0]=request.getContextPath();
  if (completeStatus) {
    args[1]=sm.getString("statusServlet.complete");
  }
 else {
    args[1]=sm.getString("statusServlet.title");
  }
  StatusTransformer.writeBody(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.manager");
  args[1]=response.encodeURL(request.getContextPath() + "/html/list");
  args[2]=sm.getString("htmlManagerServlet.list");
  args[3]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile"));
  args[4]=sm.getString("htmlManagerServlet.helpHtmlManager");
  args[5]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile"));
  args[6]=sm.getString("htmlManagerServlet.helpManager");
  if (completeStatus) {
    args[7]=response.encodeURL(request.getContextPath() + "/status");
    args[8]=sm.getString("statusServlet.title");
  }
 else {
    args[7]=response.encodeURL(request.getContextPath() + "/status/all");
    args[8]=sm.getString("statusServlet.complete");
  }
  StatusTransformer.writeManager(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.serverTitle");
  args[1]=sm.getString("htmlManagerServlet.serverVersion");
  args[2]=sm.getString("htmlManagerServlet.serverJVMVersion");
  args[3]=sm.getString("htmlManagerServlet.serverJVMVendor");
  args[4]=sm.getString("htmlManagerServlet.serverOSName");
  args[5]=sm.getString("htmlManagerServlet.serverOSVersion");
  args[6]=sm.getString("htmlManagerServlet.serverOSArch");
  args[7]=sm.getString("htmlManagerServlet.serverHostname");
  args[8]=sm.getString("htmlManagerServlet.serverIPAddress");
  StatusTransformer.writePageHeading(writer,args,mode);
  args=new Object[8];
  args[0]=ServerInfo.getServerInfo();
  args[1]=System.getProperty("java.runtime.version");
  args[2]=System.getProperty("java.vm.vendor");
  args[3]=System.getProperty("os.name");
  args[4]=System.getProperty("os.version");
  args[5]=System.getProperty("os.arch");
  try {
    InetAddress address=InetAddress.getLocalHost();
    args[6]=address.getHostName();
    args[7]=address.getHostAddress();
  }
 catch (  UnknownHostException e) {
    args[6]="-";
    args[7]="-";
  }
  StatusTransformer.writeServerInfo(writer,args,mode);
  try {
    StatusTransformer.writeOSState(writer,mode);
    StatusTransformer.writeVMState(writer,mode);
    Enumeration<ObjectName> enumeration=threadPools.elements();
    while (enumeration.hasMoreElements()) {
      ObjectName objectName=enumeration.nextElement();
      String name=objectName.getKeyProperty("name");
      StatusTransformer.writeConnectorState(writer,objectName,name,mBeanServer,globalRequestProcessors,requestProcessors,mode);
    }
    if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
      StatusTransformer.writeDetailedState(writer,mBeanServer,mode);
    }
  }
 catch (  Exception e) {
    throw new ServletException(e);
  }
  StatusTransformer.writeFooter(writer,mode);
}

ID 2451=========================================================================type: 1
Method:org.apache.catalina.manager.StatusManagerServlet#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.catalina.manager.StatusTransformer#writeConnectorState(java.io.PrintWriter, javax.management.ObjectName, java.lang.String, javax.management.MBeanServer, Vector<javax.management.ObjectName>, Vector<javax.management.ObjectName>, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process a GET request for the specified resource.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  int mode=0;
  if (request.getParameter("XML") != null && request.getParameter("XML").equals("true")) {
    mode=1;
  }
  StatusTransformer.setContentType(response,mode);
  PrintWriter writer=response.getWriter();
  boolean completeStatus=false;
  if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
    completeStatus=true;
  }
  Object[] args=new Object[1];
  args[0]=request.getContextPath();
  StatusTransformer.writeHeader(writer,args,mode);
  args=new Object[2];
  args[0]=request.getContextPath();
  if (completeStatus) {
    args[1]=sm.getString("statusServlet.complete");
  }
 else {
    args[1]=sm.getString("statusServlet.title");
  }
  StatusTransformer.writeBody(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.manager");
  args[1]=response.encodeURL(request.getContextPath() + "/html/list");
  args[2]=sm.getString("htmlManagerServlet.list");
  args[3]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile"));
  args[4]=sm.getString("htmlManagerServlet.helpHtmlManager");
  args[5]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile"));
  args[6]=sm.getString("htmlManagerServlet.helpManager");
  if (completeStatus) {
    args[7]=response.encodeURL(request.getContextPath() + "/status");
    args[8]=sm.getString("statusServlet.title");
  }
 else {
    args[7]=response.encodeURL(request.getContextPath() + "/status/all");
    args[8]=sm.getString("statusServlet.complete");
  }
  StatusTransformer.writeManager(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.serverTitle");
  args[1]=sm.getString("htmlManagerServlet.serverVersion");
  args[2]=sm.getString("htmlManagerServlet.serverJVMVersion");
  args[3]=sm.getString("htmlManagerServlet.serverJVMVendor");
  args[4]=sm.getString("htmlManagerServlet.serverOSName");
  args[5]=sm.getString("htmlManagerServlet.serverOSVersion");
  args[6]=sm.getString("htmlManagerServlet.serverOSArch");
  args[7]=sm.getString("htmlManagerServlet.serverHostname");
  args[8]=sm.getString("htmlManagerServlet.serverIPAddress");
  StatusTransformer.writePageHeading(writer,args,mode);
  args=new Object[8];
  args[0]=ServerInfo.getServerInfo();
  args[1]=System.getProperty("java.runtime.version");
  args[2]=System.getProperty("java.vm.vendor");
  args[3]=System.getProperty("os.name");
  args[4]=System.getProperty("os.version");
  args[5]=System.getProperty("os.arch");
  try {
    InetAddress address=InetAddress.getLocalHost();
    args[6]=address.getHostName();
    args[7]=address.getHostAddress();
  }
 catch (  UnknownHostException e) {
    args[6]="-";
    args[7]="-";
  }
  StatusTransformer.writeServerInfo(writer,args,mode);
  try {
    StatusTransformer.writeOSState(writer,mode);
    StatusTransformer.writeVMState(writer,mode);
    Enumeration<ObjectName> enumeration=threadPools.elements();
    while (enumeration.hasMoreElements()) {
      ObjectName objectName=enumeration.nextElement();
      String name=objectName.getKeyProperty("name");
      StatusTransformer.writeConnectorState(writer,objectName,name,mBeanServer,globalRequestProcessors,requestProcessors,mode);
    }
    if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
      StatusTransformer.writeDetailedState(writer,mBeanServer,mode);
    }
  }
 catch (  Exception e) {
    throw new ServletException(e);
  }
  StatusTransformer.writeFooter(writer,mode);
}

ID 2452=========================================================================type: 1
Method:org.apache.catalina.manager.StatusManagerServlet#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.catalina.manager.StatusTransformer#writeDetailedState(java.io.PrintWriter, javax.management.MBeanServer, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process a GET request for the specified resource.
 * @param request The servlet request we are processing
 * @param response The servlet response we are creating
 * @exception IOException if an input/output error occurs
 * @exception ServletException if a servlet-specified error occurs
 */
@Override public void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  int mode=0;
  if (request.getParameter("XML") != null && request.getParameter("XML").equals("true")) {
    mode=1;
  }
  StatusTransformer.setContentType(response,mode);
  PrintWriter writer=response.getWriter();
  boolean completeStatus=false;
  if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
    completeStatus=true;
  }
  Object[] args=new Object[1];
  args[0]=request.getContextPath();
  StatusTransformer.writeHeader(writer,args,mode);
  args=new Object[2];
  args[0]=request.getContextPath();
  if (completeStatus) {
    args[1]=sm.getString("statusServlet.complete");
  }
 else {
    args[1]=sm.getString("statusServlet.title");
  }
  StatusTransformer.writeBody(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.manager");
  args[1]=response.encodeURL(request.getContextPath() + "/html/list");
  args[2]=sm.getString("htmlManagerServlet.list");
  args[3]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpHtmlManagerFile"));
  args[4]=sm.getString("htmlManagerServlet.helpHtmlManager");
  args[5]=response.encodeURL(request.getContextPath() + "/" + sm.getString("htmlManagerServlet.helpManagerFile"));
  args[6]=sm.getString("htmlManagerServlet.helpManager");
  if (completeStatus) {
    args[7]=response.encodeURL(request.getContextPath() + "/status");
    args[8]=sm.getString("statusServlet.title");
  }
 else {
    args[7]=response.encodeURL(request.getContextPath() + "/status/all");
    args[8]=sm.getString("statusServlet.complete");
  }
  StatusTransformer.writeManager(writer,args,mode);
  args=new Object[9];
  args[0]=sm.getString("htmlManagerServlet.serverTitle");
  args[1]=sm.getString("htmlManagerServlet.serverVersion");
  args[2]=sm.getString("htmlManagerServlet.serverJVMVersion");
  args[3]=sm.getString("htmlManagerServlet.serverJVMVendor");
  args[4]=sm.getString("htmlManagerServlet.serverOSName");
  args[5]=sm.getString("htmlManagerServlet.serverOSVersion");
  args[6]=sm.getString("htmlManagerServlet.serverOSArch");
  args[7]=sm.getString("htmlManagerServlet.serverHostname");
  args[8]=sm.getString("htmlManagerServlet.serverIPAddress");
  StatusTransformer.writePageHeading(writer,args,mode);
  args=new Object[8];
  args[0]=ServerInfo.getServerInfo();
  args[1]=System.getProperty("java.runtime.version");
  args[2]=System.getProperty("java.vm.vendor");
  args[3]=System.getProperty("os.name");
  args[4]=System.getProperty("os.version");
  args[5]=System.getProperty("os.arch");
  try {
    InetAddress address=InetAddress.getLocalHost();
    args[6]=address.getHostName();
    args[7]=address.getHostAddress();
  }
 catch (  UnknownHostException e) {
    args[6]="-";
    args[7]="-";
  }
  StatusTransformer.writeServerInfo(writer,args,mode);
  try {
    StatusTransformer.writeOSState(writer,mode);
    StatusTransformer.writeVMState(writer,mode);
    Enumeration<ObjectName> enumeration=threadPools.elements();
    while (enumeration.hasMoreElements()) {
      ObjectName objectName=enumeration.nextElement();
      String name=objectName.getKeyProperty("name");
      StatusTransformer.writeConnectorState(writer,objectName,name,mBeanServer,globalRequestProcessors,requestProcessors,mode);
    }
    if ((request.getPathInfo() != null) && (request.getPathInfo().equals("/all"))) {
      StatusTransformer.writeDetailedState(writer,mBeanServer,mode);
    }
  }
 catch (  Exception e) {
    throw new ServletException(e);
  }
  StatusTransformer.writeFooter(writer,mode);
}

ID 2520=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#save(java.io.PrintWriter, java.lang.String, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.core.StandardServer#storeConfig()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Store server configuration.
 * @param path Optional context path to save
 */
protected synchronized void save(PrintWriter writer,String path,StringManager smClient){
  Server server=((Engine)host.getParent()).getService().getServer();
  if (!(server instanceof StandardServer)) {
    writer.println(smClient.getString("managerServlet.saveFail",server));
    return;
  }
  if ((path == null) || path.length() == 0 || !path.startsWith("/")) {
    try {
      ((StandardServer)server).storeConfig();
      writer.println(smClient.getString("managerServlet.saved"));
    }
 catch (    Exception e) {
      log("managerServlet.storeConfig",e);
      writer.println(smClient.getString("managerServlet.exception",e.toString()));
      return;
    }
  }
 else {
    String contextPath=path;
    if (path.equals("/")) {
      contextPath="";
    }
    Context context=(Context)host.findChild(contextPath);
    if (context == null) {
      writer.println(smClient.getString("managerServlet.noContext",path));
      return;
    }
    try {
      ((StandardServer)server).storeContext(context);
      writer.println(smClient.getString("managerServlet.savedContext",path));
    }
 catch (    Exception e) {
      log("managerServlet.save[" + path + "]",e);
      writer.println(smClient.getString("managerServlet.exception",e.toString()));
      return;
    }
  }
}

ID 2521=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#save(java.io.PrintWriter, java.lang.String, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.core.StandardServer#storeContext(org.apache.catalina.Context)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Store server configuration.
 * @param path Optional context path to save
 */
protected synchronized void save(PrintWriter writer,String path,StringManager smClient){
  Server server=((Engine)host.getParent()).getService().getServer();
  if (!(server instanceof StandardServer)) {
    writer.println(smClient.getString("managerServlet.saveFail",server));
    return;
  }
  if ((path == null) || path.length() == 0 || !path.startsWith("/")) {
    try {
      ((StandardServer)server).storeConfig();
      writer.println(smClient.getString("managerServlet.saved"));
    }
 catch (    Exception e) {
      log("managerServlet.storeConfig",e);
      writer.println(smClient.getString("managerServlet.exception",e.toString()));
      return;
    }
  }
 else {
    String contextPath=path;
    if (path.equals("/")) {
      contextPath="";
    }
    Context context=(Context)host.findChild(contextPath);
    if (context == null) {
      writer.println(smClient.getString("managerServlet.noContext",path));
      return;
    }
    try {
      ((StandardServer)server).storeContext(context);
      writer.println(smClient.getString("managerServlet.savedContext",path));
    }
 catch (    Exception e) {
      log("managerServlet.save[" + path + "]",e);
      writer.println(smClient.getString("managerServlet.exception",e.toString()));
      return;
    }
  }
}

ID 2522=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#deploy(java.io.PrintWriter, org.apache.catalina.util.ContextName, java.lang.String, boolean, javax.servlet.http.HttpServletRequest, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Deploy a web application archive (included in the current request) at the specified context path.
 * @param writer   Writer to render results to
 * @param cn       Name of the application to be installed
 * @param tag      Tag to be associated with the webapp
 * @param update   Flag that indicates that any existing app should bereplaced
 * @param request  Servlet request we are processing
 * @param smClient i18n messages using the locale of the client
 */
protected synchronized void deploy(PrintWriter writer,ContextName cn,String tag,boolean update,HttpServletRequest request,StringManager smClient){
  if (debug >= 1) {
    log("deploy: Deploying web application '" + cn + "'");
  }
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  String name=cn.getName();
  String baseName=cn.getBaseName();
  String displayPath=cn.getDisplayName();
  Context context=(Context)host.findChild(name);
  if (context != null && !update) {
    writer.println(smClient.getString("managerServlet.alreadyContext",displayPath));
    return;
  }
  File deployedWar=new File(deployed,baseName + ".war");
  File uploadedWar;
  if (tag == null) {
    if (update) {
      uploadedWar=new File(deployedWar.getAbsolutePath() + ".tmp");
      if (uploadedWar.exists() && !uploadedWar.delete()) {
        writer.println(smClient.getString("managerServlet.deleteFail",uploadedWar));
      }
    }
 else {
      uploadedWar=deployedWar;
    }
  }
 else {
    File uploadPath=new File(versioned,tag);
    if (!uploadPath.mkdirs() && !uploadPath.isDirectory()) {
      writer.println(smClient.getString("managerServlet.mkdirFail",uploadPath));
      return;
    }
    uploadedWar=new File(uploadPath,baseName + ".war");
  }
  if (debug >= 2) {
    log("Uploading WAR file to " + uploadedWar);
  }
  try {
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        uploadWar(writer,request,uploadedWar,smClient);
        if (update && tag == null) {
          if (deployedWar.exists() && !deployedWar.delete()) {
            writer.println(smClient.getString("managerServlet.deleteFail",deployedWar));
            return;
          }
          uploadedWar.renameTo(deployedWar);
        }
        if (tag != null) {
          copy(uploadedWar,deployedWar);
        }
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
  }
 catch (  Exception e) {
    log("managerServlet.check[" + displayPath + "]",e);
    writer.println(smClient.getString("managerServlet.exception",e.toString()));
    return;
  }
  writeDeployResult(writer,smClient,name,displayPath);
}

ID 2523=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#deploy(java.io.PrintWriter, org.apache.catalina.util.ContextName, java.lang.String, boolean, javax.servlet.http.HttpServletRequest, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Deploy a web application archive (included in the current request) at the specified context path.
 * @param writer   Writer to render results to
 * @param cn       Name of the application to be installed
 * @param tag      Tag to be associated with the webapp
 * @param update   Flag that indicates that any existing app should bereplaced
 * @param request  Servlet request we are processing
 * @param smClient i18n messages using the locale of the client
 */
protected synchronized void deploy(PrintWriter writer,ContextName cn,String tag,boolean update,HttpServletRequest request,StringManager smClient){
  if (debug >= 1) {
    log("deploy: Deploying web application '" + cn + "'");
  }
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  String name=cn.getName();
  String baseName=cn.getBaseName();
  String displayPath=cn.getDisplayName();
  Context context=(Context)host.findChild(name);
  if (context != null && !update) {
    writer.println(smClient.getString("managerServlet.alreadyContext",displayPath));
    return;
  }
  File deployedWar=new File(deployed,baseName + ".war");
  File uploadedWar;
  if (tag == null) {
    if (update) {
      uploadedWar=new File(deployedWar.getAbsolutePath() + ".tmp");
      if (uploadedWar.exists() && !uploadedWar.delete()) {
        writer.println(smClient.getString("managerServlet.deleteFail",uploadedWar));
      }
    }
 else {
      uploadedWar=deployedWar;
    }
  }
 else {
    File uploadPath=new File(versioned,tag);
    if (!uploadPath.mkdirs() && !uploadPath.isDirectory()) {
      writer.println(smClient.getString("managerServlet.mkdirFail",uploadPath));
      return;
    }
    uploadedWar=new File(uploadPath,baseName + ".war");
  }
  if (debug >= 2) {
    log("Uploading WAR file to " + uploadedWar);
  }
  try {
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        uploadWar(writer,request,uploadedWar,smClient);
        if (update && tag == null) {
          if (deployedWar.exists() && !deployedWar.delete()) {
            writer.println(smClient.getString("managerServlet.deleteFail",deployedWar));
            return;
          }
          uploadedWar.renameTo(deployedWar);
        }
        if (tag != null) {
          copy(uploadedWar,deployedWar);
        }
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
  }
 catch (  Exception e) {
    log("managerServlet.check[" + displayPath + "]",e);
    writer.println(smClient.getString("managerServlet.exception",e.toString()));
    return;
  }
  writeDeployResult(writer,smClient,name,displayPath);
}

ID 2527=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#deploy(java.io.PrintWriter, org.apache.catalina.util.ContextName, java.lang.String, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Install an application for the specified path from the specified web application archive.
 * @param writer    Writer to render results to
 * @param tag       Revision tag to deploy from
 * @param cn        Name of the application to be installed
 * @param smClient  i18n messages using the locale of the client
 */
protected void deploy(PrintWriter writer,ContextName cn,String tag,StringManager smClient){
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  String baseName=cn.getBaseName();
  String name=cn.getName();
  String displayPath=cn.getDisplayName();
  File localWar=new File(new File(versioned,tag),baseName + ".war");
  File deployedWar=new File(deployed,baseName + ".war");
  try {
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        if (!deployedWar.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",deployedWar));
          return;
        }
        copy(localWar,deployedWar);
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
  }
 catch (  Exception e) {
    log("managerServlet.check[" + displayPath + "]",e);
    writer.println(smClient.getString("managerServlet.exception",e.toString()));
    return;
  }
  writeDeployResult(writer,smClient,name,displayPath);
}

ID 2528=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#deploy(java.io.PrintWriter, org.apache.catalina.util.ContextName, java.lang.String, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Install an application for the specified path from the specified web application archive.
 * @param writer    Writer to render results to
 * @param tag       Revision tag to deploy from
 * @param cn        Name of the application to be installed
 * @param smClient  i18n messages using the locale of the client
 */
protected void deploy(PrintWriter writer,ContextName cn,String tag,StringManager smClient){
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  String baseName=cn.getBaseName();
  String name=cn.getName();
  String displayPath=cn.getDisplayName();
  File localWar=new File(new File(versioned,tag),baseName + ".war");
  File deployedWar=new File(deployed,baseName + ".war");
  try {
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        if (!deployedWar.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",deployedWar));
          return;
        }
        copy(localWar,deployedWar);
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
  }
 catch (  Exception e) {
    log("managerServlet.check[" + displayPath + "]",e);
    writer.println(smClient.getString("managerServlet.exception",e.toString()));
    return;
  }
  writeDeployResult(writer,smClient,name,displayPath);
}

ID 2531=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#deploy(java.io.PrintWriter, java.lang.String, org.apache.catalina.util.ContextName, java.lang.String, boolean, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Install an application for the specified path from the specified web application archive.
 * @param writer    Writer to render results to
 * @param config    URL of the context configuration file to be installed
 * @param cn        Name of the application to be installed
 * @param war       URL of the web application archive to be installed
 * @param update    true to override any existing webapp on the path
 * @param smClient  i18n messages using the locale of the client
 */
protected void deploy(PrintWriter writer,String config,ContextName cn,String war,boolean update,StringManager smClient){
  if (config != null && config.length() == 0) {
    config=null;
  }
  if (war != null && war.length() == 0) {
    war=null;
  }
  if (debug >= 1) {
    if (config != null && config.length() > 0) {
      if (war != null) {
        log("install: Installing context configuration at '" + config + "' from '"+ war+ "'");
      }
 else {
        log("install: Installing context configuration at '" + config + "'");
      }
    }
 else {
      if (cn != null) {
        log("install: Installing web application '" + cn + "' from '"+ war+ "'");
      }
 else {
        log("install: Installing web application from '" + war + "'");
      }
    }
  }
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  @SuppressWarnings("null") String name=cn.getName();
  String baseName=cn.getBaseName();
  String displayPath=cn.getDisplayName();
  Context context=(Context)host.findChild(name);
  if (context != null && !update) {
    writer.println(smClient.getString("managerServlet.alreadyContext",displayPath));
    return;
  }
  if (config != null && (config.startsWith("file:"))) {
    config=config.substring("file:".length());
  }
  if (war != null && (war.startsWith("file:"))) {
    war=war.substring("file:".length());
  }
  try {
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        if (config != null) {
          if (!configBase.mkdirs() && !configBase.isDirectory()) {
            writer.println(smClient.getString("managerServlet.mkdirFail",configBase));
            return;
          }
          File localConfig=new File(configBase,baseName + ".xml");
          if (localConfig.isFile() && !localConfig.delete()) {
            writer.println(smClient.getString("managerServlet.deleteFail",localConfig));
            return;
          }
          copy(new File(config),localConfig);
        }
        if (war != null) {
          File localWar;
          if (war.endsWith(".war")) {
            localWar=new File(deployed,baseName + ".war");
          }
 else {
            localWar=new File(deployed,baseName);
          }
          if (localWar.exists() && !ExpandWar.delete(localWar)) {
            writer.println(smClient.getString("managerServlet.deleteFail",localWar));
            return;
          }
          copy(new File(war),localWar);
        }
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
    writeDeployResult(writer,smClient,name,displayPath);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log("ManagerServlet.install[" + displayPath + "]",t);
    writer.println(smClient.getString("managerServlet.exception",t.toString()));
  }
}

ID 2532=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#deploy(java.io.PrintWriter, java.lang.String, org.apache.catalina.util.ContextName, java.lang.String, boolean, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Install an application for the specified path from the specified web application archive.
 * @param writer    Writer to render results to
 * @param config    URL of the context configuration file to be installed
 * @param cn        Name of the application to be installed
 * @param war       URL of the web application archive to be installed
 * @param update    true to override any existing webapp on the path
 * @param smClient  i18n messages using the locale of the client
 */
protected void deploy(PrintWriter writer,String config,ContextName cn,String war,boolean update,StringManager smClient){
  if (config != null && config.length() == 0) {
    config=null;
  }
  if (war != null && war.length() == 0) {
    war=null;
  }
  if (debug >= 1) {
    if (config != null && config.length() > 0) {
      if (war != null) {
        log("install: Installing context configuration at '" + config + "' from '"+ war+ "'");
      }
 else {
        log("install: Installing context configuration at '" + config + "'");
      }
    }
 else {
      if (cn != null) {
        log("install: Installing web application '" + cn + "' from '"+ war+ "'");
      }
 else {
        log("install: Installing web application from '" + war + "'");
      }
    }
  }
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  @SuppressWarnings("null") String name=cn.getName();
  String baseName=cn.getBaseName();
  String displayPath=cn.getDisplayName();
  Context context=(Context)host.findChild(name);
  if (context != null && !update) {
    writer.println(smClient.getString("managerServlet.alreadyContext",displayPath));
    return;
  }
  if (config != null && (config.startsWith("file:"))) {
    config=config.substring("file:".length());
  }
  if (war != null && (war.startsWith("file:"))) {
    war=war.substring("file:".length());
  }
  try {
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        if (config != null) {
          if (!configBase.mkdirs() && !configBase.isDirectory()) {
            writer.println(smClient.getString("managerServlet.mkdirFail",configBase));
            return;
          }
          File localConfig=new File(configBase,baseName + ".xml");
          if (localConfig.isFile() && !localConfig.delete()) {
            writer.println(smClient.getString("managerServlet.deleteFail",localConfig));
            return;
          }
          copy(new File(config),localConfig);
        }
        if (war != null) {
          File localWar;
          if (war.endsWith(".war")) {
            localWar=new File(deployed,baseName + ".war");
          }
 else {
            localWar=new File(deployed,baseName);
          }
          if (localWar.exists() && !ExpandWar.delete(localWar)) {
            writer.println(smClient.getString("managerServlet.deleteFail",localWar));
            return;
          }
          copy(new File(war),localWar);
        }
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
    writeDeployResult(writer,smClient,name,displayPath);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log("ManagerServlet.install[" + displayPath + "]",t);
    writer.println(smClient.getString("managerServlet.exception",t.toString()));
  }
}

ID 2539=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#expireSessions(java.io.PrintWriter, org.apache.catalina.util.ContextName, javax.servlet.http.HttpServletRequest, org.apache.tomcat.util.res.StringManager)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Extract the expiration request parameter
 * @param cn
 * @param req
 */
protected void expireSessions(PrintWriter writer,ContextName cn,HttpServletRequest req,StringManager smClient){
  int idle=-1;
  String idleParam=req.getParameter("idle");
  if (idleParam != null) {
    try {
      idle=Integer.parseInt(idleParam);
    }
 catch (    NumberFormatException e) {
      log("Could not parse idle parameter to an int: " + idleParam);
    }
  }
  sessions(writer,cn,idle,smClient);
}

ID 2542=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#undeploy(java.io.PrintWriter, org.apache.catalina.util.ContextName, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isDeployed(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Undeploy the web application at the specified context path.
 * @param writer Writer to render to
 * @param cn Name of the application to be removed
 */
protected void undeploy(PrintWriter writer,ContextName cn,StringManager smClient){
  if (debug >= 1)   log("undeploy: Undeploying web application at '" + cn + "'");
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  String name=cn.getName();
  String baseName=cn.getBaseName();
  String displayPath=cn.getDisplayName();
  try {
    Context context=(Context)host.findChild(name);
    if (context == null) {
      writer.println(smClient.getString("managerServlet.noContext",RequestUtil.filter(displayPath)));
      return;
    }
    if (!isDeployed(name)) {
      writer.println(smClient.getString("managerServlet.notDeployed",RequestUtil.filter(displayPath)));
      return;
    }
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        context.stop();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      try {
        File war=new File(deployed,baseName + ".war");
        File dir=new File(deployed,baseName);
        File xml=new File(configBase,baseName + ".xml");
        if (war.exists() && !war.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",war));
          return;
        }
 else         if (dir.exists() && !undeployDir(dir)) {
          writer.println(smClient.getString("managerServlet.deleteFail",dir));
          return;
        }
 else         if (xml.exists() && !xml.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",xml));
          return;
        }
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
    writer.println(smClient.getString("managerServlet.undeployed",displayPath));
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log("ManagerServlet.undeploy[" + displayPath + "]",t);
    writer.println(smClient.getString("managerServlet.exception",t.toString()));
  }
}

ID 2543=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#undeploy(java.io.PrintWriter, org.apache.catalina.util.ContextName, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Undeploy the web application at the specified context path.
 * @param writer Writer to render to
 * @param cn Name of the application to be removed
 */
protected void undeploy(PrintWriter writer,ContextName cn,StringManager smClient){
  if (debug >= 1)   log("undeploy: Undeploying web application at '" + cn + "'");
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  String name=cn.getName();
  String baseName=cn.getBaseName();
  String displayPath=cn.getDisplayName();
  try {
    Context context=(Context)host.findChild(name);
    if (context == null) {
      writer.println(smClient.getString("managerServlet.noContext",RequestUtil.filter(displayPath)));
      return;
    }
    if (!isDeployed(name)) {
      writer.println(smClient.getString("managerServlet.notDeployed",RequestUtil.filter(displayPath)));
      return;
    }
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        context.stop();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      try {
        File war=new File(deployed,baseName + ".war");
        File dir=new File(deployed,baseName);
        File xml=new File(configBase,baseName + ".xml");
        if (war.exists() && !war.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",war));
          return;
        }
 else         if (dir.exists() && !undeployDir(dir)) {
          writer.println(smClient.getString("managerServlet.deleteFail",dir));
          return;
        }
 else         if (xml.exists() && !xml.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",xml));
          return;
        }
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
    writer.println(smClient.getString("managerServlet.undeployed",displayPath));
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log("ManagerServlet.undeploy[" + displayPath + "]",t);
    writer.println(smClient.getString("managerServlet.exception",t.toString()));
  }
}

ID 2544=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#undeploy(java.io.PrintWriter, org.apache.catalina.util.ContextName, org.apache.tomcat.util.res.StringManager)
Rmethod: org.apache.catalina.manager.ManagerServlet#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Undeploy the web application at the specified context path.
 * @param writer Writer to render to
 * @param cn Name of the application to be removed
 */
protected void undeploy(PrintWriter writer,ContextName cn,StringManager smClient){
  if (debug >= 1)   log("undeploy: Undeploying web application at '" + cn + "'");
  if (!validateContextName(cn,writer,smClient)) {
    return;
  }
  String name=cn.getName();
  String baseName=cn.getBaseName();
  String displayPath=cn.getDisplayName();
  try {
    Context context=(Context)host.findChild(name);
    if (context == null) {
      writer.println(smClient.getString("managerServlet.noContext",RequestUtil.filter(displayPath)));
      return;
    }
    if (!isDeployed(name)) {
      writer.println(smClient.getString("managerServlet.notDeployed",RequestUtil.filter(displayPath)));
      return;
    }
    if (isServiced(name)) {
      writer.println(smClient.getString("managerServlet.inService",displayPath));
    }
 else {
      addServiced(name);
      try {
        context.stop();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      try {
        File war=new File(deployed,baseName + ".war");
        File dir=new File(deployed,baseName);
        File xml=new File(configBase,baseName + ".xml");
        if (war.exists() && !war.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",war));
          return;
        }
 else         if (dir.exists() && !undeployDir(dir)) {
          writer.println(smClient.getString("managerServlet.deleteFail",dir));
          return;
        }
 else         if (xml.exists() && !xml.delete()) {
          writer.println(smClient.getString("managerServlet.deleteFail",xml));
          return;
        }
        check(name);
      }
  finally {
        removeServiced(name);
      }
    }
    writer.println(smClient.getString("managerServlet.undeployed",displayPath));
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log("ManagerServlet.undeploy[" + displayPath + "]",t);
    writer.println(smClient.getString("managerServlet.exception",t.toString()));
  }
}

ID 2548=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#getAppBase()
Rmethod: java.io.File#getCanonicalFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Return a File object representing the "application root" directory for our associated Host.
 * @deprecated  Unused
 */
@Deprecated protected File getAppBase(){
  if (appBase != null) {
    return appBase;
  }
  File file=new File(host.getAppBase());
  if (!file.isAbsolute())   file=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  try {
    appBase=file.getCanonicalFile();
  }
 catch (  IOException e) {
    appBase=file;
  }
  return (appBase);
}

ID 2564=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#uploadWar(java.io.PrintWriter, javax.servlet.http.HttpServletRequest, java.io.File, org.apache.tomcat.util.res.StringManager)
Rmethod: javax.servlet.ServletRequest#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Upload the WAR file included in this request, and store it at the specified file location.
 * @param writer    Writer to render to
 * @param request   The servlet request we are processing
 * @param war       The file into which we should store the uploaded WAR
 * @param smClient  The StringManager used to construct i18n messages basedon the Locale of the client
 * @exception IOException if an I/O error occurs during processing
 */
protected void uploadWar(PrintWriter writer,HttpServletRequest request,File war,StringManager smClient) throws IOException {
  if (war.exists() && !war.delete()) {
    String msg=smClient.getString("managerServlet.deleteFail",war);
    throw new IOException(msg);
  }
  ServletInputStream istream=null;
  BufferedOutputStream ostream=null;
  try {
    istream=request.getInputStream();
    ostream=new BufferedOutputStream(new FileOutputStream(war),1024);
    byte buffer[]=new byte[1024];
    while (true) {
      int n=istream.read(buffer);
      if (n < 0) {
        break;
      }
      ostream.write(buffer,0,n);
    }
    ostream.flush();
    ostream.close();
    ostream=null;
    istream.close();
    istream=null;
  }
 catch (  IOException e) {
    if (war.exists() && !war.delete()) {
      writer.println(smClient.getString("managerServlet.deleteFail",war));
    }
    throw e;
  }
 finally {
    if (ostream != null) {
      try {
        ostream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      ostream=null;
    }
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      istream=null;
    }
  }
}

ID 2565=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#uploadWar(java.io.PrintWriter, javax.servlet.http.HttpServletRequest, java.io.File, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Upload the WAR file included in this request, and store it at the specified file location.
 * @param writer    Writer to render to
 * @param request   The servlet request we are processing
 * @param war       The file into which we should store the uploaded WAR
 * @param smClient  The StringManager used to construct i18n messages basedon the Locale of the client
 * @exception IOException if an I/O error occurs during processing
 */
protected void uploadWar(PrintWriter writer,HttpServletRequest request,File war,StringManager smClient) throws IOException {
  if (war.exists() && !war.delete()) {
    String msg=smClient.getString("managerServlet.deleteFail",war);
    throw new IOException(msg);
  }
  ServletInputStream istream=null;
  BufferedOutputStream ostream=null;
  try {
    istream=request.getInputStream();
    ostream=new BufferedOutputStream(new FileOutputStream(war),1024);
    byte buffer[]=new byte[1024];
    while (true) {
      int n=istream.read(buffer);
      if (n < 0) {
        break;
      }
      ostream.write(buffer,0,n);
    }
    ostream.flush();
    ostream.close();
    ostream=null;
    istream.close();
    istream=null;
  }
 catch (  IOException e) {
    if (war.exists() && !war.delete()) {
      writer.println(smClient.getString("managerServlet.deleteFail",war));
    }
    throw e;
  }
 finally {
    if (ostream != null) {
      try {
        ostream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      ostream=null;
    }
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      istream=null;
    }
  }
}

ID 2566=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#uploadWar(java.io.PrintWriter, javax.servlet.http.HttpServletRequest, java.io.File, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.InputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Upload the WAR file included in this request, and store it at the specified file location.
 * @param writer    Writer to render to
 * @param request   The servlet request we are processing
 * @param war       The file into which we should store the uploaded WAR
 * @param smClient  The StringManager used to construct i18n messages basedon the Locale of the client
 * @exception IOException if an I/O error occurs during processing
 */
protected void uploadWar(PrintWriter writer,HttpServletRequest request,File war,StringManager smClient) throws IOException {
  if (war.exists() && !war.delete()) {
    String msg=smClient.getString("managerServlet.deleteFail",war);
    throw new IOException(msg);
  }
  ServletInputStream istream=null;
  BufferedOutputStream ostream=null;
  try {
    istream=request.getInputStream();
    ostream=new BufferedOutputStream(new FileOutputStream(war),1024);
    byte buffer[]=new byte[1024];
    while (true) {
      int n=istream.read(buffer);
      if (n < 0) {
        break;
      }
      ostream.write(buffer,0,n);
    }
    ostream.flush();
    ostream.close();
    ostream=null;
    istream.close();
    istream=null;
  }
 catch (  IOException e) {
    if (war.exists() && !war.delete()) {
      writer.println(smClient.getString("managerServlet.deleteFail",war));
    }
    throw e;
  }
 finally {
    if (ostream != null) {
      try {
        ostream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      ostream=null;
    }
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      istream=null;
    }
  }
}

ID 2567=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#uploadWar(java.io.PrintWriter, javax.servlet.http.HttpServletRequest, java.io.File, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.BufferedOutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Upload the WAR file included in this request, and store it at the specified file location.
 * @param writer    Writer to render to
 * @param request   The servlet request we are processing
 * @param war       The file into which we should store the uploaded WAR
 * @param smClient  The StringManager used to construct i18n messages basedon the Locale of the client
 * @exception IOException if an I/O error occurs during processing
 */
protected void uploadWar(PrintWriter writer,HttpServletRequest request,File war,StringManager smClient) throws IOException {
  if (war.exists() && !war.delete()) {
    String msg=smClient.getString("managerServlet.deleteFail",war);
    throw new IOException(msg);
  }
  ServletInputStream istream=null;
  BufferedOutputStream ostream=null;
  try {
    istream=request.getInputStream();
    ostream=new BufferedOutputStream(new FileOutputStream(war),1024);
    byte buffer[]=new byte[1024];
    while (true) {
      int n=istream.read(buffer);
      if (n < 0) {
        break;
      }
      ostream.write(buffer,0,n);
    }
    ostream.flush();
    ostream.close();
    ostream=null;
    istream.close();
    istream=null;
  }
 catch (  IOException e) {
    if (war.exists() && !war.delete()) {
      writer.println(smClient.getString("managerServlet.deleteFail",war));
    }
    throw e;
  }
 finally {
    if (ostream != null) {
      try {
        ostream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      ostream=null;
    }
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      istream=null;
    }
  }
}

ID 2568=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#uploadWar(java.io.PrintWriter, javax.servlet.http.HttpServletRequest, java.io.File, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.BufferedOutputStream#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Upload the WAR file included in this request, and store it at the specified file location.
 * @param writer    Writer to render to
 * @param request   The servlet request we are processing
 * @param war       The file into which we should store the uploaded WAR
 * @param smClient  The StringManager used to construct i18n messages basedon the Locale of the client
 * @exception IOException if an I/O error occurs during processing
 */
protected void uploadWar(PrintWriter writer,HttpServletRequest request,File war,StringManager smClient) throws IOException {
  if (war.exists() && !war.delete()) {
    String msg=smClient.getString("managerServlet.deleteFail",war);
    throw new IOException(msg);
  }
  ServletInputStream istream=null;
  BufferedOutputStream ostream=null;
  try {
    istream=request.getInputStream();
    ostream=new BufferedOutputStream(new FileOutputStream(war),1024);
    byte buffer[]=new byte[1024];
    while (true) {
      int n=istream.read(buffer);
      if (n < 0) {
        break;
      }
      ostream.write(buffer,0,n);
    }
    ostream.flush();
    ostream.close();
    ostream=null;
    istream.close();
    istream=null;
  }
 catch (  IOException e) {
    if (war.exists() && !war.delete()) {
      writer.println(smClient.getString("managerServlet.deleteFail",war));
    }
    throw e;
  }
 finally {
    if (ostream != null) {
      try {
        ostream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      ostream=null;
    }
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      istream=null;
    }
  }
}

ID 2569=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#uploadWar(java.io.PrintWriter, javax.servlet.http.HttpServletRequest, java.io.File, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.FilterOutputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Upload the WAR file included in this request, and store it at the specified file location.
 * @param writer    Writer to render to
 * @param request   The servlet request we are processing
 * @param war       The file into which we should store the uploaded WAR
 * @param smClient  The StringManager used to construct i18n messages basedon the Locale of the client
 * @exception IOException if an I/O error occurs during processing
 */
protected void uploadWar(PrintWriter writer,HttpServletRequest request,File war,StringManager smClient) throws IOException {
  if (war.exists() && !war.delete()) {
    String msg=smClient.getString("managerServlet.deleteFail",war);
    throw new IOException(msg);
  }
  ServletInputStream istream=null;
  BufferedOutputStream ostream=null;
  try {
    istream=request.getInputStream();
    ostream=new BufferedOutputStream(new FileOutputStream(war),1024);
    byte buffer[]=new byte[1024];
    while (true) {
      int n=istream.read(buffer);
      if (n < 0) {
        break;
      }
      ostream.write(buffer,0,n);
    }
    ostream.flush();
    ostream.close();
    ostream=null;
    istream.close();
    istream=null;
  }
 catch (  IOException e) {
    if (war.exists() && !war.delete()) {
      writer.println(smClient.getString("managerServlet.deleteFail",war));
    }
    throw e;
  }
 finally {
    if (ostream != null) {
      try {
        ostream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      ostream=null;
    }
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      istream=null;
    }
  }
}

ID 2570=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#uploadWar(java.io.PrintWriter, javax.servlet.http.HttpServletRequest, java.io.File, org.apache.tomcat.util.res.StringManager)
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Upload the WAR file included in this request, and store it at the specified file location.
 * @param writer    Writer to render to
 * @param request   The servlet request we are processing
 * @param war       The file into which we should store the uploaded WAR
 * @param smClient  The StringManager used to construct i18n messages basedon the Locale of the client
 * @exception IOException if an I/O error occurs during processing
 */
protected void uploadWar(PrintWriter writer,HttpServletRequest request,File war,StringManager smClient) throws IOException {
  if (war.exists() && !war.delete()) {
    String msg=smClient.getString("managerServlet.deleteFail",war);
    throw new IOException(msg);
  }
  ServletInputStream istream=null;
  BufferedOutputStream ostream=null;
  try {
    istream=request.getInputStream();
    ostream=new BufferedOutputStream(new FileOutputStream(war),1024);
    byte buffer[]=new byte[1024];
    while (true) {
      int n=istream.read(buffer);
      if (n < 0) {
        break;
      }
      ostream.write(buffer,0,n);
    }
    ostream.flush();
    ostream.close();
    ostream=null;
    istream.close();
    istream=null;
  }
 catch (  IOException e) {
    if (war.exists() && !war.delete()) {
      writer.println(smClient.getString("managerServlet.deleteFail",war));
    }
    throw e;
  }
 finally {
    if (ostream != null) {
      try {
        ostream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      ostream=null;
    }
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      istream=null;
    }
  }
}

ID 2573=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#copy(java.io.File, java.io.File)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copy(File src,File dest){
  boolean result=false;
  try {
    if (src != null && !src.getCanonicalPath().equals(dest.getCanonicalPath())) {
      result=copyInternal(src,dest,new byte[4096]);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return result;
}

ID 2574=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#copyInternal(java.io.File, java.io.File, byte[])
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copyInternal(File src,File dest,byte[] buf){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copyInternal(fileSrc,fileDest,buf);
    }
 else {
      FileInputStream is=null;
      FileOutputStream os=null;
      try {
        is=new FileInputStream(fileSrc);
        os=new FileOutputStream(fileDest);
        int len=0;
        while (true) {
          len=is.read(buf);
          if (len == -1)           break;
          os.write(buf,0,len);
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        result=false;
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
        if (os != null) {
          try {
            os.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 2575=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#copyInternal(java.io.File, java.io.File, byte[])
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copyInternal(File src,File dest,byte[] buf){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copyInternal(fileSrc,fileDest,buf);
    }
 else {
      FileInputStream is=null;
      FileOutputStream os=null;
      try {
        is=new FileInputStream(fileSrc);
        os=new FileOutputStream(fileDest);
        int len=0;
        while (true) {
          len=is.read(buf);
          if (len == -1)           break;
          os.write(buf,0,len);
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        result=false;
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
        if (os != null) {
          try {
            os.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 2576=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#copyInternal(java.io.File, java.io.File, byte[])
Rmethod: java.io.FileInputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copyInternal(File src,File dest,byte[] buf){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copyInternal(fileSrc,fileDest,buf);
    }
 else {
      FileInputStream is=null;
      FileOutputStream os=null;
      try {
        is=new FileInputStream(fileSrc);
        os=new FileOutputStream(fileDest);
        int len=0;
        while (true) {
          len=is.read(buf);
          if (len == -1)           break;
          os.write(buf,0,len);
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        result=false;
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
        if (os != null) {
          try {
            os.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 2577=========================================================================type: 1
Method:org.apache.catalina.manager.ManagerServlet#copyInternal(java.io.File, java.io.File, byte[])
Rmethod: java.io.FileOutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copyInternal(File src,File dest,byte[] buf){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copyInternal(fileSrc,fileDest,buf);
    }
 else {
      FileInputStream is=null;
      FileOutputStream os=null;
      try {
        is=new FileInputStream(fileSrc);
        os=new FileOutputStream(fileDest);
        int len=0;
        while (true) {
          len=is.read(buf);
          if (len == -1)           break;
          os.write(buf,0,len);
        }
      }
 catch (      IOException e) {
        e.printStackTrace();
        result=false;
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException e) {
          }
        }
        if (os != null) {
          try {
            os.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 2580=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoader#copyWithoutTransformers()
Rmethod: org.apache.catalina.loader.WebappClassLoaderBase#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Returns a copy of this class loader without any class file transformers. This is a tool often used by Java Persistence API providers to inspect entity classes in the absence of any instrumentation, something that can't be guaranteed within the context of a  {@link java.lang.instrument.ClassFileTransformer}'s {@link java.lang.instrument.ClassFileTransformer#transform(ClassLoader,String,Class,java.security.ProtectionDomain,byte[]) transform} method.<p> The returned class loader's resource cache will have been cleared so that classes already instrumented will not be retained or returned.
 * @return the transformer-free copy of this class loader.
 */
@Override public WebappClassLoader copyWithoutTransformers(){
  WebappClassLoader result=new WebappClassLoader(getParent());
  super.copyStateWithoutTransformers(result);
  try {
    result.start();
  }
 catch (  LifecycleException e) {
    throw new IllegalStateException(e);
  }
  return result;
}

ID 2581=========================================================================type: 1
Method:org.apache.catalina.loader.ParallelWebappClassLoader#copyWithoutTransformers()
Rmethod: org.apache.catalina.loader.WebappClassLoaderBase#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Returns a copy of this class loader without any class file transformers. This is a tool often used by Java Persistence API providers to inspect entity classes in the absence of any instrumentation, something that can't be guaranteed within the context of a  {@link java.lang.instrument.ClassFileTransformer}'s {@link java.lang.instrument.ClassFileTransformer#transform(ClassLoader,String,Class,java.security.ProtectionDomain,byte[]) transform} method.<p> The returned class loader's resource cache will have been cleared so that classes already instrumented will not be retained or returned.
 * @return the transformer-free copy of this class loader.
 */
@Override public ParallelWebappClassLoader copyWithoutTransformers(){
  ParallelWebappClassLoader result=new ParallelWebappClassLoader(getParent());
  super.copyStateWithoutTransformers(result);
  try {
    result.start();
  }
 catch (  LifecycleException e) {
    throw new IllegalStateException(e);
  }
  return result;
}

ID 2583=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#setWorkDir(java.io.File)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Change the work directory.
 */
public void setWorkDir(File workDir){
  this.loaderDir=new File(workDir,"loader");
  try {
    canonicalLoaderDir=loaderDir.getCanonicalPath();
    if (!canonicalLoaderDir.endsWith(File.separator)) {
      canonicalLoaderDir+=File.separator;
    }
  }
 catch (  IOException ioe) {
    canonicalLoaderDir=null;
  }
}

ID 2584=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#addRepository(java.lang.String)
Rmethod: java.net.URL#URL(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Add a new repository to the set of places this ClassLoader can look for classes to be loaded.
 * @param repository Name of a source of classes to be loaded, such as adirectory pathname, a JAR file pathname, or a ZIP file pathname
 * @exception IllegalArgumentException if the specified repository isinvalid or does not exist
 */
public void addRepository(String repository){
  if (repository.startsWith("/WEB-INF/lib") || repository.startsWith("/WEB-INF/classes"))   return;
  try {
    URL url=new URL(repository);
    super.addURL(url);
    hasExternalRepositories=true;
    repositoryURLs=null;
  }
 catch (  MalformedURLException e) {
    IllegalArgumentException iae=new IllegalArgumentException("Invalid repository: " + repository);
    iae.initCause(e);
    throw iae;
  }
}

ID 2587=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#modified()
Rmethod: javax.naming.directory.DirContext#getAttributes(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Have one or more classes or resources been modified so that a reload is appropriate?
 */
public boolean modified(){
  if (log.isDebugEnabled())   log.debug("modified()");
  int length=paths.length;
  int length2=lastModifiedDates.length;
  if (length > length2)   length=length2;
  for (int i=0; i < length; i++) {
    try {
      long lastModified=((ResourceAttributes)resources.getAttributes(paths[i])).getLastModified();
      if (lastModified != lastModifiedDates[i]) {
        if (log.isDebugEnabled())         log.debug("  Resource '" + paths[i] + "' was modified; Date is now: "+ new java.util.Date(lastModified)+ " Was: "+ new java.util.Date(lastModifiedDates[i]));
        return (true);
      }
    }
 catch (    NamingException e) {
      log.error("    Resource '" + paths[i] + "' is missing");
      return (true);
    }
  }
  length=jarNames.length;
  if (getJarPath() != null) {
    try {
      NamingEnumeration<Binding> enumeration=resources.listBindings(getJarPath());
      int i=0;
      while (enumeration.hasMoreElements() && (i < length)) {
        NameClassPair ncPair=enumeration.nextElement();
        String name=ncPair.getName();
        if (!name.endsWith(".jar"))         continue;
        if (!name.equals(jarNames[i])) {
          log.info("    Additional JARs have been added : '" + name + "'");
          return (true);
        }
        i++;
      }
      if (enumeration.hasMoreElements()) {
        while (enumeration.hasMoreElements()) {
          NameClassPair ncPair=enumeration.nextElement();
          String name=ncPair.getName();
          if (name.endsWith(".jar")) {
            log.info("    Additional JARs have been added");
            return (true);
          }
        }
      }
 else       if (i < jarNames.length) {
        log.info("    Additional JARs have been added");
        return (true);
      }
    }
 catch (    NamingException e) {
      if (log.isDebugEnabled())       log.debug("    Failed tracking modifications of '" + getJarPath() + "'");
    }
catch (    ClassCastException e) {
      log.error("    Failed tracking modifications of '" + getJarPath() + "' : "+ e.getMessage());
    }
  }
  return (false);
}

ID 2588=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#modified()
Rmethod: javax.naming.Context#listBindings(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Have one or more classes or resources been modified so that a reload is appropriate?
 */
public boolean modified(){
  if (log.isDebugEnabled())   log.debug("modified()");
  int length=paths.length;
  int length2=lastModifiedDates.length;
  if (length > length2)   length=length2;
  for (int i=0; i < length; i++) {
    try {
      long lastModified=((ResourceAttributes)resources.getAttributes(paths[i])).getLastModified();
      if (lastModified != lastModifiedDates[i]) {
        if (log.isDebugEnabled())         log.debug("  Resource '" + paths[i] + "' was modified; Date is now: "+ new java.util.Date(lastModified)+ " Was: "+ new java.util.Date(lastModifiedDates[i]));
        return (true);
      }
    }
 catch (    NamingException e) {
      log.error("    Resource '" + paths[i] + "' is missing");
      return (true);
    }
  }
  length=jarNames.length;
  if (getJarPath() != null) {
    try {
      NamingEnumeration<Binding> enumeration=resources.listBindings(getJarPath());
      int i=0;
      while (enumeration.hasMoreElements() && (i < length)) {
        NameClassPair ncPair=enumeration.nextElement();
        String name=ncPair.getName();
        if (!name.endsWith(".jar"))         continue;
        if (!name.equals(jarNames[i])) {
          log.info("    Additional JARs have been added : '" + name + "'");
          return (true);
        }
        i++;
      }
      if (enumeration.hasMoreElements()) {
        while (enumeration.hasMoreElements()) {
          NameClassPair ncPair=enumeration.nextElement();
          String name=ncPair.getName();
          if (name.endsWith(".jar")) {
            log.info("    Additional JARs have been added");
            return (true);
          }
        }
      }
 else       if (i < jarNames.length) {
        log.info("    Additional JARs have been added");
        return (true);
      }
    }
 catch (    NamingException e) {
      if (log.isDebugEnabled())       log.debug("    Failed tracking modifications of '" + getJarPath() + "'");
    }
catch (    ClassCastException e) {
      log.error("    Failed tracking modifications of '" + getJarPath() + "' : "+ e.getMessage());
    }
  }
  return (false);
}

ID 2589=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#findClass(java.lang.String)
Rmethod: org.apache.catalina.loader.WebappClassLoaderBase#findClassInternal(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Find the specified class in our local repositories, if possible.  If not found, throw <code>ClassNotFoundException</code>.
 * @param name Name of the class to be loaded
 * @exception ClassNotFoundException if the class was not found
 */
@Override public Class<?> findClass(String name) throws ClassNotFoundException {
  if (log.isDebugEnabled())   log.debug("    findClass(" + name + ")");
  if (!started) {
    throw new ClassNotFoundException(name);
  }
  if (securityManager != null) {
    int i=name.lastIndexOf('.');
    if (i >= 0) {
      try {
        if (log.isTraceEnabled())         log.trace("      securityManager.checkPackageDefinition");
        securityManager.checkPackageDefinition(name.substring(0,i));
      }
 catch (      Exception se) {
        if (log.isTraceEnabled())         log.trace("      -->Exception-->ClassNotFoundException",se);
        throw new ClassNotFoundException(name,se);
      }
    }
  }
  Class<?> clazz=null;
  try {
    if (log.isTraceEnabled())     log.trace("      findClassInternal(" + name + ")");
    if (hasExternalRepositories && searchExternalFirst) {
      try {
        clazz=super.findClass(name);
      }
 catch (      ClassNotFoundException cnfe) {
      }
catch (      AccessControlException ace) {
        log.warn("WebappClassLoaderBase.findClassInternal(" + name + ") security exception: "+ ace.getMessage(),ace);
        throw new ClassNotFoundException(name,ace);
      }
catch (      RuntimeException e) {
        if (log.isTraceEnabled())         log.trace("      -->RuntimeException Rethrown",e);
        throw e;
      }
    }
    if ((clazz == null)) {
      try {
        clazz=findClassInternal(name);
      }
 catch (      ClassNotFoundException cnfe) {
        if (!hasExternalRepositories || searchExternalFirst) {
          throw cnfe;
        }
      }
catch (      AccessControlException ace) {
        log.warn("WebappClassLoaderBase.findClassInternal(" + name + ") security exception: "+ ace.getMessage(),ace);
        throw new ClassNotFoundException(name,ace);
      }
catch (      RuntimeException e) {
        if (log.isTraceEnabled())         log.trace("      -->RuntimeException Rethrown",e);
        throw e;
      }
    }
    if ((clazz == null) && hasExternalRepositories && !searchExternalFirst) {
      try {
        clazz=super.findClass(name);
      }
 catch (      AccessControlException ace) {
        log.warn("WebappClassLoaderBase.findClassInternal(" + name + ") security exception: "+ ace.getMessage(),ace);
        throw new ClassNotFoundException(name,ace);
      }
catch (      RuntimeException e) {
        if (log.isTraceEnabled())         log.trace("      -->RuntimeException Rethrown",e);
        throw e;
      }
    }
    if (clazz == null) {
      if (log.isDebugEnabled())       log.debug("    --> Returning ClassNotFoundException");
      throw new ClassNotFoundException(name);
    }
  }
 catch (  ClassNotFoundException e) {
    if (log.isTraceEnabled())     log.trace("    --> Passing on ClassNotFoundException");
    throw e;
  }
  if (log.isTraceEnabled())   log.debug("      Returning class " + clazz);
  if (log.isTraceEnabled()) {
    ClassLoader cl;
    if (Globals.IS_SECURITY_ENABLED) {
      cl=AccessController.doPrivileged(new PrivilegedGetClassLoader(clazz));
    }
 else {
      cl=clazz.getClassLoader();
    }
    log.debug("      Loaded by " + cl.toString());
  }
  return (clazz);
}

ID 2602=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#getURLs()
Rmethod: org.apache.catalina.loader.WebappClassLoaderBase#getURI(java.io.File)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Returns the search path of URLs for loading classes and resources. This includes the original list of URLs specified to the constructor, along with any URLs subsequently appended by the addURL() method.
 * @return the search path of URLs for loading classes and resources.
 */
@Override public URL[] getURLs(){
  if (repositoryURLs != null) {
    return repositoryURLs.clone();
  }
  URL[] external=super.getURLs();
  int filesLength=files.length;
  int jarFilesLength=jarRealFiles.length;
  int externalsLength=external.length;
  int off=0;
  int i;
  try {
    URL[] urls=new URL[filesLength + jarFilesLength + externalsLength];
    if (searchExternalFirst) {
      for (i=0; i < externalsLength; i++) {
        urls[i]=external[i];
      }
      off=externalsLength;
    }
    for (i=0; i < filesLength; i++) {
      urls[off + i]=getURI(files[i]);
    }
    off+=filesLength;
    for (i=0; i < jarFilesLength; i++) {
      urls[off + i]=getURI(jarRealFiles[i]);
    }
    off+=jarFilesLength;
    if (!searchExternalFirst) {
      for (i=0; i < externalsLength; i++) {
        urls[off + i]=external[i];
      }
    }
    repositoryURLs=urls;
  }
 catch (  MalformedURLException e) {
    repositoryURLs=new URL[0];
  }
  return repositoryURLs.clone();
}

ID 2605=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#closeJARs(boolean)
Rmethod: java.util.zip.ZipFile#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Used to periodically signal to the classloader to release JAR resources.
 */
public void closeJARs(boolean force){
  if (jarFiles.length > 0) {
synchronized (jarFiles) {
      if (force || (System.currentTimeMillis() > (lastJarAccessed + 90000))) {
        for (int i=0; i < jarFiles.length; i++) {
          try {
            if (jarFiles[i] != null) {
              jarFiles[i].close();
              jarFiles[i]=null;
            }
          }
 catch (          IOException e) {
            if (log.isDebugEnabled()) {
              log.debug("Failed to close JAR",e);
            }
          }
        }
      }
    }
  }
}

ID 2616=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesJdbc()
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Deregister any JDBC drivers registered by the webapp that the webapp forgot. This is made unnecessary complex because a) DriverManager checks the class loader of the calling class (it would be much easier if it checked the context class loader) b) using reflection would create a dependency on the DriverManager implementation which can, and has, changed. We can't just create an instance of JdbcLeakPrevention as it will be loaded by the common class loader (since it's .class file is in the $CATALINA_HOME/lib directory). This would fail DriverManager's check on the class loader of the calling class. So, we load the bytes via our parent class loader but define the class with this class loader so the JdbcLeakPrevention looks like a webapp class to the DriverManager. If only apps cleaned up after themselves...
 */
private final void clearReferencesJdbc(){
  InputStream is=getResourceAsStream("org/apache/catalina/loader/JdbcLeakPrevention.class");
  byte[] classBytes=new byte[2048];
  int offset=0;
  try {
    int read=is.read(classBytes,offset,classBytes.length - offset);
    while (read > -1) {
      offset+=read;
      if (offset == classBytes.length) {
        byte[] tmp=new byte[classBytes.length * 2];
        System.arraycopy(classBytes,0,tmp,0,classBytes.length);
        classBytes=tmp;
      }
      read=is.read(classBytes,offset,classBytes.length - offset);
    }
    Class<?> lpClass=defineClass("org.apache.catalina.loader.JdbcLeakPrevention",classBytes,0,offset,this.getClass().getProtectionDomain());
    Object obj=lpClass.newInstance();
    @SuppressWarnings("unchecked") List<String> driverNames=(List<String>)obj.getClass().getMethod("clearJdbcDriverRegistrations").invoke(obj);
    for (    String name : driverNames) {
      log.error(sm.getString("webappClassLoader.clearJdbc",contextName,name));
    }
  }
 catch (  Exception e) {
    Throwable t=ExceptionUtils.unwrapInvocationTargetException(e);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("webappClassLoader.jdbcRemoveFailed",contextName),t);
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("webappClassLoader.jdbcRemoveStreamError",contextName),ioe);
      }
    }
  }
}

ID 2629=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesThreads()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: ReflectiveOperationException 
thrown: NoSuchFieldException
exception comment: /** 
 * Signals that the class doesn't have a field of a specified name.
 * @author  unascribed
 * @since   JDK1.1
 */

block: 
@SuppressWarnings("deprecation") private void clearReferencesThreads(){
  Thread[] threads=getThreads();
  List<Thread> executorThreadsToStop=new ArrayList<Thread>();
  for (  Thread thread : threads) {
    if (thread != null) {
      ClassLoader ccl=thread.getContextClassLoader();
      if (ccl == this) {
        if (thread == Thread.currentThread()) {
          continue;
        }
        ThreadGroup tg=thread.getThreadGroup();
        if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {
          if (clearReferencesHttpClientKeepAliveThread && thread.getName().equals("Keep-Alive-Timer")) {
            thread.setContextClassLoader(parent);
            log.debug(sm.getString("webappClassLoader.checkThreadsHttpClient"));
          }
          continue;
        }
        if (!thread.isAlive()) {
          continue;
        }
        if (thread.getClass().getName().startsWith("java.util.Timer") && clearReferencesStopTimerThreads) {
          clearReferencesStopTimerThread(thread);
          continue;
        }
        if (isRequestThread(thread)) {
          log.error(sm.getString("webappClassLoader.warnRequestThread",contextName,thread.getName()));
        }
 else {
          log.error(sm.getString("webappClassLoader.warnThread",contextName,thread.getName()));
        }
        if (!clearReferencesStopThreads) {
          continue;
        }
        boolean usingExecutor=false;
        try {
          Object target=null;
          for (          String fieldName : new String[]{"target","runnable","action"}) {
            try {
              Field targetField=thread.getClass().getDeclaredField(fieldName);
              targetField.setAccessible(true);
              target=targetField.get(thread);
              break;
            }
 catch (            NoSuchFieldException nfe) {
              continue;
            }
          }
          if (target != null && target.getClass().getCanonicalName() != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) {
            Field executorField=target.getClass().getDeclaredField("this$0");
            executorField.setAccessible(true);
            Object executor=executorField.get(target);
            if (executor instanceof ThreadPoolExecutor) {
              ((ThreadPoolExecutor)executor).shutdownNow();
              usingExecutor=true;
            }
          }
        }
 catch (        SecurityException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        NoSuchFieldException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
        if (usingExecutor) {
          executorThreadsToStop.add(thread);
        }
 else {
          thread.stop();
        }
      }
    }
  }
  int count=0;
  for (  Thread t : executorThreadsToStop) {
    while (t.isAlive() && count < 100) {
      try {
        Thread.sleep(20);
      }
 catch (      InterruptedException e) {
        break;
      }
      count++;
    }
    if (t.isAlive()) {
      t.stop();
    }
  }
}

ID 2634=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesThreads()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") private void clearReferencesThreads(){
  Thread[] threads=getThreads();
  List<Thread> executorThreadsToStop=new ArrayList<Thread>();
  for (  Thread thread : threads) {
    if (thread != null) {
      ClassLoader ccl=thread.getContextClassLoader();
      if (ccl == this) {
        if (thread == Thread.currentThread()) {
          continue;
        }
        ThreadGroup tg=thread.getThreadGroup();
        if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {
          if (clearReferencesHttpClientKeepAliveThread && thread.getName().equals("Keep-Alive-Timer")) {
            thread.setContextClassLoader(parent);
            log.debug(sm.getString("webappClassLoader.checkThreadsHttpClient"));
          }
          continue;
        }
        if (!thread.isAlive()) {
          continue;
        }
        if (thread.getClass().getName().startsWith("java.util.Timer") && clearReferencesStopTimerThreads) {
          clearReferencesStopTimerThread(thread);
          continue;
        }
        if (isRequestThread(thread)) {
          log.error(sm.getString("webappClassLoader.warnRequestThread",contextName,thread.getName()));
        }
 else {
          log.error(sm.getString("webappClassLoader.warnThread",contextName,thread.getName()));
        }
        if (!clearReferencesStopThreads) {
          continue;
        }
        boolean usingExecutor=false;
        try {
          Object target=null;
          for (          String fieldName : new String[]{"target","runnable","action"}) {
            try {
              Field targetField=thread.getClass().getDeclaredField(fieldName);
              targetField.setAccessible(true);
              target=targetField.get(thread);
              break;
            }
 catch (            NoSuchFieldException nfe) {
              continue;
            }
          }
          if (target != null && target.getClass().getCanonicalName() != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) {
            Field executorField=target.getClass().getDeclaredField("this$0");
            executorField.setAccessible(true);
            Object executor=executorField.get(target);
            if (executor instanceof ThreadPoolExecutor) {
              ((ThreadPoolExecutor)executor).shutdownNow();
              usingExecutor=true;
            }
          }
        }
 catch (        SecurityException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        NoSuchFieldException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
        if (usingExecutor) {
          executorThreadsToStop.add(thread);
        }
 else {
          thread.stop();
        }
      }
    }
  }
  int count=0;
  for (  Thread t : executorThreadsToStop) {
    while (t.isAlive() && count < 100) {
      try {
        Thread.sleep(20);
      }
 catch (      InterruptedException e) {
        break;
      }
      count++;
    }
    if (t.isAlive()) {
      t.stop();
    }
  }
}

ID 2635=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesThreads()
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") private void clearReferencesThreads(){
  Thread[] threads=getThreads();
  List<Thread> executorThreadsToStop=new ArrayList<Thread>();
  for (  Thread thread : threads) {
    if (thread != null) {
      ClassLoader ccl=thread.getContextClassLoader();
      if (ccl == this) {
        if (thread == Thread.currentThread()) {
          continue;
        }
        ThreadGroup tg=thread.getThreadGroup();
        if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {
          if (clearReferencesHttpClientKeepAliveThread && thread.getName().equals("Keep-Alive-Timer")) {
            thread.setContextClassLoader(parent);
            log.debug(sm.getString("webappClassLoader.checkThreadsHttpClient"));
          }
          continue;
        }
        if (!thread.isAlive()) {
          continue;
        }
        if (thread.getClass().getName().startsWith("java.util.Timer") && clearReferencesStopTimerThreads) {
          clearReferencesStopTimerThread(thread);
          continue;
        }
        if (isRequestThread(thread)) {
          log.error(sm.getString("webappClassLoader.warnRequestThread",contextName,thread.getName()));
        }
 else {
          log.error(sm.getString("webappClassLoader.warnThread",contextName,thread.getName()));
        }
        if (!clearReferencesStopThreads) {
          continue;
        }
        boolean usingExecutor=false;
        try {
          Object target=null;
          for (          String fieldName : new String[]{"target","runnable","action"}) {
            try {
              Field targetField=thread.getClass().getDeclaredField(fieldName);
              targetField.setAccessible(true);
              target=targetField.get(thread);
              break;
            }
 catch (            NoSuchFieldException nfe) {
              continue;
            }
          }
          if (target != null && target.getClass().getCanonicalName() != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) {
            Field executorField=target.getClass().getDeclaredField("this$0");
            executorField.setAccessible(true);
            Object executor=executorField.get(target);
            if (executor instanceof ThreadPoolExecutor) {
              ((ThreadPoolExecutor)executor).shutdownNow();
              usingExecutor=true;
            }
          }
        }
 catch (        SecurityException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        NoSuchFieldException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
        if (usingExecutor) {
          executorThreadsToStop.add(thread);
        }
 else {
          thread.stop();
        }
      }
    }
  }
  int count=0;
  for (  Thread t : executorThreadsToStop) {
    while (t.isAlive() && count < 100) {
      try {
        Thread.sleep(20);
      }
 catch (      InterruptedException e) {
        break;
      }
      count++;
    }
    if (t.isAlive()) {
      t.stop();
    }
  }
}

ID 2636=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesThreads()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") private void clearReferencesThreads(){
  Thread[] threads=getThreads();
  List<Thread> executorThreadsToStop=new ArrayList<Thread>();
  for (  Thread thread : threads) {
    if (thread != null) {
      ClassLoader ccl=thread.getContextClassLoader();
      if (ccl == this) {
        if (thread == Thread.currentThread()) {
          continue;
        }
        ThreadGroup tg=thread.getThreadGroup();
        if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {
          if (clearReferencesHttpClientKeepAliveThread && thread.getName().equals("Keep-Alive-Timer")) {
            thread.setContextClassLoader(parent);
            log.debug(sm.getString("webappClassLoader.checkThreadsHttpClient"));
          }
          continue;
        }
        if (!thread.isAlive()) {
          continue;
        }
        if (thread.getClass().getName().startsWith("java.util.Timer") && clearReferencesStopTimerThreads) {
          clearReferencesStopTimerThread(thread);
          continue;
        }
        if (isRequestThread(thread)) {
          log.error(sm.getString("webappClassLoader.warnRequestThread",contextName,thread.getName()));
        }
 else {
          log.error(sm.getString("webappClassLoader.warnThread",contextName,thread.getName()));
        }
        if (!clearReferencesStopThreads) {
          continue;
        }
        boolean usingExecutor=false;
        try {
          Object target=null;
          for (          String fieldName : new String[]{"target","runnable","action"}) {
            try {
              Field targetField=thread.getClass().getDeclaredField(fieldName);
              targetField.setAccessible(true);
              target=targetField.get(thread);
              break;
            }
 catch (            NoSuchFieldException nfe) {
              continue;
            }
          }
          if (target != null && target.getClass().getCanonicalName() != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) {
            Field executorField=target.getClass().getDeclaredField("this$0");
            executorField.setAccessible(true);
            Object executor=executorField.get(target);
            if (executor instanceof ThreadPoolExecutor) {
              ((ThreadPoolExecutor)executor).shutdownNow();
              usingExecutor=true;
            }
          }
        }
 catch (        SecurityException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        NoSuchFieldException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
        if (usingExecutor) {
          executorThreadsToStop.add(thread);
        }
 else {
          thread.stop();
        }
      }
    }
  }
  int count=0;
  for (  Thread t : executorThreadsToStop) {
    while (t.isAlive() && count < 100) {
      try {
        Thread.sleep(20);
      }
 catch (      InterruptedException e) {
        break;
      }
      count++;
    }
    if (t.isAlive()) {
      t.stop();
    }
  }
}

ID 2637=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesThreads()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") private void clearReferencesThreads(){
  Thread[] threads=getThreads();
  List<Thread> executorThreadsToStop=new ArrayList<Thread>();
  for (  Thread thread : threads) {
    if (thread != null) {
      ClassLoader ccl=thread.getContextClassLoader();
      if (ccl == this) {
        if (thread == Thread.currentThread()) {
          continue;
        }
        ThreadGroup tg=thread.getThreadGroup();
        if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {
          if (clearReferencesHttpClientKeepAliveThread && thread.getName().equals("Keep-Alive-Timer")) {
            thread.setContextClassLoader(parent);
            log.debug(sm.getString("webappClassLoader.checkThreadsHttpClient"));
          }
          continue;
        }
        if (!thread.isAlive()) {
          continue;
        }
        if (thread.getClass().getName().startsWith("java.util.Timer") && clearReferencesStopTimerThreads) {
          clearReferencesStopTimerThread(thread);
          continue;
        }
        if (isRequestThread(thread)) {
          log.error(sm.getString("webappClassLoader.warnRequestThread",contextName,thread.getName()));
        }
 else {
          log.error(sm.getString("webappClassLoader.warnThread",contextName,thread.getName()));
        }
        if (!clearReferencesStopThreads) {
          continue;
        }
        boolean usingExecutor=false;
        try {
          Object target=null;
          for (          String fieldName : new String[]{"target","runnable","action"}) {
            try {
              Field targetField=thread.getClass().getDeclaredField(fieldName);
              targetField.setAccessible(true);
              target=targetField.get(thread);
              break;
            }
 catch (            NoSuchFieldException nfe) {
              continue;
            }
          }
          if (target != null && target.getClass().getCanonicalName() != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) {
            Field executorField=target.getClass().getDeclaredField("this$0");
            executorField.setAccessible(true);
            Object executor=executorField.get(target);
            if (executor instanceof ThreadPoolExecutor) {
              ((ThreadPoolExecutor)executor).shutdownNow();
              usingExecutor=true;
            }
          }
        }
 catch (        SecurityException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        NoSuchFieldException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
        if (usingExecutor) {
          executorThreadsToStop.add(thread);
        }
 else {
          thread.stop();
        }
      }
    }
  }
  int count=0;
  for (  Thread t : executorThreadsToStop) {
    while (t.isAlive() && count < 100) {
      try {
        Thread.sleep(20);
      }
 catch (      InterruptedException e) {
        break;
      }
      count++;
    }
    if (t.isAlive()) {
      t.stop();
    }
  }
}

ID 2638=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesThreads()
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") private void clearReferencesThreads(){
  Thread[] threads=getThreads();
  List<Thread> executorThreadsToStop=new ArrayList<Thread>();
  for (  Thread thread : threads) {
    if (thread != null) {
      ClassLoader ccl=thread.getContextClassLoader();
      if (ccl == this) {
        if (thread == Thread.currentThread()) {
          continue;
        }
        ThreadGroup tg=thread.getThreadGroup();
        if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {
          if (clearReferencesHttpClientKeepAliveThread && thread.getName().equals("Keep-Alive-Timer")) {
            thread.setContextClassLoader(parent);
            log.debug(sm.getString("webappClassLoader.checkThreadsHttpClient"));
          }
          continue;
        }
        if (!thread.isAlive()) {
          continue;
        }
        if (thread.getClass().getName().startsWith("java.util.Timer") && clearReferencesStopTimerThreads) {
          clearReferencesStopTimerThread(thread);
          continue;
        }
        if (isRequestThread(thread)) {
          log.error(sm.getString("webappClassLoader.warnRequestThread",contextName,thread.getName()));
        }
 else {
          log.error(sm.getString("webappClassLoader.warnThread",contextName,thread.getName()));
        }
        if (!clearReferencesStopThreads) {
          continue;
        }
        boolean usingExecutor=false;
        try {
          Object target=null;
          for (          String fieldName : new String[]{"target","runnable","action"}) {
            try {
              Field targetField=thread.getClass().getDeclaredField(fieldName);
              targetField.setAccessible(true);
              target=targetField.get(thread);
              break;
            }
 catch (            NoSuchFieldException nfe) {
              continue;
            }
          }
          if (target != null && target.getClass().getCanonicalName() != null && target.getClass().getCanonicalName().equals("java.util.concurrent.ThreadPoolExecutor.Worker")) {
            Field executorField=target.getClass().getDeclaredField("this$0");
            executorField.setAccessible(true);
            Object executor=executorField.get(target);
            if (executor instanceof ThreadPoolExecutor) {
              ((ThreadPoolExecutor)executor).shutdownNow();
              usingExecutor=true;
            }
          }
        }
 catch (        SecurityException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        NoSuchFieldException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalArgumentException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
catch (        IllegalAccessException e) {
          log.warn(sm.getString("webappClassLoader.stopThreadFail",thread.getName(),contextName),e);
        }
        if (usingExecutor) {
          executorThreadsToStop.add(thread);
        }
 else {
          thread.stop();
        }
      }
    }
  }
  int count=0;
  for (  Thread t : executorThreadsToStop) {
    while (t.isAlive() && count < 100) {
      try {
        Thread.sleep(20);
      }
 catch (      InterruptedException e) {
        break;
      }
      count++;
    }
    if (t.isAlive()) {
      t.stop();
    }
  }
}

ID 2639=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesStopTimerThread(java.lang.Thread)
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: ReflectiveOperationException 
thrown: NoSuchFieldException
exception comment: /** 
 * Signals that the class doesn't have a field of a specified name.
 * @author  unascribed
 * @since   JDK1.1
 */

block: 
private void clearReferencesStopTimerThread(Thread thread){
  try {
    try {
      Field newTasksMayBeScheduledField=thread.getClass().getDeclaredField("newTasksMayBeScheduled");
      newTasksMayBeScheduledField.setAccessible(true);
      Field queueField=thread.getClass().getDeclaredField("queue");
      queueField.setAccessible(true);
      Object queue=queueField.get(thread);
      Method clearMethod=queue.getClass().getDeclaredMethod("clear");
      clearMethod.setAccessible(true);
synchronized (queue) {
        newTasksMayBeScheduledField.setBoolean(thread,false);
        clearMethod.invoke(queue);
        queue.notify();
      }
    }
 catch (    NoSuchFieldException nfe) {
      Method cancelMethod=thread.getClass().getDeclaredMethod("cancel");
synchronized (thread) {
        cancelMethod.setAccessible(true);
        cancelMethod.invoke(thread);
      }
    }
    log.error(sm.getString("webappClassLoader.warnTimerThread",contextName,thread.getName()));
  }
 catch (  Exception e) {
    Throwable t=ExceptionUtils.unwrapInvocationTargetException(e);
    ExceptionUtils.handleThrowable(t);
    log.warn(sm.getString("webappClassLoader.stopTimerThreadFail",thread.getName(),contextName),t);
  }
}

ID 2671=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2672=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: ReflectiveOperationException 
thrown: NoSuchFieldException
exception comment: /** 
 * Signals that the class doesn't have a field of a specified name.
 * @author  unascribed
 * @since   JDK1.1
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2673=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2674=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2675=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2676=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2677=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2678=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesRmiTargets()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * This depends on the internals of the Sun JVM so it does everything by reflection.
 */
private void clearReferencesRmiTargets(){
  try {
    Class<?> objectTargetClass=Class.forName("sun.rmi.transport.Target");
    Field cclField=objectTargetClass.getDeclaredField("ccl");
    cclField.setAccessible(true);
    Field stubField=objectTargetClass.getDeclaredField("stub");
    stubField.setAccessible(true);
    Class<?> objectTableClass=Class.forName("sun.rmi.transport.ObjectTable");
    Field objTableField=objectTableClass.getDeclaredField("objTable");
    objTableField.setAccessible(true);
    Object objTable=objTableField.get(null);
    if (objTable == null) {
      return;
    }
    if (objTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)objTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
          Object stubObject=stubField.get(obj);
          log.error(sm.getString("webappClassLoader.clearRmi",stubObject.getClass().getName(),stubObject));
        }
      }
    }
    Field implTableField=objectTableClass.getDeclaredField("implTable");
    implTableField.setAccessible(true);
    Object implTable=implTableField.get(null);
    if (implTable == null) {
      return;
    }
    if (implTable instanceof Map<?,?>) {
      Iterator<?> iter=((Map<?,?>)implTable).values().iterator();
      while (iter.hasNext()) {
        Object obj=iter.next();
        Object cclObject=cclField.get(obj);
        if (this == cclObject) {
          iter.remove();
        }
      }
    }
  }
 catch (  ClassNotFoundException e) {
    log.info(sm.getString("webappClassLoader.clearRmiInfo",contextName),e);
  }
catch (  SecurityException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalArgumentException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.warn(sm.getString("webappClassLoader.clearRmiFail",contextName),e);
  }
catch (  Exception e) {
    JreCompat jreCompat=JreCompat.getInstance();
    if (jreCompat.isInstanceOfInaccessibleObjectException(e)) {
      log.warn(sm.getString("webappClassLoader.addExports"));
    }
 else {
      throw new RuntimeException(e);
    }
  }
}

ID 2679=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: ReflectiveOperationException 
thrown: NoSuchFieldException
exception comment: /** 
 * Signals that the class doesn't have a field of a specified name.
 * @author  unascribed
 * @since   JDK1.1
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2680=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2681=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2682=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2683=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2684=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: ReflectiveOperationException 
thrown: NoSuchFieldException
exception comment: /** 
 * Signals that the class doesn't have a field of a specified name.
 * @author  unascribed
 * @since   JDK1.1
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2685=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.Class#getDeclaredField(java.lang.String)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2686=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.reflect.AccessibleObject#setAccessible(boolean)
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2687=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2688=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#clearReferencesResourceBundles()
Rmethod: java.lang.reflect.Field#get(java.lang.Object)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the  {@link ResourceBundle} cache of any bundles loaded by thisclass loader or any class loader where this loader is a parent class loader. Whilst  {@link ResourceBundle#clearCache()} could be used thereare complications around the {@link org.apache.jasper.servlet.JasperLoader} that mean a reflectionbased approach is more likely to be complete. The ResourceBundle is using WeakReferences so it shouldn't be pinning the class loader in memory. However, it is. Therefore clear ou the references.
 */
private void clearReferencesResourceBundles(){
  try {
    Field cacheListField=ResourceBundle.class.getDeclaredField("cacheList");
    cacheListField.setAccessible(true);
    Map<?,?> cacheList=(Map<?,?>)cacheListField.get(null);
    Set<?> keys=cacheList.keySet();
    Field loaderRefField=null;
    Iterator<?> keysIter=keys.iterator();
    int countRemoved=0;
    while (keysIter.hasNext()) {
      Object key=keysIter.next();
      if (loaderRefField == null) {
        loaderRefField=key.getClass().getDeclaredField("loaderRef");
        loaderRefField.setAccessible(true);
      }
      WeakReference<?> loaderRef=(WeakReference<?>)loaderRefField.get(key);
      ClassLoader loader=(ClassLoader)loaderRef.get();
      while (loader != null && loader != this) {
        loader=loader.getParent();
      }
      if (loader != null) {
        keysIter.remove();
        countRemoved++;
      }
    }
    if (countRemoved > 0 && log.isDebugEnabled()) {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesCount",Integer.valueOf(countRemoved),contextName));
    }
  }
 catch (  SecurityException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  NoSuchFieldException e) {
    if (JreVendor.IS_ORACLE_JVM) {
      log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
 else {
      log.debug(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",getContextName()),e);
    }
  }
catch (  IllegalArgumentException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
catch (  IllegalAccessException e) {
    log.error(sm.getString("webappClassLoader.clearReferencesResourceBundlesFail",contextName),e);
  }
}

ID 2689=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#openJARs()
Rmethod: java.util.jar.JarFile#JarFile(java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Used to periodically signal to the classloader to release JAR resources.
 */
protected boolean openJARs(){
  if (started && (jarFiles.length > 0)) {
    lastJarAccessed=System.currentTimeMillis();
    if (jarFiles[0] == null) {
      for (int i=0; i < jarFiles.length; i++) {
        try {
          jarFiles[i]=new JarFile(jarRealFiles[i]);
        }
 catch (        IOException e) {
          log.warn(sm.getString("webappClassLoader.jarOpenFail",jarFiles[i]),e);
          closeJARs(true);
          return false;
        }
      }
    }
  }
  return true;
}

ID 2700=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#findResourceInternal(java.lang.String, java.lang.String, boolean)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Find specified resource in local repositories.
 * @return the loaded resource, or null if the resource isn't found
 */
protected ResourceEntry findResourceInternal(final String name,final String path,final boolean manifestRequired){
  if (!started) {
    log.info(sm.getString("webappClassLoader.stopped",name));
    return null;
  }
  if ((name == null) || (path == null))   return null;
  JarEntry jarEntry=null;
  String jarEntryPath=path.substring(1);
  ResourceEntry entry=resourceEntries.get(path);
  if (entry != null) {
    if (manifestRequired && entry.manifest == MANIFEST_UNKNOWN) {
synchronized (jarFiles) {
        if (openJARs()) {
          for (int i=0; i < jarFiles.length; i++) {
            jarEntry=jarFiles[i].getJarEntry(jarEntryPath);
            if (jarEntry != null) {
              try {
                entry.manifest=jarFiles[i].getManifest();
              }
 catch (              IOException ioe) {
              }
              break;
            }
          }
        }
      }
    }
    return entry;
  }
  int contentLength=-1;
  InputStream binaryStream=null;
  boolean isClassResource=path.endsWith(CLASS_FILE_SUFFIX);
  boolean isCacheable=isClassResource;
  if (!isCacheable) {
    isCacheable=path.startsWith(SERVICES_PREFIX);
  }
  int jarFilesLength=jarFiles.length;
  int repositoriesLength=repositories.length;
  int i;
  Resource resource=null;
  boolean fileNeedConvert=false;
  for (i=0; (entry == null) && (i < repositoriesLength); i++) {
    try {
      String fullPath=repositories[i] + path;
      Object lookupResult=resources.lookup(fullPath);
      if (lookupResult instanceof Resource) {
        resource=(Resource)lookupResult;
      }
      ResourceAttributes attributes=(ResourceAttributes)resources.getAttributes(fullPath);
      contentLength=(int)attributes.getContentLength();
      String canonicalPath=attributes.getCanonicalPath();
      if (canonicalPath != null) {
        entry=findResourceInternal(new File(canonicalPath),"");
      }
 else {
        entry=findResourceInternal(files[i],path);
      }
      entry.lastModified=attributes.getLastModified();
      if (resource != null) {
        try {
          binaryStream=resource.streamContent();
        }
 catch (        IOException e) {
          return null;
        }
        if (needConvert) {
          if (path.endsWith(".properties")) {
            fileNeedConvert=true;
          }
        }
synchronized (allPermission) {
          int j;
          long[] result2=new long[lastModifiedDates.length + 1];
          for (j=0; j < lastModifiedDates.length; j++) {
            result2[j]=lastModifiedDates[j];
          }
          result2[lastModifiedDates.length]=entry.lastModified;
          lastModifiedDates=result2;
          String[] result=new String[paths.length + 1];
          for (j=0; j < paths.length; j++) {
            result[j]=paths[j];
          }
          result[paths.length]=fullPath;
          paths=result;
        }
      }
    }
 catch (    NamingException e) {
    }
  }
  if ((entry == null) && (notFoundResources.containsKey(name)))   return null;
synchronized (jarFiles) {
    try {
      if (!openJARs()) {
        return null;
      }
      for (i=0; (entry == null) && (i < jarFilesLength); i++) {
        jarEntry=jarFiles[i].getJarEntry(jarEntryPath);
        if (jarEntry != null) {
          entry=new ResourceEntry();
          try {
            entry.codeBase=getURI(jarRealFiles[i]);
            entry.source=UriUtil.buildJarUrl(entry.codeBase.toString(),jarEntryPath);
            entry.lastModified=jarRealFiles[i].lastModified();
          }
 catch (          MalformedURLException e) {
            return null;
          }
          contentLength=(int)jarEntry.getSize();
          try {
            if (manifestRequired) {
              entry.manifest=jarFiles[i].getManifest();
            }
 else {
              entry.manifest=MANIFEST_UNKNOWN;
            }
            binaryStream=jarFiles[i].getInputStream(jarEntry);
          }
 catch (          IOException e) {
            return null;
          }
          if (antiJARLocking && !(path.endsWith(CLASS_FILE_SUFFIX))) {
            byte[] buf=new byte[1024];
            File resourceFile=new File(loaderDir,jarEntry.getName());
            if (!resourceFile.exists()) {
              Enumeration<JarEntry> entries=jarFiles[i].entries();
              while (entries.hasMoreElements()) {
                JarEntry jarEntry2=entries.nextElement();
                if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith(CLASS_FILE_SUFFIX))) {
                  resourceFile=new File(loaderDir,jarEntry2.getName());
                  try {
                    if (!resourceFile.getCanonicalPath().startsWith(canonicalLoaderDir)) {
                      throw new IllegalArgumentException(sm.getString("webappClassLoader.illegalJarPath",jarEntry2.getName()));
                    }
                  }
 catch (                  IOException ioe) {
                    throw new IllegalArgumentException(sm.getString("webappClassLoader.validationErrorJarPath",jarEntry2.getName()),ioe);
                  }
                  File parentFile=resourceFile.getParentFile();
                  if (!parentFile.mkdirs() && !parentFile.exists()) {
                  }
                  FileOutputStream os=null;
                  InputStream is=null;
                  try {
                    is=jarFiles[i].getInputStream(jarEntry2);
                    os=new FileOutputStream(resourceFile);
                    while (true) {
                      int n=is.read(buf);
                      if (n <= 0) {
                        break;
                      }
                      os.write(buf,0,n);
                    }
                    resourceFile.setLastModified(jarEntry2.getTime());
                  }
 catch (                  IOException e) {
                  }
 finally {
                    try {
                      if (is != null) {
                        is.close();
                      }
                    }
 catch (                    IOException e) {
                    }
                    try {
                      if (os != null) {
                        os.close();
                      }
                    }
 catch (                    IOException e) {
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (entry == null) {
synchronized (notFoundResources) {
          notFoundResources.put(name,name);
        }
        return null;
      }
      if (binaryStream != null && (isCacheable || fileNeedConvert)) {
        byte[] binaryContent=new byte[contentLength];
        int pos=0;
        try {
          while (true) {
            int n=binaryStream.read(binaryContent,pos,binaryContent.length - pos);
            if (n <= 0)             break;
            pos+=n;
          }
        }
 catch (        IOException e) {
          log.error(sm.getString("webappClassLoader.readError",name),e);
          return null;
        }
        if (fileNeedConvert) {
          String str=new String(binaryContent,0,pos);
          try {
            binaryContent=str.getBytes(CHARSET_UTF8);
          }
 catch (          Exception e) {
            return null;
          }
        }
        entry.binaryContent=binaryContent;
        if (jarEntry != null) {
          entry.certificates=jarEntry.getCertificates();
        }
      }
    }
  finally {
      if (binaryStream != null) {
        try {
          binaryStream.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  if (isClassResource && entry.binaryContent != null && this.transformers.size() > 0) {
    String className=name.endsWith(CLASS_FILE_SUFFIX) ? name.substring(0,name.length() - CLASS_FILE_SUFFIX.length()) : name;
    String internalName=className.replace(".","/");
    for (    ClassFileTransformer transformer : this.transformers) {
      try {
        byte[] transformed=transformer.transform(this,internalName,null,null,entry.binaryContent);
        if (transformed != null) {
          entry.binaryContent=transformed;
        }
      }
 catch (      IllegalClassFormatException e) {
        log.error(sm.getString("webappClassLoader.transformError",name),e);
        return null;
      }
    }
  }
synchronized (resourceEntries) {
    ResourceEntry entry2=resourceEntries.get(path);
    if (entry2 == null) {
      resourceEntries.put(path,entry);
    }
 else {
      entry=entry2;
    }
  }
  return entry;
}

ID 2706=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#findResourceInternal(java.lang.String, java.lang.String, boolean)
Rmethod: java.io.InputStream#read(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Find specified resource in local repositories.
 * @return the loaded resource, or null if the resource isn't found
 */
protected ResourceEntry findResourceInternal(final String name,final String path,final boolean manifestRequired){
  if (!started) {
    log.info(sm.getString("webappClassLoader.stopped",name));
    return null;
  }
  if ((name == null) || (path == null))   return null;
  JarEntry jarEntry=null;
  String jarEntryPath=path.substring(1);
  ResourceEntry entry=resourceEntries.get(path);
  if (entry != null) {
    if (manifestRequired && entry.manifest == MANIFEST_UNKNOWN) {
synchronized (jarFiles) {
        if (openJARs()) {
          for (int i=0; i < jarFiles.length; i++) {
            jarEntry=jarFiles[i].getJarEntry(jarEntryPath);
            if (jarEntry != null) {
              try {
                entry.manifest=jarFiles[i].getManifest();
              }
 catch (              IOException ioe) {
              }
              break;
            }
          }
        }
      }
    }
    return entry;
  }
  int contentLength=-1;
  InputStream binaryStream=null;
  boolean isClassResource=path.endsWith(CLASS_FILE_SUFFIX);
  boolean isCacheable=isClassResource;
  if (!isCacheable) {
    isCacheable=path.startsWith(SERVICES_PREFIX);
  }
  int jarFilesLength=jarFiles.length;
  int repositoriesLength=repositories.length;
  int i;
  Resource resource=null;
  boolean fileNeedConvert=false;
  for (i=0; (entry == null) && (i < repositoriesLength); i++) {
    try {
      String fullPath=repositories[i] + path;
      Object lookupResult=resources.lookup(fullPath);
      if (lookupResult instanceof Resource) {
        resource=(Resource)lookupResult;
      }
      ResourceAttributes attributes=(ResourceAttributes)resources.getAttributes(fullPath);
      contentLength=(int)attributes.getContentLength();
      String canonicalPath=attributes.getCanonicalPath();
      if (canonicalPath != null) {
        entry=findResourceInternal(new File(canonicalPath),"");
      }
 else {
        entry=findResourceInternal(files[i],path);
      }
      entry.lastModified=attributes.getLastModified();
      if (resource != null) {
        try {
          binaryStream=resource.streamContent();
        }
 catch (        IOException e) {
          return null;
        }
        if (needConvert) {
          if (path.endsWith(".properties")) {
            fileNeedConvert=true;
          }
        }
synchronized (allPermission) {
          int j;
          long[] result2=new long[lastModifiedDates.length + 1];
          for (j=0; j < lastModifiedDates.length; j++) {
            result2[j]=lastModifiedDates[j];
          }
          result2[lastModifiedDates.length]=entry.lastModified;
          lastModifiedDates=result2;
          String[] result=new String[paths.length + 1];
          for (j=0; j < paths.length; j++) {
            result[j]=paths[j];
          }
          result[paths.length]=fullPath;
          paths=result;
        }
      }
    }
 catch (    NamingException e) {
    }
  }
  if ((entry == null) && (notFoundResources.containsKey(name)))   return null;
synchronized (jarFiles) {
    try {
      if (!openJARs()) {
        return null;
      }
      for (i=0; (entry == null) && (i < jarFilesLength); i++) {
        jarEntry=jarFiles[i].getJarEntry(jarEntryPath);
        if (jarEntry != null) {
          entry=new ResourceEntry();
          try {
            entry.codeBase=getURI(jarRealFiles[i]);
            entry.source=UriUtil.buildJarUrl(entry.codeBase.toString(),jarEntryPath);
            entry.lastModified=jarRealFiles[i].lastModified();
          }
 catch (          MalformedURLException e) {
            return null;
          }
          contentLength=(int)jarEntry.getSize();
          try {
            if (manifestRequired) {
              entry.manifest=jarFiles[i].getManifest();
            }
 else {
              entry.manifest=MANIFEST_UNKNOWN;
            }
            binaryStream=jarFiles[i].getInputStream(jarEntry);
          }
 catch (          IOException e) {
            return null;
          }
          if (antiJARLocking && !(path.endsWith(CLASS_FILE_SUFFIX))) {
            byte[] buf=new byte[1024];
            File resourceFile=new File(loaderDir,jarEntry.getName());
            if (!resourceFile.exists()) {
              Enumeration<JarEntry> entries=jarFiles[i].entries();
              while (entries.hasMoreElements()) {
                JarEntry jarEntry2=entries.nextElement();
                if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith(CLASS_FILE_SUFFIX))) {
                  resourceFile=new File(loaderDir,jarEntry2.getName());
                  try {
                    if (!resourceFile.getCanonicalPath().startsWith(canonicalLoaderDir)) {
                      throw new IllegalArgumentException(sm.getString("webappClassLoader.illegalJarPath",jarEntry2.getName()));
                    }
                  }
 catch (                  IOException ioe) {
                    throw new IllegalArgumentException(sm.getString("webappClassLoader.validationErrorJarPath",jarEntry2.getName()),ioe);
                  }
                  File parentFile=resourceFile.getParentFile();
                  if (!parentFile.mkdirs() && !parentFile.exists()) {
                  }
                  FileOutputStream os=null;
                  InputStream is=null;
                  try {
                    is=jarFiles[i].getInputStream(jarEntry2);
                    os=new FileOutputStream(resourceFile);
                    while (true) {
                      int n=is.read(buf);
                      if (n <= 0) {
                        break;
                      }
                      os.write(buf,0,n);
                    }
                    resourceFile.setLastModified(jarEntry2.getTime());
                  }
 catch (                  IOException e) {
                  }
 finally {
                    try {
                      if (is != null) {
                        is.close();
                      }
                    }
 catch (                    IOException e) {
                    }
                    try {
                      if (os != null) {
                        os.close();
                      }
                    }
 catch (                    IOException e) {
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (entry == null) {
synchronized (notFoundResources) {
          notFoundResources.put(name,name);
        }
        return null;
      }
      if (binaryStream != null && (isCacheable || fileNeedConvert)) {
        byte[] binaryContent=new byte[contentLength];
        int pos=0;
        try {
          while (true) {
            int n=binaryStream.read(binaryContent,pos,binaryContent.length - pos);
            if (n <= 0)             break;
            pos+=n;
          }
        }
 catch (        IOException e) {
          log.error(sm.getString("webappClassLoader.readError",name),e);
          return null;
        }
        if (fileNeedConvert) {
          String str=new String(binaryContent,0,pos);
          try {
            binaryContent=str.getBytes(CHARSET_UTF8);
          }
 catch (          Exception e) {
            return null;
          }
        }
        entry.binaryContent=binaryContent;
        if (jarEntry != null) {
          entry.certificates=jarEntry.getCertificates();
        }
      }
    }
  finally {
      if (binaryStream != null) {
        try {
          binaryStream.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  if (isClassResource && entry.binaryContent != null && this.transformers.size() > 0) {
    String className=name.endsWith(CLASS_FILE_SUFFIX) ? name.substring(0,name.length() - CLASS_FILE_SUFFIX.length()) : name;
    String internalName=className.replace(".","/");
    for (    ClassFileTransformer transformer : this.transformers) {
      try {
        byte[] transformed=transformer.transform(this,internalName,null,null,entry.binaryContent);
        if (transformed != null) {
          entry.binaryContent=transformed;
        }
      }
 catch (      IllegalClassFormatException e) {
        log.error(sm.getString("webappClassLoader.transformError",name),e);
        return null;
      }
    }
  }
synchronized (resourceEntries) {
    ResourceEntry entry2=resourceEntries.get(path);
    if (entry2 == null) {
      resourceEntries.put(path,entry);
    }
 else {
      entry=entry2;
    }
  }
  return entry;
}

ID 2708=========================================================================type: 1
Method:org.apache.catalina.loader.WebappClassLoaderBase#findResourceInternal(java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.instrument.ClassFileTransformer#transform(java.lang.ClassLoader, java.lang.String, Class<?>, java.security.ProtectionDomain, byte[])
parentException: 
thrown: IllegalClassFormatException
exception comment: /** 
 * Thrown by an implementation of {@link java.lang.instrument.ClassFileTransformer#transform ClassFileTransformer.transform}when its input parameters are invalid. This may occur either because the initial class file bytes were invalid or a previously applied transform corrupted the bytes.
 * @see java.lang.instrument.ClassFileTransformer#transform
 * @since   1.5
 */

block: 
/** 
 * Find specified resource in local repositories.
 * @return the loaded resource, or null if the resource isn't found
 */
protected ResourceEntry findResourceInternal(final String name,final String path,final boolean manifestRequired){
  if (!started) {
    log.info(sm.getString("webappClassLoader.stopped",name));
    return null;
  }
  if ((name == null) || (path == null))   return null;
  JarEntry jarEntry=null;
  String jarEntryPath=path.substring(1);
  ResourceEntry entry=resourceEntries.get(path);
  if (entry != null) {
    if (manifestRequired && entry.manifest == MANIFEST_UNKNOWN) {
synchronized (jarFiles) {
        if (openJARs()) {
          for (int i=0; i < jarFiles.length; i++) {
            jarEntry=jarFiles[i].getJarEntry(jarEntryPath);
            if (jarEntry != null) {
              try {
                entry.manifest=jarFiles[i].getManifest();
              }
 catch (              IOException ioe) {
              }
              break;
            }
          }
        }
      }
    }
    return entry;
  }
  int contentLength=-1;
  InputStream binaryStream=null;
  boolean isClassResource=path.endsWith(CLASS_FILE_SUFFIX);
  boolean isCacheable=isClassResource;
  if (!isCacheable) {
    isCacheable=path.startsWith(SERVICES_PREFIX);
  }
  int jarFilesLength=jarFiles.length;
  int repositoriesLength=repositories.length;
  int i;
  Resource resource=null;
  boolean fileNeedConvert=false;
  for (i=0; (entry == null) && (i < repositoriesLength); i++) {
    try {
      String fullPath=repositories[i] + path;
      Object lookupResult=resources.lookup(fullPath);
      if (lookupResult instanceof Resource) {
        resource=(Resource)lookupResult;
      }
      ResourceAttributes attributes=(ResourceAttributes)resources.getAttributes(fullPath);
      contentLength=(int)attributes.getContentLength();
      String canonicalPath=attributes.getCanonicalPath();
      if (canonicalPath != null) {
        entry=findResourceInternal(new File(canonicalPath),"");
      }
 else {
        entry=findResourceInternal(files[i],path);
      }
      entry.lastModified=attributes.getLastModified();
      if (resource != null) {
        try {
          binaryStream=resource.streamContent();
        }
 catch (        IOException e) {
          return null;
        }
        if (needConvert) {
          if (path.endsWith(".properties")) {
            fileNeedConvert=true;
          }
        }
synchronized (allPermission) {
          int j;
          long[] result2=new long[lastModifiedDates.length + 1];
          for (j=0; j < lastModifiedDates.length; j++) {
            result2[j]=lastModifiedDates[j];
          }
          result2[lastModifiedDates.length]=entry.lastModified;
          lastModifiedDates=result2;
          String[] result=new String[paths.length + 1];
          for (j=0; j < paths.length; j++) {
            result[j]=paths[j];
          }
          result[paths.length]=fullPath;
          paths=result;
        }
      }
    }
 catch (    NamingException e) {
    }
  }
  if ((entry == null) && (notFoundResources.containsKey(name)))   return null;
synchronized (jarFiles) {
    try {
      if (!openJARs()) {
        return null;
      }
      for (i=0; (entry == null) && (i < jarFilesLength); i++) {
        jarEntry=jarFiles[i].getJarEntry(jarEntryPath);
        if (jarEntry != null) {
          entry=new ResourceEntry();
          try {
            entry.codeBase=getURI(jarRealFiles[i]);
            entry.source=UriUtil.buildJarUrl(entry.codeBase.toString(),jarEntryPath);
            entry.lastModified=jarRealFiles[i].lastModified();
          }
 catch (          MalformedURLException e) {
            return null;
          }
          contentLength=(int)jarEntry.getSize();
          try {
            if (manifestRequired) {
              entry.manifest=jarFiles[i].getManifest();
            }
 else {
              entry.manifest=MANIFEST_UNKNOWN;
            }
            binaryStream=jarFiles[i].getInputStream(jarEntry);
          }
 catch (          IOException e) {
            return null;
          }
          if (antiJARLocking && !(path.endsWith(CLASS_FILE_SUFFIX))) {
            byte[] buf=new byte[1024];
            File resourceFile=new File(loaderDir,jarEntry.getName());
            if (!resourceFile.exists()) {
              Enumeration<JarEntry> entries=jarFiles[i].entries();
              while (entries.hasMoreElements()) {
                JarEntry jarEntry2=entries.nextElement();
                if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith(CLASS_FILE_SUFFIX))) {
                  resourceFile=new File(loaderDir,jarEntry2.getName());
                  try {
                    if (!resourceFile.getCanonicalPath().startsWith(canonicalLoaderDir)) {
                      throw new IllegalArgumentException(sm.getString("webappClassLoader.illegalJarPath",jarEntry2.getName()));
                    }
                  }
 catch (                  IOException ioe) {
                    throw new IllegalArgumentException(sm.getString("webappClassLoader.validationErrorJarPath",jarEntry2.getName()),ioe);
                  }
                  File parentFile=resourceFile.getParentFile();
                  if (!parentFile.mkdirs() && !parentFile.exists()) {
                  }
                  FileOutputStream os=null;
                  InputStream is=null;
                  try {
                    is=jarFiles[i].getInputStream(jarEntry2);
                    os=new FileOutputStream(resourceFile);
                    while (true) {
                      int n=is.read(buf);
                      if (n <= 0) {
                        break;
                      }
                      os.write(buf,0,n);
                    }
                    resourceFile.setLastModified(jarEntry2.getTime());
                  }
 catch (                  IOException e) {
                  }
 finally {
                    try {
                      if (is != null) {
                        is.close();
                      }
                    }
 catch (                    IOException e) {
                    }
                    try {
                      if (os != null) {
                        os.close();
                      }
                    }
 catch (                    IOException e) {
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (entry == null) {
synchronized (notFoundResources) {
          notFoundResources.put(name,name);
        }
        return null;
      }
      if (binaryStream != null && (isCacheable || fileNeedConvert)) {
        byte[] binaryContent=new byte[contentLength];
        int pos=0;
        try {
          while (true) {
            int n=binaryStream.read(binaryContent,pos,binaryContent.length - pos);
            if (n <= 0)             break;
            pos+=n;
          }
        }
 catch (        IOException e) {
          log.error(sm.getString("webappClassLoader.readError",name),e);
          return null;
        }
        if (fileNeedConvert) {
          String str=new String(binaryContent,0,pos);
          try {
            binaryContent=str.getBytes(CHARSET_UTF8);
          }
 catch (          Exception e) {
            return null;
          }
        }
        entry.binaryContent=binaryContent;
        if (jarEntry != null) {
          entry.certificates=jarEntry.getCertificates();
        }
      }
    }
  finally {
      if (binaryStream != null) {
        try {
          binaryStream.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  if (isClassResource && entry.binaryContent != null && this.transformers.size() > 0) {
    String className=name.endsWith(CLASS_FILE_SUFFIX) ? name.substring(0,name.length() - CLASS_FILE_SUFFIX.length()) : name;
    String internalName=className.replace(".","/");
    for (    ClassFileTransformer transformer : this.transformers) {
      try {
        byte[] transformed=transformer.transform(this,internalName,null,null,entry.binaryContent);
        if (transformed != null) {
          entry.binaryContent=transformed;
        }
      }
 catch (      IllegalClassFormatException e) {
        log.error(sm.getString("webappClassLoader.transformError",name),e);
        return null;
      }
    }
  }
synchronized (resourceEntries) {
    ResourceEntry entry2=resourceEntries.get(path);
    if (entry2 == null) {
      resourceEntries.put(path,entry);
    }
 else {
      entry=entry2;
    }
  }
  return entry;
}

ID 2720=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#startInternal()
Rmethod: org.apache.catalina.loader.WebappLoader#createClassLoader()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Start associated  {@link ClassLoader} and implement the requirementsof  {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  if (log.isDebugEnabled())   log.debug(sm.getString("webappLoader.starting"));
  if (container.getResources() == null) {
    log.info("No resources for " + container);
    setState(LifecycleState.STARTING);
    return;
  }
  URLStreamHandlerFactory streamHandlerFactory=DirContextURLStreamHandlerFactory.getInstance();
  if (first) {
    first=false;
    try {
      URL.setURLStreamHandlerFactory(streamHandlerFactory);
    }
 catch (    Exception e) {
      log.error("Error registering jndi stream handler",e);
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.info("Dual registration of jndi stream handler: " + t.getMessage());
    }
  }
  try {
    classLoader=createClassLoader();
    classLoader.setResources(container.getResources());
    classLoader.setDelegate(this.delegate);
    classLoader.setSearchExternalFirst(searchExternalFirst);
    if (container instanceof StandardContext) {
      classLoader.setAntiJARLocking(((StandardContext)container).getAntiJARLocking());
      classLoader.setClearReferencesRmiTargets(((StandardContext)container).getClearReferencesRmiTargets());
      classLoader.setClearReferencesStatic(((StandardContext)container).getClearReferencesStatic());
      classLoader.setClearReferencesStopThreads(((StandardContext)container).getClearReferencesStopThreads());
      classLoader.setClearReferencesStopTimerThreads(((StandardContext)container).getClearReferencesStopTimerThreads());
      classLoader.setClearReferencesHttpClientKeepAliveThread(((StandardContext)container).getClearReferencesHttpClientKeepAliveThread());
    }
    for (int i=0; i < repositories.length; i++) {
      classLoader.addRepository(repositories[i]);
    }
    setRepositories();
    setClassPath();
    setPermissions();
    ((Lifecycle)classLoader).start();
    DirContextURLStreamHandler.bind(classLoader,this.container.getResources());
    StandardContext ctx=(StandardContext)container;
    String contextName=ctx.getName();
    if (!contextName.startsWith("/")) {
      contextName="/" + contextName;
    }
    ObjectName cloname=new ObjectName(MBeanUtils.getDomain(ctx) + ":type=WebappClassLoader,context=" + contextName+ ",host="+ ctx.getParent().getName());
    Registry.getRegistry(null,null).registerComponent(classLoader,cloname,null);
  }
 catch (  Throwable t) {
    t=ExceptionUtils.unwrapInvocationTargetException(t);
    ExceptionUtils.handleThrowable(t);
    log.error("LifecycleException ",t);
    throw new LifecycleException("start: ",t);
  }
  setState(LifecycleState.STARTING);
}

ID 2724=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#startInternal()
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Start associated  {@link ClassLoader} and implement the requirementsof  {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  if (log.isDebugEnabled())   log.debug(sm.getString("webappLoader.starting"));
  if (container.getResources() == null) {
    log.info("No resources for " + container);
    setState(LifecycleState.STARTING);
    return;
  }
  URLStreamHandlerFactory streamHandlerFactory=DirContextURLStreamHandlerFactory.getInstance();
  if (first) {
    first=false;
    try {
      URL.setURLStreamHandlerFactory(streamHandlerFactory);
    }
 catch (    Exception e) {
      log.error("Error registering jndi stream handler",e);
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.info("Dual registration of jndi stream handler: " + t.getMessage());
    }
  }
  try {
    classLoader=createClassLoader();
    classLoader.setResources(container.getResources());
    classLoader.setDelegate(this.delegate);
    classLoader.setSearchExternalFirst(searchExternalFirst);
    if (container instanceof StandardContext) {
      classLoader.setAntiJARLocking(((StandardContext)container).getAntiJARLocking());
      classLoader.setClearReferencesRmiTargets(((StandardContext)container).getClearReferencesRmiTargets());
      classLoader.setClearReferencesStatic(((StandardContext)container).getClearReferencesStatic());
      classLoader.setClearReferencesStopThreads(((StandardContext)container).getClearReferencesStopThreads());
      classLoader.setClearReferencesStopTimerThreads(((StandardContext)container).getClearReferencesStopTimerThreads());
      classLoader.setClearReferencesHttpClientKeepAliveThread(((StandardContext)container).getClearReferencesHttpClientKeepAliveThread());
    }
    for (int i=0; i < repositories.length; i++) {
      classLoader.addRepository(repositories[i]);
    }
    setRepositories();
    setClassPath();
    setPermissions();
    ((Lifecycle)classLoader).start();
    DirContextURLStreamHandler.bind(classLoader,this.container.getResources());
    StandardContext ctx=(StandardContext)container;
    String contextName=ctx.getName();
    if (!contextName.startsWith("/")) {
      contextName="/" + contextName;
    }
    ObjectName cloname=new ObjectName(MBeanUtils.getDomain(ctx) + ":type=WebappClassLoader,context=" + contextName+ ",host="+ ctx.getParent().getName());
    Registry.getRegistry(null,null).registerComponent(classLoader,cloname,null);
  }
 catch (  Throwable t) {
    t=ExceptionUtils.unwrapInvocationTargetException(t);
    ExceptionUtils.handleThrowable(t);
    log.error("LifecycleException ",t);
    throw new LifecycleException("start: ",t);
  }
  setState(LifecycleState.STARTING);
}

ID 2738=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#setRepositories()
Rmethod: javax.naming.Context#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Configure the repositories for our class loader, based on the associated Context.
 * @throws IOException
 */
private void setRepositories() throws IOException {
  if (!(container instanceof Context))   return;
  ServletContext servletContext=((Context)container).getServletContext();
  if (servletContext == null)   return;
  loaderRepositories=new ArrayList<String>();
  File workDir=(File)servletContext.getAttribute(ServletContext.TEMPDIR);
  if (workDir == null) {
    log.info("No work dir for " + servletContext);
  }
  if (log.isDebugEnabled() && workDir != null)   log.debug(sm.getString("webappLoader.deploy",workDir.getAbsolutePath()));
  classLoader.setWorkDir(workDir);
  DirContext resources=container.getResources();
  String classesPath="/WEB-INF/classes";
  DirContext classes=null;
  try {
    Object object=resources.lookup(classesPath);
    if (object instanceof DirContext) {
      classes=(DirContext)object;
    }
  }
 catch (  NamingException e) {
  }
  if (classes != null) {
    File classRepository=null;
    String absoluteClassesPath=servletContext.getRealPath(classesPath);
    if (absoluteClassesPath != null) {
      classRepository=new File(absoluteClassesPath);
    }
 else {
      classRepository=new File(workDir,classesPath);
      if (!classRepository.mkdirs() && !classRepository.isDirectory()) {
        throw new IOException(sm.getString("webappLoader.mkdirFailure"));
      }
      if (!copyDir(classes,classRepository)) {
        throw new IOException(sm.getString("webappLoader.copyFailure"));
      }
    }
    if (log.isDebugEnabled())     log.debug(sm.getString("webappLoader.classDeploy",classesPath,classRepository.getAbsolutePath()));
    classLoader.addRepository(classesPath + "/",classRepository);
    loaderRepositories.add(classesPath + "/");
  }
  String libPath="/WEB-INF/lib";
  classLoader.setJarPath(libPath);
  DirContext libDir=null;
  try {
    Object object=resources.lookup(libPath);
    if (object instanceof DirContext)     libDir=(DirContext)object;
  }
 catch (  NamingException e) {
  }
  if (libDir != null) {
    boolean copyJars=false;
    String absoluteLibPath=servletContext.getRealPath(libPath);
    File destDir=null;
    if (absoluteLibPath != null) {
      destDir=new File(absoluteLibPath);
    }
 else {
      copyJars=true;
      destDir=new File(workDir,libPath);
      if (!destDir.mkdirs() && !destDir.isDirectory()) {
        throw new IOException(sm.getString("webappLoader.mkdirFailure"));
      }
    }
    NamingEnumeration<NameClassPair> enumeration=null;
    try {
      enumeration=libDir.list("");
    }
 catch (    NamingException e) {
      IOException ioe=new IOException(sm.getString("webappLoader.namingFailure",libPath));
      ioe.initCause(e);
      throw ioe;
    }
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String filename=libPath + "/" + ncPair.getName();
      if (!filename.endsWith(".jar"))       continue;
      File destFile=new File(destDir,ncPair.getName());
      if (log.isDebugEnabled())       log.debug(sm.getString("webappLoader.jarDeploy",filename,destFile.getAbsolutePath()));
      Object obj=null;
      try {
        obj=libDir.lookup(ncPair.getName());
      }
 catch (      NamingException e) {
        IOException ioe=new IOException(sm.getString("webappLoader.namingFailure",filename));
        ioe.initCause(e);
        throw ioe;
      }
      if (!(obj instanceof Resource))       continue;
      Resource jarResource=(Resource)obj;
      if (copyJars) {
        if (!copy(jarResource.streamContent(),new FileOutputStream(destFile))) {
          throw new IOException(sm.getString("webappLoader.copyFailure"));
        }
      }
      try {
        JarFile jarFile=new JarFile(destFile);
        classLoader.addJar(filename,jarFile,destFile);
      }
 catch (      Exception ex) {
      }
      loaderRepositories.add(filename);
    }
  }
}

ID 2739=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#setRepositories()
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Configure the repositories for our class loader, based on the associated Context.
 * @throws IOException
 */
private void setRepositories() throws IOException {
  if (!(container instanceof Context))   return;
  ServletContext servletContext=((Context)container).getServletContext();
  if (servletContext == null)   return;
  loaderRepositories=new ArrayList<String>();
  File workDir=(File)servletContext.getAttribute(ServletContext.TEMPDIR);
  if (workDir == null) {
    log.info("No work dir for " + servletContext);
  }
  if (log.isDebugEnabled() && workDir != null)   log.debug(sm.getString("webappLoader.deploy",workDir.getAbsolutePath()));
  classLoader.setWorkDir(workDir);
  DirContext resources=container.getResources();
  String classesPath="/WEB-INF/classes";
  DirContext classes=null;
  try {
    Object object=resources.lookup(classesPath);
    if (object instanceof DirContext) {
      classes=(DirContext)object;
    }
  }
 catch (  NamingException e) {
  }
  if (classes != null) {
    File classRepository=null;
    String absoluteClassesPath=servletContext.getRealPath(classesPath);
    if (absoluteClassesPath != null) {
      classRepository=new File(absoluteClassesPath);
    }
 else {
      classRepository=new File(workDir,classesPath);
      if (!classRepository.mkdirs() && !classRepository.isDirectory()) {
        throw new IOException(sm.getString("webappLoader.mkdirFailure"));
      }
      if (!copyDir(classes,classRepository)) {
        throw new IOException(sm.getString("webappLoader.copyFailure"));
      }
    }
    if (log.isDebugEnabled())     log.debug(sm.getString("webappLoader.classDeploy",classesPath,classRepository.getAbsolutePath()));
    classLoader.addRepository(classesPath + "/",classRepository);
    loaderRepositories.add(classesPath + "/");
  }
  String libPath="/WEB-INF/lib";
  classLoader.setJarPath(libPath);
  DirContext libDir=null;
  try {
    Object object=resources.lookup(libPath);
    if (object instanceof DirContext)     libDir=(DirContext)object;
  }
 catch (  NamingException e) {
  }
  if (libDir != null) {
    boolean copyJars=false;
    String absoluteLibPath=servletContext.getRealPath(libPath);
    File destDir=null;
    if (absoluteLibPath != null) {
      destDir=new File(absoluteLibPath);
    }
 else {
      copyJars=true;
      destDir=new File(workDir,libPath);
      if (!destDir.mkdirs() && !destDir.isDirectory()) {
        throw new IOException(sm.getString("webappLoader.mkdirFailure"));
      }
    }
    NamingEnumeration<NameClassPair> enumeration=null;
    try {
      enumeration=libDir.list("");
    }
 catch (    NamingException e) {
      IOException ioe=new IOException(sm.getString("webappLoader.namingFailure",libPath));
      ioe.initCause(e);
      throw ioe;
    }
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String filename=libPath + "/" + ncPair.getName();
      if (!filename.endsWith(".jar"))       continue;
      File destFile=new File(destDir,ncPair.getName());
      if (log.isDebugEnabled())       log.debug(sm.getString("webappLoader.jarDeploy",filename,destFile.getAbsolutePath()));
      Object obj=null;
      try {
        obj=libDir.lookup(ncPair.getName());
      }
 catch (      NamingException e) {
        IOException ioe=new IOException(sm.getString("webappLoader.namingFailure",filename));
        ioe.initCause(e);
        throw ioe;
      }
      if (!(obj instanceof Resource))       continue;
      Resource jarResource=(Resource)obj;
      if (copyJars) {
        if (!copy(jarResource.streamContent(),new FileOutputStream(destFile))) {
          throw new IOException(sm.getString("webappLoader.copyFailure"));
        }
      }
      try {
        JarFile jarFile=new JarFile(destFile);
        classLoader.addJar(filename,jarFile,destFile);
      }
 catch (      Exception ex) {
      }
      loaderRepositories.add(filename);
    }
  }
}

ID 2750=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copyDir(javax.naming.directory.DirContext, java.io.File)
Rmethod: javax.naming.Context#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Copy directory.
 */
private boolean copyDir(DirContext srcDir,File destDir){
  try {
    NamingEnumeration<NameClassPair> enumeration=srcDir.list("");
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String name=ncPair.getName();
      Object object=srcDir.lookup(name);
      File currentFile=new File(destDir,name);
      if (object instanceof Resource) {
        InputStream is=((Resource)object).streamContent();
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy(is,os))         return false;
      }
 else       if (object instanceof InputStream) {
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy((InputStream)object,os))         return false;
      }
 else       if (object instanceof DirContext) {
        if (!currentFile.isDirectory() && !currentFile.mkdir())         return false;
        if (!copyDir((DirContext)object,currentFile))         return false;
      }
    }
  }
 catch (  NamingException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2751=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copyDir(javax.naming.directory.DirContext, java.io.File)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Copy directory.
 */
private boolean copyDir(DirContext srcDir,File destDir){
  try {
    NamingEnumeration<NameClassPair> enumeration=srcDir.list("");
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String name=ncPair.getName();
      Object object=srcDir.lookup(name);
      File currentFile=new File(destDir,name);
      if (object instanceof Resource) {
        InputStream is=((Resource)object).streamContent();
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy(is,os))         return false;
      }
 else       if (object instanceof InputStream) {
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy((InputStream)object,os))         return false;
      }
 else       if (object instanceof DirContext) {
        if (!currentFile.isDirectory() && !currentFile.mkdir())         return false;
        if (!copyDir((DirContext)object,currentFile))         return false;
      }
    }
  }
 catch (  NamingException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2752=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copyDir(javax.naming.directory.DirContext, java.io.File)
Rmethod: org.apache.naming.resources.Resource#streamContent()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy directory.
 */
private boolean copyDir(DirContext srcDir,File destDir){
  try {
    NamingEnumeration<NameClassPair> enumeration=srcDir.list("");
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String name=ncPair.getName();
      Object object=srcDir.lookup(name);
      File currentFile=new File(destDir,name);
      if (object instanceof Resource) {
        InputStream is=((Resource)object).streamContent();
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy(is,os))         return false;
      }
 else       if (object instanceof InputStream) {
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy((InputStream)object,os))         return false;
      }
 else       if (object instanceof DirContext) {
        if (!currentFile.isDirectory() && !currentFile.mkdir())         return false;
        if (!copyDir((DirContext)object,currentFile))         return false;
      }
    }
  }
 catch (  NamingException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2753=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copyDir(javax.naming.directory.DirContext, java.io.File)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Copy directory.
 */
private boolean copyDir(DirContext srcDir,File destDir){
  try {
    NamingEnumeration<NameClassPair> enumeration=srcDir.list("");
    while (enumeration.hasMoreElements()) {
      NameClassPair ncPair=enumeration.nextElement();
      String name=ncPair.getName();
      Object object=srcDir.lookup(name);
      File currentFile=new File(destDir,name);
      if (object instanceof Resource) {
        InputStream is=((Resource)object).streamContent();
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy(is,os))         return false;
      }
 else       if (object instanceof InputStream) {
        OutputStream os=new FileOutputStream(currentFile);
        if (!copy((InputStream)object,os))         return false;
      }
 else       if (object instanceof DirContext) {
        if (!currentFile.isDirectory() && !currentFile.mkdir())         return false;
        if (!copyDir((DirContext)object,currentFile))         return false;
      }
    }
  }
 catch (  NamingException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2754=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copy(java.io.InputStream, java.io.OutputStream)
Rmethod: java.io.InputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory. This is required only because Jasper depends on it.
 */
private boolean copy(InputStream is,OutputStream os){
  try {
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
    is.close();
    os.close();
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2755=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copy(java.io.InputStream, java.io.OutputStream)
Rmethod: java.io.OutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory. This is required only because Jasper depends on it.
 */
private boolean copy(InputStream is,OutputStream os){
  try {
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
    is.close();
    os.close();
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2756=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copy(java.io.InputStream, java.io.OutputStream)
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory. This is required only because Jasper depends on it.
 */
private boolean copy(InputStream is,OutputStream os){
  try {
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
    is.close();
    os.close();
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2757=========================================================================type: 1
Method:org.apache.catalina.loader.WebappLoader#copy(java.io.InputStream, java.io.OutputStream)
Rmethod: java.io.OutputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory. This is required only because Jasper depends on it.
 */
private boolean copy(InputStream is,OutputStream os){
  try {
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
    is.close();
    os.close();
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}

ID 2759=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#messageReceived(org.apache.catalina.ha.ClusterMessage)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#getFactory(org.apache.catalina.ha.deploy.FileMessage)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Callback from the cluster, when a message is received, The cluster will broadcast it invoking the messageReceived on the receiver.
 * @param msg ClusterMessage - the message received from the cluster
 */
@Override public void messageReceived(ClusterMessage msg){
  try {
    if (msg instanceof FileMessage) {
      FileMessage fmsg=(FileMessage)msg;
      if (log.isDebugEnabled())       log.debug(sm.getString("farmWarDeployer.msgRxDeploy",fmsg.getContextName(),fmsg.getFileName()));
      FileMessageFactory factory=getFactory(fmsg);
      if (factory.writeMessage(fmsg)) {
        String name=factory.getFile().getName();
        if (!name.endsWith(".war"))         name=name + ".war";
        File deployable=new File(getDeployDirFile(),name);
        try {
          String contextName=fmsg.getContextName();
          if (!isServiced(contextName)) {
            addServiced(contextName);
            try {
              remove(contextName);
              if (!factory.getFile().renameTo(deployable)) {
                log.error(sm.getString("farmWarDeployer.renameFail",factory.getFile(),deployable));
              }
              check(contextName);
            }
  finally {
              removeServiced(contextName);
            }
            if (log.isDebugEnabled())             log.debug(sm.getString("farmWarDeployer.deployEnd",contextName));
          }
 else           log.error(sm.getString("farmWarDeployer.servicingDeploy",contextName,name));
        }
 catch (        Exception ex) {
          log.error(ex);
        }
 finally {
          removeFactory(fmsg);
        }
      }
    }
 else     if (msg instanceof UndeployMessage) {
      try {
        UndeployMessage umsg=(UndeployMessage)msg;
        String contextName=umsg.getContextName();
        if (log.isDebugEnabled())         log.debug(sm.getString("farmWarDeployer.msgRxUndeploy",contextName));
        if (!isServiced(contextName)) {
          addServiced(contextName);
          try {
            remove(contextName);
          }
  finally {
            removeServiced(contextName);
          }
          if (log.isDebugEnabled())           log.debug(sm.getString("farmWarDeployer.undeployEnd",contextName));
        }
 else         log.error(sm.getString("farmWarDeployer.servicingUneploy",contextName));
      }
 catch (      Exception ex) {
        log.error(ex);
      }
    }
  }
 catch (  java.io.IOException x) {
    log.error(sm.getString("farmWarDeployer.msgIoe"),x);
  }
}

ID 2760=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#messageReceived(org.apache.catalina.ha.ClusterMessage)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#getFactory(org.apache.catalina.ha.deploy.FileMessage)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Callback from the cluster, when a message is received, The cluster will broadcast it invoking the messageReceived on the receiver.
 * @param msg ClusterMessage - the message received from the cluster
 */
@Override public void messageReceived(ClusterMessage msg){
  try {
    if (msg instanceof FileMessage) {
      FileMessage fmsg=(FileMessage)msg;
      if (log.isDebugEnabled())       log.debug(sm.getString("farmWarDeployer.msgRxDeploy",fmsg.getContextName(),fmsg.getFileName()));
      FileMessageFactory factory=getFactory(fmsg);
      if (factory.writeMessage(fmsg)) {
        String name=factory.getFile().getName();
        if (!name.endsWith(".war"))         name=name + ".war";
        File deployable=new File(getDeployDirFile(),name);
        try {
          String contextName=fmsg.getContextName();
          if (!isServiced(contextName)) {
            addServiced(contextName);
            try {
              remove(contextName);
              if (!factory.getFile().renameTo(deployable)) {
                log.error(sm.getString("farmWarDeployer.renameFail",factory.getFile(),deployable));
              }
              check(contextName);
            }
  finally {
              removeServiced(contextName);
            }
            if (log.isDebugEnabled())             log.debug(sm.getString("farmWarDeployer.deployEnd",contextName));
          }
 else           log.error(sm.getString("farmWarDeployer.servicingDeploy",contextName,name));
        }
 catch (        Exception ex) {
          log.error(ex);
        }
 finally {
          removeFactory(fmsg);
        }
      }
    }
 else     if (msg instanceof UndeployMessage) {
      try {
        UndeployMessage umsg=(UndeployMessage)msg;
        String contextName=umsg.getContextName();
        if (log.isDebugEnabled())         log.debug(sm.getString("farmWarDeployer.msgRxUndeploy",contextName));
        if (!isServiced(contextName)) {
          addServiced(contextName);
          try {
            remove(contextName);
          }
  finally {
            removeServiced(contextName);
          }
          if (log.isDebugEnabled())           log.debug(sm.getString("farmWarDeployer.undeployEnd",contextName));
        }
 else         log.error(sm.getString("farmWarDeployer.servicingUneploy",contextName));
      }
 catch (      Exception ex) {
        log.error(ex);
      }
    }
  }
 catch (  java.io.IOException x) {
    log.error(sm.getString("farmWarDeployer.msgIoe"),x);
  }
}

ID 2762=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#messageReceived(org.apache.catalina.ha.ClusterMessage)
Rmethod: org.apache.catalina.ha.deploy.FileMessageFactory#writeMessage(org.apache.catalina.ha.deploy.FileMessage)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Callback from the cluster, when a message is received, The cluster will broadcast it invoking the messageReceived on the receiver.
 * @param msg ClusterMessage - the message received from the cluster
 */
@Override public void messageReceived(ClusterMessage msg){
  try {
    if (msg instanceof FileMessage) {
      FileMessage fmsg=(FileMessage)msg;
      if (log.isDebugEnabled())       log.debug(sm.getString("farmWarDeployer.msgRxDeploy",fmsg.getContextName(),fmsg.getFileName()));
      FileMessageFactory factory=getFactory(fmsg);
      if (factory.writeMessage(fmsg)) {
        String name=factory.getFile().getName();
        if (!name.endsWith(".war"))         name=name + ".war";
        File deployable=new File(getDeployDirFile(),name);
        try {
          String contextName=fmsg.getContextName();
          if (!isServiced(contextName)) {
            addServiced(contextName);
            try {
              remove(contextName);
              if (!factory.getFile().renameTo(deployable)) {
                log.error(sm.getString("farmWarDeployer.renameFail",factory.getFile(),deployable));
              }
              check(contextName);
            }
  finally {
              removeServiced(contextName);
            }
            if (log.isDebugEnabled())             log.debug(sm.getString("farmWarDeployer.deployEnd",contextName));
          }
 else           log.error(sm.getString("farmWarDeployer.servicingDeploy",contextName,name));
        }
 catch (        Exception ex) {
          log.error(ex);
        }
 finally {
          removeFactory(fmsg);
        }
      }
    }
 else     if (msg instanceof UndeployMessage) {
      try {
        UndeployMessage umsg=(UndeployMessage)msg;
        String contextName=umsg.getContextName();
        if (log.isDebugEnabled())         log.debug(sm.getString("farmWarDeployer.msgRxUndeploy",contextName));
        if (!isServiced(contextName)) {
          addServiced(contextName);
          try {
            remove(contextName);
          }
  finally {
            removeServiced(contextName);
          }
          if (log.isDebugEnabled())           log.debug(sm.getString("farmWarDeployer.undeployEnd",contextName));
        }
 else         log.error(sm.getString("farmWarDeployer.servicingUneploy",contextName));
      }
 catch (      Exception ex) {
        log.error(ex);
      }
    }
  }
 catch (  java.io.IOException x) {
    log.error(sm.getString("farmWarDeployer.msgIoe"),x);
  }
}

ID 2763=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#messageReceived(org.apache.catalina.ha.ClusterMessage)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Callback from the cluster, when a message is received, The cluster will broadcast it invoking the messageReceived on the receiver.
 * @param msg ClusterMessage - the message received from the cluster
 */
@Override public void messageReceived(ClusterMessage msg){
  try {
    if (msg instanceof FileMessage) {
      FileMessage fmsg=(FileMessage)msg;
      if (log.isDebugEnabled())       log.debug(sm.getString("farmWarDeployer.msgRxDeploy",fmsg.getContextName(),fmsg.getFileName()));
      FileMessageFactory factory=getFactory(fmsg);
      if (factory.writeMessage(fmsg)) {
        String name=factory.getFile().getName();
        if (!name.endsWith(".war"))         name=name + ".war";
        File deployable=new File(getDeployDirFile(),name);
        try {
          String contextName=fmsg.getContextName();
          if (!isServiced(contextName)) {
            addServiced(contextName);
            try {
              remove(contextName);
              if (!factory.getFile().renameTo(deployable)) {
                log.error(sm.getString("farmWarDeployer.renameFail",factory.getFile(),deployable));
              }
              check(contextName);
            }
  finally {
              removeServiced(contextName);
            }
            if (log.isDebugEnabled())             log.debug(sm.getString("farmWarDeployer.deployEnd",contextName));
          }
 else           log.error(sm.getString("farmWarDeployer.servicingDeploy",contextName,name));
        }
 catch (        Exception ex) {
          log.error(ex);
        }
 finally {
          removeFactory(fmsg);
        }
      }
    }
 else     if (msg instanceof UndeployMessage) {
      try {
        UndeployMessage umsg=(UndeployMessage)msg;
        String contextName=umsg.getContextName();
        if (log.isDebugEnabled())         log.debug(sm.getString("farmWarDeployer.msgRxUndeploy",contextName));
        if (!isServiced(contextName)) {
          addServiced(contextName);
          try {
            remove(contextName);
          }
  finally {
            removeServiced(contextName);
          }
          if (log.isDebugEnabled())           log.debug(sm.getString("farmWarDeployer.undeployEnd",contextName));
        }
 else         log.error(sm.getString("farmWarDeployer.servicingUneploy",contextName));
      }
 catch (      Exception ex) {
        log.error(ex);
      }
    }
  }
 catch (  java.io.IOException x) {
    log.error(sm.getString("farmWarDeployer.msgIoe"),x);
  }
}

ID 2764=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#messageReceived(org.apache.catalina.ha.ClusterMessage)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Callback from the cluster, when a message is received, The cluster will broadcast it invoking the messageReceived on the receiver.
 * @param msg ClusterMessage - the message received from the cluster
 */
@Override public void messageReceived(ClusterMessage msg){
  try {
    if (msg instanceof FileMessage) {
      FileMessage fmsg=(FileMessage)msg;
      if (log.isDebugEnabled())       log.debug(sm.getString("farmWarDeployer.msgRxDeploy",fmsg.getContextName(),fmsg.getFileName()));
      FileMessageFactory factory=getFactory(fmsg);
      if (factory.writeMessage(fmsg)) {
        String name=factory.getFile().getName();
        if (!name.endsWith(".war"))         name=name + ".war";
        File deployable=new File(getDeployDirFile(),name);
        try {
          String contextName=fmsg.getContextName();
          if (!isServiced(contextName)) {
            addServiced(contextName);
            try {
              remove(contextName);
              if (!factory.getFile().renameTo(deployable)) {
                log.error(sm.getString("farmWarDeployer.renameFail",factory.getFile(),deployable));
              }
              check(contextName);
            }
  finally {
              removeServiced(contextName);
            }
            if (log.isDebugEnabled())             log.debug(sm.getString("farmWarDeployer.deployEnd",contextName));
          }
 else           log.error(sm.getString("farmWarDeployer.servicingDeploy",contextName,name));
        }
 catch (        Exception ex) {
          log.error(ex);
        }
 finally {
          removeFactory(fmsg);
        }
      }
    }
 else     if (msg instanceof UndeployMessage) {
      try {
        UndeployMessage umsg=(UndeployMessage)msg;
        String contextName=umsg.getContextName();
        if (log.isDebugEnabled())         log.debug(sm.getString("farmWarDeployer.msgRxUndeploy",contextName));
        if (!isServiced(contextName)) {
          addServiced(contextName);
          try {
            remove(contextName);
          }
  finally {
            removeServiced(contextName);
          }
          if (log.isDebugEnabled())           log.debug(sm.getString("farmWarDeployer.undeployEnd",contextName));
        }
 else         log.error(sm.getString("farmWarDeployer.servicingUneploy",contextName));
      }
 catch (      Exception ex) {
        log.error(ex);
      }
    }
  }
 catch (  java.io.IOException x) {
    log.error(sm.getString("farmWarDeployer.msgIoe"),x);
  }
}

ID 2776=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#remove(java.lang.String, boolean)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove an existing web application, attached to the specified context name. If this application is successfully removed, a ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to all registered listeners, with the removed <code>Context</code> as an argument. Deletes the web application war file and/or directory if they exist in the Host's appBase.
 * @param contextName The context name of the application to be removed
 * @param undeploy boolean flag to remove web application from server
 * @exception IllegalArgumentException if the specified context name is malformed
 * @exception IllegalArgumentException if the specified context name does not identify a currently installed web application
 * @exception IOException if an input/output error occurs during removal
 */
@Override public void remove(String contextName,boolean undeploy) throws IOException {
  if (getCluster().getMembers().length > 0) {
    if (log.isInfoEnabled())     log.info(sm.getString("farmWarDeployer.removeStart",contextName));
    Member localMember=getCluster().getLocalMember();
    UndeployMessage msg=new UndeployMessage(localMember,System.currentTimeMillis(),"Undeploy:" + contextName + ":"+ System.currentTimeMillis(),contextName,undeploy);
    if (log.isDebugEnabled())     log.debug(sm.getString("farmWarDeployer.removeTxMsg",contextName));
    cluster.send(msg);
  }
  if (undeploy) {
    try {
      if (!isServiced(contextName)) {
        addServiced(contextName);
        try {
          remove(contextName);
        }
  finally {
          removeServiced(contextName);
        }
      }
 else       log.error(sm.getString("farmWarDeployer.removeFailRemote",contextName));
    }
 catch (    Exception ex) {
      log.error(sm.getString("farmWarDeployer.removeFailLocal",contextName),ex);
    }
  }
}

ID 2777=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#remove(java.lang.String, boolean)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Remove an existing web application, attached to the specified context name. If this application is successfully removed, a ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to all registered listeners, with the removed <code>Context</code> as an argument. Deletes the web application war file and/or directory if they exist in the Host's appBase.
 * @param contextName The context name of the application to be removed
 * @param undeploy boolean flag to remove web application from server
 * @exception IllegalArgumentException if the specified context name is malformed
 * @exception IllegalArgumentException if the specified context name does not identify a currently installed web application
 * @exception IOException if an input/output error occurs during removal
 */
@Override public void remove(String contextName,boolean undeploy) throws IOException {
  if (getCluster().getMembers().length > 0) {
    if (log.isInfoEnabled())     log.info(sm.getString("farmWarDeployer.removeStart",contextName));
    Member localMember=getCluster().getLocalMember();
    UndeployMessage msg=new UndeployMessage(localMember,System.currentTimeMillis(),"Undeploy:" + contextName + ":"+ System.currentTimeMillis(),contextName,undeploy);
    if (log.isDebugEnabled())     log.debug(sm.getString("farmWarDeployer.removeTxMsg",contextName));
    cluster.send(msg);
  }
  if (undeploy) {
    try {
      if (!isServiced(contextName)) {
        addServiced(contextName);
        try {
          remove(contextName);
        }
  finally {
          removeServiced(contextName);
        }
      }
 else       log.error(sm.getString("farmWarDeployer.removeFailRemote",contextName));
    }
 catch (    Exception ex) {
      log.error(sm.getString("farmWarDeployer.removeFailLocal",contextName),ex);
    }
  }
}

ID 2780=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#fileModified(java.io.File)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#isServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void fileModified(File newWar){
  try {
    File deployWar=new File(getDeployDirFile(),newWar.getName());
    ContextName cn=new ContextName(deployWar.getName(),true);
    if (deployWar.exists() && deployWar.lastModified() > newWar.lastModified()) {
      if (log.isInfoEnabled())       log.info(sm.getString("farmWarDeployer.alreadyDeployed",cn.getName()));
      return;
    }
    if (log.isInfoEnabled())     log.info(sm.getString("farmWarDeployer.modInstall",cn.getName(),deployWar.getAbsolutePath()));
    if (!isServiced(cn.getName())) {
      addServiced(cn.getName());
      try {
        copy(newWar,deployWar);
        check(cn.getName());
      }
  finally {
        removeServiced(cn.getName());
      }
    }
 else {
      log.error(sm.getString("farmWarDeployer.servicingDeploy",cn.getName(),deployWar.getName()));
    }
    install(cn.getName(),deployWar);
  }
 catch (  Exception x) {
    log.error(sm.getString("farmWarDeployer.modInstallFail"),x);
  }
}

ID 2781=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#fileModified(java.io.File)
Rmethod: org.apache.catalina.ha.deploy.FarmWarDeployer#addServiced(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void fileModified(File newWar){
  try {
    File deployWar=new File(getDeployDirFile(),newWar.getName());
    ContextName cn=new ContextName(deployWar.getName(),true);
    if (deployWar.exists() && deployWar.lastModified() > newWar.lastModified()) {
      if (log.isInfoEnabled())       log.info(sm.getString("farmWarDeployer.alreadyDeployed",cn.getName()));
      return;
    }
    if (log.isInfoEnabled())     log.info(sm.getString("farmWarDeployer.modInstall",cn.getName(),deployWar.getAbsolutePath()));
    if (!isServiced(cn.getName())) {
      addServiced(cn.getName());
      try {
        copy(newWar,deployWar);
        check(cn.getName());
      }
  finally {
        removeServiced(cn.getName());
      }
    }
 else {
      log.error(sm.getString("farmWarDeployer.servicingDeploy",cn.getName(),deployWar.getName()));
    }
    install(cn.getName(),deployWar);
  }
 catch (  Exception x) {
    log.error(sm.getString("farmWarDeployer.modInstallFail"),x);
  }
}

ID 2786=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#getAppBase()
Rmethod: java.io.File#getCanonicalFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Return a File object representing the "application root" directory for our associated Host.
 */
protected File getAppBase(){
  if (appBase != null) {
    return appBase;
  }
  File file=new File(host.getAppBase());
  if (!file.isAbsolute())   file=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  try {
    appBase=file.getCanonicalFile();
  }
 catch (  IOException e) {
    appBase=file;
  }
  return (appBase);
}

ID 2798=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#copy(java.io.File, java.io.File)
Rmethod: java.io.File#createNewFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory.
 * @param from copy from temp
 * @param to   to host appBase directory
 * @return true, copy successful
 */
protected boolean copy(File from,File to){
  java.io.FileInputStream is=null;
  java.io.FileOutputStream os=null;
  try {
    if (!to.exists()) {
      if (!to.createNewFile()) {
        log.error(sm.getString("fileNewFail",to));
        return false;
      }
    }
    is=new java.io.FileInputStream(from);
    os=new java.io.FileOutputStream(to,false);
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("farmWarDeployer.fileCopyFail",from,to),e);
    return false;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","InputStream",from),e);
      }
    }
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","OutputStream",to),e);
      }
    }
  }
  return true;
}

ID 2799=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#copy(java.io.File, java.io.File)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory.
 * @param from copy from temp
 * @param to   to host appBase directory
 * @return true, copy successful
 */
protected boolean copy(File from,File to){
  java.io.FileInputStream is=null;
  java.io.FileOutputStream os=null;
  try {
    if (!to.exists()) {
      if (!to.createNewFile()) {
        log.error(sm.getString("fileNewFail",to));
        return false;
      }
    }
    is=new java.io.FileInputStream(from);
    os=new java.io.FileOutputStream(to,false);
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("farmWarDeployer.fileCopyFail",from,to),e);
    return false;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","InputStream",from),e);
      }
    }
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","OutputStream",to),e);
      }
    }
  }
  return true;
}

ID 2800=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#copy(java.io.File, java.io.File)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File, boolean)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory.
 * @param from copy from temp
 * @param to   to host appBase directory
 * @return true, copy successful
 */
protected boolean copy(File from,File to){
  java.io.FileInputStream is=null;
  java.io.FileOutputStream os=null;
  try {
    if (!to.exists()) {
      if (!to.createNewFile()) {
        log.error(sm.getString("fileNewFail",to));
        return false;
      }
    }
    is=new java.io.FileInputStream(from);
    os=new java.io.FileOutputStream(to,false);
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("farmWarDeployer.fileCopyFail",from,to),e);
    return false;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","InputStream",from),e);
      }
    }
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","OutputStream",to),e);
      }
    }
  }
  return true;
}

ID 2801=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#copy(java.io.File, java.io.File)
Rmethod: java.io.FileInputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory.
 * @param from copy from temp
 * @param to   to host appBase directory
 * @return true, copy successful
 */
protected boolean copy(File from,File to){
  java.io.FileInputStream is=null;
  java.io.FileOutputStream os=null;
  try {
    if (!to.exists()) {
      if (!to.createNewFile()) {
        log.error(sm.getString("fileNewFail",to));
        return false;
      }
    }
    is=new java.io.FileInputStream(from);
    os=new java.io.FileOutputStream(to,false);
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("farmWarDeployer.fileCopyFail",from,to),e);
    return false;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","InputStream",from),e);
      }
    }
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","OutputStream",to),e);
      }
    }
  }
  return true;
}

ID 2802=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#copy(java.io.File, java.io.File)
Rmethod: java.io.FileOutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory.
 * @param from copy from temp
 * @param to   to host appBase directory
 * @return true, copy successful
 */
protected boolean copy(File from,File to){
  java.io.FileInputStream is=null;
  java.io.FileOutputStream os=null;
  try {
    if (!to.exists()) {
      if (!to.createNewFile()) {
        log.error(sm.getString("fileNewFail",to));
        return false;
      }
    }
    is=new java.io.FileInputStream(from);
    os=new java.io.FileOutputStream(to,false);
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("farmWarDeployer.fileCopyFail",from,to),e);
    return false;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","InputStream",from),e);
      }
    }
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","OutputStream",to),e);
      }
    }
  }
  return true;
}

ID 2803=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#copy(java.io.File, java.io.File)
Rmethod: java.io.FileInputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory.
 * @param from copy from temp
 * @param to   to host appBase directory
 * @return true, copy successful
 */
protected boolean copy(File from,File to){
  java.io.FileInputStream is=null;
  java.io.FileOutputStream os=null;
  try {
    if (!to.exists()) {
      if (!to.createNewFile()) {
        log.error(sm.getString("fileNewFail",to));
        return false;
      }
    }
    is=new java.io.FileInputStream(from);
    os=new java.io.FileOutputStream(to,false);
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("farmWarDeployer.fileCopyFail",from,to),e);
    return false;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","InputStream",from),e);
      }
    }
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","OutputStream",to),e);
      }
    }
  }
  return true;
}

ID 2804=========================================================================type: 1
Method:org.apache.catalina.ha.deploy.FarmWarDeployer#copy(java.io.File, java.io.File)
Rmethod: java.io.FileOutputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy a file to the specified temp directory.
 * @param from copy from temp
 * @param to   to host appBase directory
 * @return true, copy successful
 */
protected boolean copy(File from,File to){
  java.io.FileInputStream is=null;
  java.io.FileOutputStream os=null;
  try {
    if (!to.exists()) {
      if (!to.createNewFile()) {
        log.error(sm.getString("fileNewFail",to));
        return false;
      }
    }
    is=new java.io.FileInputStream(from);
    os=new java.io.FileOutputStream(to,false);
    byte[] buf=new byte[4096];
    while (true) {
      int len=is.read(buf);
      if (len < 0)       break;
      os.write(buf,0,len);
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("farmWarDeployer.fileCopyFail",from,to),e);
    return false;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","InputStream",from),e);
      }
    }
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.debug(sm.getString("farmWarDeployer.streamCannotBeClosed","OutputStream",to),e);
      }
    }
  }
  return true;
}

ID 2826=========================================================================type: 1
Method:org.apache.catalina.ha.jmx.ClusterJmxHelper#initMetaData(Class<?>)
Rmethod: org.apache.tomcat.util.modeler.Registry#loadMetadata(java.lang.Object)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
protected static boolean initMetaData(Class<?> clazz){
  try {
    if (clazz == null)     return false;
    getRegistry().loadMetadata(clazz.getResourceAsStream("mbeans-descriptors.xml"));
  }
 catch (  Exception x) {
    log.warn("Unable to load meta data for class:" + clazz.getName());
    return false;
  }
  return true;
}

ID 2830=========================================================================type: 1
Method:org.apache.catalina.ha.jmx.ClusterJmxHelper#registerDefaultCluster(org.apache.catalina.ha.tcp.SimpleTcpCluster)
Rmethod: org.apache.catalina.ha.jmx.ClusterJmxHelper#getDefaultClusterName(org.apache.catalina.ha.tcp.SimpleTcpCluster)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
public static boolean registerDefaultCluster(SimpleTcpCluster cluster){
  try {
    initDefaultCluster();
    ObjectName clusterName=getDefaultClusterName(cluster);
    if (!getMBeanServer().isRegistered(clusterName)) {
      getMBeanServer().registerMBean(getManagedBean(cluster),clusterName);
    }
    return true;
  }
 catch (  Exception x) {
    log.warn("Unable to register default cluster implementation with JMX",x);
    return false;
  }
}

ID 2831=========================================================================type: 1
Method:org.apache.catalina.ha.jmx.ClusterJmxHelper#registerDefaultCluster(org.apache.catalina.ha.tcp.SimpleTcpCluster)
Rmethod: org.apache.catalina.ha.jmx.ClusterJmxHelper#getMBeanServer()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
public static boolean registerDefaultCluster(SimpleTcpCluster cluster){
  try {
    initDefaultCluster();
    ObjectName clusterName=getDefaultClusterName(cluster);
    if (!getMBeanServer().isRegistered(clusterName)) {
      getMBeanServer().registerMBean(getManagedBean(cluster),clusterName);
    }
    return true;
  }
 catch (  Exception x) {
    log.warn("Unable to register default cluster implementation with JMX",x);
    return false;
  }
}

ID 2832=========================================================================type: 1
Method:org.apache.catalina.ha.jmx.ClusterJmxHelper#registerDefaultCluster(org.apache.catalina.ha.tcp.SimpleTcpCluster)
Rmethod: org.apache.catalina.ha.jmx.ClusterJmxHelper#getManagedBean(java.lang.Object)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
public static boolean registerDefaultCluster(SimpleTcpCluster cluster){
  try {
    initDefaultCluster();
    ObjectName clusterName=getDefaultClusterName(cluster);
    if (!getMBeanServer().isRegistered(clusterName)) {
      getMBeanServer().registerMBean(getManagedBean(cluster),clusterName);
    }
    return true;
  }
 catch (  Exception x) {
    log.warn("Unable to register default cluster implementation with JMX",x);
    return false;
  }
}

ID 2836=========================================================================type: 1
Method:org.apache.catalina.ha.jmx.ClusterJmxHelper#unregisterDefaultCluster(org.apache.catalina.ha.tcp.SimpleTcpCluster)
Rmethod: org.apache.catalina.ha.jmx.ClusterJmxHelper#getDefaultClusterName(org.apache.catalina.ha.tcp.SimpleTcpCluster)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
public static boolean unregisterDefaultCluster(SimpleTcpCluster cluster){
  try {
    ObjectName clusterName=getDefaultClusterName(cluster);
    if (getMBeanServer().isRegistered(clusterName)) {
      getMBeanServer().unregisterMBean(clusterName);
    }
    return true;
  }
 catch (  Exception x) {
    log.warn("Unable to unregister default cluster implementation with JMX",x);
    return false;
  }
}

ID 2837=========================================================================type: 1
Method:org.apache.catalina.ha.jmx.ClusterJmxHelper#unregisterDefaultCluster(org.apache.catalina.ha.tcp.SimpleTcpCluster)
Rmethod: org.apache.catalina.ha.jmx.ClusterJmxHelper#getMBeanServer()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
public static boolean unregisterDefaultCluster(SimpleTcpCluster cluster){
  try {
    ObjectName clusterName=getDefaultClusterName(cluster);
    if (getMBeanServer().isRegistered(clusterName)) {
      getMBeanServer().unregisterMBean(clusterName);
    }
    return true;
  }
 catch (  Exception x) {
    log.warn("Unable to unregister default cluster implementation with JMX",x);
    return false;
  }
}

ID 2842=========================================================================type: 1
Method:org.apache.catalina.ha.backend.HeartbeatListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.catalina.ha.backend.CollectedInfo#CollectedInfo(java.lang.String, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.PERIODIC_EVENT.equals(event.getType())) {
    if (sender == null) {
      if (proxyList == null)       sender=new MultiCastSender();
 else       sender=new TcpSender();
    }
    if (coll == null) {
      try {
        coll=new CollectedInfo(host,port);
        this.port=coll.port;
        this.host=coll.host;
      }
 catch (      Exception ex) {
        log.error("Unable to initialize info collection: " + ex);
        coll=null;
        return;
      }
    }
    try {
      sender.init(this);
    }
 catch (    Exception ex) {
      log.error("Unable to initialize Sender: " + ex);
      sender=null;
      return;
    }
    try {
      coll.refresh();
    }
 catch (    Exception ex) {
      log.error("Unable to collect load information: " + ex);
      coll=null;
      return;
    }
    String output="v=1&ready=" + coll.ready + "&busy="+ coll.busy+ "&port="+ port;
    try {
      sender.send(output);
    }
 catch (    Exception ex) {
      log.error("Unable to send colllected load information: " + ex);
    }
  }
}

ID 2843=========================================================================type: 1
Method:org.apache.catalina.ha.backend.HeartbeatListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.catalina.ha.backend.Sender#init(org.apache.catalina.ha.backend.HeartbeatListener)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.PERIODIC_EVENT.equals(event.getType())) {
    if (sender == null) {
      if (proxyList == null)       sender=new MultiCastSender();
 else       sender=new TcpSender();
    }
    if (coll == null) {
      try {
        coll=new CollectedInfo(host,port);
        this.port=coll.port;
        this.host=coll.host;
      }
 catch (      Exception ex) {
        log.error("Unable to initialize info collection: " + ex);
        coll=null;
        return;
      }
    }
    try {
      sender.init(this);
    }
 catch (    Exception ex) {
      log.error("Unable to initialize Sender: " + ex);
      sender=null;
      return;
    }
    try {
      coll.refresh();
    }
 catch (    Exception ex) {
      log.error("Unable to collect load information: " + ex);
      coll=null;
      return;
    }
    String output="v=1&ready=" + coll.ready + "&busy="+ coll.busy+ "&port="+ port;
    try {
      sender.send(output);
    }
 catch (    Exception ex) {
      log.error("Unable to send colllected load information: " + ex);
    }
  }
}

ID 2844=========================================================================type: 1
Method:org.apache.catalina.ha.backend.HeartbeatListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.catalina.ha.backend.CollectedInfo#refresh()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.PERIODIC_EVENT.equals(event.getType())) {
    if (sender == null) {
      if (proxyList == null)       sender=new MultiCastSender();
 else       sender=new TcpSender();
    }
    if (coll == null) {
      try {
        coll=new CollectedInfo(host,port);
        this.port=coll.port;
        this.host=coll.host;
      }
 catch (      Exception ex) {
        log.error("Unable to initialize info collection: " + ex);
        coll=null;
        return;
      }
    }
    try {
      sender.init(this);
    }
 catch (    Exception ex) {
      log.error("Unable to initialize Sender: " + ex);
      sender=null;
      return;
    }
    try {
      coll.refresh();
    }
 catch (    Exception ex) {
      log.error("Unable to collect load information: " + ex);
      coll=null;
      return;
    }
    String output="v=1&ready=" + coll.ready + "&busy="+ coll.busy+ "&port="+ port;
    try {
      sender.send(output);
    }
 catch (    Exception ex) {
      log.error("Unable to send colllected load information: " + ex);
    }
  }
}

ID 2845=========================================================================type: 1
Method:org.apache.catalina.ha.backend.HeartbeatListener#lifecycleEvent(org.apache.catalina.LifecycleEvent)
Rmethod: org.apache.catalina.ha.backend.Sender#send(java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void lifecycleEvent(LifecycleEvent event){
  if (Lifecycle.PERIODIC_EVENT.equals(event.getType())) {
    if (sender == null) {
      if (proxyList == null)       sender=new MultiCastSender();
 else       sender=new TcpSender();
    }
    if (coll == null) {
      try {
        coll=new CollectedInfo(host,port);
        this.port=coll.port;
        this.host=coll.host;
      }
 catch (      Exception ex) {
        log.error("Unable to initialize info collection: " + ex);
        coll=null;
        return;
      }
    }
    try {
      sender.init(this);
    }
 catch (    Exception ex) {
      log.error("Unable to initialize Sender: " + ex);
      sender=null;
      return;
    }
    try {
      coll.refresh();
    }
 catch (    Exception ex) {
      log.error("Unable to collect load information: " + ex);
      coll=null;
      return;
    }
    String output="v=1&ready=" + coll.ready + "&busy="+ coll.busy+ "&port="+ port;
    try {
      sender.send(output);
    }
 catch (    Exception ex) {
      log.error("Unable to send colllected load information: " + ex);
    }
  }
}

ID 2881=========================================================================type: 1
Method:org.apache.catalina.ha.tcp.SimpleTcpCluster#startInternal()
Rmethod: org.apache.catalina.ha.ClusterDeployer#start()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Start Cluster and implement the requirements of  {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  if (log.isInfoEnabled())   log.info("Cluster is about to start");
  try {
    checkDefaults();
    registerClusterValve();
    channel.addMembershipListener(this);
    channel.addChannelListener(this);
    if (channel instanceof GroupChannel)     ((GroupChannel)channel).setName(getClusterName() + "-Channel");
    channel.start(channelStartOptions);
    if (clusterDeployer != null)     clusterDeployer.start();
    registerMember(channel.getLocalMember(false));
  }
 catch (  Exception x) {
    log.error("Unable to start cluster.",x);
    throw new LifecycleException(x);
  }
  setState(LifecycleState.STARTING);
}

ID 2898=========================================================================type: 1
Method:org.apache.catalina.ha.session.DeltaManager#changeSessionId(org.apache.catalina.Session, boolean)
Rmethod: org.apache.catalina.ha.session.DeltaManager#serializeSessionId(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void changeSessionId(Session session,boolean notify){
  String orgSessionID=session.getId();
  super.changeSessionId(session);
  if (notify && cluster.getMembers().length > 0) {
    String newSessionID=session.getId();
    try {
      byte[] data=serializeSessionId(newSessionID);
      SessionMessage msg=new SessionMessageImpl(getName(),SessionMessage.EVT_CHANGE_SESSION_ID,data,orgSessionID,orgSessionID + "-" + System.currentTimeMillis());
      msg.setTimestamp(System.currentTimeMillis());
      counterSend_EVT_CHANGE_SESSION_ID++;
      send(msg);
    }
 catch (    IOException e) {
      log.error(sm.getString("deltaManager.unableSerializeSessionID",newSessionID),e);
    }
  }
}

ID 2926=========================================================================type: 1
Method:org.apache.catalina.ha.session.DeltaManager#requestCompleted(java.lang.String, boolean)
Rmethod: org.apache.catalina.session.ManagerBase#findSession(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * When the request has been completed, the replication valve will notify the manager, and the manager will decide whether any replication is needed or not. If there is a need for replication, the manager will create a session message and that will be replicated. The cluster determines where it gets sent. Session expiration also calls this method, but with expires == true.
 * @param sessionId -the sessionId that just completed.
 * @param expires -whether this method has been called during session expiration
 * @return a SessionMessage to be sent,
 */
public ClusterMessage requestCompleted(String sessionId,boolean expires){
  DeltaSession session=null;
  SessionMessage msg=null;
  try {
    session=(DeltaSession)findSession(sessionId);
    if (session == null) {
      return null;
    }
    DeltaRequest deltaRequest=session.getDeltaRequest();
    session.lock();
    if (deltaRequest.getSize() > 0) {
      counterSend_EVT_SESSION_DELTA++;
      byte[] data=serializeDeltaRequest(session,deltaRequest);
      msg=new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_DELTA,data,sessionId,sessionId + "-" + System.currentTimeMillis());
      session.resetDeltaRequest();
    }
  }
 catch (  IOException x) {
    log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest",sessionId),x);
    return null;
  }
 finally {
    if (session != null)     session.unlock();
  }
  if (msg == null) {
    if (!expires && !session.isPrimarySession()) {
      counterSend_EVT_SESSION_ACCESSED++;
      msg=new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_ACCESSED,null,sessionId,sessionId + "-" + System.currentTimeMillis());
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary",getName(),sessionId));
      }
    }
  }
 else {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("deltaManager.createMessage.delta",getName(),sessionId));
    }
  }
  if (!expires)   session.setPrimarySession(true);
  if (!expires && (msg == null)) {
    long replDelta=System.currentTimeMillis() - session.getLastTimeReplicated();
    if (session.getMaxInactiveInterval() >= 0 && replDelta > (session.getMaxInactiveInterval() * 1000L)) {
      counterSend_EVT_SESSION_ACCESSED++;
      msg=new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_ACCESSED,null,sessionId,sessionId + "-" + System.currentTimeMillis());
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("deltaManager.createMessage.access",getName(),sessionId));
      }
    }
  }
  if (msg != null) {
    session.setLastTimeReplicated(System.currentTimeMillis());
    msg.setTimestamp(session.getLastTimeReplicated());
  }
  return msg;
}

ID 2927=========================================================================type: 1
Method:org.apache.catalina.ha.session.DeltaManager#requestCompleted(java.lang.String, boolean)
Rmethod: org.apache.catalina.ha.session.DeltaManager#serializeDeltaRequest(org.apache.catalina.ha.session.DeltaSession, org.apache.catalina.ha.session.DeltaRequest)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * When the request has been completed, the replication valve will notify the manager, and the manager will decide whether any replication is needed or not. If there is a need for replication, the manager will create a session message and that will be replicated. The cluster determines where it gets sent. Session expiration also calls this method, but with expires == true.
 * @param sessionId -the sessionId that just completed.
 * @param expires -whether this method has been called during session expiration
 * @return a SessionMessage to be sent,
 */
public ClusterMessage requestCompleted(String sessionId,boolean expires){
  DeltaSession session=null;
  SessionMessage msg=null;
  try {
    session=(DeltaSession)findSession(sessionId);
    if (session == null) {
      return null;
    }
    DeltaRequest deltaRequest=session.getDeltaRequest();
    session.lock();
    if (deltaRequest.getSize() > 0) {
      counterSend_EVT_SESSION_DELTA++;
      byte[] data=serializeDeltaRequest(session,deltaRequest);
      msg=new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_DELTA,data,sessionId,sessionId + "-" + System.currentTimeMillis());
      session.resetDeltaRequest();
    }
  }
 catch (  IOException x) {
    log.error(sm.getString("deltaManager.createMessage.unableCreateDeltaRequest",sessionId),x);
    return null;
  }
 finally {
    if (session != null)     session.unlock();
  }
  if (msg == null) {
    if (!expires && !session.isPrimarySession()) {
      counterSend_EVT_SESSION_ACCESSED++;
      msg=new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_ACCESSED,null,sessionId,sessionId + "-" + System.currentTimeMillis());
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("deltaManager.createMessage.accessChangePrimary",getName(),sessionId));
      }
    }
  }
 else {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("deltaManager.createMessage.delta",getName(),sessionId));
    }
  }
  if (!expires)   session.setPrimarySession(true);
  if (!expires && (msg == null)) {
    long replDelta=System.currentTimeMillis() - session.getLastTimeReplicated();
    if (session.getMaxInactiveInterval() >= 0 && replDelta > (session.getMaxInactiveInterval() * 1000L)) {
      counterSend_EVT_SESSION_ACCESSED++;
      msg=new SessionMessageImpl(getName(),SessionMessage.EVT_SESSION_ACCESSED,null,sessionId,sessionId + "-" + System.currentTimeMillis());
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("deltaManager.createMessage.access",getName(),sessionId));
      }
    }
  }
  if (msg != null) {
    session.setLastTimeReplicated(System.currentTimeMillis());
    msg.setTimestamp(session.getLastTimeReplicated());
  }
  return msg;
}

ID 2981=========================================================================type: 1
Method:org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener#messageReceived(org.apache.catalina.ha.ClusterMessage)
Rmethod: org.apache.catalina.Manager#findSession(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Callback from the cluster, when a message is received, The cluster will broadcast it invoking the messageReceived on the receiver.
 * @param msg ClusterMessage - the message received from the cluster
 */
@Override public void messageReceived(ClusterMessage msg){
  if (msg instanceof SessionIDMessage) {
    SessionIDMessage sessionmsg=(SessionIDMessage)msg;
    if (log.isDebugEnabled())     log.debug(sm.getString("jvmRoute.receiveMessage.sessionIDChanged",sessionmsg.getOrignalSessionID(),sessionmsg.getBackupSessionID(),sessionmsg.getContextName()));
    Container container=getCluster().getContainer();
    Container host=null;
    if (container instanceof Engine) {
      host=container.findChild(sessionmsg.getHost());
    }
 else {
      host=container;
    }
    if (host != null) {
      Context context=(Context)host.findChild(sessionmsg.getContextName());
      if (context != null) {
        try {
          Session session=context.getManager().findSession(sessionmsg.getOrignalSessionID());
          if (session != null) {
            session.setId(sessionmsg.getBackupSessionID());
          }
 else           if (log.isInfoEnabled())           log.info(sm.getString("jvmRoute.lostSession",sessionmsg.getOrignalSessionID(),sessionmsg.getContextName()));
        }
 catch (        IOException e) {
          log.error(e);
        }
      }
 else       if (log.isErrorEnabled())       log.error(sm.getString("jvmRoute.contextNotFound",sessionmsg.getContextName(),((StandardEngine)host.getParent()).getJvmRoute()));
    }
 else     if (log.isErrorEnabled())     log.error(sm.getString("jvmRoute.hostNotFound",sessionmsg.getContextName()));
  }
  return;
}

ID 3011=========================================================================type: 1
Method:org.apache.catalina.users.MemoryUserDatabase#open()
Rmethod: org.apache.tomcat.util.file.ConfigFileLoader#getInputStream(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Initialize access to this user database.
 * @exception Exception if any exception is thrown during opening
 */
@Override public void open() throws Exception {
synchronized (groups) {
synchronized (users) {
      users.clear();
      groups.clear();
      roles.clear();
      String pathName=getPathname();
      InputStream is=null;
      try {
        is=ConfigFileLoader.getInputStream(pathName);
        Digester digester=new Digester();
        try {
          digester.setFeature("http://apache.org/xml/features/allow-java-encodings",true);
        }
 catch (        Exception e) {
          log.warn(sm.getString("memoryUserDatabase.xmlFeatureEncoding"),e);
        }
        digester.addFactoryCreate("tomcat-users/group",new MemoryGroupCreationFactory(this),true);
        digester.addFactoryCreate("tomcat-users/role",new MemoryRoleCreationFactory(this),true);
        digester.addFactoryCreate("tomcat-users/user",new MemoryUserCreationFactory(this),true);
        digester.parse(is);
      }
 catch (      IOException ioe) {
        log.error(sm.getString("memoryUserDatabase.fileNotFound",pathName));
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException ioe) {
          }
        }
      }
    }
  }
}

ID 3015=========================================================================type: 1
Method:org.apache.catalina.users.MemoryUserDatabase#open()
Rmethod: org.apache.tomcat.util.digester.Digester#parse(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Initialize access to this user database.
 * @exception Exception if any exception is thrown during opening
 */
@Override public void open() throws Exception {
synchronized (groups) {
synchronized (users) {
      users.clear();
      groups.clear();
      roles.clear();
      String pathName=getPathname();
      InputStream is=null;
      try {
        is=ConfigFileLoader.getInputStream(pathName);
        Digester digester=new Digester();
        try {
          digester.setFeature("http://apache.org/xml/features/allow-java-encodings",true);
        }
 catch (        Exception e) {
          log.warn(sm.getString("memoryUserDatabase.xmlFeatureEncoding"),e);
        }
        digester.addFactoryCreate("tomcat-users/group",new MemoryGroupCreationFactory(this),true);
        digester.addFactoryCreate("tomcat-users/role",new MemoryRoleCreationFactory(this),true);
        digester.addFactoryCreate("tomcat-users/user",new MemoryUserCreationFactory(this),true);
        digester.parse(is);
      }
 catch (      IOException ioe) {
        log.error(sm.getString("memoryUserDatabase.fileNotFound",pathName));
      }
 finally {
        if (is != null) {
          try {
            is.close();
          }
 catch (          IOException ioe) {
          }
        }
      }
    }
  }
}

ID 3018=========================================================================type: 1
Method:org.apache.catalina.users.MemoryUserDatabase#save()
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Save any updated information to the persistent storage location for this user database.
 * @exception Exception if any exception is thrown during saving
 */
@Override public void save() throws Exception {
  if (getReadonly()) {
    log.error(sm.getString("memoryUserDatabase.readOnly"));
    return;
  }
  if (!isWriteable()) {
    log.warn(sm.getString("memoryUserDatabase.notPersistable"));
    return;
  }
  File fileNew=new File(pathnameNew);
  if (!fileNew.isAbsolute()) {
    fileNew=new File(System.getProperty(Globals.CATALINA_BASE_PROP),pathnameNew);
  }
  PrintWriter writer=null;
  try {
    FileOutputStream fos=new FileOutputStream(fileNew);
    OutputStreamWriter osw=new OutputStreamWriter(fos,"UTF8");
    writer=new PrintWriter(osw);
    writer.println("<?xml version='1.0' encoding='utf-8'?>");
    writer.println("<tomcat-users>");
    Iterator<?> values=null;
    values=getRoles();
    while (values.hasNext()) {
      writer.print("  ");
      writer.println(values.next());
    }
    values=getGroups();
    while (values.hasNext()) {
      writer.print("  ");
      writer.println(values.next());
    }
    values=getUsers();
    while (values.hasNext()) {
      writer.print("  ");
      writer.println(((MemoryUser)values.next()).toXml());
    }
    writer.println("</tomcat-users>");
    if (writer.checkError()) {
      writer.close();
      fileNew.delete();
      throw new IOException(sm.getString("memoryUserDatabase.writeException",fileNew.getAbsolutePath()));
    }
    writer.close();
  }
 catch (  IOException e) {
    if (writer != null) {
      writer.close();
    }
    fileNew.delete();
    throw e;
  }
  File fileOld=new File(pathnameOld);
  if (!fileOld.isAbsolute()) {
    fileOld=new File(System.getProperty(Globals.CATALINA_BASE_PROP),pathnameOld);
  }
  fileOld.delete();
  File fileOrig=new File(pathname);
  if (!fileOrig.isAbsolute()) {
    fileOrig=new File(System.getProperty(Globals.CATALINA_BASE_PROP),pathname);
  }
  if (fileOrig.exists()) {
    fileOld.delete();
    if (!fileOrig.renameTo(fileOld)) {
      throw new IOException(sm.getString("memoryUserDatabase.renameOld",fileOld.getAbsolutePath()));
    }
  }
  if (!fileNew.renameTo(fileOrig)) {
    if (fileOld.exists()) {
      fileOld.renameTo(fileOrig);
    }
    throw new IOException(sm.getString("memoryUserDatabase.renameNew",fileOrig.getAbsolutePath()));
  }
  fileOld.delete();
}

ID 3019=========================================================================type: 1
Method:org.apache.catalina.users.MemoryUserDatabase#save()
Rmethod: java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Save any updated information to the persistent storage location for this user database.
 * @exception Exception if any exception is thrown during saving
 */
@Override public void save() throws Exception {
  if (getReadonly()) {
    log.error(sm.getString("memoryUserDatabase.readOnly"));
    return;
  }
  if (!isWriteable()) {
    log.warn(sm.getString("memoryUserDatabase.notPersistable"));
    return;
  }
  File fileNew=new File(pathnameNew);
  if (!fileNew.isAbsolute()) {
    fileNew=new File(System.getProperty(Globals.CATALINA_BASE_PROP),pathnameNew);
  }
  PrintWriter writer=null;
  try {
    FileOutputStream fos=new FileOutputStream(fileNew);
    OutputStreamWriter osw=new OutputStreamWriter(fos,"UTF8");
    writer=new PrintWriter(osw);
    writer.println("<?xml version='1.0' encoding='utf-8'?>");
    writer.println("<tomcat-users>");
    Iterator<?> values=null;
    values=getRoles();
    while (values.hasNext()) {
      writer.print("  ");
      writer.println(values.next());
    }
    values=getGroups();
    while (values.hasNext()) {
      writer.print("  ");
      writer.println(values.next());
    }
    values=getUsers();
    while (values.hasNext()) {
      writer.print("  ");
      writer.println(((MemoryUser)values.next()).toXml());
    }
    writer.println("</tomcat-users>");
    if (writer.checkError()) {
      writer.close();
      fileNew.delete();
      throw new IOException(sm.getString("memoryUserDatabase.writeException",fileNew.getAbsolutePath()));
    }
    writer.close();
  }
 catch (  IOException e) {
    if (writer != null) {
      writer.close();
    }
    fileNew.delete();
    throw e;
  }
  File fileOld=new File(pathnameOld);
  if (!fileOld.isAbsolute()) {
    fileOld=new File(System.getProperty(Globals.CATALINA_BASE_PROP),pathnameOld);
  }
  fileOld.delete();
  File fileOrig=new File(pathname);
  if (!fileOrig.isAbsolute()) {
    fileOrig=new File(System.getProperty(Globals.CATALINA_BASE_PROP),pathname);
  }
  if (fileOrig.exists()) {
    fileOld.delete();
    if (!fileOrig.renameTo(fileOld)) {
      throw new IOException(sm.getString("memoryUserDatabase.renameOld",fileOld.getAbsolutePath()));
    }
  }
  if (!fileNew.renameTo(fileOrig)) {
    if (fileOld.exists()) {
      fileOld.renameTo(fileOrig);
    }
    throw new IOException(sm.getString("memoryUserDatabase.renameNew",fileOrig.getAbsolutePath()));
  }
  fileOld.delete();
}

ID 3043=========================================================================type: 1
Method:org.apache.catalina.connector.OutputBuffer#realWriteBytes(byte[], int, int)
Rmethod: org.apache.coyote.Response#doWrite(org.apache.tomcat.util.buf.ByteChunk)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Sends the buffer data to the client output, checking the state of Response and calling the right interceptors.
 * @param buf Byte buffer to be written to the response
 * @param off Offset
 * @param cnt Length
 * @throws IOException An underlying IOException occurred
 */
@Override public void realWriteBytes(byte buf[],int off,int cnt) throws IOException {
  if (closed) {
    return;
  }
  if (coyoteResponse == null) {
    return;
  }
  if (cnt > 0) {
    outputChunk.setBytes(buf,off,cnt);
    try {
      coyoteResponse.doWrite(outputChunk);
    }
 catch (    IOException e) {
      throw new ClientAbortException(e);
    }
  }
}

ID 3057=========================================================================type: 1
Method:org.apache.catalina.connector.OutputBuffer#setConverter()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
protected void setConverter() throws IOException {
  if (coyoteResponse != null) {
    enc=coyoteResponse.getCharacterEncoding();
  }
  gotEnc=true;
  if (enc == null) {
    enc=DEFAULT_ENCODING;
  }
  conv=encoders.get(enc);
  if (conv == null) {
    if (Globals.IS_SECURITY_ENABLED) {
      try {
        conv=AccessController.doPrivileged(new PrivilegedExceptionAction<C2BConverter>(){
          @Override public C2BConverter run() throws IOException {
            return new C2BConverter(enc);
          }
        }
);
      }
 catch (      PrivilegedActionException ex) {
        Exception e=ex.getException();
        if (e instanceof IOException) {
          throw (IOException)e;
        }
      }
    }
 else {
      conv=new C2BConverter(enc);
    }
    encoders.put(enc,conv);
  }
}

ID 3069=========================================================================type: 1
Method:org.apache.catalina.connector.Response#doIsEncodeable(org.apache.catalina.connector.Request, org.apache.catalina.Session, java.lang.String)
Rmethod: org.apache.tomcat.util.net.URL#URL(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
private boolean doIsEncodeable(Request hreq,Session session,String location){
  URL url=null;
  try {
    url=new URL(location);
  }
 catch (  MalformedURLException e) {
    return (false);
  }
  if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol())) {
    return (false);
  }
  if (!hreq.getServerName().equalsIgnoreCase(url.getHost())) {
    return (false);
  }
  int serverPort=hreq.getServerPort();
  if (serverPort == -1) {
    if ("https".equals(hreq.getScheme())) {
      serverPort=443;
    }
 else {
      serverPort=80;
    }
  }
  int urlPort=url.getPort();
  if (urlPort == -1) {
    if ("https".equals(url.getProtocol())) {
      urlPort=443;
    }
 else {
      urlPort=80;
    }
  }
  if (serverPort != urlPort) {
    return (false);
  }
  String contextPath=getContext().getPath();
  if (contextPath != null) {
    String file=url.getFile();
    if (!file.startsWith(contextPath)) {
      return (false);
    }
    String tok=";" + SessionConfig.getSessionUriParamName(request.getContext()) + "="+ session.getIdInternal();
    if (file.indexOf(tok,contextPath.length()) >= 0) {
      return (false);
    }
  }
  return (true);
}

ID 3070=========================================================================type: 1
Method:org.apache.catalina.connector.Response#toAbsolute(java.lang.String)
Rmethod: org.apache.tomcat.util.buf.CharChunk#append(java.lang.String, int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Convert (if necessary) and return the absolute URL that represents the resource referenced by this possibly relative URL.  If this URL is already absolute, return it unchanged.
 * @param location URL to be (possibly) converted and then returned
 * @exception IllegalArgumentException if a MalformedURLException isthrown when converting the relative URL to an absolute one
 */
protected String toAbsolute(String location){
  if (location == null) {
    return (location);
  }
  boolean leadingSlash=location.startsWith("/");
  if (location.startsWith("//")) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append(':');
      redirectURLCC.append(location,0,location.length());
      return redirectURLCC.toString();
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
  }
 else   if (leadingSlash || !hasScheme(location)) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    String name=request.getServerName();
    int port=request.getServerPort();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append("://",0,3);
      redirectURLCC.append(name,0,name.length());
      if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) {
        redirectURLCC.append(':');
        String portS=port + "";
        redirectURLCC.append(portS,0,portS.length());
      }
      if (!leadingSlash) {
        String relativePath=request.getDecodedRequestURI();
        int pos=relativePath.lastIndexOf('/');
        CharChunk encodedURI=null;
        final String frelativePath=relativePath;
        final int fend=pos;
        if (SecurityUtil.isPackageProtectionEnabled()) {
          try {
            encodedURI=AccessController.doPrivileged(new PrivilegedExceptionAction<CharChunk>(){
              @Override public CharChunk run() throws IOException {
                return urlEncoder.encodeURL(frelativePath,0,fend);
              }
            }
);
          }
 catch (          PrivilegedActionException pae) {
            IllegalArgumentException iae=new IllegalArgumentException(location);
            iae.initCause(pae.getException());
            throw iae;
          }
        }
 else {
          encodedURI=urlEncoder.encodeURL(relativePath,0,pos);
        }
        redirectURLCC.append(encodedURI);
        encodedURI.recycle();
        redirectURLCC.append('/');
      }
      redirectURLCC.append(location,0,location.length());
      normalize(redirectURLCC);
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
    return redirectURLCC.toString();
  }
 else {
    return (location);
  }
}

ID 3071=========================================================================type: 1
Method:org.apache.catalina.connector.Response#toAbsolute(java.lang.String)
Rmethod: org.apache.tomcat.util.buf.CharChunk#append(char)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Convert (if necessary) and return the absolute URL that represents the resource referenced by this possibly relative URL.  If this URL is already absolute, return it unchanged.
 * @param location URL to be (possibly) converted and then returned
 * @exception IllegalArgumentException if a MalformedURLException isthrown when converting the relative URL to an absolute one
 */
protected String toAbsolute(String location){
  if (location == null) {
    return (location);
  }
  boolean leadingSlash=location.startsWith("/");
  if (location.startsWith("//")) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append(':');
      redirectURLCC.append(location,0,location.length());
      return redirectURLCC.toString();
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
  }
 else   if (leadingSlash || !hasScheme(location)) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    String name=request.getServerName();
    int port=request.getServerPort();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append("://",0,3);
      redirectURLCC.append(name,0,name.length());
      if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) {
        redirectURLCC.append(':');
        String portS=port + "";
        redirectURLCC.append(portS,0,portS.length());
      }
      if (!leadingSlash) {
        String relativePath=request.getDecodedRequestURI();
        int pos=relativePath.lastIndexOf('/');
        CharChunk encodedURI=null;
        final String frelativePath=relativePath;
        final int fend=pos;
        if (SecurityUtil.isPackageProtectionEnabled()) {
          try {
            encodedURI=AccessController.doPrivileged(new PrivilegedExceptionAction<CharChunk>(){
              @Override public CharChunk run() throws IOException {
                return urlEncoder.encodeURL(frelativePath,0,fend);
              }
            }
);
          }
 catch (          PrivilegedActionException pae) {
            IllegalArgumentException iae=new IllegalArgumentException(location);
            iae.initCause(pae.getException());
            throw iae;
          }
        }
 else {
          encodedURI=urlEncoder.encodeURL(relativePath,0,pos);
        }
        redirectURLCC.append(encodedURI);
        encodedURI.recycle();
        redirectURLCC.append('/');
      }
      redirectURLCC.append(location,0,location.length());
      normalize(redirectURLCC);
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
    return redirectURLCC.toString();
  }
 else {
    return (location);
  }
}

ID 3073=========================================================================type: 1
Method:org.apache.catalina.connector.Response#toAbsolute(java.lang.String)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Convert (if necessary) and return the absolute URL that represents the resource referenced by this possibly relative URL.  If this URL is already absolute, return it unchanged.
 * @param location URL to be (possibly) converted and then returned
 * @exception IllegalArgumentException if a MalformedURLException isthrown when converting the relative URL to an absolute one
 */
protected String toAbsolute(String location){
  if (location == null) {
    return (location);
  }
  boolean leadingSlash=location.startsWith("/");
  if (location.startsWith("//")) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append(':');
      redirectURLCC.append(location,0,location.length());
      return redirectURLCC.toString();
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
  }
 else   if (leadingSlash || !hasScheme(location)) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    String name=request.getServerName();
    int port=request.getServerPort();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append("://",0,3);
      redirectURLCC.append(name,0,name.length());
      if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) {
        redirectURLCC.append(':');
        String portS=port + "";
        redirectURLCC.append(portS,0,portS.length());
      }
      if (!leadingSlash) {
        String relativePath=request.getDecodedRequestURI();
        int pos=relativePath.lastIndexOf('/');
        CharChunk encodedURI=null;
        final String frelativePath=relativePath;
        final int fend=pos;
        if (SecurityUtil.isPackageProtectionEnabled()) {
          try {
            encodedURI=AccessController.doPrivileged(new PrivilegedExceptionAction<CharChunk>(){
              @Override public CharChunk run() throws IOException {
                return urlEncoder.encodeURL(frelativePath,0,fend);
              }
            }
);
          }
 catch (          PrivilegedActionException pae) {
            IllegalArgumentException iae=new IllegalArgumentException(location);
            iae.initCause(pae.getException());
            throw iae;
          }
        }
 else {
          encodedURI=urlEncoder.encodeURL(relativePath,0,pos);
        }
        redirectURLCC.append(encodedURI);
        encodedURI.recycle();
        redirectURLCC.append('/');
      }
      redirectURLCC.append(location,0,location.length());
      normalize(redirectURLCC);
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
    return redirectURLCC.toString();
  }
 else {
    return (location);
  }
}

ID 3074=========================================================================type: 1
Method:org.apache.catalina.connector.Response#toAbsolute(java.lang.String)
Rmethod: org.apache.tomcat.util.buf.UEncoder#encodeURL(java.lang.String, int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Convert (if necessary) and return the absolute URL that represents the resource referenced by this possibly relative URL.  If this URL is already absolute, return it unchanged.
 * @param location URL to be (possibly) converted and then returned
 * @exception IllegalArgumentException if a MalformedURLException isthrown when converting the relative URL to an absolute one
 */
protected String toAbsolute(String location){
  if (location == null) {
    return (location);
  }
  boolean leadingSlash=location.startsWith("/");
  if (location.startsWith("//")) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append(':');
      redirectURLCC.append(location,0,location.length());
      return redirectURLCC.toString();
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
  }
 else   if (leadingSlash || !hasScheme(location)) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    String name=request.getServerName();
    int port=request.getServerPort();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append("://",0,3);
      redirectURLCC.append(name,0,name.length());
      if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) {
        redirectURLCC.append(':');
        String portS=port + "";
        redirectURLCC.append(portS,0,portS.length());
      }
      if (!leadingSlash) {
        String relativePath=request.getDecodedRequestURI();
        int pos=relativePath.lastIndexOf('/');
        CharChunk encodedURI=null;
        final String frelativePath=relativePath;
        final int fend=pos;
        if (SecurityUtil.isPackageProtectionEnabled()) {
          try {
            encodedURI=AccessController.doPrivileged(new PrivilegedExceptionAction<CharChunk>(){
              @Override public CharChunk run() throws IOException {
                return urlEncoder.encodeURL(frelativePath,0,fend);
              }
            }
);
          }
 catch (          PrivilegedActionException pae) {
            IllegalArgumentException iae=new IllegalArgumentException(location);
            iae.initCause(pae.getException());
            throw iae;
          }
        }
 else {
          encodedURI=urlEncoder.encodeURL(relativePath,0,pos);
        }
        redirectURLCC.append(encodedURI);
        encodedURI.recycle();
        redirectURLCC.append('/');
      }
      redirectURLCC.append(location,0,location.length());
      normalize(redirectURLCC);
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
    return redirectURLCC.toString();
  }
 else {
    return (location);
  }
}

ID 3075=========================================================================type: 1
Method:org.apache.catalina.connector.Response#toAbsolute(java.lang.String)
Rmethod: org.apache.tomcat.util.buf.CharChunk#append(org.apache.tomcat.util.buf.CharChunk)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Convert (if necessary) and return the absolute URL that represents the resource referenced by this possibly relative URL.  If this URL is already absolute, return it unchanged.
 * @param location URL to be (possibly) converted and then returned
 * @exception IllegalArgumentException if a MalformedURLException isthrown when converting the relative URL to an absolute one
 */
protected String toAbsolute(String location){
  if (location == null) {
    return (location);
  }
  boolean leadingSlash=location.startsWith("/");
  if (location.startsWith("//")) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append(':');
      redirectURLCC.append(location,0,location.length());
      return redirectURLCC.toString();
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
  }
 else   if (leadingSlash || !hasScheme(location)) {
    redirectURLCC.recycle();
    String scheme=request.getScheme();
    String name=request.getServerName();
    int port=request.getServerPort();
    try {
      redirectURLCC.append(scheme,0,scheme.length());
      redirectURLCC.append("://",0,3);
      redirectURLCC.append(name,0,name.length());
      if ((scheme.equals("http") && port != 80) || (scheme.equals("https") && port != 443)) {
        redirectURLCC.append(':');
        String portS=port + "";
        redirectURLCC.append(portS,0,portS.length());
      }
      if (!leadingSlash) {
        String relativePath=request.getDecodedRequestURI();
        int pos=relativePath.lastIndexOf('/');
        CharChunk encodedURI=null;
        final String frelativePath=relativePath;
        final int fend=pos;
        if (SecurityUtil.isPackageProtectionEnabled()) {
          try {
            encodedURI=AccessController.doPrivileged(new PrivilegedExceptionAction<CharChunk>(){
              @Override public CharChunk run() throws IOException {
                return urlEncoder.encodeURL(frelativePath,0,fend);
              }
            }
);
          }
 catch (          PrivilegedActionException pae) {
            IllegalArgumentException iae=new IllegalArgumentException(location);
            iae.initCause(pae.getException());
            throw iae;
          }
        }
 else {
          encodedURI=urlEncoder.encodeURL(relativePath,0,pos);
        }
        redirectURLCC.append(encodedURI);
        encodedURI.recycle();
        redirectURLCC.append('/');
      }
      redirectURLCC.append(location,0,location.length());
      normalize(redirectURLCC);
    }
 catch (    IOException e) {
      IllegalArgumentException iae=new IllegalArgumentException(location);
      iae.initCause(e);
      throw iae;
    }
    return redirectURLCC.toString();
  }
 else {
    return (location);
  }
}

ID 3077=========================================================================type: 1
Method:org.apache.catalina.connector.Response#normalize(org.apache.tomcat.util.buf.CharChunk)
Rmethod: org.apache.tomcat.util.buf.CharChunk#append(char)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void normalize(CharChunk cc){
  int truncate=cc.indexOf('?');
  if (truncate == -1) {
    truncate=cc.indexOf('#');
  }
  char[] truncateCC=null;
  if (truncate > -1) {
    truncateCC=Arrays.copyOfRange(cc.getBuffer(),cc.getStart() + truncate,cc.getEnd());
    cc.setEnd(cc.getStart() + truncate);
  }
  if (cc.endsWith("/.") || cc.endsWith("/..")) {
    try {
      cc.append('/');
    }
 catch (    IOException e) {
      throw new IllegalArgumentException(cc.toString(),e);
    }
  }
  char[] c=cc.getChars();
  int start=cc.getStart();
  int end=cc.getEnd();
  int index=0;
  int startIndex=0;
  for (int i=0; i < 3; i++) {
    startIndex=cc.indexOf('/',startIndex + 1);
  }
  index=startIndex;
  while (true) {
    index=cc.indexOf("/./",0,3,index);
    if (index < 0) {
      break;
    }
    copyChars(c,start + index,start + index + 2,end - start - index- 2);
    end=end - 2;
    cc.setEnd(end);
  }
  index=startIndex;
  int pos;
  while (true) {
    index=cc.indexOf("/../",0,4,index);
    if (index < 0) {
      break;
    }
    if (index == startIndex) {
      throw new IllegalArgumentException();
    }
    int index2=-1;
    for (pos=start + index - 1; (pos >= 0) && (index2 < 0); pos--) {
      if (c[pos] == (byte)'/') {
        index2=pos;
      }
    }
    copyChars(c,start + index2,start + index + 3,end - start - index- 3);
    end=end + index2 - index - 3;
    cc.setEnd(end);
    index=index2;
  }
  if (truncateCC != null) {
    try {
      cc.append(truncateCC,0,truncateCC.length);
    }
 catch (    IOException ioe) {
      throw new IllegalArgumentException(ioe);
    }
  }
}

ID 3078=========================================================================type: 1
Method:org.apache.catalina.connector.Response#normalize(org.apache.tomcat.util.buf.CharChunk)
Rmethod: org.apache.tomcat.util.buf.CharChunk#append(char[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void normalize(CharChunk cc){
  int truncate=cc.indexOf('?');
  if (truncate == -1) {
    truncate=cc.indexOf('#');
  }
  char[] truncateCC=null;
  if (truncate > -1) {
    truncateCC=Arrays.copyOfRange(cc.getBuffer(),cc.getStart() + truncate,cc.getEnd());
    cc.setEnd(cc.getStart() + truncate);
  }
  if (cc.endsWith("/.") || cc.endsWith("/..")) {
    try {
      cc.append('/');
    }
 catch (    IOException e) {
      throw new IllegalArgumentException(cc.toString(),e);
    }
  }
  char[] c=cc.getChars();
  int start=cc.getStart();
  int end=cc.getEnd();
  int index=0;
  int startIndex=0;
  for (int i=0; i < 3; i++) {
    startIndex=cc.indexOf('/',startIndex + 1);
  }
  index=startIndex;
  while (true) {
    index=cc.indexOf("/./",0,3,index);
    if (index < 0) {
      break;
    }
    copyChars(c,start + index,start + index + 2,end - start - index- 2);
    end=end - 2;
    cc.setEnd(end);
  }
  index=startIndex;
  int pos;
  while (true) {
    index=cc.indexOf("/../",0,4,index);
    if (index < 0) {
      break;
    }
    if (index == startIndex) {
      throw new IllegalArgumentException();
    }
    int index2=-1;
    for (pos=start + index - 1; (pos >= 0) && (index2 < 0); pos--) {
      if (c[pos] == (byte)'/') {
        index2=pos;
      }
    }
    copyChars(c,start + index2,start + index + 3,end - start - index- 3);
    end=end + index2 - index - 3;
    cc.setEnd(end);
    index=index2;
  }
  if (truncateCC != null) {
    try {
      cc.append(truncateCC,0,truncateCC.length);
    }
 catch (    IOException ioe) {
      throw new IllegalArgumentException(ioe);
    }
  }
}

ID 3091=========================================================================type: 1
Method:org.apache.catalina.connector.InputBuffer#setConverter()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
protected void setConverter() throws IOException {
  if (coyoteRequest != null) {
    enc=coyoteRequest.getCharacterEncoding();
  }
  gotEnc=true;
  if (enc == null) {
    enc=DEFAULT_ENCODING;
  }
  conv=encoders.get(enc);
  if (conv == null) {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        conv=AccessController.doPrivileged(new PrivilegedExceptionAction<B2CConverter>(){
          @Override public B2CConverter run() throws IOException {
            return new B2CConverter(enc);
          }
        }
);
      }
 catch (      PrivilegedActionException ex) {
        Exception e=ex.getException();
        if (e instanceof IOException) {
          throw (IOException)e;
        }
      }
    }
 else {
      conv=new B2CConverter(enc);
    }
    encoders.put(enc,conv);
  }
}

ID 3106=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteAdapter#event(org.apache.coyote.Request, org.apache.coyote.Response, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.catalina.connector.Request#read()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Event method.
 * @return false to indicate an error, expected or not
 */
@Override public boolean event(org.apache.coyote.Request req,org.apache.coyote.Response res,SocketStatus status){
  Request request=(Request)req.getNote(ADAPTER_NOTES);
  Response response=(Response)res.getNote(ADAPTER_NOTES);
  if (request.getWrapper() == null) {
    return false;
  }
  boolean error=false;
  boolean read=false;
  try {
    if (status == SocketStatus.OPEN_READ) {
      if (response.isClosed()) {
        request.getEvent().setEventType(CometEvent.EventType.END);
        request.getEvent().setEventSubType(null);
      }
 else {
        try {
          if (request.read()) {
            read=true;
          }
        }
 catch (        IOException e) {
          error=true;
        }
        if (read) {
          request.getEvent().setEventType(CometEvent.EventType.READ);
          request.getEvent().setEventSubType(null);
        }
 else         if (error) {
          request.getEvent().setEventType(CometEvent.EventType.ERROR);
          request.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT);
        }
 else {
          request.getEvent().setEventType(CometEvent.EventType.END);
          request.getEvent().setEventSubType(null);
        }
      }
    }
 else     if (status == SocketStatus.DISCONNECT) {
      request.getEvent().setEventType(CometEvent.EventType.ERROR);
      request.getEvent().setEventSubType(CometEvent.EventSubType.CLIENT_DISCONNECT);
      error=true;
    }
 else     if (status == SocketStatus.ERROR) {
      request.getEvent().setEventType(CometEvent.EventType.ERROR);
      request.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION);
      error=true;
    }
 else     if (status == SocketStatus.STOP) {
      request.getEvent().setEventType(CometEvent.EventType.END);
      request.getEvent().setEventSubType(CometEvent.EventSubType.SERVER_SHUTDOWN);
    }
 else     if (status == SocketStatus.TIMEOUT) {
      if (response.isClosed()) {
        request.getEvent().setEventType(CometEvent.EventType.END);
        request.getEvent().setEventSubType(null);
      }
 else {
        request.getEvent().setEventType(CometEvent.EventType.ERROR);
        request.getEvent().setEventSubType(CometEvent.EventSubType.TIMEOUT);
      }
    }
    req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
    connector.getService().getContainer().getPipeline().getFirst().event(request,response,request.getEvent());
    if (!error && !response.isClosed() && (request.getAttribute(RequestDispatcher.ERROR_EXCEPTION) != null)) {
      request.getEvent().setEventType(CometEvent.EventType.ERROR);
      request.getEvent().setEventSubType(null);
      error=true;
      connector.getService().getContainer().getPipeline().getFirst().event(request,response,request.getEvent());
    }
    if (response.isClosed() || !request.isComet()) {
      if (status == SocketStatus.OPEN_READ && request.getEvent().getEventType() != EventType.END) {
        request.getEvent().setEventType(CometEvent.EventType.END);
        request.getEvent().setEventSubType(null);
        error=true;
        connector.getService().getContainer().getPipeline().getFirst().event(request,response,request.getEvent());
      }
      res.action(ActionCode.COMET_END,null);
    }
 else     if (!error && read && request.getAvailable()) {
      request.getEvent().setEventType(CometEvent.EventType.ERROR);
      request.getEvent().setEventSubType(CometEvent.EventSubType.IOEXCEPTION);
      error=true;
      connector.getService().getContainer().getPipeline().getFirst().event(request,response,request.getEvent());
    }
    return (!error);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    if (!(t instanceof IOException)) {
      log.error(sm.getString("coyoteAdapter.service"),t);
    }
    error=true;
    return false;
  }
 finally {
    req.getRequestProcessor().setWorkerThreadName(null);
    if (error || response.isClosed() || !request.isComet()) {
      ((Context)request.getMappingData().context).logAccess(request,response,System.currentTimeMillis() - req.getStartTime(),false);
      request.recycle();
      request.setFilterChain(null);
      response.recycle();
    }
  }
}

ID 3109=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteAdapter#asyncDispatch(org.apache.coyote.Request, org.apache.coyote.Response, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.catalina.Valve#invoke(org.apache.catalina.connector.Request, org.apache.catalina.connector.Response)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public boolean asyncDispatch(org.apache.coyote.Request req,org.apache.coyote.Response res,SocketStatus status) throws Exception {
  Request request=(Request)req.getNote(ADAPTER_NOTES);
  Response response=(Response)res.getNote(ADAPTER_NOTES);
  if (request == null) {
    throw new IllegalStateException("Dispatch may only happen on an existing request.");
  }
  boolean comet=false;
  boolean success=true;
  AsyncContextImpl asyncConImpl=request.getAsyncContextInternal();
  req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());
  try {
    if (!request.isAsync() && !comet) {
      Context ctxt=(Context)request.getMappingData().context;
      if (ctxt != null) {
        ctxt.fireRequestDestroyEvent(request);
      }
      response.setSuspended(false);
    }
    if (status == SocketStatus.TIMEOUT) {
      if (!asyncConImpl.timeout()) {
        asyncConImpl.setErrorState(null,false);
      }
    }
 else     if (status == SocketStatus.ERROR) {
      success=false;
      Throwable t=(Throwable)req.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
      req.getAttributes().remove(RequestDispatcher.ERROR_EXCEPTION);
      if (t != null) {
        asyncConImpl.setErrorState(t,true);
      }
    }
    if (!request.isAsyncDispatching() && request.isAsync() && response.isErrorReportRequired()) {
      connector.getService().getContainer().getPipeline().getFirst().invoke(request,response);
    }
    if (request.isAsyncDispatching()) {
      connector.getService().getContainer().getPipeline().getFirst().invoke(request,response);
      Throwable t=(Throwable)request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
      if (t != null) {
        asyncConImpl.setErrorState(t,true);
      }
    }
    if (request.isComet()) {
      if (!response.isClosed() && !response.isError()) {
        if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {
          if (event(req,res,SocketStatus.OPEN_READ)) {
            comet=true;
            res.action(ActionCode.COMET_BEGIN,null);
          }
 else {
            return false;
          }
        }
 else {
          comet=true;
          res.action(ActionCode.COMET_BEGIN,null);
        }
      }
 else {
        request.setFilterChain(null);
      }
    }
    if (!request.isAsync() && !comet) {
      try {
        request.finishRequest();
        response.finishResponse();
      }
  finally {
        long time=0;
        if (req.getStartTime() != -1) {
          time=System.currentTimeMillis() - req.getStartTime();
        }
        if (request.getMappingData().context != null) {
          ((Context)request.getMappingData().context).logAccess(request,response,time,false);
        }
 else {
          log(req,res,time);
        }
        req.action(ActionCode.POST_REQUEST,null);
      }
    }
    AtomicBoolean error=new AtomicBoolean(false);
    res.action(ActionCode.IS_ERROR,error);
    if (error.get()) {
      if (request.isAsyncCompleting()) {
        res.action(ActionCode.ASYNC_POST_PROCESS,null);
      }
      success=false;
    }
  }
 catch (  IOException e) {
    success=false;
  }
catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    success=false;
    log.error(sm.getString("coyoteAdapter.service"),t);
  }
 finally {
    req.getRequestProcessor().setWorkerThreadName(null);
    if (!success || (!comet && !request.isAsync())) {
      request.recycle();
      response.recycle();
    }
 else {
      request.clearEncoders();
      response.clearEncoders();
    }
  }
  return success;
}

ID 3119=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteAdapter#postParseRequest(org.apache.coyote.Request, org.apache.catalina.connector.Request, org.apache.coyote.Response, org.apache.catalina.connector.Response)
Rmethod: org.apache.tomcat.util.buf.UDecoder#convert(org.apache.tomcat.util.buf.MessageBytes, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Parse additional request parameters.
 */
protected boolean postParseRequest(org.apache.coyote.Request req,Request request,org.apache.coyote.Response res,Response response) throws Exception {
  if (!req.scheme().isNull()) {
    request.setSecure(req.scheme().equals("https"));
  }
 else {
    req.scheme().setString(connector.getScheme());
    request.setSecure(connector.getSecure());
  }
  String proxyName=connector.getProxyName();
  int proxyPort=connector.getProxyPort();
  if (proxyPort != 0) {
    req.setServerPort(proxyPort);
  }
  if (proxyName != null) {
    req.serverName().setString(proxyName);
  }
  MessageBytes decodedURI=req.decodedURI();
  decodedURI.duplicate(req.requestURI());
  parsePathParameters(req,request);
  try {
    req.getURLDecoder().convert(decodedURI,false);
  }
 catch (  IOException ioe) {
    res.setStatus(400);
    res.setMessage("Invalid URI: " + ioe.getMessage());
    connector.getService().getContainer().logAccess(request,response,0,true);
    return false;
  }
  if (!normalize(req.decodedURI())) {
    res.setStatus(400);
    res.setMessage("Invalid URI");
    connector.getService().getContainer().logAccess(request,response,0,true);
    return false;
  }
  convertURI(decodedURI,request);
  if (!checkNormalize(req.decodedURI())) {
    res.setStatus(400);
    res.setMessage("Invalid URI character encoding");
    connector.getService().getContainer().logAccess(request,response,0,true);
    return false;
  }
  MessageBytes serverName;
  if (connector.getUseIPVHosts()) {
    serverName=req.localName();
    if (serverName.isNull()) {
      res.action(ActionCode.REQ_LOCAL_NAME_ATTRIBUTE,null);
    }
  }
 else {
    serverName=req.serverName();
  }
  if (request.isAsyncStarted()) {
    request.getMappingData().recycle();
  }
  String version=null;
  Context versionContext=null;
  boolean mapRequired=true;
  while (mapRequired) {
    connector.getMapper().map(serverName,decodedURI,version,request.getMappingData());
    request.setContext((Context)request.getMappingData().context);
    request.setWrapper((Wrapper)request.getMappingData().wrapper);
    if (request.getContext() == null) {
      res.setStatus(404);
      res.setMessage("Not found");
      Host host=request.getHost();
      if (host != null) {
        host.logAccess(request,response,0,true);
      }
      return false;
    }
    String sessionID;
    if (request.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.URL)) {
      sessionID=request.getPathParameter(SessionConfig.getSessionUriParamName(request.getContext()));
      if (sessionID != null) {
        request.setRequestedSessionId(sessionID);
        request.setRequestedSessionURL(true);
      }
    }
    parseSessionCookiesId(req,request);
    parseSessionSslId(request);
    sessionID=request.getRequestedSessionId();
    mapRequired=false;
    if (version != null && request.getContext() == versionContext) {
    }
 else {
      version=null;
      versionContext=null;
      Object[] contexts=request.getMappingData().contexts;
      if (contexts != null && sessionID != null) {
        for (int i=(contexts.length); i > 0; i--) {
          Context ctxt=(Context)contexts[i - 1];
          if (ctxt.getManager().findSession(sessionID) != null) {
            if (!ctxt.equals(request.getMappingData().context)) {
              version=ctxt.getWebappVersion();
              versionContext=ctxt;
              request.getMappingData().recycle();
              mapRequired=true;
              request.recycleSessionInfo();
            }
            break;
          }
        }
      }
    }
    if (!mapRequired && request.getContext().getPaused()) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
      }
      request.getMappingData().recycle();
      mapRequired=true;
    }
  }
  MessageBytes redirectPathMB=request.getMappingData().redirectPath;
  if (!redirectPathMB.isNull()) {
    String redirectPath=urlEncoder.encode(redirectPathMB.toString(),"UTF-8");
    String query=request.getQueryString();
    if (request.isRequestedSessionIdFromURL()) {
      redirectPath=redirectPath + ";" + SessionConfig.getSessionUriParamName(request.getContext())+ "="+ request.getRequestedSessionId();
    }
    if (query != null) {
      redirectPath=redirectPath + "?" + query;
    }
    response.sendRedirect(redirectPath);
    request.getContext().logAccess(request,response,0,true);
    return false;
  }
  if (!connector.getAllowTrace() && req.method().equalsIgnoreCase("TRACE")) {
    Wrapper wrapper=request.getWrapper();
    String header=null;
    if (wrapper != null) {
      String[] methods=wrapper.getServletMethods();
      if (methods != null) {
        for (int i=0; i < methods.length; i++) {
          if ("TRACE".equals(methods[i])) {
            continue;
          }
          if (header == null) {
            header=methods[i];
          }
 else {
            header+=", " + methods[i];
          }
        }
      }
    }
    res.setStatus(405);
    res.addHeader("Allow",header);
    res.setMessage("TRACE method is not allowed");
    request.getContext().logAccess(request,response,0,true);
    return false;
  }
  doConnectorAuthenticationAuthorization(req,request);
  return true;
}

ID 3126=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteAdapter#parsePathParameters(org.apache.coyote.Request, org.apache.catalina.connector.Request)
Rmethod: org.apache.tomcat.util.buf.B2CConverter#getCharset(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Extract the path parameters from the request. This assumes parameters are of the form /path;name=value;name2=value2/ etc. Currently only really interested in the session ID that will be in this form. Other parameters can safely be ignored.
 * @param req
 * @param request
 */
protected void parsePathParameters(org.apache.coyote.Request req,Request request){
  req.decodedURI().toBytes();
  ByteChunk uriBC=req.decodedURI().getByteChunk();
  int semicolon=uriBC.indexOf(';',0);
  String enc=connector.getURIEncoding();
  if (enc == null) {
    enc="ISO-8859-1";
  }
  Charset charset=null;
  try {
    charset=B2CConverter.getCharset(enc);
  }
 catch (  UnsupportedEncodingException e1) {
    log.warn(sm.getString("coyoteAdapter.parsePathParam",enc));
  }
  if (log.isDebugEnabled()) {
    log.debug(sm.getString("coyoteAdapter.debug","uriBC",uriBC.toString()));
    log.debug(sm.getString("coyoteAdapter.debug","semicolon",String.valueOf(semicolon)));
    log.debug(sm.getString("coyoteAdapter.debug","enc",enc));
  }
  while (semicolon > -1) {
    int start=uriBC.getStart();
    int end=uriBC.getEnd();
    int pathParamStart=semicolon + 1;
    int pathParamEnd=ByteChunk.findBytes(uriBC.getBuffer(),start + pathParamStart,end,new byte[]{';','/'});
    String pv=null;
    if (pathParamEnd >= 0) {
      if (charset != null) {
        pv=new String(uriBC.getBuffer(),start + pathParamStart,pathParamEnd - pathParamStart,charset);
      }
      byte[] buf=uriBC.getBuffer();
      for (int i=0; i < end - start - pathParamEnd; i++) {
        buf[start + semicolon + i]=buf[start + i + pathParamEnd];
      }
      uriBC.setBytes(buf,start,end - start - pathParamEnd + semicolon);
    }
 else {
      if (charset != null) {
        pv=new String(uriBC.getBuffer(),start + pathParamStart,(end - start) - pathParamStart,charset);
      }
      uriBC.setEnd(start + semicolon);
    }
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("coyoteAdapter.debug","pathParamStart",String.valueOf(pathParamStart)));
      log.debug(sm.getString("coyoteAdapter.debug","pathParamEnd",String.valueOf(pathParamEnd)));
      log.debug(sm.getString("coyoteAdapter.debug","pv",pv));
    }
    if (pv != null) {
      int equals=pv.indexOf('=');
      if (equals > -1) {
        String name=pv.substring(0,equals);
        String value=pv.substring(equals + 1);
        request.addPathParameter(name,value);
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("coyoteAdapter.debug","equals",String.valueOf(equals)));
          log.debug(sm.getString("coyoteAdapter.debug","name",name));
          log.debug(sm.getString("coyoteAdapter.debug","value",value));
        }
      }
    }
    semicolon=uriBC.indexOf(';',semicolon);
  }
}

ID 3127=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteAdapter#convertURI(org.apache.tomcat.util.buf.MessageBytes, org.apache.catalina.connector.Request)
Rmethod: org.apache.tomcat.util.buf.B2CConverter#B2CConverter(java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Character conversion of the URI.
 */
protected void convertURI(MessageBytes uri,Request request) throws Exception {
  ByteChunk bc=uri.getByteChunk();
  int length=bc.getLength();
  CharChunk cc=uri.getCharChunk();
  cc.allocate(length,-1);
  String enc=connector.getURIEncoding();
  if (enc != null) {
    B2CConverter conv=request.getURIConverter();
    try {
      if (conv == null) {
        conv=new B2CConverter(enc,true);
        request.setURIConverter(conv);
      }
 else {
        conv.recycle();
      }
    }
 catch (    IOException e) {
      log.error("Invalid URI encoding; using HTTP default");
      connector.setURIEncoding(null);
    }
    if (conv != null) {
      try {
        conv.convert(bc,cc,true);
        uri.setChars(cc.getBuffer(),cc.getStart(),cc.getLength());
        return;
      }
 catch (      IOException ioe) {
        request.getResponse().sendError(HttpServletResponse.SC_BAD_REQUEST);
      }
    }
  }
  byte[] bbuf=bc.getBuffer();
  char[] cbuf=cc.getBuffer();
  int start=bc.getStart();
  for (int i=0; i < length; i++) {
    cbuf[i]=(char)(bbuf[i + start] & 0xff);
  }
  uri.setChars(cbuf,0,length);
}

ID 3128=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteAdapter#convertURI(org.apache.tomcat.util.buf.MessageBytes, org.apache.catalina.connector.Request)
Rmethod: org.apache.tomcat.util.buf.B2CConverter#convert(org.apache.tomcat.util.buf.ByteChunk, org.apache.tomcat.util.buf.CharChunk, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Character conversion of the URI.
 */
protected void convertURI(MessageBytes uri,Request request) throws Exception {
  ByteChunk bc=uri.getByteChunk();
  int length=bc.getLength();
  CharChunk cc=uri.getCharChunk();
  cc.allocate(length,-1);
  String enc=connector.getURIEncoding();
  if (enc != null) {
    B2CConverter conv=request.getURIConverter();
    try {
      if (conv == null) {
        conv=new B2CConverter(enc,true);
        request.setURIConverter(conv);
      }
 else {
        conv.recycle();
      }
    }
 catch (    IOException e) {
      log.error("Invalid URI encoding; using HTTP default");
      connector.setURIEncoding(null);
    }
    if (conv != null) {
      try {
        conv.convert(bc,cc,true);
        uri.setChars(cc.getBuffer(),cc.getStart(),cc.getLength());
        return;
      }
 catch (      IOException ioe) {
        request.getResponse().sendError(HttpServletResponse.SC_BAD_REQUEST);
      }
    }
  }
  byte[] bbuf=bc.getBuffer();
  char[] cbuf=cc.getBuffer();
  int start=bc.getStart();
  for (int i=0; i < length; i++) {
    cbuf[i]=(char)(bbuf[i + start] & 0xff);
  }
  uri.setChars(cbuf,0,length);
}

ID 3129=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteAdapter#convertURI(org.apache.tomcat.util.buf.MessageBytes, org.apache.catalina.connector.Request)
Rmethod: org.apache.catalina.connector.Response#sendError(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Character conversion of the URI.
 */
protected void convertURI(MessageBytes uri,Request request) throws Exception {
  ByteChunk bc=uri.getByteChunk();
  int length=bc.getLength();
  CharChunk cc=uri.getCharChunk();
  cc.allocate(length,-1);
  String enc=connector.getURIEncoding();
  if (enc != null) {
    B2CConverter conv=request.getURIConverter();
    try {
      if (conv == null) {
        conv=new B2CConverter(enc,true);
        request.setURIConverter(conv);
      }
 else {
        conv.recycle();
      }
    }
 catch (    IOException e) {
      log.error("Invalid URI encoding; using HTTP default");
      connector.setURIEncoding(null);
    }
    if (conv != null) {
      try {
        conv.convert(bc,cc,true);
        uri.setChars(cc.getBuffer(),cc.getStart(),cc.getLength());
        return;
      }
 catch (      IOException ioe) {
        request.getResponse().sendError(HttpServletResponse.SC_BAD_REQUEST);
      }
    }
  }
  byte[] bbuf=bc.getBuffer();
  char[] cbuf=cc.getBuffer();
  int start=bc.getStart();
  for (int i=0; i < length; i++) {
    cbuf[i]=(char)(bbuf[i + start] & 0xff);
  }
  uri.setChars(cbuf,0,length);
}

ID 3130=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteWriter#flush()
Rmethod: org.apache.catalina.connector.OutputBuffer#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void flush(){
  if (error) {
    return;
  }
  try {
    ob.flush();
  }
 catch (  IOException e) {
    error=true;
  }
}

ID 3132=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteWriter#write(int)
Rmethod: org.apache.catalina.connector.OutputBuffer#write(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void write(int c){
  if (error) {
    return;
  }
  try {
    ob.write(c);
  }
 catch (  IOException e) {
    error=true;
  }
}

ID 3133=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteWriter#write(char[], int, int)
Rmethod: org.apache.catalina.connector.OutputBuffer#write(char[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void write(char buf[],int off,int len){
  if (error) {
    return;
  }
  try {
    ob.write(buf,off,len);
  }
 catch (  IOException e) {
    error=true;
  }
}

ID 3134=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteWriter#write(java.lang.String, int, int)
Rmethod: org.apache.catalina.connector.OutputBuffer#write(java.lang.String, int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void write(String s,int off,int len){
  if (error) {
    return;
  }
  try {
    ob.write(s,off,len);
  }
 catch (  IOException e) {
    error=true;
  }
}

ID 3138=========================================================================type: 1
Method:org.apache.catalina.connector.Connector#pause()
Rmethod: org.apache.coyote.ProtocolHandler#pause()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Pause the connector.
 */
public void pause(){
  try {
    protocolHandler.pause();
  }
 catch (  Exception e) {
    log.error(sm.getString("coyoteConnector.protocolHandlerPauseFailed"),e);
  }
}

ID 3139=========================================================================type: 1
Method:org.apache.catalina.connector.Connector#resume()
Rmethod: org.apache.coyote.ProtocolHandler#resume()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Pause the connector.
 */
public void resume(){
  try {
    protocolHandler.resume();
  }
 catch (  Exception e) {
    log.error(sm.getString("coyoteConnector.protocolHandlerResumeFailed"),e);
  }
}

ID 3140=========================================================================type: 1
Method:org.apache.catalina.connector.Connector#initInternal()
Rmethod: org.apache.coyote.ProtocolHandler#init()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void initInternal() throws LifecycleException {
  super.initInternal();
  adapter=new CoyoteAdapter(this);
  protocolHandler.setAdapter(adapter);
  if (null == parseBodyMethodsSet) {
    setParseBodyMethods(getParseBodyMethods());
  }
  if (protocolHandler.isAprRequired() && !AprLifecycleListener.isAprAvailable()) {
    throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerNoApr",getProtocolHandlerClassName()));
  }
  try {
    protocolHandler.init();
  }
 catch (  Exception e) {
    throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerInitializationFailed"),e);
  }
  mapperListener.init();
}

ID 3143=========================================================================type: 1
Method:org.apache.catalina.connector.Connector#startInternal()
Rmethod: org.apache.coyote.ProtocolHandler#start()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Begin processing requests via this Connector.
 * @exception LifecycleException if a fatal startup error occurs
 */
@Override protected void startInternal() throws LifecycleException {
  if (getPort() < 0) {
    throw new LifecycleException(sm.getString("coyoteConnector.invalidPort",Integer.valueOf(getPort())));
  }
  setState(LifecycleState.STARTING);
  try {
    protocolHandler.start();
  }
 catch (  Exception e) {
    String errPrefix="";
    if (this.service != null) {
      errPrefix+="service.getName(): \"" + this.service.getName() + "\"; ";
    }
    throw new LifecycleException(errPrefix + " " + sm.getString("coyoteConnector.protocolHandlerStartFailed"),e);
  }
  mapperListener.start();
}

ID 3146=========================================================================type: 1
Method:org.apache.catalina.connector.Connector#stopInternal()
Rmethod: org.apache.coyote.ProtocolHandler#stop()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Terminate processing requests via this Connector.
 * @exception LifecycleException if a fatal shutdown error occurs
 */
@Override protected void stopInternal() throws LifecycleException {
  setState(LifecycleState.STOPPING);
  try {
    protocolHandler.stop();
  }
 catch (  Exception e) {
    throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerStopFailed"),e);
  }
  mapperListener.stop();
}

ID 3149=========================================================================type: 1
Method:org.apache.catalina.connector.Connector#destroyInternal()
Rmethod: org.apache.coyote.ProtocolHandler#destroy()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override protected void destroyInternal() throws LifecycleException {
  mapperListener.destroy();
  try {
    protocolHandler.destroy();
  }
 catch (  Exception e) {
    throw new LifecycleException(sm.getString("coyoteConnector.protocolHandlerDestroyFailed"),e);
  }
  if (getService() != null) {
    getService().removeConnector(this);
  }
  super.destroyInternal();
}

ID 3155=========================================================================type: 1
Method:org.apache.catalina.connector.ResponseFacade#flushBuffer()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public void flushBuffer() throws IOException {
  if (isFinished()) {
    return;
  }
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      AccessController.doPrivileged(new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws IOException {
          response.setAppCommitted(true);
          response.flushBuffer();
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException e) {
      Exception ex=e.getException();
      if (ex instanceof IOException) {
        throw (IOException)ex;
      }
    }
  }
 else {
    response.setAppCommitted(true);
    response.flushBuffer();
  }
}

ID 3168=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteInputStream#read()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public int read() throws IOException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      Integer result=AccessController.doPrivileged(new PrivilegedExceptionAction<Integer>(){
        @Override public Integer run() throws IOException {
          Integer integer=Integer.valueOf(ib.readByte());
          return integer;
        }
      }
);
      return result.intValue();
    }
 catch (    PrivilegedActionException pae) {
      Exception e=pae.getException();
      if (e instanceof IOException) {
        throw (IOException)e;
      }
 else {
        throw new RuntimeException(e.getMessage(),e);
      }
    }
  }
 else {
    return ib.readByte();
  }
}

ID 3170=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteInputStream#available()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public int available() throws IOException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      Integer result=AccessController.doPrivileged(new PrivilegedExceptionAction<Integer>(){
        @Override public Integer run() throws IOException {
          Integer integer=Integer.valueOf(ib.available());
          return integer;
        }
      }
);
      return result.intValue();
    }
 catch (    PrivilegedActionException pae) {
      Exception e=pae.getException();
      if (e instanceof IOException) {
        throw (IOException)e;
      }
 else {
        throw new RuntimeException(e.getMessage(),e);
      }
    }
  }
 else {
    return ib.available();
  }
}

ID 3172=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteInputStream#read(byte[])
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public int read(final byte[] b) throws IOException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      Integer result=AccessController.doPrivileged(new PrivilegedExceptionAction<Integer>(){
        @Override public Integer run() throws IOException {
          Integer integer=Integer.valueOf(ib.read(b,0,b.length));
          return integer;
        }
      }
);
      return result.intValue();
    }
 catch (    PrivilegedActionException pae) {
      Exception e=pae.getException();
      if (e instanceof IOException) {
        throw (IOException)e;
      }
 else {
        throw new RuntimeException(e.getMessage(),e);
      }
    }
  }
 else {
    return ib.read(b,0,b.length);
  }
}

ID 3175=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteInputStream#read(byte[], int, int)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public int read(final byte[] b,final int off,final int len) throws IOException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      Integer result=AccessController.doPrivileged(new PrivilegedExceptionAction<Integer>(){
        @Override public Integer run() throws IOException {
          Integer integer=Integer.valueOf(ib.read(b,off,len));
          return integer;
        }
      }
);
      return result.intValue();
    }
 catch (    PrivilegedActionException pae) {
      Exception e=pae.getException();
      if (e instanceof IOException) {
        throw (IOException)e;
      }
 else {
        throw new RuntimeException(e.getMessage(),e);
      }
    }
  }
 else {
    return ib.read(b,off,len);
  }
}

ID 3178=========================================================================type: 1
Method:org.apache.catalina.connector.CoyoteInputStream#close()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Close the stream Since we re-cycle, we can't allow the call to super.close() which would permanently disable us.
 */
@Override public void close() throws IOException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      AccessController.doPrivileged(new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws IOException {
          ib.close();
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException pae) {
      Exception e=pae.getException();
      if (e instanceof IOException) {
        throw (IOException)e;
      }
 else {
        throw new RuntimeException(e.getMessage(),e);
      }
    }
  }
 else {
    ib.close();
  }
}

ID 3183=========================================================================type: 1
Method:org.apache.catalina.connector.Request#setAttribute(java.lang.String, java.lang.Object)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Set the specified request attribute to the specified value.
 * @param name Name of the request attribute to set
 * @param value The associated value
 */
@Override public void setAttribute(String name,Object value){
  if (name == null) {
    throw new IllegalArgumentException(sm.getString("coyoteRequest.setAttribute.namenull"));
  }
  if (value == null) {
    removeAttribute(name);
    return;
  }
  SpecialAttributeAdapter adapter=specialAttributes.get(name);
  if (adapter != null) {
    adapter.set(this,name,value);
    return;
  }
  if (Globals.IS_SECURITY_ENABLED && name.equals(Globals.SENDFILE_FILENAME_ATTR)) {
    String canonicalPath;
    try {
      canonicalPath=new File(value.toString()).getCanonicalPath();
    }
 catch (    IOException e) {
      throw new SecurityException(sm.getString("coyoteRequest.sendfileNotCanonical",value),e);
    }
    System.getSecurityManager().checkRead(canonicalPath);
    value=canonicalPath;
  }
  Object oldValue=attributes.put(name,value);
  if (name.startsWith("org.apache.tomcat.")) {
    coyoteRequest.setAttribute(name,value);
  }
  notifyAttributeAssigned(name,value,oldValue);
}

ID 3188=========================================================================type: 1
Method:org.apache.catalina.connector.Request#getUserPrincipal()
Rmethod: org.ietf.jgss.GSSCredential#getRemainingLifetime()
parentException: 
thrown: GSSException
exception comment: /** 
 * This exception is thrown whenever a GSS-API error occurs, including any mechanism specific error.  It may contain both the major and the minor GSS-API status codes.  Major error codes are those defined at the GSS-API level in this class. Minor error codes are mechanism specific error codes that can provide additional information. The underlying mechanism implementation is responsible for setting appropriate minor status codes when throwing this exception.  Aside from delivering the numeric error codes to the caller, this class performs the mapping from their numeric values to textual representations. <p>
 * @author Mayank Upadhyay
 * @since 1.4
 */

block: 
/** 
 * Return the principal that has been authenticated for this Request.
 */
@Override public Principal getUserPrincipal(){
  if (userPrincipal instanceof GenericPrincipal) {
    GSSCredential gssCredential=((GenericPrincipal)userPrincipal).getGssCredential();
    if (gssCredential != null) {
      int left=-1;
      try {
        left=gssCredential.getRemainingLifetime();
      }
 catch (      GSSException e) {
        log.warn(sm.getString("coyoteRequest.gssLifetimeFail",userPrincipal.getName()),e);
      }
      if (left == 0) {
        try {
          logout();
        }
 catch (        ServletException e) {
        }
        return null;
      }
    }
    return ((GenericPrincipal)userPrincipal).getUserPrincipal();
  }
  return userPrincipal;
}

ID 3193=========================================================================type: 1
Method:org.apache.catalina.connector.Request#parseParts()
Rmethod: java.io.File#getCanonicalFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void parseParts(){
  if (parts != null || partsParseException != null) {
    return;
  }
  MultipartConfigElement mce=getWrapper().getMultipartConfigElement();
  if (mce == null) {
    if (getContext().getAllowCasualMultipartParsing()) {
      mce=new MultipartConfigElement(null,connector.getMaxPostSize(),connector.getMaxPostSize(),connector.getMaxPostSize());
    }
 else {
      parts=Collections.emptyList();
      return;
    }
  }
  Parameters parameters=coyoteRequest.getParameters();
  parameters.setLimit(getConnector().getMaxParameterCount());
  boolean success=false;
  try {
    File location;
    String locationStr=mce.getLocation();
    if (locationStr == null || locationStr.length() == 0) {
      location=((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR));
    }
 else {
      location=new File(locationStr);
      if (!location.isAbsolute()) {
        location=new File((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR),locationStr).getAbsoluteFile();
      }
    }
    if (!location.isDirectory()) {
      parameters.setParseFailedReason(FailReason.MULTIPART_CONFIG_INVALID);
      partsParseException=new IOException(sm.getString("coyoteRequest.uploadLocationInvalid",location));
      return;
    }
    DiskFileItemFactory factory=new DiskFileItemFactory();
    try {
      factory.setRepository(location.getCanonicalFile());
    }
 catch (    IOException ioe) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=ioe;
      return;
    }
    factory.setSizeThreshold(mce.getFileSizeThreshold());
    ServletFileUpload upload=new ServletFileUpload();
    upload.setFileItemFactory(factory);
    upload.setFileSizeMax(mce.getMaxFileSize());
    upload.setSizeMax(mce.getMaxRequestSize());
    parts=new ArrayList<Part>();
    try {
      List<FileItem> items=upload.parseRequest(new ServletRequestContext(this));
      int maxPostSize=getConnector().getMaxPostSize();
      int postSize=0;
      String enc=getCharacterEncoding();
      Charset charset=null;
      if (enc != null) {
        try {
          charset=B2CConverter.getCharset(enc);
        }
 catch (        UnsupportedEncodingException e) {
        }
      }
      for (      FileItem item : items) {
        ApplicationPart part=new ApplicationPart(item,location);
        parts.add(part);
        if (part.getSubmittedFileName() == null) {
          String name=part.getName();
          String value=null;
          try {
            String encoding=parameters.getEncoding();
            if (encoding == null) {
              if (enc == null) {
                encoding=Parameters.DEFAULT_ENCODING;
              }
 else {
                encoding=enc;
              }
            }
            value=part.getString(encoding);
          }
 catch (          UnsupportedEncodingException uee) {
            try {
              value=part.getString(Parameters.DEFAULT_ENCODING);
            }
 catch (            UnsupportedEncodingException e) {
            }
          }
          if (maxPostSize >= 0) {
            if (charset == null) {
              postSize+=name.getBytes().length;
            }
 else {
              postSize+=name.getBytes(charset).length;
            }
            if (value != null) {
              postSize++;
              postSize+=part.getSize();
            }
            postSize++;
            if (postSize > maxPostSize) {
              parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
              throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded"));
            }
          }
          parameters.addParameter(name,value);
        }
      }
      success=true;
    }
 catch (    InvalidContentTypeException e) {
      parameters.setParseFailedReason(FailReason.INVALID_CONTENT_TYPE);
      partsParseException=new ServletException(e);
    }
catch (    FileUploadBase.SizeException e) {
      parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
      checkSwallowInput();
      partsParseException=new IllegalStateException(e);
    }
catch (    FileUploadException e) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=new IOException(e);
    }
catch (    IllegalStateException e) {
      checkSwallowInput();
      partsParseException=e;
    }
  }
  finally {
    if (partsParseException != null || !success) {
      parameters.setParseFailedReason(FailReason.UNKNOWN);
    }
  }
}

ID 3194=========================================================================type: 1
Method:org.apache.catalina.connector.Request#parseParts()
Rmethod: org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest(org.apache.tomcat.util.http.fileupload.RequestContext)
parentException: 
thrown: FileUploadException
exception comment: null
block: 
private void parseParts(){
  if (parts != null || partsParseException != null) {
    return;
  }
  MultipartConfigElement mce=getWrapper().getMultipartConfigElement();
  if (mce == null) {
    if (getContext().getAllowCasualMultipartParsing()) {
      mce=new MultipartConfigElement(null,connector.getMaxPostSize(),connector.getMaxPostSize(),connector.getMaxPostSize());
    }
 else {
      parts=Collections.emptyList();
      return;
    }
  }
  Parameters parameters=coyoteRequest.getParameters();
  parameters.setLimit(getConnector().getMaxParameterCount());
  boolean success=false;
  try {
    File location;
    String locationStr=mce.getLocation();
    if (locationStr == null || locationStr.length() == 0) {
      location=((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR));
    }
 else {
      location=new File(locationStr);
      if (!location.isAbsolute()) {
        location=new File((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR),locationStr).getAbsoluteFile();
      }
    }
    if (!location.isDirectory()) {
      parameters.setParseFailedReason(FailReason.MULTIPART_CONFIG_INVALID);
      partsParseException=new IOException(sm.getString("coyoteRequest.uploadLocationInvalid",location));
      return;
    }
    DiskFileItemFactory factory=new DiskFileItemFactory();
    try {
      factory.setRepository(location.getCanonicalFile());
    }
 catch (    IOException ioe) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=ioe;
      return;
    }
    factory.setSizeThreshold(mce.getFileSizeThreshold());
    ServletFileUpload upload=new ServletFileUpload();
    upload.setFileItemFactory(factory);
    upload.setFileSizeMax(mce.getMaxFileSize());
    upload.setSizeMax(mce.getMaxRequestSize());
    parts=new ArrayList<Part>();
    try {
      List<FileItem> items=upload.parseRequest(new ServletRequestContext(this));
      int maxPostSize=getConnector().getMaxPostSize();
      int postSize=0;
      String enc=getCharacterEncoding();
      Charset charset=null;
      if (enc != null) {
        try {
          charset=B2CConverter.getCharset(enc);
        }
 catch (        UnsupportedEncodingException e) {
        }
      }
      for (      FileItem item : items) {
        ApplicationPart part=new ApplicationPart(item,location);
        parts.add(part);
        if (part.getSubmittedFileName() == null) {
          String name=part.getName();
          String value=null;
          try {
            String encoding=parameters.getEncoding();
            if (encoding == null) {
              if (enc == null) {
                encoding=Parameters.DEFAULT_ENCODING;
              }
 else {
                encoding=enc;
              }
            }
            value=part.getString(encoding);
          }
 catch (          UnsupportedEncodingException uee) {
            try {
              value=part.getString(Parameters.DEFAULT_ENCODING);
            }
 catch (            UnsupportedEncodingException e) {
            }
          }
          if (maxPostSize >= 0) {
            if (charset == null) {
              postSize+=name.getBytes().length;
            }
 else {
              postSize+=name.getBytes(charset).length;
            }
            if (value != null) {
              postSize++;
              postSize+=part.getSize();
            }
            postSize++;
            if (postSize > maxPostSize) {
              parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
              throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded"));
            }
          }
          parameters.addParameter(name,value);
        }
      }
      success=true;
    }
 catch (    InvalidContentTypeException e) {
      parameters.setParseFailedReason(FailReason.INVALID_CONTENT_TYPE);
      partsParseException=new ServletException(e);
    }
catch (    FileUploadBase.SizeException e) {
      parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
      checkSwallowInput();
      partsParseException=new IllegalStateException(e);
    }
catch (    FileUploadException e) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=new IOException(e);
    }
catch (    IllegalStateException e) {
      checkSwallowInput();
      partsParseException=e;
    }
  }
  finally {
    if (partsParseException != null || !success) {
      parameters.setParseFailedReason(FailReason.UNKNOWN);
    }
  }
}

ID 3196=========================================================================type: 1
Method:org.apache.catalina.connector.Request#parseParts()
Rmethod: org.apache.catalina.core.ApplicationPart#getString(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
private void parseParts(){
  if (parts != null || partsParseException != null) {
    return;
  }
  MultipartConfigElement mce=getWrapper().getMultipartConfigElement();
  if (mce == null) {
    if (getContext().getAllowCasualMultipartParsing()) {
      mce=new MultipartConfigElement(null,connector.getMaxPostSize(),connector.getMaxPostSize(),connector.getMaxPostSize());
    }
 else {
      parts=Collections.emptyList();
      return;
    }
  }
  Parameters parameters=coyoteRequest.getParameters();
  parameters.setLimit(getConnector().getMaxParameterCount());
  boolean success=false;
  try {
    File location;
    String locationStr=mce.getLocation();
    if (locationStr == null || locationStr.length() == 0) {
      location=((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR));
    }
 else {
      location=new File(locationStr);
      if (!location.isAbsolute()) {
        location=new File((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR),locationStr).getAbsoluteFile();
      }
    }
    if (!location.isDirectory()) {
      parameters.setParseFailedReason(FailReason.MULTIPART_CONFIG_INVALID);
      partsParseException=new IOException(sm.getString("coyoteRequest.uploadLocationInvalid",location));
      return;
    }
    DiskFileItemFactory factory=new DiskFileItemFactory();
    try {
      factory.setRepository(location.getCanonicalFile());
    }
 catch (    IOException ioe) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=ioe;
      return;
    }
    factory.setSizeThreshold(mce.getFileSizeThreshold());
    ServletFileUpload upload=new ServletFileUpload();
    upload.setFileItemFactory(factory);
    upload.setFileSizeMax(mce.getMaxFileSize());
    upload.setSizeMax(mce.getMaxRequestSize());
    parts=new ArrayList<Part>();
    try {
      List<FileItem> items=upload.parseRequest(new ServletRequestContext(this));
      int maxPostSize=getConnector().getMaxPostSize();
      int postSize=0;
      String enc=getCharacterEncoding();
      Charset charset=null;
      if (enc != null) {
        try {
          charset=B2CConverter.getCharset(enc);
        }
 catch (        UnsupportedEncodingException e) {
        }
      }
      for (      FileItem item : items) {
        ApplicationPart part=new ApplicationPart(item,location);
        parts.add(part);
        if (part.getSubmittedFileName() == null) {
          String name=part.getName();
          String value=null;
          try {
            String encoding=parameters.getEncoding();
            if (encoding == null) {
              if (enc == null) {
                encoding=Parameters.DEFAULT_ENCODING;
              }
 else {
                encoding=enc;
              }
            }
            value=part.getString(encoding);
          }
 catch (          UnsupportedEncodingException uee) {
            try {
              value=part.getString(Parameters.DEFAULT_ENCODING);
            }
 catch (            UnsupportedEncodingException e) {
            }
          }
          if (maxPostSize >= 0) {
            if (charset == null) {
              postSize+=name.getBytes().length;
            }
 else {
              postSize+=name.getBytes(charset).length;
            }
            if (value != null) {
              postSize++;
              postSize+=part.getSize();
            }
            postSize++;
            if (postSize > maxPostSize) {
              parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
              throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded"));
            }
          }
          parameters.addParameter(name,value);
        }
      }
      success=true;
    }
 catch (    InvalidContentTypeException e) {
      parameters.setParseFailedReason(FailReason.INVALID_CONTENT_TYPE);
      partsParseException=new ServletException(e);
    }
catch (    FileUploadBase.SizeException e) {
      parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
      checkSwallowInput();
      partsParseException=new IllegalStateException(e);
    }
catch (    FileUploadException e) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=new IOException(e);
    }
catch (    IllegalStateException e) {
      checkSwallowInput();
      partsParseException=e;
    }
  }
  finally {
    if (partsParseException != null || !success) {
      parameters.setParseFailedReason(FailReason.UNKNOWN);
    }
  }
}

ID 3198=========================================================================type: 1
Method:org.apache.catalina.connector.Request#parseParts()
Rmethod: org.apache.tomcat.util.http.Parameters#addParameter(java.lang.String, java.lang.String)
parentException: RuntimeException 
thrown: IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

block: 
private void parseParts(){
  if (parts != null || partsParseException != null) {
    return;
  }
  MultipartConfigElement mce=getWrapper().getMultipartConfigElement();
  if (mce == null) {
    if (getContext().getAllowCasualMultipartParsing()) {
      mce=new MultipartConfigElement(null,connector.getMaxPostSize(),connector.getMaxPostSize(),connector.getMaxPostSize());
    }
 else {
      parts=Collections.emptyList();
      return;
    }
  }
  Parameters parameters=coyoteRequest.getParameters();
  parameters.setLimit(getConnector().getMaxParameterCount());
  boolean success=false;
  try {
    File location;
    String locationStr=mce.getLocation();
    if (locationStr == null || locationStr.length() == 0) {
      location=((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR));
    }
 else {
      location=new File(locationStr);
      if (!location.isAbsolute()) {
        location=new File((File)context.getServletContext().getAttribute(ServletContext.TEMPDIR),locationStr).getAbsoluteFile();
      }
    }
    if (!location.isDirectory()) {
      parameters.setParseFailedReason(FailReason.MULTIPART_CONFIG_INVALID);
      partsParseException=new IOException(sm.getString("coyoteRequest.uploadLocationInvalid",location));
      return;
    }
    DiskFileItemFactory factory=new DiskFileItemFactory();
    try {
      factory.setRepository(location.getCanonicalFile());
    }
 catch (    IOException ioe) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=ioe;
      return;
    }
    factory.setSizeThreshold(mce.getFileSizeThreshold());
    ServletFileUpload upload=new ServletFileUpload();
    upload.setFileItemFactory(factory);
    upload.setFileSizeMax(mce.getMaxFileSize());
    upload.setSizeMax(mce.getMaxRequestSize());
    parts=new ArrayList<Part>();
    try {
      List<FileItem> items=upload.parseRequest(new ServletRequestContext(this));
      int maxPostSize=getConnector().getMaxPostSize();
      int postSize=0;
      String enc=getCharacterEncoding();
      Charset charset=null;
      if (enc != null) {
        try {
          charset=B2CConverter.getCharset(enc);
        }
 catch (        UnsupportedEncodingException e) {
        }
      }
      for (      FileItem item : items) {
        ApplicationPart part=new ApplicationPart(item,location);
        parts.add(part);
        if (part.getSubmittedFileName() == null) {
          String name=part.getName();
          String value=null;
          try {
            String encoding=parameters.getEncoding();
            if (encoding == null) {
              if (enc == null) {
                encoding=Parameters.DEFAULT_ENCODING;
              }
 else {
                encoding=enc;
              }
            }
            value=part.getString(encoding);
          }
 catch (          UnsupportedEncodingException uee) {
            try {
              value=part.getString(Parameters.DEFAULT_ENCODING);
            }
 catch (            UnsupportedEncodingException e) {
            }
          }
          if (maxPostSize >= 0) {
            if (charset == null) {
              postSize+=name.getBytes().length;
            }
 else {
              postSize+=name.getBytes(charset).length;
            }
            if (value != null) {
              postSize++;
              postSize+=part.getSize();
            }
            postSize++;
            if (postSize > maxPostSize) {
              parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
              throw new IllegalStateException(sm.getString("coyoteRequest.maxPostSizeExceeded"));
            }
          }
          parameters.addParameter(name,value);
        }
      }
      success=true;
    }
 catch (    InvalidContentTypeException e) {
      parameters.setParseFailedReason(FailReason.INVALID_CONTENT_TYPE);
      partsParseException=new ServletException(e);
    }
catch (    FileUploadBase.SizeException e) {
      parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
      checkSwallowInput();
      partsParseException=new IllegalStateException(e);
    }
catch (    FileUploadException e) {
      parameters.setParseFailedReason(FailReason.IO_ERROR);
      partsParseException=new IOException(e);
    }
catch (    IllegalStateException e) {
      checkSwallowInput();
      partsParseException=e;
    }
  }
  finally {
    if (partsParseException != null || !success) {
      parameters.setParseFailedReason(FailReason.UNKNOWN);
    }
  }
}

ID 3203=========================================================================type: 1
Method:org.apache.catalina.connector.Request#upgrade(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("unchecked") public <T extends HttpUpgradeHandler>T upgrade(Class<T> httpUpgradeHandlerClass) throws ServletException {
  T handler;
  try {
    handler=(T)context.getInstanceManager().newInstance(httpUpgradeHandlerClass);
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
  coyoteRequest.action(ActionCode.UPGRADE,handler);
  response.setStatus(HttpServletResponse.SC_SWITCHING_PROTOCOLS);
  return handler;
}

ID 3204=========================================================================type: 1
Method:org.apache.catalina.connector.Request#upgrade(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@SuppressWarnings("unchecked") public <T extends HttpUpgradeHandler>T upgrade(Class<T> httpUpgradeHandlerClass) throws ServletException {
  T handler;
  try {
    handler=(T)context.getInstanceManager().newInstance(httpUpgradeHandlerClass);
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
  coyoteRequest.action(ActionCode.UPGRADE,handler);
  response.setStatus(HttpServletResponse.SC_SWITCHING_PROTOCOLS);
  return handler;
}

ID 3205=========================================================================type: 1
Method:org.apache.catalina.connector.Request#upgrade(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@SuppressWarnings("unchecked") public <T extends HttpUpgradeHandler>T upgrade(Class<T> httpUpgradeHandlerClass) throws ServletException {
  T handler;
  try {
    handler=(T)context.getInstanceManager().newInstance(httpUpgradeHandlerClass);
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
  coyoteRequest.action(ActionCode.UPGRADE,handler);
  response.setStatus(HttpServletResponse.SC_SWITCHING_PROTOCOLS);
  return handler;
}

ID 3206=========================================================================type: 1
Method:org.apache.catalina.connector.Request#upgrade(Class<T>)
Rmethod: org.apache.tomcat.InstanceManager#newInstance(Class<?>)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("unchecked") public <T extends HttpUpgradeHandler>T upgrade(Class<T> httpUpgradeHandlerClass) throws ServletException {
  T handler;
  try {
    handler=(T)context.getInstanceManager().newInstance(httpUpgradeHandlerClass);
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
catch (  InvocationTargetException e) {
    throw new ServletException(e);
  }
catch (  NamingException e) {
    throw new ServletException(e);
  }
  coyoteRequest.action(ActionCode.UPGRADE,handler);
  response.setStatus(HttpServletResponse.SC_SWITCHING_PROTOCOLS);
  return handler;
}

ID 3207=========================================================================type: 1
Method:org.apache.catalina.connector.Request#doGetSession(boolean)
Rmethod: org.apache.catalina.Manager#findSession(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected Session doGetSession(boolean create){
  Context context=getContext();
  if (context == null) {
    return (null);
  }
  if ((session != null) && !session.isValid()) {
    session=null;
  }
  if (session != null) {
    return (session);
  }
  Manager manager=context.getManager();
  if (manager == null) {
    return null;
  }
  if (requestedSessionId != null) {
    try {
      session=manager.findSession(requestedSessionId);
    }
 catch (    IOException e) {
      session=null;
    }
    if ((session != null) && !session.isValid()) {
      session=null;
    }
    if (session != null) {
      session.access();
      return (session);
    }
  }
  if (!create) {
    return (null);
  }
  if ((response != null) && context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE) && response.getResponse().isCommitted()) {
    throw new IllegalStateException(sm.getString("coyoteRequest.sessionCreateCommitted"));
  }
  String sessionId=getRequestedSessionId();
  if (requestedSessionSSL) {
  }
 else   if (("/".equals(context.getSessionCookiePath()) && isRequestedSessionIdFromCookie())) {
    if (context.getValidateClientProvidedNewSessionId()) {
      boolean found=false;
      for (      Container container : getHost().findChildren()) {
        Manager m=((Context)container).getManager();
        if (m != null) {
          try {
            if (m.findSession(sessionId) != null) {
              found=true;
              break;
            }
          }
 catch (          IOException e) {
          }
        }
      }
      if (!found) {
        sessionId=null;
      }
    }
  }
 else {
    sessionId=null;
  }
  session=manager.createSession(sessionId);
  if ((session != null) && (getContext() != null) && getContext().getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE)) {
    Cookie cookie=ApplicationSessionCookieConfig.createSessionCookie(context,session.getIdInternal(),isSecure());
    response.addSessionCookieInternal(cookie);
  }
  if (session == null) {
    return null;
  }
  session.access();
  return session;
}

ID 3209=========================================================================type: 1
Method:org.apache.catalina.connector.Request#parseParameters()
Rmethod: org.apache.catalina.connector.Request#readPostBody(byte[], int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Parse request parameters.
 */
protected void parseParameters(){
  parametersParsed=true;
  Parameters parameters=coyoteRequest.getParameters();
  boolean success=false;
  try {
    parameters.setLimit(getConnector().getMaxParameterCount());
    String enc=getCharacterEncoding();
    boolean useBodyEncodingForURI=connector.getUseBodyEncodingForURI();
    if (enc != null) {
      parameters.setEncoding(enc);
      if (useBodyEncodingForURI) {
        parameters.setQueryStringEncoding(enc);
      }
    }
 else {
      parameters.setEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);
      if (useBodyEncodingForURI) {
        parameters.setQueryStringEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);
      }
    }
    parameters.handleQueryParameters();
    if (usingInputStream || usingReader) {
      success=true;
      return;
    }
    if (!getConnector().isParseBodyMethod(getMethod())) {
      success=true;
      return;
    }
    String contentType=getContentType();
    if (contentType == null) {
      contentType="";
    }
    int semicolon=contentType.indexOf(';');
    if (semicolon >= 0) {
      contentType=contentType.substring(0,semicolon).trim();
    }
 else {
      contentType=contentType.trim();
    }
    if ("multipart/form-data".equals(contentType)) {
      parseParts();
      success=true;
      return;
    }
    if (!("application/x-www-form-urlencoded".equals(contentType))) {
      success=true;
      return;
    }
    int len=getContentLength();
    if (len > 0) {
      int maxPostSize=connector.getMaxPostSize();
      if ((maxPostSize >= 0) && (len > maxPostSize)) {
        if (context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.postTooLarge"));
        }
        checkSwallowInput();
        parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
        return;
      }
      byte[] formData=null;
      if (len < CACHED_POST_LEN) {
        if (postData == null) {
          postData=new byte[CACHED_POST_LEN];
        }
        formData=postData;
      }
 else {
        formData=new byte[len];
      }
      try {
        if (readPostBody(formData,len) != len) {
          parameters.setParseFailedReason(FailReason.REQUEST_BODY_INCOMPLETE);
          return;
        }
      }
 catch (      IOException e) {
        if (context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"),e);
        }
        parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);
        return;
      }
      parameters.processParameters(formData,0,len);
    }
 else     if ("chunked".equalsIgnoreCase(coyoteRequest.getHeader("transfer-encoding"))) {
      byte[] formData=null;
      try {
        formData=readChunkedPostBody();
      }
 catch (      IllegalStateException ise) {
        parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
        Context context=getContext();
        if (context != null && context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"),ise);
        }
        return;
      }
catch (      IOException e) {
        parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);
        Context context=getContext();
        if (context != null && context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"),e);
        }
        return;
      }
      if (formData != null) {
        parameters.processParameters(formData,0,formData.length);
      }
    }
    success=true;
  }
  finally {
    if (!success) {
      parameters.setParseFailedReason(FailReason.UNKNOWN);
    }
  }
}

ID 3210=========================================================================type: 1
Method:org.apache.catalina.connector.Request#parseParameters()
Rmethod: org.apache.catalina.connector.Request#readChunkedPostBody()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Parse request parameters.
 */
protected void parseParameters(){
  parametersParsed=true;
  Parameters parameters=coyoteRequest.getParameters();
  boolean success=false;
  try {
    parameters.setLimit(getConnector().getMaxParameterCount());
    String enc=getCharacterEncoding();
    boolean useBodyEncodingForURI=connector.getUseBodyEncodingForURI();
    if (enc != null) {
      parameters.setEncoding(enc);
      if (useBodyEncodingForURI) {
        parameters.setQueryStringEncoding(enc);
      }
    }
 else {
      parameters.setEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);
      if (useBodyEncodingForURI) {
        parameters.setQueryStringEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);
      }
    }
    parameters.handleQueryParameters();
    if (usingInputStream || usingReader) {
      success=true;
      return;
    }
    if (!getConnector().isParseBodyMethod(getMethod())) {
      success=true;
      return;
    }
    String contentType=getContentType();
    if (contentType == null) {
      contentType="";
    }
    int semicolon=contentType.indexOf(';');
    if (semicolon >= 0) {
      contentType=contentType.substring(0,semicolon).trim();
    }
 else {
      contentType=contentType.trim();
    }
    if ("multipart/form-data".equals(contentType)) {
      parseParts();
      success=true;
      return;
    }
    if (!("application/x-www-form-urlencoded".equals(contentType))) {
      success=true;
      return;
    }
    int len=getContentLength();
    if (len > 0) {
      int maxPostSize=connector.getMaxPostSize();
      if ((maxPostSize >= 0) && (len > maxPostSize)) {
        if (context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.postTooLarge"));
        }
        checkSwallowInput();
        parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
        return;
      }
      byte[] formData=null;
      if (len < CACHED_POST_LEN) {
        if (postData == null) {
          postData=new byte[CACHED_POST_LEN];
        }
        formData=postData;
      }
 else {
        formData=new byte[len];
      }
      try {
        if (readPostBody(formData,len) != len) {
          parameters.setParseFailedReason(FailReason.REQUEST_BODY_INCOMPLETE);
          return;
        }
      }
 catch (      IOException e) {
        if (context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"),e);
        }
        parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);
        return;
      }
      parameters.processParameters(formData,0,len);
    }
 else     if ("chunked".equalsIgnoreCase(coyoteRequest.getHeader("transfer-encoding"))) {
      byte[] formData=null;
      try {
        formData=readChunkedPostBody();
      }
 catch (      IllegalStateException ise) {
        parameters.setParseFailedReason(FailReason.POST_TOO_LARGE);
        Context context=getContext();
        if (context != null && context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"),ise);
        }
        return;
      }
catch (      IOException e) {
        parameters.setParseFailedReason(FailReason.CLIENT_DISCONNECT);
        Context context=getContext();
        if (context != null && context.getLogger().isDebugEnabled()) {
          context.getLogger().debug(sm.getString("coyoteRequest.parseParameters"),e);
        }
        return;
      }
      if (formData != null) {
        parameters.processParameters(formData,0,formData.length);
      }
    }
    success=true;
  }
  finally {
    if (!success) {
      parameters.setParseFailedReason(FailReason.UNKNOWN);
    }
  }
}

ID 3214=========================================================================type: 1
Method:org.apache.catalina.connector.Request#parseLocalesHeader(java.lang.String, TreeMap<java.lang.Double,ArrayList<java.util.Locale>>)
Rmethod: java.lang.Double#parseDouble(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parse accept-language header value.
 */
protected void parseLocalesHeader(String value,TreeMap<Double,ArrayList<Locale>> locales){
  int white=value.indexOf(' ');
  if (white < 0) {
    white=value.indexOf('\t');
  }
  if (white >= 0) {
    StringBuilder sb=new StringBuilder();
    int len=value.length();
    for (int i=0; i < len; i++) {
      char ch=value.charAt(i);
      if ((ch != ' ') && (ch != '\t')) {
        sb.append(ch);
      }
    }
    parser.setString(sb.toString());
  }
 else {
    parser.setString(value);
  }
  JreCompat jreCompat=JreCompat.getInstance();
  int length=parser.getLength();
  while (true) {
    int start=parser.getIndex();
    if (start >= length) {
      break;
    }
    int end=parser.findChar(',');
    String entry=parser.extract(start,end).trim();
    parser.advance();
    double quality=1.0;
    int semi=entry.indexOf(";q=");
    if (semi >= 0) {
      try {
        String strQuality=entry.substring(semi + 3);
        if (strQuality.length() <= 5) {
          quality=Double.parseDouble(strQuality);
        }
 else {
          quality=0.0;
        }
      }
 catch (      NumberFormatException e) {
        quality=0.0;
      }
      entry=entry.substring(0,semi);
    }
    if (quality < 0.00005) {
      continue;
    }
    if ("*".equals(entry)) {
      continue;
    }
    Locale locale=jreCompat.forLanguageTag(entry);
    if (locale == null) {
      continue;
    }
    Double key=Double.valueOf(-quality);
    ArrayList<Locale> values=locales.get(key);
    if (values == null) {
      values=new ArrayList<Locale>();
      locales.put(key,values);
    }
    values.add(locale);
  }
}

ID 3228=========================================================================type: 1
Method:org.apache.catalina.authenticator.FormAuthenticator#authenticate(org.apache.catalina.connector.Request, javax.servlet.http.HttpServletResponse, org.apache.catalina.deploy.LoginConfig)
Rmethod: org.apache.catalina.authenticator.FormAuthenticator#saveRequest(org.apache.catalina.connector.Request, org.apache.catalina.Session)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Authenticate the user making this request, based on the specified login configuration.  Return <code>true</code> if any specified constraint has been satisfied, or <code>false</code> if we have created a response challenge already.
 * @param request Request we are processing
 * @param response Response we are creating
 * @param config    Login configuration describing how authenticationshould be performed
 * @exception IOException if an input/output error occurs
 */
@Override public boolean authenticate(Request request,HttpServletResponse response,LoginConfig config) throws IOException {
  if (checkForCachedAuthentication(request,response,true)) {
    return (true);
  }
  Session session=null;
  Principal principal=null;
  if (!cache) {
    session=request.getSessionInternal(true);
    if (log.isDebugEnabled()) {
      log.debug("Checking for reauthenticate in session " + session);
    }
    String username=(String)session.getNote(Constants.SESS_USERNAME_NOTE);
    String password=(String)session.getNote(Constants.SESS_PASSWORD_NOTE);
    if ((username != null) && (password != null)) {
      if (log.isDebugEnabled()) {
        log.debug("Reauthenticating username '" + username + "'");
      }
      principal=context.getRealm().authenticate(username,password);
      if (principal != null) {
        session.setNote(Constants.FORM_PRINCIPAL_NOTE,principal);
        if (!matchRequest(request)) {
          register(request,response,principal,HttpServletRequest.FORM_AUTH,username,password);
          return (true);
        }
      }
      if (log.isDebugEnabled()) {
        log.debug("Reauthentication failed, proceed normally");
      }
    }
  }
  if (matchRequest(request)) {
    session=request.getSessionInternal(true);
    if (log.isDebugEnabled()) {
      log.debug("Restore request from session '" + session.getIdInternal() + "'");
    }
    principal=(Principal)session.getNote(Constants.FORM_PRINCIPAL_NOTE);
    register(request,response,principal,HttpServletRequest.FORM_AUTH,(String)session.getNote(Constants.SESS_USERNAME_NOTE),(String)session.getNote(Constants.SESS_PASSWORD_NOTE));
    if (cache) {
      session.removeNote(Constants.SESS_USERNAME_NOTE);
      session.removeNote(Constants.SESS_PASSWORD_NOTE);
    }
    if (restoreRequest(request,session)) {
      if (log.isDebugEnabled()) {
        log.debug("Proceed to restored request");
      }
      return (true);
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("Restore of original request failed");
      }
      response.sendError(HttpServletResponse.SC_BAD_REQUEST);
      return (false);
    }
  }
  MessageBytes uriMB=MessageBytes.newInstance();
  CharChunk uriCC=uriMB.getCharChunk();
  uriCC.setLimit(-1);
  String contextPath=request.getContextPath();
  String requestURI=request.getDecodedRequestURI();
  boolean loginAction=requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION);
  if (!loginAction) {
    if (request.getServletPath().length() == 0 && request.getPathInfo() == null) {
      StringBuilder location=new StringBuilder(requestURI);
      location.append('/');
      if (request.getQueryString() != null) {
        location.append('?');
        location.append(request.getQueryString());
      }
      response.sendRedirect(response.encodeRedirectURL(location.toString()));
      return false;
    }
    session=request.getSessionInternal(true);
    if (log.isDebugEnabled()) {
      log.debug("Save request in session '" + session.getIdInternal() + "'");
    }
    try {
      saveRequest(request,session);
    }
 catch (    IOException ioe) {
      log.debug("Request body too big to save during authentication");
      response.sendError(HttpServletResponse.SC_FORBIDDEN,sm.getString("authenticator.requestBodyTooBig"));
      return (false);
    }
    forwardToLoginPage(request,response,config);
    return (false);
  }
  request.getResponse().sendAcknowledgement();
  Realm realm=context.getRealm();
  if (characterEncoding != null) {
    request.setCharacterEncoding(characterEncoding);
  }
  String username=request.getParameter(Constants.FORM_USERNAME);
  String password=request.getParameter(Constants.FORM_PASSWORD);
  if (log.isDebugEnabled()) {
    log.debug("Authenticating username '" + username + "'");
  }
  principal=realm.authenticate(username,password);
  if (principal == null) {
    forwardToErrorPage(request,response,config);
    return (false);
  }
  if (log.isDebugEnabled()) {
    log.debug("Authentication of '" + username + "' was successful");
  }
  if (session == null) {
    session=request.getSessionInternal(false);
  }
  if (session == null) {
    if (containerLog.isDebugEnabled()) {
      containerLog.debug("User took so long to log on the session expired");
    }
    if (landingPage == null) {
      response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT,sm.getString("authenticator.sessionExpired"));
    }
 else {
      String uri=request.getContextPath() + landingPage;
      SavedRequest saved=new SavedRequest();
      saved.setMethod("GET");
      saved.setRequestURI(uri);
      saved.setDecodedRequestURI(uri);
      request.getSessionInternal(true).setNote(Constants.FORM_REQUEST_NOTE,saved);
      response.sendRedirect(response.encodeRedirectURL(uri));
    }
    return (false);
  }
  session.setNote(Constants.FORM_PRINCIPAL_NOTE,principal);
  session.setNote(Constants.SESS_USERNAME_NOTE,username);
  session.setNote(Constants.SESS_PASSWORD_NOTE,password);
  requestURI=savedRequestURL(session);
  if (log.isDebugEnabled()) {
    log.debug("Redirecting to original '" + requestURI + "'");
  }
  if (requestURI == null) {
    if (landingPage == null) {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST,sm.getString("authenticator.formlogin"));
    }
 else {
      String uri=request.getContextPath() + landingPage;
      SavedRequest saved=new SavedRequest();
      saved.setMethod("GET");
      saved.setRequestURI(uri);
      saved.setDecodedRequestURI(uri);
      session.setNote(Constants.FORM_REQUEST_NOTE,saved);
      response.sendRedirect(response.encodeRedirectURL(uri));
    }
  }
 else {
    response.sendRedirect(response.encodeRedirectURL(requestURI));
  }
  return (false);
}

ID 3229=========================================================================type: 1
Method:org.apache.catalina.authenticator.FormAuthenticator#authenticate(org.apache.catalina.connector.Request, javax.servlet.http.HttpServletResponse, org.apache.catalina.deploy.LoginConfig)
Rmethod: javax.servlet.http.HttpServletResponse#sendError(int, java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Authenticate the user making this request, based on the specified login configuration.  Return <code>true</code> if any specified constraint has been satisfied, or <code>false</code> if we have created a response challenge already.
 * @param request Request we are processing
 * @param response Response we are creating
 * @param config    Login configuration describing how authenticationshould be performed
 * @exception IOException if an input/output error occurs
 */
@Override public boolean authenticate(Request request,HttpServletResponse response,LoginConfig config) throws IOException {
  if (checkForCachedAuthentication(request,response,true)) {
    return (true);
  }
  Session session=null;
  Principal principal=null;
  if (!cache) {
    session=request.getSessionInternal(true);
    if (log.isDebugEnabled()) {
      log.debug("Checking for reauthenticate in session " + session);
    }
    String username=(String)session.getNote(Constants.SESS_USERNAME_NOTE);
    String password=(String)session.getNote(Constants.SESS_PASSWORD_NOTE);
    if ((username != null) && (password != null)) {
      if (log.isDebugEnabled()) {
        log.debug("Reauthenticating username '" + username + "'");
      }
      principal=context.getRealm().authenticate(username,password);
      if (principal != null) {
        session.setNote(Constants.FORM_PRINCIPAL_NOTE,principal);
        if (!matchRequest(request)) {
          register(request,response,principal,HttpServletRequest.FORM_AUTH,username,password);
          return (true);
        }
      }
      if (log.isDebugEnabled()) {
        log.debug("Reauthentication failed, proceed normally");
      }
    }
  }
  if (matchRequest(request)) {
    session=request.getSessionInternal(true);
    if (log.isDebugEnabled()) {
      log.debug("Restore request from session '" + session.getIdInternal() + "'");
    }
    principal=(Principal)session.getNote(Constants.FORM_PRINCIPAL_NOTE);
    register(request,response,principal,HttpServletRequest.FORM_AUTH,(String)session.getNote(Constants.SESS_USERNAME_NOTE),(String)session.getNote(Constants.SESS_PASSWORD_NOTE));
    if (cache) {
      session.removeNote(Constants.SESS_USERNAME_NOTE);
      session.removeNote(Constants.SESS_PASSWORD_NOTE);
    }
    if (restoreRequest(request,session)) {
      if (log.isDebugEnabled()) {
        log.debug("Proceed to restored request");
      }
      return (true);
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("Restore of original request failed");
      }
      response.sendError(HttpServletResponse.SC_BAD_REQUEST);
      return (false);
    }
  }
  MessageBytes uriMB=MessageBytes.newInstance();
  CharChunk uriCC=uriMB.getCharChunk();
  uriCC.setLimit(-1);
  String contextPath=request.getContextPath();
  String requestURI=request.getDecodedRequestURI();
  boolean loginAction=requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION);
  if (!loginAction) {
    if (request.getServletPath().length() == 0 && request.getPathInfo() == null) {
      StringBuilder location=new StringBuilder(requestURI);
      location.append('/');
      if (request.getQueryString() != null) {
        location.append('?');
        location.append(request.getQueryString());
      }
      response.sendRedirect(response.encodeRedirectURL(location.toString()));
      return false;
    }
    session=request.getSessionInternal(true);
    if (log.isDebugEnabled()) {
      log.debug("Save request in session '" + session.getIdInternal() + "'");
    }
    try {
      saveRequest(request,session);
    }
 catch (    IOException ioe) {
      log.debug("Request body too big to save during authentication");
      response.sendError(HttpServletResponse.SC_FORBIDDEN,sm.getString("authenticator.requestBodyTooBig"));
      return (false);
    }
    forwardToLoginPage(request,response,config);
    return (false);
  }
  request.getResponse().sendAcknowledgement();
  Realm realm=context.getRealm();
  if (characterEncoding != null) {
    request.setCharacterEncoding(characterEncoding);
  }
  String username=request.getParameter(Constants.FORM_USERNAME);
  String password=request.getParameter(Constants.FORM_PASSWORD);
  if (log.isDebugEnabled()) {
    log.debug("Authenticating username '" + username + "'");
  }
  principal=realm.authenticate(username,password);
  if (principal == null) {
    forwardToErrorPage(request,response,config);
    return (false);
  }
  if (log.isDebugEnabled()) {
    log.debug("Authentication of '" + username + "' was successful");
  }
  if (session == null) {
    session=request.getSessionInternal(false);
  }
  if (session == null) {
    if (containerLog.isDebugEnabled()) {
      containerLog.debug("User took so long to log on the session expired");
    }
    if (landingPage == null) {
      response.sendError(HttpServletResponse.SC_REQUEST_TIMEOUT,sm.getString("authenticator.sessionExpired"));
    }
 else {
      String uri=request.getContextPath() + landingPage;
      SavedRequest saved=new SavedRequest();
      saved.setMethod("GET");
      saved.setRequestURI(uri);
      saved.setDecodedRequestURI(uri);
      request.getSessionInternal(true).setNote(Constants.FORM_REQUEST_NOTE,saved);
      response.sendRedirect(response.encodeRedirectURL(uri));
    }
    return (false);
  }
  session.setNote(Constants.FORM_PRINCIPAL_NOTE,principal);
  session.setNote(Constants.SESS_USERNAME_NOTE,username);
  session.setNote(Constants.SESS_PASSWORD_NOTE,password);
  requestURI=savedRequestURL(session);
  if (log.isDebugEnabled()) {
    log.debug("Redirecting to original '" + requestURI + "'");
  }
  if (requestURI == null) {
    if (landingPage == null) {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST,sm.getString("authenticator.formlogin"));
    }
 else {
      String uri=request.getContextPath() + landingPage;
      SavedRequest saved=new SavedRequest();
      saved.setMethod("GET");
      saved.setRequestURI(uri);
      saved.setDecodedRequestURI(uri);
      session.setNote(Constants.FORM_REQUEST_NOTE,saved);
      response.sendRedirect(response.encodeRedirectURL(uri));
    }
  }
 else {
    response.sendRedirect(response.encodeRedirectURL(requestURI));
  }
  return (false);
}

ID 3249=========================================================================type: 1
Method:org.apache.catalina.authenticator.SingleSignOn#expire(org.apache.catalina.authenticator.SingleSignOnSessionKey)
Rmethod: org.apache.catalina.Manager#findSession(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void expire(SingleSignOnSessionKey key){
  if (engine == null) {
    containerLog.warn(sm.getString("singleSignOn.sessionExpire.engineNull",key));
    return;
  }
  Container host=engine.findChild(key.getHostName());
  if (host == null) {
    containerLog.warn(sm.getString("singleSignOn.sessionExpire.hostNotFound",key));
    return;
  }
  Context context=(Context)host.findChild(key.getContextName());
  if (context == null) {
    containerLog.warn(sm.getString("singleSignOn.sessionExpire.contextNotFound",key));
    return;
  }
  Manager manager=context.getManager();
  if (manager == null) {
    containerLog.warn(sm.getString("singleSignOn.sessionExpire.managerNotFound",key));
    return;
  }
  Session session=null;
  try {
    session=manager.findSession(key.getSessionId());
  }
 catch (  IOException e) {
    containerLog.warn(sm.getString("singleSignOn.sessionExpire.managerError",key),e);
    return;
  }
  if (session == null) {
    containerLog.warn(sm.getString("singleSignOn.sessionExpire.sessionNotFound",key));
    return;
  }
  session.expire();
}

ID 3261=========================================================================type: 1
Method:org.apache.catalina.authenticator.DigestAuthenticator#DigestAuthenticator()
Rmethod: java.security.MessageDigest#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
public DigestAuthenticator(){
  super();
  setCache(false);
  try {
    if (md5Helper == null)     md5Helper=MessageDigest.getInstance("MD5");
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalStateException(e);
  }
}

ID 3264=========================================================================type: 1
Method:org.apache.catalina.authenticator.DigestInfo#parse(org.apache.catalina.connector.Request, java.lang.String)
Rmethod: org.apache.tomcat.util.http.parser.HttpParser#parseAuthorizationDigest(java.io.StringReader)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public boolean parse(Request request,String authorization){
  if (authorization == null) {
    return false;
  }
  Map<String,String> directives;
  try {
    directives=HttpParser.parseAuthorizationDigest(new StringReader(authorization));
  }
 catch (  IOException e) {
    return false;
  }
  if (directives == null) {
    return false;
  }
  method=request.getMethod();
  userName=directives.get("username");
  realmName=directives.get("realm");
  nonce=directives.get("nonce");
  nc=directives.get("nc");
  cnonce=directives.get("cnonce");
  qop=directives.get("qop");
  uri=directives.get("uri");
  response=directives.get("response");
  opaqueReceived=directives.get("opaque");
  return true;
}

ID 3265=========================================================================type: 1
Method:org.apache.catalina.authenticator.DigestInfo#validate(org.apache.catalina.connector.Request, org.apache.catalina.deploy.LoginConfig)
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public boolean validate(Request request,LoginConfig config){
  if ((userName == null) || (realmName == null) || (nonce == null)|| (uri == null)|| (response == null)) {
    return false;
  }
  if (validateUri) {
    String uriQuery;
    String query=request.getQueryString();
    if (query == null) {
      uriQuery=request.getRequestURI();
    }
 else {
      uriQuery=request.getRequestURI() + "?" + query;
    }
    if (!uri.equals(uriQuery)) {
      String host=request.getHeader("host");
      String scheme=request.getScheme();
      if (host != null && !uriQuery.startsWith(scheme)) {
        StringBuilder absolute=new StringBuilder();
        absolute.append(scheme);
        absolute.append("://");
        absolute.append(host);
        absolute.append(uriQuery);
        if (!uri.equals(absolute.toString())) {
          return false;
        }
      }
 else {
        return false;
      }
    }
  }
  String lcRealm=config.getRealmName();
  if (lcRealm == null) {
    lcRealm=REALM_NAME;
  }
  if (!lcRealm.equals(realmName)) {
    return false;
  }
  if (!opaque.equals(opaqueReceived)) {
    return false;
  }
  int i=nonce.indexOf(':');
  if (i < 0 || (i + 1) == nonce.length()) {
    return false;
  }
  long nonceTime;
  try {
    nonceTime=Long.parseLong(nonce.substring(0,i));
  }
 catch (  NumberFormatException nfe) {
    return false;
  }
  String md5clientIpTimeKey=nonce.substring(i + 1);
  long currentTime=System.currentTimeMillis();
  if ((currentTime - nonceTime) > nonceValidity) {
    nonceStale=true;
synchronized (nonces) {
      nonces.remove(nonce);
    }
  }
  String serverIpTimeKey=request.getRemoteAddr() + ":" + nonceTime+ ":"+ key;
  byte[] buffer=ConcurrentMessageDigest.digestMD5(serverIpTimeKey.getBytes(B2CConverter.ISO_8859_1));
  String md5ServerIpTimeKey=MD5Encoder.encode(buffer);
  if (!md5ServerIpTimeKey.equals(md5clientIpTimeKey)) {
    return false;
  }
  if (qop != null && !QOP.equals(qop)) {
    return false;
  }
  if (qop == null) {
    if (cnonce != null || nc != null) {
      return false;
    }
  }
 else {
    if (cnonce == null || nc == null) {
      return false;
    }
    if (nc.length() < 6 || nc.length() > 8) {
      return false;
    }
    long count;
    try {
      count=Long.parseLong(nc,16);
    }
 catch (    NumberFormatException nfe) {
      return false;
    }
    NonceInfo info;
synchronized (nonces) {
      info=nonces.get(nonce);
    }
    if (info == null) {
      nonceStale=true;
    }
 else {
      if (!info.nonceCountValid(count)) {
        return false;
      }
    }
  }
  return true;
}

ID 3266=========================================================================type: 1
Method:org.apache.catalina.authenticator.DigestInfo#validate(org.apache.catalina.connector.Request, org.apache.catalina.deploy.LoginConfig)
Rmethod: java.lang.Long#parseLong(java.lang.String, int)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public boolean validate(Request request,LoginConfig config){
  if ((userName == null) || (realmName == null) || (nonce == null)|| (uri == null)|| (response == null)) {
    return false;
  }
  if (validateUri) {
    String uriQuery;
    String query=request.getQueryString();
    if (query == null) {
      uriQuery=request.getRequestURI();
    }
 else {
      uriQuery=request.getRequestURI() + "?" + query;
    }
    if (!uri.equals(uriQuery)) {
      String host=request.getHeader("host");
      String scheme=request.getScheme();
      if (host != null && !uriQuery.startsWith(scheme)) {
        StringBuilder absolute=new StringBuilder();
        absolute.append(scheme);
        absolute.append("://");
        absolute.append(host);
        absolute.append(uriQuery);
        if (!uri.equals(absolute.toString())) {
          return false;
        }
      }
 else {
        return false;
      }
    }
  }
  String lcRealm=config.getRealmName();
  if (lcRealm == null) {
    lcRealm=REALM_NAME;
  }
  if (!lcRealm.equals(realmName)) {
    return false;
  }
  if (!opaque.equals(opaqueReceived)) {
    return false;
  }
  int i=nonce.indexOf(':');
  if (i < 0 || (i + 1) == nonce.length()) {
    return false;
  }
  long nonceTime;
  try {
    nonceTime=Long.parseLong(nonce.substring(0,i));
  }
 catch (  NumberFormatException nfe) {
    return false;
  }
  String md5clientIpTimeKey=nonce.substring(i + 1);
  long currentTime=System.currentTimeMillis();
  if ((currentTime - nonceTime) > nonceValidity) {
    nonceStale=true;
synchronized (nonces) {
      nonces.remove(nonce);
    }
  }
  String serverIpTimeKey=request.getRemoteAddr() + ":" + nonceTime+ ":"+ key;
  byte[] buffer=ConcurrentMessageDigest.digestMD5(serverIpTimeKey.getBytes(B2CConverter.ISO_8859_1));
  String md5ServerIpTimeKey=MD5Encoder.encode(buffer);
  if (!md5ServerIpTimeKey.equals(md5clientIpTimeKey)) {
    return false;
  }
  if (qop != null && !QOP.equals(qop)) {
    return false;
  }
  if (qop == null) {
    if (cnonce != null || nc != null) {
      return false;
    }
  }
 else {
    if (cnonce == null || nc == null) {
      return false;
    }
    if (nc.length() < 6 || nc.length() > 8) {
      return false;
    }
    long count;
    try {
      count=Long.parseLong(nc,16);
    }
 catch (    NumberFormatException nfe) {
      return false;
    }
    NonceInfo info;
synchronized (nonces) {
      info=nonces.get(nonce);
    }
    if (info == null) {
      nonceStale=true;
    }
 else {
      if (!info.nonceCountValid(count)) {
        return false;
      }
    }
  }
  return true;
}

ID 3268=========================================================================type: 1
Method:org.apache.catalina.authenticator.SpnegoAuthenticator#authenticate(org.apache.catalina.connector.Request, javax.servlet.http.HttpServletResponse, org.apache.catalina.deploy.LoginConfig)
Rmethod: javax.security.auth.login.LoginContext#LoginContext(java.lang.String)
parentException: GeneralSecurityException 
thrown: LoginException
exception comment: /** 
 * This is the basic login exception.
 * @see javax.security.auth.login.LoginContext
 */

block: 
@Override public boolean authenticate(Request request,HttpServletResponse response,LoginConfig config) throws IOException {
  if (checkForCachedAuthentication(request,response,true)) {
    return true;
  }
  MessageBytes authorization=request.getCoyoteRequest().getMimeHeaders().getValue("authorization");
  if (authorization == null) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("authenticator.noAuthHeader"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorization.toBytes();
  ByteChunk authorizationBC=authorization.getByteChunk();
  if (!authorizationBC.startsWithIgnoreCase("negotiate ",0)) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNotNego"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorizationBC.setOffset(authorizationBC.getOffset() + 10);
  byte[] decoded=Base64.decodeBase64(authorizationBC.getBuffer(),authorizationBC.getOffset(),authorizationBC.getLength());
  if (getApplyJava8u40Fix()) {
    SpnegoTokenFixer.fix(decoded);
  }
  if (decoded.length == 0) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNoToken"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  LoginContext lc=null;
  GSSContext gssContext=null;
  byte[] outToken=null;
  Principal principal=null;
  try {
    try {
      lc=new LoginContext(getLoginConfigName());
      lc.login();
    }
 catch (    LoginException e) {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
      return false;
    }
    Subject subject=lc.getSubject();
    final GSSManager manager=GSSManager.getInstance();
    final int credentialLifetime;
    if (JreVendor.IS_IBM_JVM) {
      credentialLifetime=GSSCredential.INDEFINITE_LIFETIME;
    }
 else {
      credentialLifetime=GSSCredential.DEFAULT_LIFETIME;
    }
    final PrivilegedExceptionAction<GSSCredential> action=new PrivilegedExceptionAction<GSSCredential>(){
      @Override public GSSCredential run() throws GSSException {
        return manager.createCredential(null,credentialLifetime,new Oid("1.3.6.1.5.5.2"),GSSCredential.ACCEPT_ONLY);
      }
    }
;
    gssContext=manager.createContext(Subject.doAs(subject,action));
    outToken=Subject.doAs(lc.getSubject(),new AcceptAction(gssContext,decoded));
    if (outToken == null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"));
      }
      response.setHeader("WWW-Authenticate","Negotiate");
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
      return false;
    }
    principal=Subject.doAs(subject,new AuthenticateAction(context.getRealm(),gssContext,storeDelegatedCredential));
  }
 catch (  GSSException e) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
catch (  PrivilegedActionException e) {
    Throwable cause=e.getCause();
    if (cause instanceof GSSException) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      }
    }
 else {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
 finally {
    if (gssContext != null) {
      try {
        gssContext.dispose();
      }
 catch (      GSSException e) {
      }
    }
    if (lc != null) {
      try {
        lc.logout();
      }
 catch (      LoginException e) {
      }
    }
  }
  response.setHeader("WWW-Authenticate","Negotiate " + Base64.encodeBase64String(outToken));
  if (principal != null) {
    register(request,response,principal,Constants.SPNEGO_METHOD,principal.getName(),null);
    Pattern p=noKeepAliveUserAgents;
    if (p != null) {
      MessageBytes ua=request.getCoyoteRequest().getMimeHeaders().getValue("user-agent");
      if (ua != null && p.matcher(ua.toString()).matches()) {
        response.setHeader("Connection","close");
      }
    }
    return true;
  }
  response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
  return false;
}

ID 3269=========================================================================type: 1
Method:org.apache.catalina.authenticator.SpnegoAuthenticator#authenticate(org.apache.catalina.connector.Request, javax.servlet.http.HttpServletResponse, org.apache.catalina.deploy.LoginConfig)
Rmethod: javax.security.auth.login.LoginContext#login()
parentException: GeneralSecurityException 
thrown: LoginException
exception comment: /** 
 * This is the basic login exception.
 * @see javax.security.auth.login.LoginContext
 */

block: 
@Override public boolean authenticate(Request request,HttpServletResponse response,LoginConfig config) throws IOException {
  if (checkForCachedAuthentication(request,response,true)) {
    return true;
  }
  MessageBytes authorization=request.getCoyoteRequest().getMimeHeaders().getValue("authorization");
  if (authorization == null) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("authenticator.noAuthHeader"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorization.toBytes();
  ByteChunk authorizationBC=authorization.getByteChunk();
  if (!authorizationBC.startsWithIgnoreCase("negotiate ",0)) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNotNego"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorizationBC.setOffset(authorizationBC.getOffset() + 10);
  byte[] decoded=Base64.decodeBase64(authorizationBC.getBuffer(),authorizationBC.getOffset(),authorizationBC.getLength());
  if (getApplyJava8u40Fix()) {
    SpnegoTokenFixer.fix(decoded);
  }
  if (decoded.length == 0) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNoToken"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  LoginContext lc=null;
  GSSContext gssContext=null;
  byte[] outToken=null;
  Principal principal=null;
  try {
    try {
      lc=new LoginContext(getLoginConfigName());
      lc.login();
    }
 catch (    LoginException e) {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
      return false;
    }
    Subject subject=lc.getSubject();
    final GSSManager manager=GSSManager.getInstance();
    final int credentialLifetime;
    if (JreVendor.IS_IBM_JVM) {
      credentialLifetime=GSSCredential.INDEFINITE_LIFETIME;
    }
 else {
      credentialLifetime=GSSCredential.DEFAULT_LIFETIME;
    }
    final PrivilegedExceptionAction<GSSCredential> action=new PrivilegedExceptionAction<GSSCredential>(){
      @Override public GSSCredential run() throws GSSException {
        return manager.createCredential(null,credentialLifetime,new Oid("1.3.6.1.5.5.2"),GSSCredential.ACCEPT_ONLY);
      }
    }
;
    gssContext=manager.createContext(Subject.doAs(subject,action));
    outToken=Subject.doAs(lc.getSubject(),new AcceptAction(gssContext,decoded));
    if (outToken == null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"));
      }
      response.setHeader("WWW-Authenticate","Negotiate");
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
      return false;
    }
    principal=Subject.doAs(subject,new AuthenticateAction(context.getRealm(),gssContext,storeDelegatedCredential));
  }
 catch (  GSSException e) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
catch (  PrivilegedActionException e) {
    Throwable cause=e.getCause();
    if (cause instanceof GSSException) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      }
    }
 else {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
 finally {
    if (gssContext != null) {
      try {
        gssContext.dispose();
      }
 catch (      GSSException e) {
      }
    }
    if (lc != null) {
      try {
        lc.logout();
      }
 catch (      LoginException e) {
      }
    }
  }
  response.setHeader("WWW-Authenticate","Negotiate " + Base64.encodeBase64String(outToken));
  if (principal != null) {
    register(request,response,principal,Constants.SPNEGO_METHOD,principal.getName(),null);
    Pattern p=noKeepAliveUserAgents;
    if (p != null) {
      MessageBytes ua=request.getCoyoteRequest().getMimeHeaders().getValue("user-agent");
      if (ua != null && p.matcher(ua.toString()).matches()) {
        response.setHeader("Connection","close");
      }
    }
    return true;
  }
  response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
  return false;
}

ID 3272=========================================================================type: 1
Method:org.apache.catalina.authenticator.SpnegoAuthenticator#authenticate(org.apache.catalina.connector.Request, javax.servlet.http.HttpServletResponse, org.apache.catalina.deploy.LoginConfig)
Rmethod: javax.security.auth.Subject#doAs(javax.security.auth.Subject, PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public boolean authenticate(Request request,HttpServletResponse response,LoginConfig config) throws IOException {
  if (checkForCachedAuthentication(request,response,true)) {
    return true;
  }
  MessageBytes authorization=request.getCoyoteRequest().getMimeHeaders().getValue("authorization");
  if (authorization == null) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("authenticator.noAuthHeader"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorization.toBytes();
  ByteChunk authorizationBC=authorization.getByteChunk();
  if (!authorizationBC.startsWithIgnoreCase("negotiate ",0)) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNotNego"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorizationBC.setOffset(authorizationBC.getOffset() + 10);
  byte[] decoded=Base64.decodeBase64(authorizationBC.getBuffer(),authorizationBC.getOffset(),authorizationBC.getLength());
  if (getApplyJava8u40Fix()) {
    SpnegoTokenFixer.fix(decoded);
  }
  if (decoded.length == 0) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNoToken"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  LoginContext lc=null;
  GSSContext gssContext=null;
  byte[] outToken=null;
  Principal principal=null;
  try {
    try {
      lc=new LoginContext(getLoginConfigName());
      lc.login();
    }
 catch (    LoginException e) {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
      return false;
    }
    Subject subject=lc.getSubject();
    final GSSManager manager=GSSManager.getInstance();
    final int credentialLifetime;
    if (JreVendor.IS_IBM_JVM) {
      credentialLifetime=GSSCredential.INDEFINITE_LIFETIME;
    }
 else {
      credentialLifetime=GSSCredential.DEFAULT_LIFETIME;
    }
    final PrivilegedExceptionAction<GSSCredential> action=new PrivilegedExceptionAction<GSSCredential>(){
      @Override public GSSCredential run() throws GSSException {
        return manager.createCredential(null,credentialLifetime,new Oid("1.3.6.1.5.5.2"),GSSCredential.ACCEPT_ONLY);
      }
    }
;
    gssContext=manager.createContext(Subject.doAs(subject,action));
    outToken=Subject.doAs(lc.getSubject(),new AcceptAction(gssContext,decoded));
    if (outToken == null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"));
      }
      response.setHeader("WWW-Authenticate","Negotiate");
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
      return false;
    }
    principal=Subject.doAs(subject,new AuthenticateAction(context.getRealm(),gssContext,storeDelegatedCredential));
  }
 catch (  GSSException e) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
catch (  PrivilegedActionException e) {
    Throwable cause=e.getCause();
    if (cause instanceof GSSException) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      }
    }
 else {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
 finally {
    if (gssContext != null) {
      try {
        gssContext.dispose();
      }
 catch (      GSSException e) {
      }
    }
    if (lc != null) {
      try {
        lc.logout();
      }
 catch (      LoginException e) {
      }
    }
  }
  response.setHeader("WWW-Authenticate","Negotiate " + Base64.encodeBase64String(outToken));
  if (principal != null) {
    register(request,response,principal,Constants.SPNEGO_METHOD,principal.getName(),null);
    Pattern p=noKeepAliveUserAgents;
    if (p != null) {
      MessageBytes ua=request.getCoyoteRequest().getMimeHeaders().getValue("user-agent");
      if (ua != null && p.matcher(ua.toString()).matches()) {
        response.setHeader("Connection","close");
      }
    }
    return true;
  }
  response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
  return false;
}

ID 3273=========================================================================type: 1
Method:org.apache.catalina.authenticator.SpnegoAuthenticator#authenticate(org.apache.catalina.connector.Request, javax.servlet.http.HttpServletResponse, org.apache.catalina.deploy.LoginConfig)
Rmethod: org.ietf.jgss.GSSManager#createContext(org.ietf.jgss.GSSCredential)
parentException: 
thrown: GSSException
exception comment: /** 
 * This exception is thrown whenever a GSS-API error occurs, including any mechanism specific error.  It may contain both the major and the minor GSS-API status codes.  Major error codes are those defined at the GSS-API level in this class. Minor error codes are mechanism specific error codes that can provide additional information. The underlying mechanism implementation is responsible for setting appropriate minor status codes when throwing this exception.  Aside from delivering the numeric error codes to the caller, this class performs the mapping from their numeric values to textual representations. <p>
 * @author Mayank Upadhyay
 * @since 1.4
 */

block: 
@Override public boolean authenticate(Request request,HttpServletResponse response,LoginConfig config) throws IOException {
  if (checkForCachedAuthentication(request,response,true)) {
    return true;
  }
  MessageBytes authorization=request.getCoyoteRequest().getMimeHeaders().getValue("authorization");
  if (authorization == null) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("authenticator.noAuthHeader"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorization.toBytes();
  ByteChunk authorizationBC=authorization.getByteChunk();
  if (!authorizationBC.startsWithIgnoreCase("negotiate ",0)) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNotNego"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  authorizationBC.setOffset(authorizationBC.getOffset() + 10);
  byte[] decoded=Base64.decodeBase64(authorizationBC.getBuffer(),authorizationBC.getOffset(),authorizationBC.getLength());
  if (getApplyJava8u40Fix()) {
    SpnegoTokenFixer.fix(decoded);
  }
  if (decoded.length == 0) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.authHeaderNoToken"));
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
  LoginContext lc=null;
  GSSContext gssContext=null;
  byte[] outToken=null;
  Principal principal=null;
  try {
    try {
      lc=new LoginContext(getLoginConfigName());
      lc.login();
    }
 catch (    LoginException e) {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
      return false;
    }
    Subject subject=lc.getSubject();
    final GSSManager manager=GSSManager.getInstance();
    final int credentialLifetime;
    if (JreVendor.IS_IBM_JVM) {
      credentialLifetime=GSSCredential.INDEFINITE_LIFETIME;
    }
 else {
      credentialLifetime=GSSCredential.DEFAULT_LIFETIME;
    }
    final PrivilegedExceptionAction<GSSCredential> action=new PrivilegedExceptionAction<GSSCredential>(){
      @Override public GSSCredential run() throws GSSException {
        return manager.createCredential(null,credentialLifetime,new Oid("1.3.6.1.5.5.2"),GSSCredential.ACCEPT_ONLY);
      }
    }
;
    gssContext=manager.createContext(Subject.doAs(subject,action));
    outToken=Subject.doAs(lc.getSubject(),new AcceptAction(gssContext,decoded));
    if (outToken == null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"));
      }
      response.setHeader("WWW-Authenticate","Negotiate");
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
      return false;
    }
    principal=Subject.doAs(subject,new AuthenticateAction(context.getRealm(),gssContext,storeDelegatedCredential));
  }
 catch (  GSSException e) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("spnegoAuthenticator.ticketValidateFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
catch (  PrivilegedActionException e) {
    Throwable cause=e.getCause();
    if (cause instanceof GSSException) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
      }
    }
 else {
      log.error(sm.getString("spnegoAuthenticator.serviceLoginFail"),e);
    }
    response.setHeader("WWW-Authenticate","Negotiate");
    response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
    return false;
  }
 finally {
    if (gssContext != null) {
      try {
        gssContext.dispose();
      }
 catch (      GSSException e) {
      }
    }
    if (lc != null) {
      try {
        lc.logout();
      }
 catch (      LoginException e) {
      }
    }
  }
  response.setHeader("WWW-Authenticate","Negotiate " + Base64.encodeBase64String(outToken));
  if (principal != null) {
    register(request,response,principal,Constants.SPNEGO_METHOD,principal.getName(),null);
    Pattern p=noKeepAliveUserAgents;
    if (p != null) {
      MessageBytes ua=request.getCoyoteRequest().getMimeHeaders().getValue("user-agent");
      if (ua != null && p.matcher(ua.toString()).matches()) {
        response.setHeader("Connection","close");
      }
    }
    return true;
  }
  response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
  return false;
}

ID 3346=========================================================================type: 1
Method:org.apache.catalina.startup.Bootstrap#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.Bootstrap#init()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Main method and entry point when starting Tomcat via the provided scripts.
 * @param args Command line arguments to be processed
 */
public static void main(String args[]){
  if (daemon == null) {
    Bootstrap bootstrap=new Bootstrap();
    try {
      bootstrap.init();
    }
 catch (    Throwable t) {
      handleThrowable(t);
      t.printStackTrace();
      return;
    }
    daemon=bootstrap;
  }
 else {
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  }
  try {
    String command="start";
    if (args.length > 0) {
      command=args[args.length - 1];
    }
    if (command.equals("startd")) {
      args[args.length - 1]="start";
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stopd")) {
      args[args.length - 1]="stop";
      daemon.stop();
    }
 else     if (command.equals("start")) {
      daemon.setAwait(true);
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stop")) {
      daemon.stopServer(args);
    }
 else     if (command.equals("configtest")) {
      daemon.load(args);
      if (null == daemon.getServer()) {
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
  }
 catch (  Throwable t) {
    if (t instanceof InvocationTargetException && t.getCause() != null) {
      t=t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
  }
}

ID 3347=========================================================================type: 1
Method:org.apache.catalina.startup.Bootstrap#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.Bootstrap#load(java.lang.String[])
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Main method and entry point when starting Tomcat via the provided scripts.
 * @param args Command line arguments to be processed
 */
public static void main(String args[]){
  if (daemon == null) {
    Bootstrap bootstrap=new Bootstrap();
    try {
      bootstrap.init();
    }
 catch (    Throwable t) {
      handleThrowable(t);
      t.printStackTrace();
      return;
    }
    daemon=bootstrap;
  }
 else {
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  }
  try {
    String command="start";
    if (args.length > 0) {
      command=args[args.length - 1];
    }
    if (command.equals("startd")) {
      args[args.length - 1]="start";
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stopd")) {
      args[args.length - 1]="stop";
      daemon.stop();
    }
 else     if (command.equals("start")) {
      daemon.setAwait(true);
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stop")) {
      daemon.stopServer(args);
    }
 else     if (command.equals("configtest")) {
      daemon.load(args);
      if (null == daemon.getServer()) {
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
  }
 catch (  Throwable t) {
    if (t instanceof InvocationTargetException && t.getCause() != null) {
      t=t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
  }
}

ID 3348=========================================================================type: 1
Method:org.apache.catalina.startup.Bootstrap#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.Bootstrap#start()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Main method and entry point when starting Tomcat via the provided scripts.
 * @param args Command line arguments to be processed
 */
public static void main(String args[]){
  if (daemon == null) {
    Bootstrap bootstrap=new Bootstrap();
    try {
      bootstrap.init();
    }
 catch (    Throwable t) {
      handleThrowable(t);
      t.printStackTrace();
      return;
    }
    daemon=bootstrap;
  }
 else {
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  }
  try {
    String command="start";
    if (args.length > 0) {
      command=args[args.length - 1];
    }
    if (command.equals("startd")) {
      args[args.length - 1]="start";
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stopd")) {
      args[args.length - 1]="stop";
      daemon.stop();
    }
 else     if (command.equals("start")) {
      daemon.setAwait(true);
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stop")) {
      daemon.stopServer(args);
    }
 else     if (command.equals("configtest")) {
      daemon.load(args);
      if (null == daemon.getServer()) {
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
  }
 catch (  Throwable t) {
    if (t instanceof InvocationTargetException && t.getCause() != null) {
      t=t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
  }
}

ID 3349=========================================================================type: 1
Method:org.apache.catalina.startup.Bootstrap#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.Bootstrap#stop()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Main method and entry point when starting Tomcat via the provided scripts.
 * @param args Command line arguments to be processed
 */
public static void main(String args[]){
  if (daemon == null) {
    Bootstrap bootstrap=new Bootstrap();
    try {
      bootstrap.init();
    }
 catch (    Throwable t) {
      handleThrowable(t);
      t.printStackTrace();
      return;
    }
    daemon=bootstrap;
  }
 else {
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  }
  try {
    String command="start";
    if (args.length > 0) {
      command=args[args.length - 1];
    }
    if (command.equals("startd")) {
      args[args.length - 1]="start";
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stopd")) {
      args[args.length - 1]="stop";
      daemon.stop();
    }
 else     if (command.equals("start")) {
      daemon.setAwait(true);
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stop")) {
      daemon.stopServer(args);
    }
 else     if (command.equals("configtest")) {
      daemon.load(args);
      if (null == daemon.getServer()) {
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
  }
 catch (  Throwable t) {
    if (t instanceof InvocationTargetException && t.getCause() != null) {
      t=t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
  }
}

ID 3350=========================================================================type: 1
Method:org.apache.catalina.startup.Bootstrap#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.Bootstrap#setAwait(boolean)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Main method and entry point when starting Tomcat via the provided scripts.
 * @param args Command line arguments to be processed
 */
public static void main(String args[]){
  if (daemon == null) {
    Bootstrap bootstrap=new Bootstrap();
    try {
      bootstrap.init();
    }
 catch (    Throwable t) {
      handleThrowable(t);
      t.printStackTrace();
      return;
    }
    daemon=bootstrap;
  }
 else {
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  }
  try {
    String command="start";
    if (args.length > 0) {
      command=args[args.length - 1];
    }
    if (command.equals("startd")) {
      args[args.length - 1]="start";
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stopd")) {
      args[args.length - 1]="stop";
      daemon.stop();
    }
 else     if (command.equals("start")) {
      daemon.setAwait(true);
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stop")) {
      daemon.stopServer(args);
    }
 else     if (command.equals("configtest")) {
      daemon.load(args);
      if (null == daemon.getServer()) {
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
  }
 catch (  Throwable t) {
    if (t instanceof InvocationTargetException && t.getCause() != null) {
      t=t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
  }
}

ID 3351=========================================================================type: 1
Method:org.apache.catalina.startup.Bootstrap#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.Bootstrap#stopServer(java.lang.String[])
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Main method and entry point when starting Tomcat via the provided scripts.
 * @param args Command line arguments to be processed
 */
public static void main(String args[]){
  if (daemon == null) {
    Bootstrap bootstrap=new Bootstrap();
    try {
      bootstrap.init();
    }
 catch (    Throwable t) {
      handleThrowable(t);
      t.printStackTrace();
      return;
    }
    daemon=bootstrap;
  }
 else {
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  }
  try {
    String command="start";
    if (args.length > 0) {
      command=args[args.length - 1];
    }
    if (command.equals("startd")) {
      args[args.length - 1]="start";
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stopd")) {
      args[args.length - 1]="stop";
      daemon.stop();
    }
 else     if (command.equals("start")) {
      daemon.setAwait(true);
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stop")) {
      daemon.stopServer(args);
    }
 else     if (command.equals("configtest")) {
      daemon.load(args);
      if (null == daemon.getServer()) {
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
  }
 catch (  Throwable t) {
    if (t instanceof InvocationTargetException && t.getCause() != null) {
      t=t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
  }
}

ID 3352=========================================================================type: 1
Method:org.apache.catalina.startup.Bootstrap#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.Bootstrap#getServer()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Main method and entry point when starting Tomcat via the provided scripts.
 * @param args Command line arguments to be processed
 */
public static void main(String args[]){
  if (daemon == null) {
    Bootstrap bootstrap=new Bootstrap();
    try {
      bootstrap.init();
    }
 catch (    Throwable t) {
      handleThrowable(t);
      t.printStackTrace();
      return;
    }
    daemon=bootstrap;
  }
 else {
    Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  }
  try {
    String command="start";
    if (args.length > 0) {
      command=args[args.length - 1];
    }
    if (command.equals("startd")) {
      args[args.length - 1]="start";
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stopd")) {
      args[args.length - 1]="stop";
      daemon.stop();
    }
 else     if (command.equals("start")) {
      daemon.setAwait(true);
      daemon.load(args);
      daemon.start();
    }
 else     if (command.equals("stop")) {
      daemon.stopServer(args);
    }
 else     if (command.equals("configtest")) {
      daemon.load(args);
      if (null == daemon.getServer()) {
        System.exit(1);
      }
      System.exit(0);
    }
 else {
      log.warn("Bootstrap: command \"" + command + "\" does not exist.");
    }
  }
 catch (  Throwable t) {
    if (t instanceof InvocationTargetException && t.getCause() != null) {
      t=t.getCause();
    }
    handleThrowable(t);
    t.printStackTrace();
    System.exit(1);
  }
}

ID 3366=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#initBaseDir()
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void initBaseDir(){
  String catalinaHome=System.getProperty(Globals.CATALINA_HOME_PROP);
  if (basedir == null) {
    basedir=System.getProperty(Globals.CATALINA_BASE_PROP);
  }
  if (basedir == null) {
    basedir=catalinaHome;
  }
  if (basedir == null) {
    basedir=System.getProperty("user.dir") + "/tomcat." + port;
    File home=new File(basedir);
    home.mkdir();
    if (!home.isAbsolute()) {
      try {
        basedir=home.getCanonicalPath();
      }
 catch (      IOException e) {
        basedir=home.getAbsolutePath();
      }
    }
  }
  if (catalinaHome == null) {
    System.setProperty(Globals.CATALINA_HOME_PROP,basedir);
  }
  System.setProperty(Globals.CATALINA_BASE_PROP,basedir);
}

ID 3367=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#createContext(org.apache.catalina.Host, java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create the configured  {@link Context} for the given <code>host</code>.The default constructor of the class that was configured with {@link StandardHost#setContextClass(String)} will be used
 * @param host host for which the  {@link Context} should be created, or<code>null</code> if default host should be used
 * @param url path of the webapp which should get the  {@link Context}
 * @return newly created {@link Context}
 */
private Context createContext(Host host,String url){
  String contextClass=StandardContext.class.getName();
  if (host == null) {
    host=this.getHost();
  }
  if (host instanceof StandardHost) {
    contextClass=((StandardHost)host).getContextClass();
  }
  try {
    return (Context)Class.forName(contextClass).getConstructor().newInstance();
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  InvocationTargetException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
}

ID 3368=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#createContext(org.apache.catalina.Host, java.lang.String)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
/** 
 * Create the configured  {@link Context} for the given <code>host</code>.The default constructor of the class that was configured with {@link StandardHost#setContextClass(String)} will be used
 * @param host host for which the  {@link Context} should be created, or<code>null</code> if default host should be used
 * @param url path of the webapp which should get the  {@link Context}
 * @return newly created {@link Context}
 */
private Context createContext(Host host,String url){
  String contextClass=StandardContext.class.getName();
  if (host == null) {
    host=this.getHost();
  }
  if (host instanceof StandardHost) {
    contextClass=((StandardHost)host).getContextClass();
  }
  try {
    return (Context)Class.forName(contextClass).getConstructor().newInstance();
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  InvocationTargetException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
}

ID 3369=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#createContext(org.apache.catalina.Host, java.lang.String)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Create the configured  {@link Context} for the given <code>host</code>.The default constructor of the class that was configured with {@link StandardHost#setContextClass(String)} will be used
 * @param host host for which the  {@link Context} should be created, or<code>null</code> if default host should be used
 * @param url path of the webapp which should get the  {@link Context}
 * @return newly created {@link Context}
 */
private Context createContext(Host host,String url){
  String contextClass=StandardContext.class.getName();
  if (host == null) {
    host=this.getHost();
  }
  if (host instanceof StandardHost) {
    contextClass=((StandardHost)host).getContextClass();
  }
  try {
    return (Context)Class.forName(contextClass).getConstructor().newInstance();
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  InvocationTargetException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
}

ID 3370=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#createContext(org.apache.catalina.Host, java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Create the configured  {@link Context} for the given <code>host</code>.The default constructor of the class that was configured with {@link StandardHost#setContextClass(String)} will be used
 * @param host host for which the  {@link Context} should be created, or<code>null</code> if default host should be used
 * @param url path of the webapp which should get the  {@link Context}
 * @return newly created {@link Context}
 */
private Context createContext(Host host,String url){
  String contextClass=StandardContext.class.getName();
  if (host == null) {
    host=this.getHost();
  }
  if (host instanceof StandardHost) {
    contextClass=((StandardHost)host).getContextClass();
  }
  try {
    return (Context)Class.forName(contextClass).getConstructor().newInstance();
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  InvocationTargetException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
}

ID 3371=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#createContext(org.apache.catalina.Host, java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Create the configured  {@link Context} for the given <code>host</code>.The default constructor of the class that was configured with {@link StandardHost#setContextClass(String)} will be used
 * @param host host for which the  {@link Context} should be created, or<code>null</code> if default host should be used
 * @param url path of the webapp which should get the  {@link Context}
 * @return newly created {@link Context}
 */
private Context createContext(Host host,String url){
  String contextClass=StandardContext.class.getName();
  if (host == null) {
    host=this.getHost();
  }
  if (host instanceof StandardHost) {
    contextClass=((StandardHost)host).getContextClass();
  }
  try {
    return (Context)Class.forName(contextClass).getConstructor().newInstance();
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  InvocationTargetException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
}

ID 3372=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#createContext(org.apache.catalina.Host, java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Create the configured  {@link Context} for the given <code>host</code>.The default constructor of the class that was configured with {@link StandardHost#setContextClass(String)} will be used
 * @param host host for which the  {@link Context} should be created, or<code>null</code> if default host should be used
 * @param url path of the webapp which should get the  {@link Context}
 * @return newly created {@link Context}
 */
private Context createContext(Host host,String url){
  String contextClass=StandardContext.class.getName();
  if (host == null) {
    host=this.getHost();
  }
  if (host instanceof StandardHost) {
    contextClass=((StandardHost)host).getContextClass();
  }
  try {
    return (Context)Class.forName(contextClass).getConstructor().newInstance();
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  InvocationTargetException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
}

ID 3373=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#createContext(org.apache.catalina.Host, java.lang.String)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Create the configured  {@link Context} for the given <code>host</code>.The default constructor of the class that was configured with {@link StandardHost#setContextClass(String)} will be used
 * @param host host for which the  {@link Context} should be created, or<code>null</code> if default host should be used
 * @param url path of the webapp which should get the  {@link Context}
 * @return newly created {@link Context}
 */
private Context createContext(Host host,String url){
  String contextClass=StandardContext.class.getName();
  if (host == null) {
    host=this.getHost();
  }
  if (host instanceof StandardHost) {
    contextClass=((StandardHost)host).getContextClass();
  }
  try {
    return (Context)Class.forName(contextClass).getConstructor().newInstance();
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  IllegalArgumentException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  InvocationTargetException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException("Can't instantiate context-class " + contextClass + " for host "+ host+ " and url "+ url,e);
  }
}

ID 3374=========================================================================type: 1
Method:org.apache.catalina.startup.ExistingStandardWrapper#loadServlet()
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public synchronized Servlet loadServlet() throws ServletException {
  if (singleThreadModel) {
    Servlet instance;
    try {
      instance=existing.getClass().newInstance();
    }
 catch (    InstantiationException e) {
      throw new ServletException(e);
    }
catch (    IllegalAccessException e) {
      throw new ServletException(e);
    }
    instance.init(facade);
    return instance;
  }
 else {
    if (!instanceInitialized) {
      existing.init(facade);
      instanceInitialized=true;
    }
    return existing;
  }
}

ID 3375=========================================================================type: 1
Method:org.apache.catalina.startup.ExistingStandardWrapper#loadServlet()
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public synchronized Servlet loadServlet() throws ServletException {
  if (singleThreadModel) {
    Servlet instance;
    try {
      instance=existing.getClass().newInstance();
    }
 catch (    InstantiationException e) {
      throw new ServletException(e);
    }
catch (    IllegalAccessException e) {
      throw new ServletException(e);
    }
    instance.init(facade);
    return instance;
  }
 else {
    if (!instanceInitialized) {
      existing.init(facade);
      instanceInitialized=true;
    }
    return existing;
  }
}

ID 3377=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#getWebappConfigFileFromDirectory(java.io.File, java.lang.String)
Rmethod: java.net.URI#toURL()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
private URL getWebappConfigFileFromDirectory(File docBase,String contextName){
  URL result=null;
  File webAppContextXml=new File(docBase,Constants.ApplicationContextXml);
  if (webAppContextXml.exists()) {
    try {
      result=webAppContextXml.toURI().toURL();
    }
 catch (    MalformedURLException e) {
      Logger.getLogger(getLoggerName(getHost(),contextName)).log(Level.WARNING,"Unable to determine web application context.xml " + docBase,e);
    }
  }
  return result;
}

ID 3378=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#getWebappConfigFileFromJar(java.io.File, java.lang.String)
Rmethod: java.util.jar.JarFile#JarFile(java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private URL getWebappConfigFileFromJar(File docBase,String contextName){
  URL result=null;
  JarFile jar=null;
  try {
    jar=new JarFile(docBase);
    JarEntry entry=jar.getJarEntry(Constants.ApplicationContextXml);
    if (entry != null) {
      result=UriUtil.buildJarUrl(docBase,Constants.ApplicationContextXml);
    }
  }
 catch (  IOException e) {
    Logger.getLogger(getLoggerName(getHost(),contextName)).log(Level.WARNING,"Unable to determine web application context.xml " + docBase,e);
  }
 finally {
    if (jar != null) {
      try {
        jar.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return result;
}

ID 3379=========================================================================type: 1
Method:org.apache.catalina.startup.Tomcat#getWebappConfigFileFromJar(java.io.File, java.lang.String)
Rmethod: org.apache.tomcat.util.buf.UriUtil#buildJarUrl(java.io.File, java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
private URL getWebappConfigFileFromJar(File docBase,String contextName){
  URL result=null;
  JarFile jar=null;
  try {
    jar=new JarFile(docBase);
    JarEntry entry=jar.getJarEntry(Constants.ApplicationContextXml);
    if (entry != null) {
      result=UriUtil.buildJarUrl(docBase,Constants.ApplicationContextXml);
    }
  }
 catch (  IOException e) {
    Logger.getLogger(getLoggerName(getHost(),contextName)).log(Level.WARNING,"Unable to determine web application context.xml " + docBase,e);
  }
 finally {
    if (jar != null) {
      try {
        jar.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return result;
}

ID 3398=========================================================================type: 1
Method:org.apache.catalina.startup.WebappServiceLoader#loadServices(Class<T>, LinkedHashSet<java.lang.String>)
Rmethod: java.lang.Class#forName(java.lang.String, boolean, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
private List<T> loadServices(Class<T> serviceType,LinkedHashSet<String> servicesFound) throws IOException {
  ClassLoader loader=servletContext.getClassLoader();
  List<T> services=new ArrayList<T>(servicesFound.size());
  for (  String serviceClass : servicesFound) {
    try {
      Class<?> clazz=Class.forName(serviceClass,true,loader);
      services.add(serviceType.cast(clazz.newInstance()));
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(e);
    }
catch (    InstantiationException e) {
      throw new IOException(e);
    }
catch (    IllegalAccessException e) {
      throw new IOException(e);
    }
catch (    ClassCastException e) {
      throw new IOException(e);
    }
  }
  return Collections.unmodifiableList(services);
}

ID 3399=========================================================================type: 1
Method:org.apache.catalina.startup.WebappServiceLoader#loadServices(Class<T>, LinkedHashSet<java.lang.String>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
private List<T> loadServices(Class<T> serviceType,LinkedHashSet<String> servicesFound) throws IOException {
  ClassLoader loader=servletContext.getClassLoader();
  List<T> services=new ArrayList<T>(servicesFound.size());
  for (  String serviceClass : servicesFound) {
    try {
      Class<?> clazz=Class.forName(serviceClass,true,loader);
      services.add(serviceType.cast(clazz.newInstance()));
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(e);
    }
catch (    InstantiationException e) {
      throw new IOException(e);
    }
catch (    IllegalAccessException e) {
      throw new IOException(e);
    }
catch (    ClassCastException e) {
      throw new IOException(e);
    }
  }
  return Collections.unmodifiableList(services);
}

ID 3400=========================================================================type: 1
Method:org.apache.catalina.startup.WebappServiceLoader#loadServices(Class<T>, LinkedHashSet<java.lang.String>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
private List<T> loadServices(Class<T> serviceType,LinkedHashSet<String> servicesFound) throws IOException {
  ClassLoader loader=servletContext.getClassLoader();
  List<T> services=new ArrayList<T>(servicesFound.size());
  for (  String serviceClass : servicesFound) {
    try {
      Class<?> clazz=Class.forName(serviceClass,true,loader);
      services.add(serviceType.cast(clazz.newInstance()));
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(e);
    }
catch (    InstantiationException e) {
      throw new IOException(e);
    }
catch (    IllegalAccessException e) {
      throw new IOException(e);
    }
catch (    ClassCastException e) {
      throw new IOException(e);
    }
  }
  return Collections.unmodifiableList(services);
}

ID 3408=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#expand(org.apache.catalina.Host, java.net.URL, java.lang.String)
Rmethod: java.net.JarURLConnection#getJarFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Expand the WAR file found at the specified URL into an unpacked directory structure, and return the absolute pathname to the expanded directory.
 * @param host Host war is being installed for
 * @param war URL of the web application archive to be expanded(must start with "jar:")
 * @param pathname Context path name for web application
 * @exception IllegalArgumentException if this is not a "jar:" URL or if theWAR file is invalid
 * @exception IOException if an input/output error was encounteredduring expansion
 */
public static String expand(Host host,URL war,String pathname) throws IOException {
  File appBase=new File(host.getAppBase());
  if (!appBase.isAbsolute()) {
    appBase=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  }
  if (!appBase.exists() || !appBase.isDirectory()) {
    throw new IOException(sm.getString("hostConfig.appBase",appBase.getAbsolutePath()));
  }
  File docBase=new File(appBase,pathname);
  if (docBase.exists()) {
    return (docBase.getAbsolutePath());
  }
  if (!docBase.mkdir() && !docBase.isDirectory())   throw new IOException(sm.getString("expandWar.createFailed",docBase));
  String canonicalDocBasePrefix=docBase.getCanonicalPath();
  if (!canonicalDocBasePrefix.endsWith(File.separator)) {
    canonicalDocBasePrefix+=File.separator;
  }
  JarURLConnection juc=(JarURLConnection)war.openConnection();
  juc.setUseCaches(false);
  JarFile jarFile=null;
  InputStream input=null;
  boolean success=false;
  try {
    jarFile=juc.getJarFile();
    Enumeration<JarEntry> jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      JarEntry jarEntry=jarEntries.nextElement();
      String name=jarEntry.getName();
      File expandedFile=new File(docBase,name);
      if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) {
        throw new IllegalArgumentException(sm.getString("expandWar.illegalPath",war,name,expandedFile.getCanonicalPath(),canonicalDocBasePrefix));
      }
      int last=name.lastIndexOf('/');
      if (last >= 0) {
        File parent=new File(docBase,name.substring(0,last));
        if (!parent.mkdirs() && !parent.isDirectory()) {
          throw new IOException(sm.getString("expandWar.createFailed",parent));
        }
      }
      if (name.endsWith("/")) {
        continue;
      }
      input=jarFile.getInputStream(jarEntry);
      if (null == input)       throw new ZipException(sm.getString("expandWar.missingJarEntry",jarEntry.getName()));
      expand(input,expandedFile);
      long lastModified=jarEntry.getTime();
      if ((lastModified != -1) && (lastModified != 0)) {
        expandedFile.setLastModified(lastModified);
      }
      input.close();
      input=null;
    }
    success=true;
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    if (!success) {
      deleteDir(docBase);
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      input=null;
    }
    if (jarFile != null) {
      try {
        jarFile.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      jarFile=null;
    }
  }
  return (docBase.getAbsolutePath());
}

ID 3409=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#expand(org.apache.catalina.Host, java.net.URL, java.lang.String)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Expand the WAR file found at the specified URL into an unpacked directory structure, and return the absolute pathname to the expanded directory.
 * @param host Host war is being installed for
 * @param war URL of the web application archive to be expanded(must start with "jar:")
 * @param pathname Context path name for web application
 * @exception IllegalArgumentException if this is not a "jar:" URL or if theWAR file is invalid
 * @exception IOException if an input/output error was encounteredduring expansion
 */
public static String expand(Host host,URL war,String pathname) throws IOException {
  File appBase=new File(host.getAppBase());
  if (!appBase.isAbsolute()) {
    appBase=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  }
  if (!appBase.exists() || !appBase.isDirectory()) {
    throw new IOException(sm.getString("hostConfig.appBase",appBase.getAbsolutePath()));
  }
  File docBase=new File(appBase,pathname);
  if (docBase.exists()) {
    return (docBase.getAbsolutePath());
  }
  if (!docBase.mkdir() && !docBase.isDirectory())   throw new IOException(sm.getString("expandWar.createFailed",docBase));
  String canonicalDocBasePrefix=docBase.getCanonicalPath();
  if (!canonicalDocBasePrefix.endsWith(File.separator)) {
    canonicalDocBasePrefix+=File.separator;
  }
  JarURLConnection juc=(JarURLConnection)war.openConnection();
  juc.setUseCaches(false);
  JarFile jarFile=null;
  InputStream input=null;
  boolean success=false;
  try {
    jarFile=juc.getJarFile();
    Enumeration<JarEntry> jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      JarEntry jarEntry=jarEntries.nextElement();
      String name=jarEntry.getName();
      File expandedFile=new File(docBase,name);
      if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) {
        throw new IllegalArgumentException(sm.getString("expandWar.illegalPath",war,name,expandedFile.getCanonicalPath(),canonicalDocBasePrefix));
      }
      int last=name.lastIndexOf('/');
      if (last >= 0) {
        File parent=new File(docBase,name.substring(0,last));
        if (!parent.mkdirs() && !parent.isDirectory()) {
          throw new IOException(sm.getString("expandWar.createFailed",parent));
        }
      }
      if (name.endsWith("/")) {
        continue;
      }
      input=jarFile.getInputStream(jarEntry);
      if (null == input)       throw new ZipException(sm.getString("expandWar.missingJarEntry",jarEntry.getName()));
      expand(input,expandedFile);
      long lastModified=jarEntry.getTime();
      if ((lastModified != -1) && (lastModified != 0)) {
        expandedFile.setLastModified(lastModified);
      }
      input.close();
      input=null;
    }
    success=true;
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    if (!success) {
      deleteDir(docBase);
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      input=null;
    }
    if (jarFile != null) {
      try {
        jarFile.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      jarFile=null;
    }
  }
  return (docBase.getAbsolutePath());
}

ID 3410=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#expand(org.apache.catalina.Host, java.net.URL, java.lang.String)
Rmethod: java.util.jar.JarFile#getInputStream(java.util.zip.ZipEntry)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Expand the WAR file found at the specified URL into an unpacked directory structure, and return the absolute pathname to the expanded directory.
 * @param host Host war is being installed for
 * @param war URL of the web application archive to be expanded(must start with "jar:")
 * @param pathname Context path name for web application
 * @exception IllegalArgumentException if this is not a "jar:" URL or if theWAR file is invalid
 * @exception IOException if an input/output error was encounteredduring expansion
 */
public static String expand(Host host,URL war,String pathname) throws IOException {
  File appBase=new File(host.getAppBase());
  if (!appBase.isAbsolute()) {
    appBase=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  }
  if (!appBase.exists() || !appBase.isDirectory()) {
    throw new IOException(sm.getString("hostConfig.appBase",appBase.getAbsolutePath()));
  }
  File docBase=new File(appBase,pathname);
  if (docBase.exists()) {
    return (docBase.getAbsolutePath());
  }
  if (!docBase.mkdir() && !docBase.isDirectory())   throw new IOException(sm.getString("expandWar.createFailed",docBase));
  String canonicalDocBasePrefix=docBase.getCanonicalPath();
  if (!canonicalDocBasePrefix.endsWith(File.separator)) {
    canonicalDocBasePrefix+=File.separator;
  }
  JarURLConnection juc=(JarURLConnection)war.openConnection();
  juc.setUseCaches(false);
  JarFile jarFile=null;
  InputStream input=null;
  boolean success=false;
  try {
    jarFile=juc.getJarFile();
    Enumeration<JarEntry> jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      JarEntry jarEntry=jarEntries.nextElement();
      String name=jarEntry.getName();
      File expandedFile=new File(docBase,name);
      if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) {
        throw new IllegalArgumentException(sm.getString("expandWar.illegalPath",war,name,expandedFile.getCanonicalPath(),canonicalDocBasePrefix));
      }
      int last=name.lastIndexOf('/');
      if (last >= 0) {
        File parent=new File(docBase,name.substring(0,last));
        if (!parent.mkdirs() && !parent.isDirectory()) {
          throw new IOException(sm.getString("expandWar.createFailed",parent));
        }
      }
      if (name.endsWith("/")) {
        continue;
      }
      input=jarFile.getInputStream(jarEntry);
      if (null == input)       throw new ZipException(sm.getString("expandWar.missingJarEntry",jarEntry.getName()));
      expand(input,expandedFile);
      long lastModified=jarEntry.getTime();
      if ((lastModified != -1) && (lastModified != 0)) {
        expandedFile.setLastModified(lastModified);
      }
      input.close();
      input=null;
    }
    success=true;
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    if (!success) {
      deleteDir(docBase);
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      input=null;
    }
    if (jarFile != null) {
      try {
        jarFile.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      jarFile=null;
    }
  }
  return (docBase.getAbsolutePath());
}

ID 3411=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#expand(org.apache.catalina.Host, java.net.URL, java.lang.String)
Rmethod: org.apache.catalina.startup.ExpandWar#expand(java.io.InputStream, java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Expand the WAR file found at the specified URL into an unpacked directory structure, and return the absolute pathname to the expanded directory.
 * @param host Host war is being installed for
 * @param war URL of the web application archive to be expanded(must start with "jar:")
 * @param pathname Context path name for web application
 * @exception IllegalArgumentException if this is not a "jar:" URL or if theWAR file is invalid
 * @exception IOException if an input/output error was encounteredduring expansion
 */
public static String expand(Host host,URL war,String pathname) throws IOException {
  File appBase=new File(host.getAppBase());
  if (!appBase.isAbsolute()) {
    appBase=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  }
  if (!appBase.exists() || !appBase.isDirectory()) {
    throw new IOException(sm.getString("hostConfig.appBase",appBase.getAbsolutePath()));
  }
  File docBase=new File(appBase,pathname);
  if (docBase.exists()) {
    return (docBase.getAbsolutePath());
  }
  if (!docBase.mkdir() && !docBase.isDirectory())   throw new IOException(sm.getString("expandWar.createFailed",docBase));
  String canonicalDocBasePrefix=docBase.getCanonicalPath();
  if (!canonicalDocBasePrefix.endsWith(File.separator)) {
    canonicalDocBasePrefix+=File.separator;
  }
  JarURLConnection juc=(JarURLConnection)war.openConnection();
  juc.setUseCaches(false);
  JarFile jarFile=null;
  InputStream input=null;
  boolean success=false;
  try {
    jarFile=juc.getJarFile();
    Enumeration<JarEntry> jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      JarEntry jarEntry=jarEntries.nextElement();
      String name=jarEntry.getName();
      File expandedFile=new File(docBase,name);
      if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) {
        throw new IllegalArgumentException(sm.getString("expandWar.illegalPath",war,name,expandedFile.getCanonicalPath(),canonicalDocBasePrefix));
      }
      int last=name.lastIndexOf('/');
      if (last >= 0) {
        File parent=new File(docBase,name.substring(0,last));
        if (!parent.mkdirs() && !parent.isDirectory()) {
          throw new IOException(sm.getString("expandWar.createFailed",parent));
        }
      }
      if (name.endsWith("/")) {
        continue;
      }
      input=jarFile.getInputStream(jarEntry);
      if (null == input)       throw new ZipException(sm.getString("expandWar.missingJarEntry",jarEntry.getName()));
      expand(input,expandedFile);
      long lastModified=jarEntry.getTime();
      if ((lastModified != -1) && (lastModified != 0)) {
        expandedFile.setLastModified(lastModified);
      }
      input.close();
      input=null;
    }
    success=true;
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    if (!success) {
      deleteDir(docBase);
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      input=null;
    }
    if (jarFile != null) {
      try {
        jarFile.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      jarFile=null;
    }
  }
  return (docBase.getAbsolutePath());
}

ID 3412=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#expand(org.apache.catalina.Host, java.net.URL, java.lang.String)
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Expand the WAR file found at the specified URL into an unpacked directory structure, and return the absolute pathname to the expanded directory.
 * @param host Host war is being installed for
 * @param war URL of the web application archive to be expanded(must start with "jar:")
 * @param pathname Context path name for web application
 * @exception IllegalArgumentException if this is not a "jar:" URL or if theWAR file is invalid
 * @exception IOException if an input/output error was encounteredduring expansion
 */
public static String expand(Host host,URL war,String pathname) throws IOException {
  File appBase=new File(host.getAppBase());
  if (!appBase.isAbsolute()) {
    appBase=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  }
  if (!appBase.exists() || !appBase.isDirectory()) {
    throw new IOException(sm.getString("hostConfig.appBase",appBase.getAbsolutePath()));
  }
  File docBase=new File(appBase,pathname);
  if (docBase.exists()) {
    return (docBase.getAbsolutePath());
  }
  if (!docBase.mkdir() && !docBase.isDirectory())   throw new IOException(sm.getString("expandWar.createFailed",docBase));
  String canonicalDocBasePrefix=docBase.getCanonicalPath();
  if (!canonicalDocBasePrefix.endsWith(File.separator)) {
    canonicalDocBasePrefix+=File.separator;
  }
  JarURLConnection juc=(JarURLConnection)war.openConnection();
  juc.setUseCaches(false);
  JarFile jarFile=null;
  InputStream input=null;
  boolean success=false;
  try {
    jarFile=juc.getJarFile();
    Enumeration<JarEntry> jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      JarEntry jarEntry=jarEntries.nextElement();
      String name=jarEntry.getName();
      File expandedFile=new File(docBase,name);
      if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) {
        throw new IllegalArgumentException(sm.getString("expandWar.illegalPath",war,name,expandedFile.getCanonicalPath(),canonicalDocBasePrefix));
      }
      int last=name.lastIndexOf('/');
      if (last >= 0) {
        File parent=new File(docBase,name.substring(0,last));
        if (!parent.mkdirs() && !parent.isDirectory()) {
          throw new IOException(sm.getString("expandWar.createFailed",parent));
        }
      }
      if (name.endsWith("/")) {
        continue;
      }
      input=jarFile.getInputStream(jarEntry);
      if (null == input)       throw new ZipException(sm.getString("expandWar.missingJarEntry",jarEntry.getName()));
      expand(input,expandedFile);
      long lastModified=jarEntry.getTime();
      if ((lastModified != -1) && (lastModified != 0)) {
        expandedFile.setLastModified(lastModified);
      }
      input.close();
      input=null;
    }
    success=true;
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    if (!success) {
      deleteDir(docBase);
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      input=null;
    }
    if (jarFile != null) {
      try {
        jarFile.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      jarFile=null;
    }
  }
  return (docBase.getAbsolutePath());
}

ID 3417=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#validate(org.apache.catalina.Host, java.net.URL, java.lang.String)
Rmethod: java.net.JarURLConnection#getJarFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Validate the WAR file found at the specified URL.
 * @param host Host war is being installed for
 * @param war URL of the web application archive to be validated(must start with "jar:")
 * @param pathname Context path name for web application
 * @exception IllegalArgumentException if this is not a "jar:" URL or if theWAR file is invalid
 * @exception IOException if an input/output error was encounteredduring validation
 */
public static void validate(Host host,URL war,String pathname) throws IOException {
  File appBase=new File(host.getAppBase());
  if (!appBase.isAbsolute()) {
    appBase=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  }
  File docBase=new File(appBase,pathname);
  String canonicalDocBasePrefix=docBase.getCanonicalPath();
  if (!canonicalDocBasePrefix.endsWith(File.separator)) {
    canonicalDocBasePrefix+=File.separator;
  }
  JarURLConnection juc=(JarURLConnection)war.openConnection();
  juc.setUseCaches(false);
  JarFile jarFile=null;
  try {
    jarFile=juc.getJarFile();
    Enumeration<JarEntry> jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      JarEntry jarEntry=jarEntries.nextElement();
      String name=jarEntry.getName();
      File expandedFile=new File(docBase,name);
      if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) {
        throw new IllegalArgumentException(sm.getString("expandWar.illegalPath",war,name,expandedFile.getCanonicalPath(),canonicalDocBasePrefix));
      }
    }
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    if (jarFile != null) {
      try {
        jarFile.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      jarFile=null;
    }
  }
}

ID 3418=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#validate(org.apache.catalina.Host, java.net.URL, java.lang.String)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Validate the WAR file found at the specified URL.
 * @param host Host war is being installed for
 * @param war URL of the web application archive to be validated(must start with "jar:")
 * @param pathname Context path name for web application
 * @exception IllegalArgumentException if this is not a "jar:" URL or if theWAR file is invalid
 * @exception IOException if an input/output error was encounteredduring validation
 */
public static void validate(Host host,URL war,String pathname) throws IOException {
  File appBase=new File(host.getAppBase());
  if (!appBase.isAbsolute()) {
    appBase=new File(System.getProperty(Globals.CATALINA_BASE_PROP),host.getAppBase());
  }
  File docBase=new File(appBase,pathname);
  String canonicalDocBasePrefix=docBase.getCanonicalPath();
  if (!canonicalDocBasePrefix.endsWith(File.separator)) {
    canonicalDocBasePrefix+=File.separator;
  }
  JarURLConnection juc=(JarURLConnection)war.openConnection();
  juc.setUseCaches(false);
  JarFile jarFile=null;
  try {
    jarFile=juc.getJarFile();
    Enumeration<JarEntry> jarEntries=jarFile.entries();
    while (jarEntries.hasMoreElements()) {
      JarEntry jarEntry=jarEntries.nextElement();
      String name=jarEntry.getName();
      File expandedFile=new File(docBase,name);
      if (!expandedFile.getCanonicalPath().startsWith(canonicalDocBasePrefix)) {
        throw new IllegalArgumentException(sm.getString("expandWar.illegalPath",war,name,expandedFile.getCanonicalPath(),canonicalDocBasePrefix));
      }
    }
  }
 catch (  IOException e) {
    throw e;
  }
 finally {
    if (jarFile != null) {
      try {
        jarFile.close();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
      }
      jarFile=null;
    }
  }
}

ID 3420=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#copy(java.io.File, java.io.File)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copy(File src,File dest){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copy(fileSrc,fileDest);
    }
 else {
      FileChannel ic=null;
      FileChannel oc=null;
      try {
        ic=(new FileInputStream(fileSrc)).getChannel();
        oc=(new FileOutputStream(fileDest)).getChannel();
        ic.transferTo(0,ic.size(),oc);
      }
 catch (      IOException e) {
        log.error(sm.getString("expandWar.copy",fileSrc,fileDest),e);
        result=false;
      }
 finally {
        if (ic != null) {
          try {
            ic.close();
          }
 catch (          IOException e) {
          }
        }
        if (oc != null) {
          try {
            oc.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 3421=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#copy(java.io.File, java.io.File)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copy(File src,File dest){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copy(fileSrc,fileDest);
    }
 else {
      FileChannel ic=null;
      FileChannel oc=null;
      try {
        ic=(new FileInputStream(fileSrc)).getChannel();
        oc=(new FileOutputStream(fileDest)).getChannel();
        ic.transferTo(0,ic.size(),oc);
      }
 catch (      IOException e) {
        log.error(sm.getString("expandWar.copy",fileSrc,fileDest),e);
        result=false;
      }
 finally {
        if (ic != null) {
          try {
            ic.close();
          }
 catch (          IOException e) {
          }
        }
        if (oc != null) {
          try {
            oc.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 3422=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#copy(java.io.File, java.io.File)
Rmethod: java.nio.channels.FileChannel#size()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copy(File src,File dest){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copy(fileSrc,fileDest);
    }
 else {
      FileChannel ic=null;
      FileChannel oc=null;
      try {
        ic=(new FileInputStream(fileSrc)).getChannel();
        oc=(new FileOutputStream(fileDest)).getChannel();
        ic.transferTo(0,ic.size(),oc);
      }
 catch (      IOException e) {
        log.error(sm.getString("expandWar.copy",fileSrc,fileDest),e);
        result=false;
      }
 finally {
        if (ic != null) {
          try {
            ic.close();
          }
 catch (          IOException e) {
          }
        }
        if (oc != null) {
          try {
            oc.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 3423=========================================================================type: 1
Method:org.apache.catalina.startup.ExpandWar#copy(java.io.File, java.io.File)
Rmethod: java.nio.channels.FileChannel#transferTo(long, long, java.nio.channels.WritableByteChannel)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Copy the specified file or directory to the destination.
 * @param src File object representing the source
 * @param dest File object representing the destination
 */
public static boolean copy(File src,File dest){
  boolean result=true;
  String files[]=null;
  if (src.isDirectory()) {
    files=src.list();
    result=dest.mkdir();
  }
 else {
    files=new String[1];
    files[0]="";
  }
  if (files == null) {
    files=new String[0];
  }
  for (int i=0; (i < files.length) && result; i++) {
    File fileSrc=new File(src,files[i]);
    File fileDest=new File(dest,files[i]);
    if (fileSrc.isDirectory()) {
      result=copy(fileSrc,fileDest);
    }
 else {
      FileChannel ic=null;
      FileChannel oc=null;
      try {
        ic=(new FileInputStream(fileSrc)).getChannel();
        oc=(new FileOutputStream(fileDest)).getChannel();
        ic.transferTo(0,ic.size(),oc);
      }
 catch (      IOException e) {
        log.error(sm.getString("expandWar.copy",fileSrc,fileDest),e);
        result=false;
      }
 finally {
        if (ic != null) {
          try {
            ic.close();
          }
 catch (          IOException e) {
          }
        }
        if (oc != null) {
          try {
            oc.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
  return result;
}

ID 3432=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#contextConfig(org.apache.tomcat.util.digester.Digester)
Rmethod: java.net.URI#toURL()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Process the default configuration file, if it exists.
 */
protected void contextConfig(Digester digester){
  if (defaultContextXml == null && context instanceof StandardContext) {
    defaultContextXml=((StandardContext)context).getDefaultContextXml();
  }
  if (defaultContextXml == null)   getDefaultContextXml();
  if (!context.getOverride()) {
    File defaultContextFile=new File(defaultContextXml);
    if (!defaultContextFile.isAbsolute()) {
      defaultContextFile=new File(getBaseDir(),defaultContextXml);
    }
    if (defaultContextFile.exists()) {
      try {
        URL defaultContextUrl=defaultContextFile.toURI().toURL();
        processContextConfig(digester,defaultContextUrl);
      }
 catch (      MalformedURLException e) {
        log.error(sm.getString("contextConfig.badUrl",defaultContextFile),e);
      }
    }
    File hostContextFile=new File(getHostConfigBase(),Constants.HostContextXml);
    if (hostContextFile.exists()) {
      try {
        URL hostContextUrl=hostContextFile.toURI().toURL();
        processContextConfig(digester,hostContextUrl);
      }
 catch (      MalformedURLException e) {
        log.error(sm.getString("contextConfig.badUrl",hostContextFile),e);
      }
    }
  }
  if (context.getConfigFile() != null)   processContextConfig(digester,context.getConfigFile());
}

ID 3437=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processContextConfig(org.apache.tomcat.util.digester.Digester, java.net.URL)
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process a context.xml.
 */
protected void processContextConfig(Digester digester,URL contextXml){
  if (log.isDebugEnabled())   log.debug("Processing context [" + context.getName() + "] configuration file ["+ contextXml+ "]");
  InputSource source=null;
  InputStream stream=null;
  try {
    source=new InputSource(contextXml.toString());
    URLConnection xmlConn=contextXml.openConnection();
    xmlConn.setUseCaches(false);
    stream=xmlConn.getInputStream();
  }
 catch (  Exception e) {
    log.error(sm.getString("contextConfig.contextMissing",contextXml),e);
  }
  if (source == null)   return;
  try {
    source.setByteStream(stream);
    digester.setClassLoader(this.getClass().getClassLoader());
    digester.setUseContextClassLoader(false);
    digester.push(context.getParent());
    digester.push(context);
    XmlErrorHandler errorHandler=new XmlErrorHandler();
    digester.setErrorHandler(errorHandler);
    digester.parse(source);
    if (errorHandler.getWarnings().size() > 0 || errorHandler.getErrors().size() > 0) {
      errorHandler.logFindings(log,contextXml.toString());
      ok=false;
    }
    if (log.isDebugEnabled()) {
      log.debug("Successfully processed context [" + context.getName() + "] configuration file ["+ contextXml+ "]");
    }
  }
 catch (  SAXParseException e) {
    log.error(sm.getString("contextConfig.contextParse",context.getName()),e);
    log.error(sm.getString("contextConfig.defaultPosition","" + e.getLineNumber(),"" + e.getColumnNumber()));
    ok=false;
  }
catch (  Exception e) {
    log.error(sm.getString("contextConfig.contextParse",context.getName()),e);
    ok=false;
  }
 finally {
    try {
      if (stream != null) {
        stream.close();
      }
    }
 catch (    IOException e) {
      log.error(sm.getString("contextConfig.contextClose"),e);
    }
  }
}

ID 3443=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#beforeStart()
Rmethod: org.apache.catalina.startup.ContextConfig#fixDocBase()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process a "before start" event for this Context.
 */
protected synchronized void beforeStart(){
  try {
    fixDocBase();
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.fixDocBase",context.getName()),e);
  }
  antiLocking();
}

ID 3444=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getHostConfigBase()
Rmethod: java.io.File#getCanonicalFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected File getHostConfigBase(){
  File file=null;
  Container container=context;
  Host host=null;
  Engine engine=null;
  while (container != null) {
    if (container instanceof Host) {
      host=(Host)container;
    }
    if (container instanceof Engine) {
      engine=(Engine)container;
    }
    container=container.getParent();
  }
  if (host != null && host.getXmlBase() != null) {
    String xmlBase=host.getXmlBase();
    file=new File(xmlBase);
    if (!file.isAbsolute())     file=new File(getBaseDir(),xmlBase);
  }
 else {
    StringBuilder result=new StringBuilder();
    if (engine != null) {
      result.append(engine.getName()).append('/');
    }
    if (host != null) {
      result.append(host.getName()).append('/');
    }
    file=new File(getConfigBase(),result.toString());
  }
  try {
    return file.getCanonicalFile();
  }
 catch (  IOException e) {
    return file;
  }
}

ID 3446=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#webConfig()
Rmethod: javax.servlet.ServletContext#getResource(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Scan the web.xml files that apply to the web application and merge them using the rules defined in the spec. For the global web.xml files, where there is duplicate configuration, the most specific level wins. ie an application's web.xml takes precedence over the host level or global web.xml file.    web.xml Mn wevTomcath@web.xmlSM(-web.xmlweb-fragment.xmlweb(-Mno vMnoservletMnfilterMnI	sT0Contexta-
 */
protected void webConfig(){
  Set<WebXml> defaults=new HashSet<WebXml>();
  defaults.add(getDefaultWebXmlFragment());
  WebXml webXml=createWebXml();
  InputSource contextWebXml=getContextWebXmlSource();
  parseWebXml(contextWebXml,webXml,false);
  ServletContext sContext=context.getServletContext();
  Map<String,WebXml> fragments=processJarsForWebFragments(webXml);
  Set<WebXml> orderedFragments=null;
  orderedFragments=WebXml.orderWebFragments(webXml,fragments,sContext);
  if (ok) {
    processServletContainerInitializers();
  }
  if (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {
    if (ok) {
      NamingEnumeration<Binding> listBindings=null;
      try {
        try {
          listBindings=context.getResources().listBindings("/WEB-INF/classes");
        }
 catch (        NameNotFoundException ignore) {
        }
        while (listBindings != null && listBindings.hasMoreElements()) {
          Binding binding=listBindings.nextElement();
          if (binding.getObject() instanceof FileDirContext) {
            File webInfClassDir=new File(((FileDirContext)binding.getObject()).getDocBase());
            processAnnotationsFile(webInfClassDir,webXml,webXml.isMetadataComplete());
          }
 else           if ("META-INF".equals(binding.getName())) {
          }
 else {
            String resource="/WEB-INF/classes/" + binding.getName();
            try {
              URL url=sContext.getResource(resource);
              processAnnotationsUrl(url,webXml,webXml.isMetadataComplete());
            }
 catch (            MalformedURLException e) {
              log.error(sm.getString("contextConfig.webinfClassesUrl",resource),e);
            }
          }
        }
      }
 catch (      NamingException e) {
        log.error(sm.getString("contextConfig.webinfClassesUrl","/WEB-INF/classes"),e);
      }
    }
    if (ok) {
      processAnnotations(orderedFragments,webXml.isMetadataComplete());
    }
    javaClassCache.clear();
  }
  if (!webXml.isMetadataComplete()) {
    if (ok) {
      ok=webXml.merge(orderedFragments);
    }
    webXml.merge(defaults);
    if (ok) {
      convertJsps(webXml);
    }
    if (ok) {
      webXml.configureContext(context);
    }
  }
 else {
    webXml.merge(defaults);
    convertJsps(webXml);
    webXml.configureContext(context);
  }
  String mergedWebXml=webXml.toXml();
  sContext.setAttribute(org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,mergedWebXml);
  if (context.getLogEffectiveWebXml()) {
    log.info("web.xml:\n" + mergedWebXml);
  }
  if (ok) {
    Set<WebXml> resourceJars=new LinkedHashSet<WebXml>();
    for (    WebXml fragment : orderedFragments) {
      resourceJars.add(fragment);
    }
    for (    WebXml fragment : fragments.values()) {
      if (!resourceJars.contains(fragment)) {
        resourceJars.add(fragment);
      }
    }
    processResourceJARs(resourceJars);
  }
  if (ok) {
    for (    Map.Entry<ServletContainerInitializer,Set<Class<?>>> entry : initializerClassMap.entrySet()) {
      if (entry.getValue().isEmpty()) {
        context.addServletContainerInitializer(entry.getKey(),null);
      }
 else {
        context.addServletContainerInitializer(entry.getKey(),entry.getValue());
      }
    }
  }
}

ID 3447=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getDefaultWebXmlFragment()
Rmethod: java.net.URL#URL(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
private WebXml getDefaultWebXmlFragment(){
  Host host=(Host)context.getParent();
  DefaultWebXmlCacheEntry entry=hostWebXmlCache.get(host);
  InputSource globalWebXml=getGlobalWebXmlSource();
  InputSource hostWebXml=getHostWebXmlSource();
  long globalTimeStamp=0;
  long hostTimeStamp=0;
  if (globalWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(globalWebXml.getSystemId());
      uc=url.openConnection();
      globalTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      globalTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          globalTimeStamp=-1;
        }
      }
    }
  }
  if (hostWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(hostWebXml.getSystemId());
      uc=url.openConnection();
      hostTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      hostTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          hostTimeStamp=-1;
        }
      }
    }
  }
  if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
    InputSourceUtil.close(globalWebXml);
    InputSourceUtil.close(hostWebXml);
    return entry.getWebXml();
  }
synchronized (host.getPipeline()) {
    entry=hostWebXmlCache.get(host);
    if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
      return entry.getWebXml();
    }
    WebXml webXmlDefaultFragment=createWebXml();
    webXmlDefaultFragment.setOverridable(true);
    webXmlDefaultFragment.setDistributable(true);
    webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false);
    if (globalWebXml == null) {
      log.info(sm.getString("contextConfig.defaultMissing"));
    }
 else {
      parseWebXml(globalWebXml,webXmlDefaultFragment,false);
    }
    webXmlDefaultFragment.setReplaceWelcomeFiles(true);
    parseWebXml(hostWebXml,webXmlDefaultFragment,false);
    if (globalTimeStamp != -1 && hostTimeStamp != -1) {
      entry=new DefaultWebXmlCacheEntry(webXmlDefaultFragment,globalTimeStamp,hostTimeStamp);
      hostWebXmlCache.put(host,entry);
    }
    return webXmlDefaultFragment;
  }
}

ID 3448=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getDefaultWebXmlFragment()
Rmethod: java.net.URL#openConnection()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private WebXml getDefaultWebXmlFragment(){
  Host host=(Host)context.getParent();
  DefaultWebXmlCacheEntry entry=hostWebXmlCache.get(host);
  InputSource globalWebXml=getGlobalWebXmlSource();
  InputSource hostWebXml=getHostWebXmlSource();
  long globalTimeStamp=0;
  long hostTimeStamp=0;
  if (globalWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(globalWebXml.getSystemId());
      uc=url.openConnection();
      globalTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      globalTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          globalTimeStamp=-1;
        }
      }
    }
  }
  if (hostWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(hostWebXml.getSystemId());
      uc=url.openConnection();
      hostTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      hostTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          hostTimeStamp=-1;
        }
      }
    }
  }
  if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
    InputSourceUtil.close(globalWebXml);
    InputSourceUtil.close(hostWebXml);
    return entry.getWebXml();
  }
synchronized (host.getPipeline()) {
    entry=hostWebXmlCache.get(host);
    if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
      return entry.getWebXml();
    }
    WebXml webXmlDefaultFragment=createWebXml();
    webXmlDefaultFragment.setOverridable(true);
    webXmlDefaultFragment.setDistributable(true);
    webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false);
    if (globalWebXml == null) {
      log.info(sm.getString("contextConfig.defaultMissing"));
    }
 else {
      parseWebXml(globalWebXml,webXmlDefaultFragment,false);
    }
    webXmlDefaultFragment.setReplaceWelcomeFiles(true);
    parseWebXml(hostWebXml,webXmlDefaultFragment,false);
    if (globalTimeStamp != -1 && hostTimeStamp != -1) {
      entry=new DefaultWebXmlCacheEntry(webXmlDefaultFragment,globalTimeStamp,hostTimeStamp);
      hostWebXmlCache.put(host,entry);
    }
    return webXmlDefaultFragment;
  }
}

ID 3449=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getDefaultWebXmlFragment()
Rmethod: java.net.URLConnection#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private WebXml getDefaultWebXmlFragment(){
  Host host=(Host)context.getParent();
  DefaultWebXmlCacheEntry entry=hostWebXmlCache.get(host);
  InputSource globalWebXml=getGlobalWebXmlSource();
  InputSource hostWebXml=getHostWebXmlSource();
  long globalTimeStamp=0;
  long hostTimeStamp=0;
  if (globalWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(globalWebXml.getSystemId());
      uc=url.openConnection();
      globalTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      globalTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          globalTimeStamp=-1;
        }
      }
    }
  }
  if (hostWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(hostWebXml.getSystemId());
      uc=url.openConnection();
      hostTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      hostTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          hostTimeStamp=-1;
        }
      }
    }
  }
  if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
    InputSourceUtil.close(globalWebXml);
    InputSourceUtil.close(hostWebXml);
    return entry.getWebXml();
  }
synchronized (host.getPipeline()) {
    entry=hostWebXmlCache.get(host);
    if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
      return entry.getWebXml();
    }
    WebXml webXmlDefaultFragment=createWebXml();
    webXmlDefaultFragment.setOverridable(true);
    webXmlDefaultFragment.setDistributable(true);
    webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false);
    if (globalWebXml == null) {
      log.info(sm.getString("contextConfig.defaultMissing"));
    }
 else {
      parseWebXml(globalWebXml,webXmlDefaultFragment,false);
    }
    webXmlDefaultFragment.setReplaceWelcomeFiles(true);
    parseWebXml(hostWebXml,webXmlDefaultFragment,false);
    if (globalTimeStamp != -1 && hostTimeStamp != -1) {
      entry=new DefaultWebXmlCacheEntry(webXmlDefaultFragment,globalTimeStamp,hostTimeStamp);
      hostWebXmlCache.put(host,entry);
    }
    return webXmlDefaultFragment;
  }
}

ID 3450=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getDefaultWebXmlFragment()
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private WebXml getDefaultWebXmlFragment(){
  Host host=(Host)context.getParent();
  DefaultWebXmlCacheEntry entry=hostWebXmlCache.get(host);
  InputSource globalWebXml=getGlobalWebXmlSource();
  InputSource hostWebXml=getHostWebXmlSource();
  long globalTimeStamp=0;
  long hostTimeStamp=0;
  if (globalWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(globalWebXml.getSystemId());
      uc=url.openConnection();
      globalTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      globalTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          globalTimeStamp=-1;
        }
      }
    }
  }
  if (hostWebXml != null) {
    URLConnection uc=null;
    try {
      URL url=new URL(hostWebXml.getSystemId());
      uc=url.openConnection();
      hostTimeStamp=uc.getLastModified();
    }
 catch (    IOException e) {
      hostTimeStamp=-1;
    }
 finally {
      if (uc != null) {
        try {
          uc.getInputStream().close();
        }
 catch (        IOException e) {
          ExceptionUtils.handleThrowable(e);
          hostTimeStamp=-1;
        }
      }
    }
  }
  if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
    InputSourceUtil.close(globalWebXml);
    InputSourceUtil.close(hostWebXml);
    return entry.getWebXml();
  }
synchronized (host.getPipeline()) {
    entry=hostWebXmlCache.get(host);
    if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp && entry.getHostTimeStamp() == hostTimeStamp) {
      return entry.getWebXml();
    }
    WebXml webXmlDefaultFragment=createWebXml();
    webXmlDefaultFragment.setOverridable(true);
    webXmlDefaultFragment.setDistributable(true);
    webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false);
    if (globalWebXml == null) {
      log.info(sm.getString("contextConfig.defaultMissing"));
    }
 else {
      parseWebXml(globalWebXml,webXmlDefaultFragment,false);
    }
    webXmlDefaultFragment.setReplaceWelcomeFiles(true);
    parseWebXml(hostWebXml,webXmlDefaultFragment,false);
    if (globalTimeStamp != -1 && hostTimeStamp != -1) {
      entry=new DefaultWebXmlCacheEntry(webXmlDefaultFragment,globalTimeStamp,hostTimeStamp);
      hostWebXmlCache.put(host,entry);
    }
    return webXmlDefaultFragment;
  }
}

ID 3451=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processServletContainerInitializers()
Rmethod: org.apache.catalina.startup.WebappServiceLoader#load(Class<T>)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Scan JARs for ServletContainerInitializer implementations.
 */
protected void processServletContainerInitializers(){
  List<ServletContainerInitializer> detectedScis;
  try {
    WebappServiceLoader<ServletContainerInitializer> loader=new WebappServiceLoader<ServletContainerInitializer>(context);
    detectedScis=loader.load(ServletContainerInitializer.class);
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.servletContainerInitializerFail",context.getName()),e);
    ok=false;
    return;
  }
  for (  ServletContainerInitializer sci : detectedScis) {
    initializerClassMap.put(sci,new HashSet<Class<?>>());
    HandlesTypes ht;
    try {
      ht=sci.getClass().getAnnotation(HandlesTypes.class);
    }
 catch (    Exception e) {
      if (log.isDebugEnabled()) {
        log.info(sm.getString("contextConfig.sci.debug",sci.getClass().getName()),e);
      }
 else {
        log.info(sm.getString("contextConfig.sci.info",sci.getClass().getName()));
      }
      continue;
    }
    if (ht == null) {
      continue;
    }
    Class<?>[] types=ht.value();
    if (types == null) {
      continue;
    }
    for (    Class<?> type : types) {
      if (type.isAnnotation()) {
        handlesTypesAnnotations=true;
      }
 else {
        handlesTypesNonAnnotations=true;
      }
      Set<ServletContainerInitializer> scis=typeInitializerMap.get(type);
      if (scis == null) {
        scis=new HashSet<ServletContainerInitializer>();
        typeInitializerMap.put(type,scis);
      }
      scis.add(sci);
    }
  }
}

ID 3452=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processResourceJARs(Set<org.apache.catalina.deploy.WebXml>)
Rmethod: org.apache.tomcat.util.scan.JarFactory#newInstance(java.net.URL)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Scan JARs that contain web-fragment.xml files that will be used to configure this application to see if they also contain static resources. If static resources are found, add them to the context. Resources are added in web-fragment.xml priority order.
 */
protected void processResourceJARs(Set<WebXml> fragments){
  for (  WebXml fragment : fragments) {
    URL url=fragment.getURL();
    Jar jar=null;
    try {
      if ("jar".equals(url.getProtocol())) {
        jar=JarFactory.newInstance(url);
        jar.nextEntry();
        String entryName=jar.getEntryName();
        while (entryName != null) {
          if (entryName.startsWith("META-INF/resources/")) {
            context.addResourceJarUrl(url);
            break;
          }
          jar.nextEntry();
          entryName=jar.getEntryName();
        }
      }
 else       if ("file".equals(url.getProtocol())) {
        FileDirContext fileDirContext=new FileDirContext();
        fileDirContext.setDocBase(new File(url.toURI()).getAbsolutePath());
        try {
          fileDirContext.lookup("META-INF/resources/");
          if (context instanceof StandardContext) {
            ((StandardContext)context).addResourcesDirContext(fileDirContext);
          }
        }
 catch (        NamingException e) {
        }
      }
    }
 catch (    IOException ioe) {
      log.error(sm.getString("contextConfig.resourceJarFail",url,context.getName()));
    }
catch (    URISyntaxException e) {
      log.error(sm.getString("contextConfig.resourceJarFail",url,context.getName()));
    }
 finally {
      if (jar != null) {
        jar.close();
      }
    }
  }
}

ID 3453=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processResourceJARs(Set<org.apache.catalina.deploy.WebXml>)
Rmethod: java.net.URL#toURI()
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
/** 
 * Scan JARs that contain web-fragment.xml files that will be used to configure this application to see if they also contain static resources. If static resources are found, add them to the context. Resources are added in web-fragment.xml priority order.
 */
protected void processResourceJARs(Set<WebXml> fragments){
  for (  WebXml fragment : fragments) {
    URL url=fragment.getURL();
    Jar jar=null;
    try {
      if ("jar".equals(url.getProtocol())) {
        jar=JarFactory.newInstance(url);
        jar.nextEntry();
        String entryName=jar.getEntryName();
        while (entryName != null) {
          if (entryName.startsWith("META-INF/resources/")) {
            context.addResourceJarUrl(url);
            break;
          }
          jar.nextEntry();
          entryName=jar.getEntryName();
        }
      }
 else       if ("file".equals(url.getProtocol())) {
        FileDirContext fileDirContext=new FileDirContext();
        fileDirContext.setDocBase(new File(url.toURI()).getAbsolutePath());
        try {
          fileDirContext.lookup("META-INF/resources/");
          if (context instanceof StandardContext) {
            ((StandardContext)context).addResourcesDirContext(fileDirContext);
          }
        }
 catch (        NamingException e) {
        }
      }
    }
 catch (    IOException ioe) {
      log.error(sm.getString("contextConfig.resourceJarFail",url,context.getName()));
    }
catch (    URISyntaxException e) {
      log.error(sm.getString("contextConfig.resourceJarFail",url,context.getName()));
    }
 finally {
      if (jar != null) {
        jar.close();
      }
    }
  }
}

ID 3455=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getContextWebXmlSource()
Rmethod: java.io.FileInputStream#FileInputStream(java.lang.String)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Identify the application web.xml to be used and obtain an input source for it.
 */
protected InputSource getContextWebXmlSource(){
  InputStream stream=null;
  InputSource source=null;
  URL url=null;
  String altDDName=null;
  ServletContext servletContext=context.getServletContext();
  try {
    if (servletContext != null) {
      altDDName=(String)servletContext.getAttribute(Globals.ALT_DD_ATTR);
      if (altDDName != null) {
        try {
          stream=new FileInputStream(altDDName);
          url=new File(altDDName).toURI().toURL();
        }
 catch (        FileNotFoundException e) {
          log.error(sm.getString("contextConfig.altDDNotFound",altDDName));
        }
catch (        MalformedURLException e) {
          log.error(sm.getString("contextConfig.applicationUrl"));
        }
      }
 else {
        stream=servletContext.getResourceAsStream(Constants.ApplicationWebXml);
        try {
          url=servletContext.getResource(Constants.ApplicationWebXml);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("contextConfig.applicationUrl"));
        }
      }
    }
    if (stream == null || url == null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("contextConfig.applicationMissing") + " " + context);
      }
    }
 else {
      source=new InputSource(url.toExternalForm());
      source.setByteStream(stream);
    }
  }
  finally {
    if (source == null && stream != null) {
      try {
        stream.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return source;
}

ID 3456=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getContextWebXmlSource()
Rmethod: java.net.URI#toURL()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Identify the application web.xml to be used and obtain an input source for it.
 */
protected InputSource getContextWebXmlSource(){
  InputStream stream=null;
  InputSource source=null;
  URL url=null;
  String altDDName=null;
  ServletContext servletContext=context.getServletContext();
  try {
    if (servletContext != null) {
      altDDName=(String)servletContext.getAttribute(Globals.ALT_DD_ATTR);
      if (altDDName != null) {
        try {
          stream=new FileInputStream(altDDName);
          url=new File(altDDName).toURI().toURL();
        }
 catch (        FileNotFoundException e) {
          log.error(sm.getString("contextConfig.altDDNotFound",altDDName));
        }
catch (        MalformedURLException e) {
          log.error(sm.getString("contextConfig.applicationUrl"));
        }
      }
 else {
        stream=servletContext.getResourceAsStream(Constants.ApplicationWebXml);
        try {
          url=servletContext.getResource(Constants.ApplicationWebXml);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("contextConfig.applicationUrl"));
        }
      }
    }
    if (stream == null || url == null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("contextConfig.applicationMissing") + " " + context);
      }
    }
 else {
      source=new InputSource(url.toExternalForm());
      source.setByteStream(stream);
    }
  }
  finally {
    if (source == null && stream != null) {
      try {
        stream.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return source;
}

ID 3457=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#getContextWebXmlSource()
Rmethod: javax.servlet.ServletContext#getResource(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Identify the application web.xml to be used and obtain an input source for it.
 */
protected InputSource getContextWebXmlSource(){
  InputStream stream=null;
  InputSource source=null;
  URL url=null;
  String altDDName=null;
  ServletContext servletContext=context.getServletContext();
  try {
    if (servletContext != null) {
      altDDName=(String)servletContext.getAttribute(Globals.ALT_DD_ATTR);
      if (altDDName != null) {
        try {
          stream=new FileInputStream(altDDName);
          url=new File(altDDName).toURI().toURL();
        }
 catch (        FileNotFoundException e) {
          log.error(sm.getString("contextConfig.altDDNotFound",altDDName));
        }
catch (        MalformedURLException e) {
          log.error(sm.getString("contextConfig.applicationUrl"));
        }
      }
 else {
        stream=servletContext.getResourceAsStream(Constants.ApplicationWebXml);
        try {
          url=servletContext.getResource(Constants.ApplicationWebXml);
        }
 catch (        MalformedURLException e) {
          log.error(sm.getString("contextConfig.applicationUrl"));
        }
      }
    }
    if (stream == null || url == null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("contextConfig.applicationMissing") + " " + context);
      }
    }
 else {
      source=new InputSource(url.toExternalForm());
      source.setByteStream(stream);
    }
  }
  finally {
    if (source == null && stream != null) {
      try {
        stream.close();
      }
 catch (      IOException e) {
      }
    }
  }
  return source;
}

ID 3464=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsUrl(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: java.net.URL#toURI()
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
protected void processAnnotationsUrl(URL url,WebXml fragment,boolean handlesTypesOnly){
  if (url == null) {
    return;
  }
 else   if ("jar".equals(url.getProtocol())) {
    processAnnotationsJar(url,fragment,handlesTypesOnly);
  }
 else   if ("jndi".equals(url.getProtocol())) {
    processAnnotationsJndi(url,fragment,handlesTypesOnly);
  }
 else   if ("file".equals(url.getProtocol())) {
    try {
      processAnnotationsFile(new File(url.toURI()),fragment,handlesTypesOnly);
    }
 catch (    URISyntaxException e) {
      log.error(sm.getString("contextConfig.fileUrl",url),e);
    }
  }
 else {
    log.error(sm.getString("contextConfig.unknownUrlProtocol",url.getProtocol(),url));
  }
}

ID 3465=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJar(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.tomcat.util.scan.JarFactory#newInstance(java.net.URL)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJar(URL url,WebXml fragment,boolean handlesTypesOnly){
  Jar jar=null;
  InputStream is;
  try {
    jar=JarFactory.newInstance(url);
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("contextConfig.processAnnotationsJar.debug",url));
    }
    jar.nextEntry();
    String entryName=jar.getEntryName();
    while (entryName != null) {
      if (entryName.endsWith(".class")) {
        is=null;
        try {
          is=jar.getEntryInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException ioe) {
            }
          }
        }
      }
      jar.nextEntry();
      entryName=jar.getEntryName();
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jarFile",url),e);
  }
 finally {
    if (jar != null) {
      jar.close();
    }
  }
}

ID 3466=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJar(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.tomcat.util.scan.Jar#getEntryInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJar(URL url,WebXml fragment,boolean handlesTypesOnly){
  Jar jar=null;
  InputStream is;
  try {
    jar=JarFactory.newInstance(url);
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("contextConfig.processAnnotationsJar.debug",url));
    }
    jar.nextEntry();
    String entryName=jar.getEntryName();
    while (entryName != null) {
      if (entryName.endsWith(".class")) {
        is=null;
        try {
          is=jar.getEntryInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException ioe) {
            }
          }
        }
      }
      jar.nextEntry();
      entryName=jar.getEntryName();
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jarFile",url),e);
  }
 finally {
    if (jar != null) {
      jar.close();
    }
  }
}

ID 3467=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJar(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.catalina.startup.ContextConfig#processAnnotationsStream(java.io.InputStream, org.apache.catalina.deploy.WebXml, boolean)
parentException: RuntimeException 
thrown: ClassFormatException
exception comment: /** 
 * Thrown when the BCEL attempts to read a class file and determines that the file is malformed or otherwise cannot be interpreted as a class file.
 * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
 */

block: 
protected void processAnnotationsJar(URL url,WebXml fragment,boolean handlesTypesOnly){
  Jar jar=null;
  InputStream is;
  try {
    jar=JarFactory.newInstance(url);
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("contextConfig.processAnnotationsJar.debug",url));
    }
    jar.nextEntry();
    String entryName=jar.getEntryName();
    while (entryName != null) {
      if (entryName.endsWith(".class")) {
        is=null;
        try {
          is=jar.getEntryInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException ioe) {
            }
          }
        }
      }
      jar.nextEntry();
      entryName=jar.getEntryName();
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jarFile",url),e);
  }
 finally {
    if (jar != null) {
      jar.close();
    }
  }
}

ID 3468=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJar(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.catalina.startup.ContextConfig#processAnnotationsStream(java.io.InputStream, org.apache.catalina.deploy.WebXml, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJar(URL url,WebXml fragment,boolean handlesTypesOnly){
  Jar jar=null;
  InputStream is;
  try {
    jar=JarFactory.newInstance(url);
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("contextConfig.processAnnotationsJar.debug",url));
    }
    jar.nextEntry();
    String entryName=jar.getEntryName();
    while (entryName != null) {
      if (entryName.endsWith(".class")) {
        is=null;
        try {
          is=jar.getEntryInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJar",entryName,url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException ioe) {
            }
          }
        }
      }
      jar.nextEntry();
      entryName=jar.getEntryName();
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jarFile",url),e);
  }
 finally {
    if (jar != null) {
      jar.close();
    }
  }
}

ID 3470=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJndi(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: java.net.URL#openConnection()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJndi(URL url,WebXml fragment,boolean handlesTypesOnly){
  try {
    URLConnection urlConn=url.openConnection();
    DirContextURLConnection dcUrlConn;
    if (!(urlConn instanceof DirContextURLConnection)) {
      sm.getString("contextConfig.jndiUrlNotDirContextConn",url);
      return;
    }
    dcUrlConn=(DirContextURLConnection)urlConn;
    dcUrlConn.setUseCaches(false);
    String type=dcUrlConn.getHeaderField(ResourceAttributes.TYPE);
    if (ResourceAttributes.COLLECTION_TYPE.equals(type)) {
      Enumeration<String> dirs=dcUrlConn.list();
      if (log.isDebugEnabled() && dirs.hasMoreElements()) {
        log.debug(sm.getString("contextConfig.processAnnotationsWebDir.debug",url));
      }
      while (dirs.hasMoreElements()) {
        String dir=dirs.nextElement();
        URL dirUrl=new URL(url.toString() + '/' + dir);
        processAnnotationsJndi(dirUrl,fragment,handlesTypesOnly);
      }
    }
 else {
      if (url.getPath().endsWith(".class")) {
        InputStream is=null;
        try {
          is=dcUrlConn.getInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jndiUrl",url),e);
  }
}

ID 3471=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJndi(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.naming.resources.DirContextURLConnection#list()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJndi(URL url,WebXml fragment,boolean handlesTypesOnly){
  try {
    URLConnection urlConn=url.openConnection();
    DirContextURLConnection dcUrlConn;
    if (!(urlConn instanceof DirContextURLConnection)) {
      sm.getString("contextConfig.jndiUrlNotDirContextConn",url);
      return;
    }
    dcUrlConn=(DirContextURLConnection)urlConn;
    dcUrlConn.setUseCaches(false);
    String type=dcUrlConn.getHeaderField(ResourceAttributes.TYPE);
    if (ResourceAttributes.COLLECTION_TYPE.equals(type)) {
      Enumeration<String> dirs=dcUrlConn.list();
      if (log.isDebugEnabled() && dirs.hasMoreElements()) {
        log.debug(sm.getString("contextConfig.processAnnotationsWebDir.debug",url));
      }
      while (dirs.hasMoreElements()) {
        String dir=dirs.nextElement();
        URL dirUrl=new URL(url.toString() + '/' + dir);
        processAnnotationsJndi(dirUrl,fragment,handlesTypesOnly);
      }
    }
 else {
      if (url.getPath().endsWith(".class")) {
        InputStream is=null;
        try {
          is=dcUrlConn.getInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jndiUrl",url),e);
  }
}

ID 3472=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJndi(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: java.net.URL#URL(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJndi(URL url,WebXml fragment,boolean handlesTypesOnly){
  try {
    URLConnection urlConn=url.openConnection();
    DirContextURLConnection dcUrlConn;
    if (!(urlConn instanceof DirContextURLConnection)) {
      sm.getString("contextConfig.jndiUrlNotDirContextConn",url);
      return;
    }
    dcUrlConn=(DirContextURLConnection)urlConn;
    dcUrlConn.setUseCaches(false);
    String type=dcUrlConn.getHeaderField(ResourceAttributes.TYPE);
    if (ResourceAttributes.COLLECTION_TYPE.equals(type)) {
      Enumeration<String> dirs=dcUrlConn.list();
      if (log.isDebugEnabled() && dirs.hasMoreElements()) {
        log.debug(sm.getString("contextConfig.processAnnotationsWebDir.debug",url));
      }
      while (dirs.hasMoreElements()) {
        String dir=dirs.nextElement();
        URL dirUrl=new URL(url.toString() + '/' + dir);
        processAnnotationsJndi(dirUrl,fragment,handlesTypesOnly);
      }
    }
 else {
      if (url.getPath().endsWith(".class")) {
        InputStream is=null;
        try {
          is=dcUrlConn.getInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jndiUrl",url),e);
  }
}

ID 3473=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJndi(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.naming.resources.DirContextURLConnection#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJndi(URL url,WebXml fragment,boolean handlesTypesOnly){
  try {
    URLConnection urlConn=url.openConnection();
    DirContextURLConnection dcUrlConn;
    if (!(urlConn instanceof DirContextURLConnection)) {
      sm.getString("contextConfig.jndiUrlNotDirContextConn",url);
      return;
    }
    dcUrlConn=(DirContextURLConnection)urlConn;
    dcUrlConn.setUseCaches(false);
    String type=dcUrlConn.getHeaderField(ResourceAttributes.TYPE);
    if (ResourceAttributes.COLLECTION_TYPE.equals(type)) {
      Enumeration<String> dirs=dcUrlConn.list();
      if (log.isDebugEnabled() && dirs.hasMoreElements()) {
        log.debug(sm.getString("contextConfig.processAnnotationsWebDir.debug",url));
      }
      while (dirs.hasMoreElements()) {
        String dir=dirs.nextElement();
        URL dirUrl=new URL(url.toString() + '/' + dir);
        processAnnotationsJndi(dirUrl,fragment,handlesTypesOnly);
      }
    }
 else {
      if (url.getPath().endsWith(".class")) {
        InputStream is=null;
        try {
          is=dcUrlConn.getInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jndiUrl",url),e);
  }
}

ID 3474=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJndi(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.catalina.startup.ContextConfig#processAnnotationsStream(java.io.InputStream, org.apache.catalina.deploy.WebXml, boolean)
parentException: RuntimeException 
thrown: ClassFormatException
exception comment: /** 
 * Thrown when the BCEL attempts to read a class file and determines that the file is malformed or otherwise cannot be interpreted as a class file.
 * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
 */

block: 
protected void processAnnotationsJndi(URL url,WebXml fragment,boolean handlesTypesOnly){
  try {
    URLConnection urlConn=url.openConnection();
    DirContextURLConnection dcUrlConn;
    if (!(urlConn instanceof DirContextURLConnection)) {
      sm.getString("contextConfig.jndiUrlNotDirContextConn",url);
      return;
    }
    dcUrlConn=(DirContextURLConnection)urlConn;
    dcUrlConn.setUseCaches(false);
    String type=dcUrlConn.getHeaderField(ResourceAttributes.TYPE);
    if (ResourceAttributes.COLLECTION_TYPE.equals(type)) {
      Enumeration<String> dirs=dcUrlConn.list();
      if (log.isDebugEnabled() && dirs.hasMoreElements()) {
        log.debug(sm.getString("contextConfig.processAnnotationsWebDir.debug",url));
      }
      while (dirs.hasMoreElements()) {
        String dir=dirs.nextElement();
        URL dirUrl=new URL(url.toString() + '/' + dir);
        processAnnotationsJndi(dirUrl,fragment,handlesTypesOnly);
      }
    }
 else {
      if (url.getPath().endsWith(".class")) {
        InputStream is=null;
        try {
          is=dcUrlConn.getInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jndiUrl",url),e);
  }
}

ID 3475=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsJndi(java.net.URL, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.catalina.startup.ContextConfig#processAnnotationsStream(java.io.InputStream, org.apache.catalina.deploy.WebXml, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsJndi(URL url,WebXml fragment,boolean handlesTypesOnly){
  try {
    URLConnection urlConn=url.openConnection();
    DirContextURLConnection dcUrlConn;
    if (!(urlConn instanceof DirContextURLConnection)) {
      sm.getString("contextConfig.jndiUrlNotDirContextConn",url);
      return;
    }
    dcUrlConn=(DirContextURLConnection)urlConn;
    dcUrlConn.setUseCaches(false);
    String type=dcUrlConn.getHeaderField(ResourceAttributes.TYPE);
    if (ResourceAttributes.COLLECTION_TYPE.equals(type)) {
      Enumeration<String> dirs=dcUrlConn.list();
      if (log.isDebugEnabled() && dirs.hasMoreElements()) {
        log.debug(sm.getString("contextConfig.processAnnotationsWebDir.debug",url));
      }
      while (dirs.hasMoreElements()) {
        String dir=dirs.nextElement();
        URL dirUrl=new URL(url.toString() + '/' + dir);
        processAnnotationsJndi(dirUrl,fragment,handlesTypesOnly);
      }
    }
 else {
      if (url.getPath().endsWith(".class")) {
        InputStream is=null;
        try {
          is=dcUrlConn.getInputStream();
          processAnnotationsStream(is,fragment,handlesTypesOnly);
        }
 catch (        IOException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
catch (        ClassFormatException e) {
          log.error(sm.getString("contextConfig.inputStreamJndi",url),e);
        }
 finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    log.error(sm.getString("contextConfig.jndiUrl",url),e);
  }
}

ID 3477=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsFile(java.io.File, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsFile(File file,WebXml fragment,boolean handlesTypesOnly){
  if (file.isDirectory()) {
    String[] dirs=file.list();
    if (dirs != null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("contextConfig.processAnnotationsDir.debug",file));
      }
      for (      String dir : dirs) {
        processAnnotationsFile(new File(file,dir),fragment,handlesTypesOnly);
      }
    }
  }
 else   if (file.getName().endsWith(".class") && file.canRead()) {
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(file);
      processAnnotationsStream(fis,fragment,handlesTypesOnly);
    }
 catch (    IOException e) {
      log.error(sm.getString("contextConfig.inputStreamFile",file.getAbsolutePath()),e);
    }
catch (    ClassFormatException e) {
      log.error(sm.getString("contextConfig.inputStreamFile",file.getAbsolutePath()),e);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        Throwable t) {
          ExceptionUtils.handleThrowable(t);
        }
      }
    }
  }
}

ID 3478=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsFile(java.io.File, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.catalina.startup.ContextConfig#processAnnotationsStream(java.io.InputStream, org.apache.catalina.deploy.WebXml, boolean)
parentException: RuntimeException 
thrown: ClassFormatException
exception comment: /** 
 * Thrown when the BCEL attempts to read a class file and determines that the file is malformed or otherwise cannot be interpreted as a class file.
 * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
 */

block: 
protected void processAnnotationsFile(File file,WebXml fragment,boolean handlesTypesOnly){
  if (file.isDirectory()) {
    String[] dirs=file.list();
    if (dirs != null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("contextConfig.processAnnotationsDir.debug",file));
      }
      for (      String dir : dirs) {
        processAnnotationsFile(new File(file,dir),fragment,handlesTypesOnly);
      }
    }
  }
 else   if (file.getName().endsWith(".class") && file.canRead()) {
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(file);
      processAnnotationsStream(fis,fragment,handlesTypesOnly);
    }
 catch (    IOException e) {
      log.error(sm.getString("contextConfig.inputStreamFile",file.getAbsolutePath()),e);
    }
catch (    ClassFormatException e) {
      log.error(sm.getString("contextConfig.inputStreamFile",file.getAbsolutePath()),e);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        Throwable t) {
          ExceptionUtils.handleThrowable(t);
        }
      }
    }
  }
}

ID 3479=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#processAnnotationsFile(java.io.File, org.apache.catalina.deploy.WebXml, boolean)
Rmethod: org.apache.catalina.startup.ContextConfig#processAnnotationsStream(java.io.InputStream, org.apache.catalina.deploy.WebXml, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void processAnnotationsFile(File file,WebXml fragment,boolean handlesTypesOnly){
  if (file.isDirectory()) {
    String[] dirs=file.list();
    if (dirs != null) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("contextConfig.processAnnotationsDir.debug",file));
      }
      for (      String dir : dirs) {
        processAnnotationsFile(new File(file,dir),fragment,handlesTypesOnly);
      }
    }
  }
 else   if (file.getName().endsWith(".class") && file.canRead()) {
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(file);
      processAnnotationsStream(fis,fragment,handlesTypesOnly);
    }
 catch (    IOException e) {
      log.error(sm.getString("contextConfig.inputStreamFile",file.getAbsolutePath()),e);
    }
catch (    ClassFormatException e) {
      log.error(sm.getString("contextConfig.inputStreamFile",file.getAbsolutePath()),e);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        Throwable t) {
          ExceptionUtils.handleThrowable(t);
        }
      }
    }
  }
}

ID 3483=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#populateJavaClassCache(java.lang.String)
Rmethod: org.apache.tomcat.util.bcel.classfile.ClassParser#parse()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void populateJavaClassCache(String className){
  if (!javaClassCache.containsKey(className)) {
    String name=className.replace('.','/') + ".class";
    InputStream is=context.getLoader().getClassLoader().getResourceAsStream(name);
    if (is == null) {
      return;
    }
    ClassParser parser=new ClassParser(is);
    try {
      JavaClass clazz=parser.parse();
      populateJavaClassCache(clazz.getClassName(),clazz);
    }
 catch (    ClassFormatException e) {
      log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",className),e);
    }
catch (    IOException e) {
      log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",className),e);
    }
 finally {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 3484=========================================================================type: 1
Method:org.apache.catalina.startup.ContextConfig#populateJavaClassCache(java.lang.String)
Rmethod: org.apache.tomcat.util.bcel.classfile.ClassParser#parse()
parentException: RuntimeException 
thrown: ClassFormatException
exception comment: /** 
 * Thrown when the BCEL attempts to read a class file and determines that the file is malformed or otherwise cannot be interpreted as a class file.
 * @author  <A HREF="mailto:markus.dahm@berlin.de">M. Dahm</A>
 */

block: 
private void populateJavaClassCache(String className){
  if (!javaClassCache.containsKey(className)) {
    String name=className.replace('.','/') + ".class";
    InputStream is=context.getLoader().getClassLoader().getResourceAsStream(name);
    if (is == null) {
      return;
    }
    ClassParser parser=new ClassParser(is);
    try {
      JavaClass clazz=parser.parse();
      populateJavaClassCache(clazz.getClassName(),clazz);
    }
 catch (    ClassFormatException e) {
      log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",className),e);
    }
catch (    IOException e) {
      log.debug(sm.getString("contextConfig.invalidSciHandlesTypes",className),e);
    }
 finally {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
}

ID 3498=========================================================================type: 1
Method:org.apache.catalina.startup.Embedded#addEngine(org.apache.catalina.Engine)
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Add a new Engine to the set of defined Engines.
 * @param engine The engine to be added
 */
public synchronized void addEngine(Engine engine){
  if (log.isDebugEnabled())   log.debug("Adding engine (" + engine.getInfo() + ")");
  Engine results[]=new Engine[engines.length + 1];
  for (int i=0; i < engines.length; i++)   results[i]=engines[i];
  results[engines.length]=engine;
  engines=results;
  if (getState().isAvailable()) {
    try {
      engine.start();
    }
 catch (    LifecycleException e) {
      log.error("Engine.start",e);
    }
  }
  this.container=engine;
}

ID 3499=========================================================================type: 1
Method:org.apache.catalina.startup.Embedded#removeEngine(org.apache.catalina.Engine)
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Remove the specified Engine from the set of defined Engines, along with all of its related Hosts and Contexts.  All associated Connectors are also removed.
 * @param engine The Engine to be removed
 */
public synchronized void removeEngine(Engine engine){
  if (log.isDebugEnabled())   log.debug("Removing engine (" + engine.getInfo() + ")");
  int j=-1;
  for (int i=0; i < engines.length; i++) {
    if (engine == engines[i]) {
      j=i;
      break;
    }
  }
  if (j < 0)   return;
  if (log.isDebugEnabled())   log.debug(" Removing related Containers");
  while (true) {
    int n=-1;
    for (int i=0; i < connectors.length; i++) {
      if (connectors[i].getService().getContainer() == engine) {
        n=i;
        break;
      }
    }
    if (n < 0)     break;
    removeConnector(connectors[n]);
  }
  if (log.isDebugEnabled())   log.debug(" Stopping this Engine");
  try {
    engine.stop();
  }
 catch (  LifecycleException e) {
    log.error("Engine.stop",e);
  }
  if (log.isDebugEnabled())   log.debug(" Removing this Engine");
  int k=0;
  Engine results[]=new Engine[engines.length - 1];
  for (int i=0; i < engines.length; i++) {
    if (i != j)     results[k++]=engines[i];
  }
  engines=results;
}

ID 3504=========================================================================type: 1
Method:org.apache.catalina.startup.Embedded#initDirs()
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void initDirs(){
  String catalinaHome=System.getProperty(Globals.CATALINA_HOME_PROP);
  if (catalinaHome == null) {
    String j2eeHome=System.getProperty("com.sun.enterprise.home");
    if (j2eeHome != null) {
      catalinaHome=System.getProperty("com.sun.enterprise.home");
    }
 else     if (System.getProperty(Globals.CATALINA_BASE_PROP) != null) {
      catalinaHome=System.getProperty(Globals.CATALINA_BASE_PROP);
    }
 else {
      catalinaHome=IntrospectionUtils.guessInstall(Globals.CATALINA_HOME_PROP,Globals.CATALINA_BASE_PROP,"catalina.jar");
      if (catalinaHome == null) {
        catalinaHome=IntrospectionUtils.guessInstall("tomcat.install",Globals.CATALINA_HOME_PROP,"tomcat.jar");
      }
    }
  }
  if (catalinaHome == null) {
    catalinaHome=System.getProperty("user.dir");
  }
  if (catalinaHome != null) {
    File home=new File(catalinaHome);
    if (!home.isAbsolute()) {
      try {
        catalinaHome=home.getCanonicalPath();
      }
 catch (      IOException e) {
        catalinaHome=home.getAbsolutePath();
      }
    }
    System.setProperty(Globals.CATALINA_HOME_PROP,catalinaHome);
  }
  if (System.getProperty(Globals.CATALINA_BASE_PROP) == null) {
    System.setProperty(Globals.CATALINA_BASE_PROP,catalinaHome);
  }
 else {
    String catalinaBase=System.getProperty(Globals.CATALINA_BASE_PROP);
    File base=new File(catalinaBase);
    if (!base.isAbsolute()) {
      try {
        catalinaBase=base.getCanonicalPath();
      }
 catch (      IOException e) {
        catalinaBase=base.getAbsolutePath();
      }
    }
    System.setProperty(Globals.CATALINA_BASE_PROP,catalinaBase);
  }
  String temp=System.getProperty("java.io.tmpdir");
  if (temp == null || (!(new File(temp)).exists()) || (!(new File(temp)).isDirectory())) {
    log.error(sm.getString("embedded.notmp",temp));
  }
}

ID 3505=========================================================================type: 1
Method:org.apache.catalina.startup.Tool#main(java.lang.String[])
Rmethod: org.apache.catalina.startup.ClassLoaderFactory#createClassLoader(java.io.File[], java.io.File[], java.lang.ClassLoader)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * The main program for the bootstrap.
 * @param args Command line arguments to be processed
 */
@SuppressWarnings("null") public static void main(String args[]){
  if (catalinaHome == null) {
    log.error("Must set '" + Globals.CATALINA_HOME_PROP + "' system property");
    System.exit(1);
  }
  int index=0;
  while (true) {
    if (index == args.length) {
      usage();
      System.exit(1);
    }
    if ("-ant".equals(args[index]))     ant=true;
 else     if ("-common".equals(args[index]))     common=true;
 else     if ("-server".equals(args[index]))     server=true;
 else     if ("-shared".equals(args[index]))     shared=true;
 else     break;
    index++;
  }
  if (index > args.length) {
    usage();
    System.exit(1);
  }
  if (ant)   System.setProperty("ant.home",catalinaHome);
  ClassLoader classLoader=null;
  try {
    ArrayList<File> packed=new ArrayList<File>();
    ArrayList<File> unpacked=new ArrayList<File>();
    unpacked.add(new File(catalinaHome,"classes"));
    packed.add(new File(catalinaHome,"lib"));
    if (common) {
      unpacked.add(new File(catalinaHome,"common" + File.separator + "classes"));
      packed.add(new File(catalinaHome,"common" + File.separator + "lib"));
    }
    if (server) {
      unpacked.add(new File(catalinaHome,"server" + File.separator + "classes"));
      packed.add(new File(catalinaHome,"server" + File.separator + "lib"));
    }
    if (shared) {
      unpacked.add(new File(catalinaHome,"shared" + File.separator + "classes"));
      packed.add(new File(catalinaHome,"shared" + File.separator + "lib"));
    }
    classLoader=ClassLoaderFactory.createClassLoader(unpacked.toArray(new File[0]),packed.toArray(new File[0]),null);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log.error("Class loader creation threw exception",t);
    System.exit(1);
  }
  Thread.currentThread().setContextClassLoader(classLoader);
  Class<?> clazz=null;
  String className=args[index++];
  try {
    if (log.isDebugEnabled())     log.debug("Loading application class " + className);
    clazz=classLoader.loadClass(className);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log.error("Exception creating instance of " + className,t);
    System.exit(1);
  }
  Method method=null;
  String params[]=new String[args.length - index];
  System.arraycopy(args,index,params,0,params.length);
  try {
    if (log.isDebugEnabled())     log.debug("Identifying main() method");
    String methodName="main";
    Class<?> paramTypes[]=new Class[1];
    paramTypes[0]=params.getClass();
    method=clazz.getMethod(methodName,paramTypes);
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log.error("Exception locating main() method",t);
    System.exit(1);
  }
  try {
    if (log.isDebugEnabled())     log.debug("Calling main() method");
    Object paramValues[]=new Object[1];
    paramValues[0]=params;
    method.invoke(null,paramValues);
  }
 catch (  Throwable t) {
    t=ExceptionUtils.unwrapInvocationTargetException(t);
    ExceptionUtils.handleThrowable(t);
    log.error("Exception calling main() method",t);
    System.exit(1);
  }
}

ID 3512=========================================================================type: 1
Method:org.apache.catalina.startup.TldConfig#tldScanWebXml()
Rmethod: org.apache.catalina.startup.TldConfig#tldScanStream(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Get the taglib entries from web.xml and add them to the map. This is not kept in sync with o.a.j.compiler.TldLocationsCache as this code needs to scan the TLDs listed in web.xml whereas Jasper only needs the URI to TLD mappings.
 */
private void tldScanWebXml(){
  if (log.isTraceEnabled()) {
    log.trace(sm.getString("tldConfig.webxmlStart"));
  }
  Collection<TaglibDescriptor> descriptors=context.getJspConfigDescriptor().getTaglibs();
  for (  TaglibDescriptor descriptor : descriptors) {
    String resourcePath=descriptor.getTaglibLocation();
    if (!resourcePath.startsWith("/")) {
      resourcePath=WEB_INF + resourcePath;
    }
    if (taglibUris.contains(descriptor.getTaglibURI())) {
      log.warn(sm.getString("tldConfig.webxmlSkip",resourcePath,descriptor.getTaglibURI()));
    }
 else {
      if (log.isTraceEnabled()) {
        log.trace(sm.getString("tldConfig.webxmlAdd",resourcePath,descriptor.getTaglibURI()));
      }
      InputStream stream=null;
      try {
        stream=context.getServletContext().getResourceAsStream(resourcePath);
        if (stream != null) {
          XmlErrorHandler handler=tldScanStream(stream);
          handler.logFindings(log,resourcePath);
          taglibUris.add(descriptor.getTaglibURI());
          webxmlTaglibUris.add(descriptor.getTaglibURI());
        }
 else {
          log.warn(sm.getString("tldConfig.webxmlFailPathDoesNotExist",resourcePath,descriptor.getTaglibURI()));
        }
      }
 catch (      IOException ioe) {
        log.warn(sm.getString("tldConfig.webxmlFail",resourcePath,descriptor.getTaglibURI()),ioe);
      }
 finally {
        if (stream != null) {
          try {
            stream.close();
          }
 catch (          Throwable t) {
            ExceptionUtils.handleThrowable(t);
          }
        }
      }
    }
  }
}

ID 3514=========================================================================type: 1
Method:org.apache.catalina.startup.TldConfig#tldScanResourcePaths(java.lang.String)
Rmethod: org.apache.catalina.startup.TldConfig#tldScanStream(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void tldScanResourcePaths(String startPath){
  if (log.isTraceEnabled()) {
    log.trace(sm.getString("tldConfig.webinfScan",startPath));
  }
  ServletContext ctxt=context.getServletContext();
  Set<String> dirList=ctxt.getResourcePaths(startPath);
  if (dirList != null) {
    Iterator<String> it=dirList.iterator();
    while (it.hasNext()) {
      String path=it.next();
      if (!path.endsWith(TLD_EXT) && (path.startsWith(WEB_INF_LIB) || path.startsWith("/WEB-INF/classes/"))) {
        continue;
      }
      if (path.endsWith(TLD_EXT)) {
        if (path.startsWith("/WEB-INF/tags/") && !path.endsWith("implicit.tld")) {
          continue;
        }
        InputStream stream=ctxt.getResourceAsStream(path);
        try {
          XmlErrorHandler handler=tldScanStream(stream);
          handler.logFindings(log,path);
        }
 catch (        IOException ioe) {
          log.warn(sm.getString("tldConfig.webinfFail",path),ioe);
        }
 finally {
          if (stream != null) {
            try {
              stream.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
 else {
        tldScanResourcePaths(path);
      }
    }
  }
}

ID 3516=========================================================================type: 1
Method:org.apache.catalina.startup.TldConfig#tldScanDir(java.io.File)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
private boolean tldScanDir(File start){
  boolean isFound=false;
  if (log.isTraceEnabled()) {
    log.trace(sm.getString("tldConfig.dirScan",start.getAbsolutePath()));
  }
  File[] fileList=start.listFiles();
  if (fileList != null) {
    for (int i=0; i < fileList.length; i++) {
      if (fileList[i].isDirectory()) {
        tldScanDir(fileList[i]);
      }
 else       if (fileList[i].getAbsolutePath().endsWith(TLD_EXT)) {
        InputStream stream=null;
        isFound=true;
        try {
          stream=new FileInputStream(fileList[i]);
          XmlErrorHandler handler=tldScanStream(stream);
          handler.logFindings(log,fileList[i].getAbsolutePath());
        }
 catch (        IOException ioe) {
          log.warn(sm.getString("tldConfig.dirFail",fileList[i].getAbsolutePath()),ioe);
        }
 finally {
          if (stream != null) {
            try {
              stream.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
  if (!isFound) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("tldConfig.noTldInDir",start.getAbsolutePath()));
    }
  }
  return isFound;
}

ID 3517=========================================================================type: 1
Method:org.apache.catalina.startup.TldConfig#tldScanDir(java.io.File)
Rmethod: org.apache.catalina.startup.TldConfig#tldScanStream(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private boolean tldScanDir(File start){
  boolean isFound=false;
  if (log.isTraceEnabled()) {
    log.trace(sm.getString("tldConfig.dirScan",start.getAbsolutePath()));
  }
  File[] fileList=start.listFiles();
  if (fileList != null) {
    for (int i=0; i < fileList.length; i++) {
      if (fileList[i].isDirectory()) {
        tldScanDir(fileList[i]);
      }
 else       if (fileList[i].getAbsolutePath().endsWith(TLD_EXT)) {
        InputStream stream=null;
        isFound=true;
        try {
          stream=new FileInputStream(fileList[i]);
          XmlErrorHandler handler=tldScanStream(stream);
          handler.logFindings(log,fileList[i].getAbsolutePath());
        }
 catch (        IOException ioe) {
          log.warn(sm.getString("tldConfig.dirFail",fileList[i].getAbsolutePath()),ioe);
        }
 finally {
          if (stream != null) {
            try {
              stream.close();
            }
 catch (            Throwable t) {
              ExceptionUtils.handleThrowable(t);
            }
          }
        }
      }
    }
  }
  if (!isFound) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("tldConfig.noTldInDir",start.getAbsolutePath()));
    }
  }
  return isFound;
}

ID 3519=========================================================================type: 1
Method:org.apache.catalina.startup.TldConfig#tldScanJar(java.net.JarURLConnection)
Rmethod: org.apache.tomcat.util.scan.JarFactory#newInstance(java.net.URL)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private boolean tldScanJar(JarURLConnection jarConn){
  Jar jar=null;
  InputStream is;
  boolean isFound=false;
  try {
    jar=JarFactory.newInstance(jarConn.getURL());
    jar.nextEntry();
    String entryName=jar.getEntryName();
    while (entryName != null) {
      if (entryName.startsWith("META-INF/") && entryName.endsWith(".tld")) {
        isFound=true;
        is=null;
        try {
          is=jar.getEntryInputStream();
          XmlErrorHandler handler=tldScanStream(is);
          handler.logFindings(log,jarConn.getURL() + entryName);
        }
  finally {
          if (is != null) {
            try {
              is.close();
            }
 catch (            IOException ioe) {
            }
          }
        }
      }
      jar.nextEntry();
      entryName=jar.getEntryName();
    }
    if (!isFound) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("tldConfig.noTldInJar",jarConn.getURL().getFile()));
      }
    }
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("tldConfig.jarFail",jarConn.getURL()),ioe);
  }
 finally {
    if (jar != null) {
      jar.close();
    }
  }
  return isFound;
}

ID 3524=========================================================================type: 1
Method:org.apache.catalina.startup.TldConfig#tldScanStream(java.io.InputStream)
Rmethod: org.apache.tomcat.util.digester.Digester#parse(org.xml.sax.InputSource)
parentException: 
thrown: SAXException
exception comment: /** 
 * Encapsulate a general SAX error or warning. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>This class can contain basic error or warning information from either the XML parser or the application: a parser writer or application writer can subclass it to provide additional functionality.  SAX handlers may throw this exception or any exception subclassed from it.</p> <p>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</p> <p>If the parser or application needs to include information about a specific location in an XML document, it should use the {@link org.xml.sax.SAXParseException SAXParseException} subclass.</p>
 * @since SAX 1.0
 * @author David Megginson
 * @version 2.0.1 (sax2r2)
 * @see org.xml.sax.SAXParseException
 */

block: 
private XmlErrorHandler tldScanStream(InputStream resourceStream) throws IOException {
  InputSource source=new InputSource(resourceStream);
  XmlErrorHandler result=new XmlErrorHandler();
synchronized (tldDigester) {
    try {
      tldDigester.setErrorHandler(result);
      tldDigester.push(this);
      tldDigester.parse(source);
    }
 catch (    SAXException s) {
      throw new IOException(s);
    }
 finally {
      tldDigester.reset();
    }
    return result;
  }
}

ID 3525=========================================================================type: 1
Method:org.apache.catalina.startup.HostConfig#returnCanonicalPath(java.lang.String)
Rmethod: java.io.File#getCanonicalFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected File returnCanonicalPath(String path){
  File file=new File(path);
  File base=new File(System.getProperty(Globals.CATALINA_BASE_PROP));
  if (!file.isAbsolute())   file=new File(base,path);
  try {
    return file.getCanonicalFile();
  }
 catch (  IOException e) {
    return file;
  }
}

ID 3539=========================================================================type: 1
Method:org.apache.catalina.startup.HostConfig#validateContextPath(java.io.File, java.lang.String)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private boolean validateContextPath(File appBase,String contextPath){
  StringBuilder docBase;
  String canonicalDocBase=null;
  try {
    String canonicalAppBase=appBase.getCanonicalPath();
    docBase=new StringBuilder(canonicalAppBase);
    if (canonicalAppBase.endsWith(File.separator)) {
      docBase.append(contextPath.substring(1).replace('/',File.separatorChar));
    }
 else {
      docBase.append(contextPath.replace('/',File.separatorChar));
    }
    canonicalDocBase=(new File(docBase.toString())).getCanonicalPath();
    if (canonicalDocBase.endsWith(File.separator)) {
      docBase.append(File.separator);
    }
  }
 catch (  IOException ioe) {
    return false;
  }
  return canonicalDocBase.equals(docBase.toString());
}

ID 3576=========================================================================type: 1
Method:org.apache.catalina.startup.HostConfig#isDeletableResource(org.apache.catalina.startup.HostConfig.DeployedApplication, java.io.File)
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private boolean isDeletableResource(DeployedApplication app,File resource){
  if (!resource.isAbsolute()) {
    log.warn(sm.getString("hostConfig.resourceNotAbsolute",app.name,resource));
    return false;
  }
  String canonicalLocation;
  try {
    canonicalLocation=resource.getParentFile().getCanonicalPath();
  }
 catch (  IOException e) {
    log.warn(sm.getString("hostConfig.canonicalizing",resource.getParentFile(),app.name),e);
    return false;
  }
  String canonicalAppBase;
  try {
    canonicalAppBase=appBase().getCanonicalPath();
  }
 catch (  IOException e) {
    log.warn(sm.getString("hostConfig.canonicalizing",appBase(),app.name),e);
    return false;
  }
  if (canonicalLocation.equals(canonicalAppBase)) {
    return true;
  }
  String canonicalConfigBase;
  try {
    canonicalConfigBase=configBase().getCanonicalPath();
  }
 catch (  IOException e) {
    log.warn(sm.getString("hostConfig.canonicalizing",configBase(),app.name),e);
    return false;
  }
  if (canonicalLocation.equals(canonicalConfigBase) && resource.getName().endsWith(".xml")) {
    return true;
  }
  return false;
}

ID 3578=========================================================================type: 1
Method:org.apache.catalina.startup.HostConfig#start()
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process a "start" event for this Host.
 */
public void start(){
  if (log.isDebugEnabled())   log.debug(sm.getString("hostConfig.start"));
  try {
    ObjectName hostON=host.getObjectName();
    oname=new ObjectName(hostON.getDomain() + ":type=Deployer,host=" + host.getName());
    Registry.getRegistry(null,null).registerComponent(this,oname,this.getClass().getName());
  }
 catch (  Exception e) {
    log.error(sm.getString("hostConfig.jmx.register",oname),e);
  }
  if (!appBase().isDirectory()) {
    log.error(sm.getString("hostConfig.appBase",host.getName(),appBase().getPath()));
    host.setDeployOnStartup(false);
    host.setAutoDeploy(false);
  }
  if (host.getDeployOnStartup()) {
    deployApps();
  }
}

ID 3579=========================================================================type: 1
Method:org.apache.catalina.startup.SetPublicIdRule#begin(java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
@Override public void begin(String namespace,String name,Attributes attributes) throws Exception {
  Object top=digester.peek();
  Class<?> paramClasses[]=new Class[1];
  paramClasses[0]="String".getClass();
  String paramValues[]=new String[1];
  paramValues[0]=digester.getPublicId();
  Method m=null;
  try {
    m=top.getClass().getMethod(method,paramClasses);
  }
 catch (  NoSuchMethodException e) {
    digester.getLogger().error("Can't find method " + method + " in "+ top+ " CLASS "+ top.getClass());
    return;
  }
  m.invoke(top,(Object[])paramValues);
  if (digester.getLogger().isDebugEnabled())   digester.getLogger().debug("" + top.getClass().getName() + "."+ method+ "("+ paramValues[0]+ ")");
}

ID 3590=========================================================================type: 1
Method:org.apache.catalina.startup.CatalinaProperties#loadProperties()
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Load properties.
 */
private static void loadProperties(){
  InputStream is=null;
  Throwable error=null;
  try {
    String configUrl=getConfigUrl();
    if (configUrl != null) {
      is=(new URL(configUrl)).openStream();
    }
  }
 catch (  Throwable t) {
    handleThrowable(t);
  }
  if (is == null) {
    try {
      File home=new File(getCatalinaBase());
      File conf=new File(home,"conf");
      File propsFile=new File(conf,"catalina.properties");
      is=new FileInputStream(propsFile);
    }
 catch (    Throwable t) {
      handleThrowable(t);
    }
  }
  if (is == null) {
    try {
      is=CatalinaProperties.class.getResourceAsStream("/org/apache/catalina/startup/catalina.properties");
    }
 catch (    Throwable t) {
      handleThrowable(t);
    }
  }
  if (is != null) {
    try {
      properties=new Properties();
      properties.load(is);
    }
 catch (    Throwable t) {
      handleThrowable(t);
      error=t;
    }
 finally {
      try {
        is.close();
      }
 catch (      IOException ioe) {
        log.warn("Could not close catalina.properties",ioe);
      }
    }
  }
  if ((is == null) || (error != null)) {
    log.warn("Failed to load catalina.properties",error);
    properties=new Properties();
  }
  Enumeration<?> enumeration=properties.propertyNames();
  while (enumeration.hasMoreElements()) {
    String name=(String)enumeration.nextElement();
    String value=properties.getProperty(name);
    if (value != null) {
      System.setProperty(name,value);
    }
  }
}

ID 3603=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stopServer(java.lang.String[])
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
public void stopServer(String[] arguments){
  if (arguments != null) {
    arguments(arguments);
  }
  Server s=getServer();
  if (s == null) {
    Digester digester=createStopDigester();
    File file=configFile();
    FileInputStream fis=null;
    try {
      InputSource is=new InputSource(file.toURI().toURL().toString());
      fis=new FileInputStream(file);
      is.setByteStream(fis);
      digester.push(this);
      digester.parse(is);
    }
 catch (    Exception e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    try {
      s.stop();
    }
 catch (    LifecycleException e) {
      log.error("Catalina.stop: ",e);
    }
    return;
  }
  s=getServer();
  if (s.getPort() > 0) {
    Socket socket=null;
    OutputStream stream=null;
    try {
      socket=new Socket(s.getAddress(),s.getPort());
      stream=socket.getOutputStream();
      String shutdown=s.getShutdown();
      for (int i=0; i < shutdown.length(); i++) {
        stream.write(shutdown.charAt(i));
      }
      stream.flush();
    }
 catch (    ConnectException ce) {
      log.error(sm.getString("catalina.stopServer.connectException",s.getAddress(),String.valueOf(s.getPort())));
      log.error("Catalina.stop: ",ce);
      System.exit(1);
    }
catch (    IOException e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (stream != null) {
        try {
          stream.close();
        }
 catch (        IOException e) {
        }
      }
      if (socket != null) {
        try {
          socket.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
  }
}

ID 3604=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stopServer(java.lang.String[])
Rmethod: java.net.Socket#Socket(java.lang.String, int)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
public void stopServer(String[] arguments){
  if (arguments != null) {
    arguments(arguments);
  }
  Server s=getServer();
  if (s == null) {
    Digester digester=createStopDigester();
    File file=configFile();
    FileInputStream fis=null;
    try {
      InputSource is=new InputSource(file.toURI().toURL().toString());
      fis=new FileInputStream(file);
      is.setByteStream(fis);
      digester.push(this);
      digester.parse(is);
    }
 catch (    Exception e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    try {
      s.stop();
    }
 catch (    LifecycleException e) {
      log.error("Catalina.stop: ",e);
    }
    return;
  }
  s=getServer();
  if (s.getPort() > 0) {
    Socket socket=null;
    OutputStream stream=null;
    try {
      socket=new Socket(s.getAddress(),s.getPort());
      stream=socket.getOutputStream();
      String shutdown=s.getShutdown();
      for (int i=0; i < shutdown.length(); i++) {
        stream.write(shutdown.charAt(i));
      }
      stream.flush();
    }
 catch (    ConnectException ce) {
      log.error(sm.getString("catalina.stopServer.connectException",s.getAddress(),String.valueOf(s.getPort())));
      log.error("Catalina.stop: ",ce);
      System.exit(1);
    }
catch (    IOException e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (stream != null) {
        try {
          stream.close();
        }
 catch (        IOException e) {
        }
      }
      if (socket != null) {
        try {
          socket.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
  }
}

ID 3605=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stopServer(java.lang.String[])
Rmethod: java.net.Socket#Socket(java.lang.String, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void stopServer(String[] arguments){
  if (arguments != null) {
    arguments(arguments);
  }
  Server s=getServer();
  if (s == null) {
    Digester digester=createStopDigester();
    File file=configFile();
    FileInputStream fis=null;
    try {
      InputSource is=new InputSource(file.toURI().toURL().toString());
      fis=new FileInputStream(file);
      is.setByteStream(fis);
      digester.push(this);
      digester.parse(is);
    }
 catch (    Exception e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    try {
      s.stop();
    }
 catch (    LifecycleException e) {
      log.error("Catalina.stop: ",e);
    }
    return;
  }
  s=getServer();
  if (s.getPort() > 0) {
    Socket socket=null;
    OutputStream stream=null;
    try {
      socket=new Socket(s.getAddress(),s.getPort());
      stream=socket.getOutputStream();
      String shutdown=s.getShutdown();
      for (int i=0; i < shutdown.length(); i++) {
        stream.write(shutdown.charAt(i));
      }
      stream.flush();
    }
 catch (    ConnectException ce) {
      log.error(sm.getString("catalina.stopServer.connectException",s.getAddress(),String.valueOf(s.getPort())));
      log.error("Catalina.stop: ",ce);
      System.exit(1);
    }
catch (    IOException e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (stream != null) {
        try {
          stream.close();
        }
 catch (        IOException e) {
        }
      }
      if (socket != null) {
        try {
          socket.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
  }
}

ID 3606=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stopServer(java.lang.String[])
Rmethod: java.net.Socket#getOutputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void stopServer(String[] arguments){
  if (arguments != null) {
    arguments(arguments);
  }
  Server s=getServer();
  if (s == null) {
    Digester digester=createStopDigester();
    File file=configFile();
    FileInputStream fis=null;
    try {
      InputSource is=new InputSource(file.toURI().toURL().toString());
      fis=new FileInputStream(file);
      is.setByteStream(fis);
      digester.push(this);
      digester.parse(is);
    }
 catch (    Exception e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    try {
      s.stop();
    }
 catch (    LifecycleException e) {
      log.error("Catalina.stop: ",e);
    }
    return;
  }
  s=getServer();
  if (s.getPort() > 0) {
    Socket socket=null;
    OutputStream stream=null;
    try {
      socket=new Socket(s.getAddress(),s.getPort());
      stream=socket.getOutputStream();
      String shutdown=s.getShutdown();
      for (int i=0; i < shutdown.length(); i++) {
        stream.write(shutdown.charAt(i));
      }
      stream.flush();
    }
 catch (    ConnectException ce) {
      log.error(sm.getString("catalina.stopServer.connectException",s.getAddress(),String.valueOf(s.getPort())));
      log.error("Catalina.stop: ",ce);
      System.exit(1);
    }
catch (    IOException e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (stream != null) {
        try {
          stream.close();
        }
 catch (        IOException e) {
        }
      }
      if (socket != null) {
        try {
          socket.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
  }
}

ID 3607=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stopServer(java.lang.String[])
Rmethod: java.io.OutputStream#write(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void stopServer(String[] arguments){
  if (arguments != null) {
    arguments(arguments);
  }
  Server s=getServer();
  if (s == null) {
    Digester digester=createStopDigester();
    File file=configFile();
    FileInputStream fis=null;
    try {
      InputSource is=new InputSource(file.toURI().toURL().toString());
      fis=new FileInputStream(file);
      is.setByteStream(fis);
      digester.push(this);
      digester.parse(is);
    }
 catch (    Exception e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    try {
      s.stop();
    }
 catch (    LifecycleException e) {
      log.error("Catalina.stop: ",e);
    }
    return;
  }
  s=getServer();
  if (s.getPort() > 0) {
    Socket socket=null;
    OutputStream stream=null;
    try {
      socket=new Socket(s.getAddress(),s.getPort());
      stream=socket.getOutputStream();
      String shutdown=s.getShutdown();
      for (int i=0; i < shutdown.length(); i++) {
        stream.write(shutdown.charAt(i));
      }
      stream.flush();
    }
 catch (    ConnectException ce) {
      log.error(sm.getString("catalina.stopServer.connectException",s.getAddress(),String.valueOf(s.getPort())));
      log.error("Catalina.stop: ",ce);
      System.exit(1);
    }
catch (    IOException e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (stream != null) {
        try {
          stream.close();
        }
 catch (        IOException e) {
        }
      }
      if (socket != null) {
        try {
          socket.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
  }
}

ID 3608=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stopServer(java.lang.String[])
Rmethod: java.io.OutputStream#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void stopServer(String[] arguments){
  if (arguments != null) {
    arguments(arguments);
  }
  Server s=getServer();
  if (s == null) {
    Digester digester=createStopDigester();
    File file=configFile();
    FileInputStream fis=null;
    try {
      InputSource is=new InputSource(file.toURI().toURL().toString());
      fis=new FileInputStream(file);
      is.setByteStream(fis);
      digester.push(this);
      digester.parse(is);
    }
 catch (    Exception e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (fis != null) {
        try {
          fis.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    try {
      s.stop();
    }
 catch (    LifecycleException e) {
      log.error("Catalina.stop: ",e);
    }
    return;
  }
  s=getServer();
  if (s.getPort() > 0) {
    Socket socket=null;
    OutputStream stream=null;
    try {
      socket=new Socket(s.getAddress(),s.getPort());
      stream=socket.getOutputStream();
      String shutdown=s.getShutdown();
      for (int i=0; i < shutdown.length(); i++) {
        stream.write(shutdown.charAt(i));
      }
      stream.flush();
    }
 catch (    ConnectException ce) {
      log.error(sm.getString("catalina.stopServer.connectException",s.getAddress(),String.valueOf(s.getPort())));
      log.error("Catalina.stop: ",ce);
      System.exit(1);
    }
catch (    IOException e) {
      log.error("Catalina.stop: ",e);
      System.exit(1);
    }
 finally {
      if (stream != null) {
        try {
          stream.close();
        }
 catch (        IOException e) {
        }
      }
      if (socket != null) {
        try {
          socket.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
 else {
    log.error(sm.getString("catalina.stopServer"));
    System.exit(1);
  }
}

ID 3616=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#load()
Rmethod: org.apache.catalina.Lifecycle#init()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Start a new server instance. } conf/server.xml
 */
public void load(){
  long t1=System.nanoTime();
  initDirs();
  initNaming();
  Digester digester=createStartDigester();
  InputSource inputSource=null;
  InputStream inputStream=null;
  File file=null;
  try {
    try {
      file=configFile();
      inputStream=new FileInputStream(file);
      inputSource=new InputSource(file.toURI().toURL().toString());
    }
 catch (    Exception e) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("catalina.configFail",file),e);
      }
    }
    if (inputStream == null) {
      try {
        inputStream=getClass().getClassLoader().getResourceAsStream(getConfigFile());
        inputSource=new InputSource(getClass().getClassLoader().getResource(getConfigFile()).toString());
      }
 catch (      Exception e) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("catalina.configFail",getConfigFile()),e);
        }
      }
    }
    if (inputStream == null) {
      try {
        inputStream=getClass().getClassLoader().getResourceAsStream("server-embed.xml");
        inputSource=new InputSource(getClass().getClassLoader().getResource("server-embed.xml").toString());
      }
 catch (      Exception e) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("catalina.configFail","server-embed.xml"),e);
        }
      }
    }
    if (inputStream == null || inputSource == null) {
      if (file == null) {
        log.warn(sm.getString("catalina.configFail",getConfigFile() + "] or [server-embed.xml]"));
      }
 else {
        log.warn(sm.getString("catalina.configFail",file.getAbsolutePath()));
        if (file.exists() && !file.canRead()) {
          log.warn("Permissions incorrect, read permission is not allowed on the file.");
        }
      }
      return;
    }
    try {
      inputSource.setByteStream(inputStream);
      digester.push(this);
      digester.parse(inputSource);
    }
 catch (    SAXParseException spe) {
      log.warn("Catalina.start using " + getConfigFile() + ": "+ spe.getMessage());
      return;
    }
catch (    Exception e) {
      log.warn("Catalina.start using " + getConfigFile() + ": ",e);
      return;
    }
  }
  finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      IOException e) {
      }
    }
  }
  getServer().setCatalina(this);
  initStreams();
  try {
    getServer().init();
  }
 catch (  LifecycleException e) {
    if (Boolean.getBoolean("org.apache.catalina.startup.EXIT_ON_INIT_FAILURE")) {
      throw new java.lang.Error(e);
    }
 else {
      log.error("Catalina.start",e);
    }
  }
  long t2=System.nanoTime();
  if (log.isInfoEnabled()) {
    log.info("Initialization processed in " + ((t2 - t1) / 1000000) + " ms");
  }
}

ID 3617=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#start()
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Start a new server instance.
 */
public void start(){
  if (getServer() == null) {
    load();
  }
  if (getServer() == null) {
    log.fatal("Cannot start server. Server instance is not configured.");
    return;
  }
  long t1=System.nanoTime();
  try {
    getServer().start();
  }
 catch (  LifecycleException e) {
    log.fatal(sm.getString("catalina.serverStartFail"),e);
    try {
      getServer().destroy();
    }
 catch (    LifecycleException e1) {
      log.debug("destroy() failed for failed Server ",e1);
    }
    return;
  }
  long t2=System.nanoTime();
  if (log.isInfoEnabled()) {
    log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms");
  }
  if (useShutdownHook) {
    if (shutdownHook == null) {
      shutdownHook=new CatalinaShutdownHook();
    }
    Runtime.getRuntime().addShutdownHook(shutdownHook);
    LogManager logManager=LogManager.getLogManager();
    if (logManager instanceof ClassLoaderLogManager) {
      ((ClassLoaderLogManager)logManager).setUseShutdownHook(false);
    }
  }
  if (await) {
    await();
    stop();
  }
}

ID 3618=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#start()
Rmethod: org.apache.catalina.Lifecycle#destroy()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Start a new server instance.
 */
public void start(){
  if (getServer() == null) {
    load();
  }
  if (getServer() == null) {
    log.fatal("Cannot start server. Server instance is not configured.");
    return;
  }
  long t1=System.nanoTime();
  try {
    getServer().start();
  }
 catch (  LifecycleException e) {
    log.fatal(sm.getString("catalina.serverStartFail"),e);
    try {
      getServer().destroy();
    }
 catch (    LifecycleException e1) {
      log.debug("destroy() failed for failed Server ",e1);
    }
    return;
  }
  long t2=System.nanoTime();
  if (log.isInfoEnabled()) {
    log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms");
  }
  if (useShutdownHook) {
    if (shutdownHook == null) {
      shutdownHook=new CatalinaShutdownHook();
    }
    Runtime.getRuntime().addShutdownHook(shutdownHook);
    LogManager logManager=LogManager.getLogManager();
    if (logManager instanceof ClassLoaderLogManager) {
      ((ClassLoaderLogManager)logManager).setUseShutdownHook(false);
    }
  }
  if (await) {
    await();
    stop();
  }
}

ID 3619=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stop()
Rmethod: org.apache.catalina.Lifecycle#stop()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Stop an existing server instance.
 */
public void stop(){
  try {
    if (useShutdownHook) {
      Runtime.getRuntime().removeShutdownHook(shutdownHook);
      LogManager logManager=LogManager.getLogManager();
      if (logManager instanceof ClassLoaderLogManager) {
        ((ClassLoaderLogManager)logManager).setUseShutdownHook(true);
      }
    }
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
  }
  try {
    Server s=getServer();
    LifecycleState state=s.getState();
    if (LifecycleState.STOPPING_PREP.compareTo(state) <= 0 && LifecycleState.DESTROYED.compareTo(state) >= 0) {
    }
 else {
      s.stop();
      s.destroy();
    }
  }
 catch (  LifecycleException e) {
    log.error("Catalina.stop",e);
  }
}

ID 3620=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#stop()
Rmethod: org.apache.catalina.Lifecycle#destroy()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Stop an existing server instance.
 */
public void stop(){
  try {
    if (useShutdownHook) {
      Runtime.getRuntime().removeShutdownHook(shutdownHook);
      LogManager logManager=LogManager.getLogManager();
      if (logManager instanceof ClassLoaderLogManager) {
        ((ClassLoaderLogManager)logManager).setUseShutdownHook(true);
      }
    }
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
  }
  try {
    Server s=getServer();
    LifecycleState state=s.getState();
    if (LifecycleState.STOPPING_PREP.compareTo(state) <= 0 && LifecycleState.DESTROYED.compareTo(state) >= 0) {
    }
 else {
      s.stop();
      s.destroy();
    }
  }
 catch (  LifecycleException e) {
    log.error("Catalina.stop",e);
  }
}

ID 3621=========================================================================type: 1
Method:org.apache.catalina.startup.Catalina#initDirs()
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void initDirs(){
  String catalinaHome=System.getProperty(Globals.CATALINA_HOME_PROP);
  if (catalinaHome == null) {
    String j2eeHome=System.getProperty("com.sun.enterprise.home");
    if (j2eeHome != null) {
      catalinaHome=System.getProperty("com.sun.enterprise.home");
    }
 else     if (System.getProperty(Globals.CATALINA_BASE_PROP) != null) {
      catalinaHome=System.getProperty(Globals.CATALINA_BASE_PROP);
    }
  }
  if (catalinaHome == null) {
    catalinaHome=System.getProperty("user.dir");
  }
  if (catalinaHome != null) {
    File home=new File(catalinaHome);
    if (!home.isAbsolute()) {
      try {
        catalinaHome=home.getCanonicalPath();
      }
 catch (      IOException e) {
        catalinaHome=home.getAbsolutePath();
      }
    }
    System.setProperty(Globals.CATALINA_HOME_PROP,catalinaHome);
  }
  if (System.getProperty(Globals.CATALINA_BASE_PROP) == null) {
    System.setProperty(Globals.CATALINA_BASE_PROP,catalinaHome);
  }
 else {
    String catalinaBase=System.getProperty(Globals.CATALINA_BASE_PROP);
    File base=new File(catalinaBase);
    if (!base.isAbsolute()) {
      try {
        catalinaBase=base.getCanonicalPath();
      }
 catch (      IOException e) {
        catalinaBase=base.getAbsolutePath();
      }
    }
    System.setProperty(Globals.CATALINA_BASE_PROP,catalinaBase);
  }
  String temp=System.getProperty("java.io.tmpdir");
  if (temp == null || (!(new File(temp)).exists()) || (!(new File(temp)).isDirectory())) {
    log.error(sm.getString("embedded.notmp",temp));
  }
}

ID 3625=========================================================================type: 1
Method:org.apache.catalina.realm.MemoryRealm#startInternal()
Rmethod: org.apache.tomcat.util.file.ConfigFileLoader#getInputStream(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Prepare for the beginning of active use of the public methods of this component and implement the requirements of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  String pathName=getPathname();
  InputStream is=null;
  try {
    is=ConfigFileLoader.getInputStream(pathName);
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("memoryRealm.loadPath",pathName));
    }
    Digester digester=getDigester();
    try {
synchronized (digester) {
        digester.push(this);
        digester.parse(is);
      }
    }
 catch (    Exception e) {
      throw new LifecycleException(sm.getString("memoryRealm.readXml"),e);
    }
 finally {
      digester.reset();
    }
  }
 catch (  IOException ioe) {
    throw new LifecycleException(sm.getString("memoryRealm.loadExist",pathName),ioe);
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
      }
    }
  }
  super.startInternal();
}

ID 3629=========================================================================type: 1
Method:org.apache.catalina.realm.LockOutRealm#authenticate(org.ietf.jgss.GSSContext, boolean)
Rmethod: org.ietf.jgss.GSSContext#getSrcName()
parentException: 
thrown: GSSException
exception comment: /** 
 * This exception is thrown whenever a GSS-API error occurs, including any mechanism specific error.  It may contain both the major and the minor GSS-API status codes.  Major error codes are those defined at the GSS-API level in this class. Minor error codes are mechanism specific error codes that can provide additional information. The underlying mechanism implementation is responsible for setting appropriate minor status codes when throwing this exception.  Aside from delivering the numeric error codes to the caller, this class performs the mapping from their numeric values to textual representations. <p>
 * @author Mayank Upadhyay
 * @since 1.4
 */

block: 
/** 
 * {@inheritDoc}
 */
@Override public Principal authenticate(GSSContext gssContext,boolean storeCreds){
  if (gssContext.isEstablished()) {
    String username=null;
    GSSName name=null;
    try {
      name=gssContext.getSrcName();
    }
 catch (    GSSException e) {
      log.warn(sm.getString("realmBase.gssNameFail"),e);
      return null;
    }
    username=name.toString();
    Principal authenticatedUser=super.authenticate(gssContext,storeCreds);
    return filterLockedAccounts(username,authenticatedUser);
  }
  return null;
}

ID 3631=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#getHostnameVerifier()
Rmethod: org.apache.catalina.realm.JNDIRealm#constructInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * @return the {@link HostnameVerifier} to use for peer certificateverification when opening connections using StartTLS.
 */
public HostnameVerifier getHostnameVerifier(){
  if (this.hostnameVerifier != null) {
    return this.hostnameVerifier;
  }
  if (this.hostNameVerifierClassName == null || hostNameVerifierClassName.equals("")) {
    return null;
  }
  try {
    Object o=constructInstance(hostNameVerifierClassName);
    if (o instanceof HostnameVerifier) {
      this.hostnameVerifier=(HostnameVerifier)o;
      return this.hostnameVerifier;
    }
 else {
      throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName));
    }
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
}

ID 3632=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#getHostnameVerifier()
Rmethod: org.apache.catalina.realm.JNDIRealm#constructInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * @return the {@link HostnameVerifier} to use for peer certificateverification when opening connections using StartTLS.
 */
public HostnameVerifier getHostnameVerifier(){
  if (this.hostnameVerifier != null) {
    return this.hostnameVerifier;
  }
  if (this.hostNameVerifierClassName == null || hostNameVerifierClassName.equals("")) {
    return null;
  }
  try {
    Object o=constructInstance(hostNameVerifierClassName);
    if (o instanceof HostnameVerifier) {
      this.hostnameVerifier=(HostnameVerifier)o;
      return this.hostnameVerifier;
    }
 else {
      throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName));
    }
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
}

ID 3633=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#getHostnameVerifier()
Rmethod: org.apache.catalina.realm.JNDIRealm#constructInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * @return the {@link HostnameVerifier} to use for peer certificateverification when opening connections using StartTLS.
 */
public HostnameVerifier getHostnameVerifier(){
  if (this.hostnameVerifier != null) {
    return this.hostnameVerifier;
  }
  if (this.hostNameVerifierClassName == null || hostNameVerifierClassName.equals("")) {
    return null;
  }
  try {
    Object o=constructInstance(hostNameVerifierClassName);
    if (o instanceof HostnameVerifier) {
      this.hostnameVerifier=(HostnameVerifier)o;
      return this.hostnameVerifier;
    }
 else {
      throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName));
    }
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidHostnameVerifier",hostNameVerifierClassName),e);
  }
}

ID 3634=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#getSupportedSslProtocols()
Rmethod: javax.net.ssl.SSLContext#getDefault()
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * @return the list of supported ssl protocols by the default{@link SSLContext}
 */
private String[] getSupportedSslProtocols(){
  try {
    SSLContext sslContext=SSLContext.getDefault();
    return sslContext.getSupportedSSLParameters().getProtocols();
  }
 catch (  NoSuchAlgorithmException e) {
    throw new RuntimeException(sm.getString("jndiRealm.exception"),e);
  }
}

ID 3638=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#authenticate(java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.realm.JNDIRealm#open()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Return the Principal associated with the specified username and credentials, if there is one; otherwise return <code>null</code>. If there are any errors with the JDBC connection, executing the query or anything we return null (don't authenticate). This event is also logged, and the connection will be closed so that a subsequent request will automatically re-open it.
 * @param username Username of the Principal to look up
 * @param credentials Password or other credentials to use inauthenticating this username
 */
@Override public Principal authenticate(String username,String credentials){
  DirContext context=null;
  Principal principal=null;
  try {
    context=open();
    try {
      principal=authenticate(context,username,credentials);
    }
 catch (    NullPointerException e) {
      containerLog.info(sm.getString("jndiRealm.exception.retry"),e);
      if (context != null)       close(context);
      context=open();
      principal=authenticate(context,username,credentials);
    }
catch (    CommunicationException e) {
      containerLog.info(sm.getString("jndiRealm.exception.retry"),e);
      if (context != null)       close(context);
      context=open();
      principal=authenticate(context,username,credentials);
    }
catch (    ServiceUnavailableException e) {
      containerLog.info(sm.getString("jndiRealm.exception.retry"),e);
      if (context != null)       close(context);
      context=open();
      principal=authenticate(context,username,credentials);
    }
    release(context);
    return principal;
  }
 catch (  NamingException e) {
    containerLog.error(sm.getString("jndiRealm.exception"),e);
    if (context != null)     close(context);
    if (containerLog.isDebugEnabled())     containerLog.debug("Returning null principal.");
    return null;
  }
}

ID 3656=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#getUserByPattern(javax.naming.directory.DirContext, java.lang.String, java.lang.String, java.lang.String[], int)
Rmethod: org.apache.catalina.realm.JNDIRealm#getUserByPattern(javax.naming.directory.DirContext, java.lang.String, java.lang.String[], java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Use the <code>UserPattern</code> configuration attribute to locate the directory entry for the user with the specified username and return a User object; otherwise return <code>null</code>.
 * @param context The directory context
 * @param username The username
 * @param credentials User credentials (optional)
 * @param attrIds String[]containing names of attributes to
 * @param curUserPattern Index into userPatternFormatArray
 * @exception NamingException if a directory server error occurs
 * @see #getUserByPattern(DirContext,String,String[],String)
 */
protected User getUserByPattern(DirContext context,String username,String credentials,String[] attrIds,int curUserPattern) throws NamingException {
  User user=null;
  if (username == null || userPatternFormatArray[curUserPattern] == null)   return null;
  String dn=userPatternFormatArray[curUserPattern].format(new String[]{username});
  try {
    user=getUserByPattern(context,username,attrIds,dn);
  }
 catch (  NameNotFoundException e) {
    return null;
  }
catch (  NamingException e) {
    try {
      userCredentialsAdd(context,dn,credentials);
      user=getUserByPattern(context,username,attrIds,dn);
    }
  finally {
      userCredentialsRemove(context);
    }
  }
  return user;
}

ID 3693=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#close(javax.naming.directory.DirContext)
Rmethod: javax.naming.ldap.StartTlsResponse#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Close any open connection to the directory server for this Realm.
 * @param context The directory context to be closed
 */
protected void close(DirContext context){
  if (context == null)   return;
  if (tls != null) {
    try {
      tls.close();
    }
 catch (    IOException e) {
      containerLog.error(sm.getString("jndiRealm.tlsClose"),e);
    }
  }
  try {
    if (containerLog.isDebugEnabled())     containerLog.debug("Closing directory context");
    context.close();
  }
 catch (  NamingException e) {
    containerLog.error(sm.getString("jndiRealm.close"),e);
  }
  this.context=null;
}

ID 3694=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#close(javax.naming.directory.DirContext)
Rmethod: javax.naming.Context#close()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Close any open connection to the directory server for this Realm.
 * @param context The directory context to be closed
 */
protected void close(DirContext context){
  if (context == null)   return;
  if (tls != null) {
    try {
      tls.close();
    }
 catch (    IOException e) {
      containerLog.error(sm.getString("jndiRealm.tlsClose"),e);
    }
  }
  try {
    if (containerLog.isDebugEnabled())     containerLog.debug("Closing directory context");
    context.close();
  }
 catch (  NamingException e) {
    containerLog.error(sm.getString("jndiRealm.close"),e);
  }
  this.context=null;
}

ID 3697=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#getPrincipal(java.lang.String, org.ietf.jgss.GSSCredential)
Rmethod: org.apache.catalina.realm.JNDIRealm#open()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@Override protected Principal getPrincipal(String username,GSSCredential gssCredential){
  DirContext context=null;
  Principal principal=null;
  try {
    context=open();
    try {
      principal=getPrincipal(context,username,gssCredential);
    }
 catch (    CommunicationException e) {
      containerLog.info(sm.getString("jndiRealm.exception.retry"),e);
      if (context != null)       close(context);
      context=open();
      principal=getPrincipal(context,username,gssCredential);
    }
catch (    ServiceUnavailableException e) {
      containerLog.info(sm.getString("jndiRealm.exception.retry"),e);
      if (context != null)       close(context);
      context=open();
      principal=getPrincipal(context,username,gssCredential);
    }
    release(context);
    return principal;
  }
 catch (  NamingException e) {
    containerLog.error(sm.getString("jndiRealm.exception"),e);
    if (context != null)     close(context);
    return null;
  }
}

ID 3709=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#createSSLSocketFactoryFromClassName(java.lang.String)
Rmethod: org.apache.catalina.realm.JNDIRealm#constructInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
private SSLSocketFactory createSSLSocketFactoryFromClassName(String className){
  try {
    Object o=constructInstance(className);
    if (o instanceof SSLSocketFactory) {
      return sslSocketFactory;
    }
 else {
      throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className));
    }
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
}

ID 3710=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#createSSLSocketFactoryFromClassName(java.lang.String)
Rmethod: org.apache.catalina.realm.JNDIRealm#constructInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
private SSLSocketFactory createSSLSocketFactoryFromClassName(String className){
  try {
    Object o=constructInstance(className);
    if (o instanceof SSLSocketFactory) {
      return sslSocketFactory;
    }
 else {
      throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className));
    }
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
}

ID 3711=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#createSSLSocketFactoryFromClassName(java.lang.String)
Rmethod: org.apache.catalina.realm.JNDIRealm#constructInstance(java.lang.String)
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
private SSLSocketFactory createSSLSocketFactoryFromClassName(String className){
  try {
    Object o=constructInstance(className);
    if (o instanceof SSLSocketFactory) {
      return sslSocketFactory;
    }
 else {
      throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className));
    }
  }
 catch (  ClassNotFoundException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslSocketFactory",className),e);
  }
}

ID 3712=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#createSSLContextFactoryFromProtocol(java.lang.String)
Rmethod: javax.net.ssl.SSLContext#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
private SSLSocketFactory createSSLContextFactoryFromProtocol(String protocol){
  try {
    SSLContext sslContext;
    if (protocol != null) {
      sslContext=SSLContext.getInstance(protocol);
      sslContext.init(null,null,null);
    }
 else {
      sslContext=SSLContext.getDefault();
    }
    return sslContext.getSocketFactory();
  }
 catch (  NoSuchAlgorithmException e) {
    List<String> allowedProtocols=Arrays.asList(getSupportedSslProtocols());
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslProtocol",protocol,allowedProtocols),e);
  }
catch (  KeyManagementException e) {
    List<String> allowedProtocols=Arrays.asList(getSupportedSslProtocols());
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslProtocol",protocol,allowedProtocols),e);
  }
}

ID 3713=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#createSSLContextFactoryFromProtocol(java.lang.String)
Rmethod: javax.net.ssl.SSLContext#init(javax.net.ssl.KeyManager[], javax.net.ssl.TrustManager[], java.security.SecureRandom)
parentException: KeyException GeneralSecurityException 
thrown: KeyManagementException
exception comment: /** 
 * This is the general key management exception for all operations dealing with key management. Examples of subclasses of KeyManagementException that developers might create for giving more detailed information could include: <ul> <li>KeyIDConflictException <li>KeyAuthorizationFailureException <li>ExpiredKeyException </ul>
 * @author Benjamin Renaud
 * @see Key
 * @see KeyException
 */

block: 
private SSLSocketFactory createSSLContextFactoryFromProtocol(String protocol){
  try {
    SSLContext sslContext;
    if (protocol != null) {
      sslContext=SSLContext.getInstance(protocol);
      sslContext.init(null,null,null);
    }
 else {
      sslContext=SSLContext.getDefault();
    }
    return sslContext.getSocketFactory();
  }
 catch (  NoSuchAlgorithmException e) {
    List<String> allowedProtocols=Arrays.asList(getSupportedSslProtocols());
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslProtocol",protocol,allowedProtocols),e);
  }
catch (  KeyManagementException e) {
    List<String> allowedProtocols=Arrays.asList(getSupportedSslProtocols());
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslProtocol",protocol,allowedProtocols),e);
  }
}

ID 3714=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#createSSLContextFactoryFromProtocol(java.lang.String)
Rmethod: javax.net.ssl.SSLContext#getDefault()
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
private SSLSocketFactory createSSLContextFactoryFromProtocol(String protocol){
  try {
    SSLContext sslContext;
    if (protocol != null) {
      sslContext=SSLContext.getInstance(protocol);
      sslContext.init(null,null,null);
    }
 else {
      sslContext=SSLContext.getDefault();
    }
    return sslContext.getSocketFactory();
  }
 catch (  NoSuchAlgorithmException e) {
    List<String> allowedProtocols=Arrays.asList(getSupportedSslProtocols());
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslProtocol",protocol,allowedProtocols),e);
  }
catch (  KeyManagementException e) {
    List<String> allowedProtocols=Arrays.asList(getSupportedSslProtocols());
    throw new IllegalArgumentException(sm.getString("jndiRealm.invalidSslProtocol",protocol,allowedProtocols),e);
  }
}

ID 3717=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#createTlsDirContext(Hashtable<java.lang.String,java.lang.String>)
Rmethod: javax.naming.ldap.StartTlsResponse#negotiate(javax.net.ssl.SSLSocketFactory)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Create a tls enabled LdapContext and set the StartTlsResponse tls instance variable.
 * @param env Environment to use for context creation
 * @return configured {@link LdapContext}
 * @throws NamingException when something goes wrong while negotiating the connection
 */
private DirContext createTlsDirContext(Hashtable<String,String> env) throws NamingException {
  Map<String,Object> savedEnv=new HashMap<String,Object>();
  for (  String key : Arrays.asList(Context.SECURITY_AUTHENTICATION,Context.SECURITY_CREDENTIALS,Context.SECURITY_PRINCIPAL,Context.SECURITY_PROTOCOL)) {
    Object entry=env.remove(key);
    if (entry != null) {
      savedEnv.put(key,entry);
    }
  }
  LdapContext result=null;
  try {
    result=new InitialLdapContext(env,null);
    tls=(StartTlsResponse)result.extendedOperation(new StartTlsRequest());
    if (getHostnameVerifier() != null) {
      tls.setHostnameVerifier(getHostnameVerifier());
    }
    if (getCipherSuitesArray() != null) {
      tls.setEnabledCipherSuites(getCipherSuitesArray());
    }
    try {
      SSLSession negotiate=tls.negotiate(getSSLSocketFactory());
      containerLog.debug(sm.getString("jndiRealm.negotiatedTls",negotiate.getProtocol()));
    }
 catch (    IOException e) {
      throw new NamingException(e.getMessage());
    }
  }
  finally {
    if (result != null) {
      for (      Map.Entry<String,Object> savedEntry : savedEnv.entrySet()) {
        result.addToEnvironment(savedEntry.getKey(),savedEntry.getValue());
      }
    }
  }
  return result;
}

ID 3719=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#startInternal()
Rmethod: org.apache.catalina.realm.JNDIRealm#open()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Prepare for the beginning of active use of the public methods of this component and implement the requirements of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  try {
    open();
  }
 catch (  NamingException e) {
    containerLog.error(sm.getString("jndiRealm.open"),e);
  }
  super.startInternal();
}

ID 3725=========================================================================type: 1
Method:org.apache.catalina.realm.JNDIRealm#getDistinguishedName(javax.naming.directory.DirContext, java.lang.String, javax.naming.directory.SearchResult)
Rmethod: java.net.URI#URI(java.lang.String)
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
/** 
 * Returns the distinguished name of a search result.
 * @param context Our DirContext
 * @param base The base DN
 * @param result The search result
 * @return String containing the distinguished name
 */
protected String getDistinguishedName(DirContext context,String base,SearchResult result) throws NamingException {
  if (result.isRelative()) {
    if (containerLog.isTraceEnabled()) {
      containerLog.trace("  search returned relative name: " + result.getName());
    }
    NameParser parser=context.getNameParser("");
    Name contextName=parser.parse(context.getNameInNamespace());
    Name baseName=parser.parse(base);
    Name entryName=parser.parse(new CompositeName(result.getName()).get(0));
    Name name=contextName.addAll(baseName);
    name=name.addAll(entryName);
    return name.toString();
  }
 else {
    String absoluteName=result.getName();
    if (containerLog.isTraceEnabled())     containerLog.trace("  search returned absolute name: " + result.getName());
    try {
      NameParser parser=context.getNameParser("");
      URI userNameUri=new URI(absoluteName);
      String pathComponent=userNameUri.getPath();
      if (pathComponent.length() < 1) {
        throw new InvalidNameException("Search returned unparseable absolute name: " + absoluteName);
      }
      Name name=parser.parse(pathComponent.substring(1));
      return name.toString();
    }
 catch (    URISyntaxException e) {
      throw new InvalidNameException("Search returned unparseable absolute name: " + absoluteName);
    }
  }
}

ID 3727=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#authenticate(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.realm.RealmBase#getDigestCharset()
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Return the Principal associated with the specified username, which matches the digest calculated using the given parameters using the method described in RFC 2069; otherwise return <code>null</code>.
 * @param username Username of the Principal to look up
 * @param clientDigest Digest which has been submitted by the client
 * @param nonce Unique (or supposedly unique) token which has been usedfor this request
 * @param realm Realm name
 * @param md5a2 Second MD5 digest used to calculate the digest :MD5(Method + ":" + uri)
 */
@Override public Principal authenticate(String username,String clientDigest,String nonce,String nc,String cnonce,String qop,String realm,String md5a2){
  String md5a1=getDigest(username,realm);
  if (md5a1 == null)   return null;
  md5a1=md5a1.toLowerCase(Locale.ENGLISH);
  String serverDigestValue;
  if (qop == null) {
    serverDigestValue=md5a1 + ":" + nonce+ ":"+ md5a2;
  }
 else {
    serverDigestValue=md5a1 + ":" + nonce+ ":"+ nc+ ":"+ cnonce+ ":"+ qop+ ":"+ md5a2;
  }
  byte[] valueBytes=null;
  try {
    valueBytes=serverDigestValue.getBytes(getDigestCharset());
  }
 catch (  UnsupportedEncodingException uee) {
    log.error("Illegal digestEncoding: " + getDigestEncoding(),uee);
    throw new IllegalArgumentException(uee.getMessage());
  }
  String serverDigest=null;
synchronized (md5Helper) {
    serverDigest=MD5Encoder.encode(md5Helper.digest(valueBytes));
  }
  if (log.isDebugEnabled()) {
    log.debug("Digest : " + clientDigest + " Username:"+ username+ " ClientSigest:"+ clientDigest+ " nonce:"+ nonce+ " nc:"+ nc+ " cnonce:"+ cnonce+ " qop:"+ qop+ " realm:"+ realm+ "md5a2:"+ md5a2+ " Server digest:"+ serverDigest);
  }
  if (serverDigest.equals(clientDigest)) {
    return getPrincipal(username);
  }
  return null;
}

ID 3730=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#authenticate(org.ietf.jgss.GSSContext, boolean)
Rmethod: org.ietf.jgss.GSSContext#getSrcName()
parentException: 
thrown: GSSException
exception comment: /** 
 * This exception is thrown whenever a GSS-API error occurs, including any mechanism specific error.  It may contain both the major and the minor GSS-API status codes.  Major error codes are those defined at the GSS-API level in this class. Minor error codes are mechanism specific error codes that can provide additional information. The underlying mechanism implementation is responsible for setting appropriate minor status codes when throwing this exception.  Aside from delivering the numeric error codes to the caller, this class performs the mapping from their numeric values to textual representations. <p>
 * @author Mayank Upadhyay
 * @since 1.4
 */

block: 
/** 
 * {@inheritDoc}
 */
@Override public Principal authenticate(GSSContext gssContext,boolean storeCred){
  if (gssContext.isEstablished()) {
    GSSName gssName=null;
    try {
      gssName=gssContext.getSrcName();
    }
 catch (    GSSException e) {
      log.warn(sm.getString("realmBase.gssNameFail"),e);
    }
    if (gssName != null) {
      String name=gssName.toString();
      if (isStripRealmForGss()) {
        int i=name.indexOf('@');
        if (i > 0) {
          name=name.substring(0,i);
        }
      }
      GSSCredential gssCredential=null;
      if (storeCred && gssContext.getCredDelegState()) {
        try {
          gssCredential=gssContext.getDelegCred();
        }
 catch (        GSSException e) {
          if (log.isDebugEnabled()) {
            log.debug(sm.getString("realmBase.delegatedCredentialFail",name),e);
          }
        }
      }
      return getPrincipal(name,gssCredential);
    }
  }
  return null;
}

ID 3731=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#authenticate(org.ietf.jgss.GSSContext, boolean)
Rmethod: org.ietf.jgss.GSSContext#getDelegCred()
parentException: 
thrown: GSSException
exception comment: /** 
 * This exception is thrown whenever a GSS-API error occurs, including any mechanism specific error.  It may contain both the major and the minor GSS-API status codes.  Major error codes are those defined at the GSS-API level in this class. Minor error codes are mechanism specific error codes that can provide additional information. The underlying mechanism implementation is responsible for setting appropriate minor status codes when throwing this exception.  Aside from delivering the numeric error codes to the caller, this class performs the mapping from their numeric values to textual representations. <p>
 * @author Mayank Upadhyay
 * @since 1.4
 */

block: 
/** 
 * {@inheritDoc}
 */
@Override public Principal authenticate(GSSContext gssContext,boolean storeCred){
  if (gssContext.isEstablished()) {
    GSSName gssName=null;
    try {
      gssName=gssContext.getSrcName();
    }
 catch (    GSSException e) {
      log.warn(sm.getString("realmBase.gssNameFail"),e);
    }
    if (gssName != null) {
      String name=gssName.toString();
      if (isStripRealmForGss()) {
        int i=name.indexOf('@');
        if (i > 0) {
          name=name.substring(0,i);
        }
      }
      GSSCredential gssCredential=null;
      if (storeCred && gssContext.getCredDelegState()) {
        try {
          gssCredential=gssContext.getDelegCred();
        }
 catch (        GSSException e) {
          if (log.isDebugEnabled()) {
            log.debug(sm.getString("realmBase.delegatedCredentialFail",name),e);
          }
        }
      }
      return getPrincipal(name,gssCredential);
    }
  }
  return null;
}

ID 3736=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#startInternal()
Rmethod: java.security.MessageDigest#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * Prepare for the beginning of active use of the public methods of this component and implement the requirements of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  if (digest != null) {
    try {
      md=MessageDigest.getInstance(digest);
    }
 catch (    NoSuchAlgorithmException e) {
      throw new LifecycleException(sm.getString("realmBase.algorithm",digest),e);
    }
  }
  setState(LifecycleState.STARTING);
}

ID 3739=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#digest(java.lang.String)
Rmethod: org.apache.catalina.realm.RealmBase#getDigestCharset()
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Digest the password using the specified algorithm and convert the result to a corresponding hexadecimal string. If exception, the plain credentials string is returned.
 * @param credentials Password or other credentials to use inauthenticating this username
 */
protected String digest(String credentials){
  if (hasMessageDigest() == false)   return (credentials);
synchronized (this) {
    try {
      md.reset();
      byte[] bytes=null;
      try {
        bytes=credentials.getBytes(getDigestCharset());
      }
 catch (      UnsupportedEncodingException uee) {
        log.error("Illegal digestEncoding: " + getDigestEncoding(),uee);
        throw new IllegalArgumentException(uee.getMessage());
      }
      md.update(bytes);
      return (HexUtils.toHexString(md.digest()));
    }
 catch (    Exception e) {
      log.error(sm.getString("realmBase.digest"),e);
      return (credentials);
    }
  }
}

ID 3740=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#getDigest(java.lang.String, java.lang.String)
Rmethod: java.security.MessageDigest#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * Return the digest associated with given principal's user name.
 */
protected String getDigest(String username,String realmName){
  if (md5Helper == null) {
    try {
      md5Helper=MessageDigest.getInstance("MD5");
    }
 catch (    NoSuchAlgorithmException e) {
      log.error("Couldn't get MD5 digest: ",e);
      throw new IllegalStateException(e.getMessage());
    }
  }
  if (hasMessageDigest()) {
    return getPassword(username);
  }
  String digestValue=username + ":" + realmName+ ":"+ getPassword(username);
  byte[] valueBytes=null;
  try {
    valueBytes=digestValue.getBytes(getDigestCharset());
  }
 catch (  UnsupportedEncodingException uee) {
    log.error("Illegal digestEncoding: " + getDigestEncoding(),uee);
    throw new IllegalArgumentException(uee.getMessage());
  }
  byte[] digest=null;
synchronized (md5Helper) {
    digest=md5Helper.digest(valueBytes);
  }
  return MD5Encoder.encode(digest);
}

ID 3741=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#getDigest(java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.realm.RealmBase#getDigestCharset()
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Return the digest associated with given principal's user name.
 */
protected String getDigest(String username,String realmName){
  if (md5Helper == null) {
    try {
      md5Helper=MessageDigest.getInstance("MD5");
    }
 catch (    NoSuchAlgorithmException e) {
      log.error("Couldn't get MD5 digest: ",e);
      throw new IllegalStateException(e.getMessage());
    }
  }
  if (hasMessageDigest()) {
    return getPassword(username);
  }
  String digestValue=username + ":" + realmName+ ":"+ getPassword(username);
  byte[] valueBytes=null;
  try {
    valueBytes=digestValue.getBytes(getDigestCharset());
  }
 catch (  UnsupportedEncodingException uee) {
    log.error("Illegal digestEncoding: " + getDigestEncoding(),uee);
    throw new IllegalArgumentException(uee.getMessage());
  }
  byte[] digest=null;
synchronized (md5Helper) {
    digest=md5Helper.digest(valueBytes);
  }
  return MD5Encoder.encode(digest);
}

ID 3745=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#createUsernameRetriever(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
private static X509UsernameRetriever createUsernameRetriever(String className) throws LifecycleException {
  if (null == className || "".equals(className.trim()))   return new X509SubjectDnRetriever();
  try {
    @SuppressWarnings("unchecked") Class<? extends X509UsernameRetriever> clazz=(Class<? extends X509UsernameRetriever>)Class.forName(className);
    return clazz.newInstance();
  }
 catch (  ClassNotFoundException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassNotFoundException",className),e);
  }
catch (  InstantiationException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.InstantiationException",className),e);
  }
catch (  IllegalAccessException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.IllegalAccessException",className),e);
  }
catch (  ClassCastException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassCastException",className),e);
  }
}

ID 3746=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#createUsernameRetriever(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
private static X509UsernameRetriever createUsernameRetriever(String className) throws LifecycleException {
  if (null == className || "".equals(className.trim()))   return new X509SubjectDnRetriever();
  try {
    @SuppressWarnings("unchecked") Class<? extends X509UsernameRetriever> clazz=(Class<? extends X509UsernameRetriever>)Class.forName(className);
    return clazz.newInstance();
  }
 catch (  ClassNotFoundException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassNotFoundException",className),e);
  }
catch (  InstantiationException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.InstantiationException",className),e);
  }
catch (  IllegalAccessException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.IllegalAccessException",className),e);
  }
catch (  ClassCastException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassCastException",className),e);
  }
}

ID 3747=========================================================================type: 1
Method:org.apache.catalina.realm.RealmBase#createUsernameRetriever(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
private static X509UsernameRetriever createUsernameRetriever(String className) throws LifecycleException {
  if (null == className || "".equals(className.trim()))   return new X509SubjectDnRetriever();
  try {
    @SuppressWarnings("unchecked") Class<? extends X509UsernameRetriever> clazz=(Class<? extends X509UsernameRetriever>)Class.forName(className);
    return clazz.newInstance();
  }
 catch (  ClassNotFoundException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassNotFoundException",className),e);
  }
catch (  InstantiationException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.InstantiationException",className),e);
  }
catch (  IllegalAccessException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.IllegalAccessException",className),e);
  }
catch (  ClassCastException e) {
    throw new LifecycleException(sm.getString("realmBase.createUsernameRetriever.ClassCastException",className),e);
  }
}

ID 3748=========================================================================type: 1
Method:org.apache.catalina.realm.CombinedRealm#startInternal()
Rmethod: org.apache.catalina.Lifecycle#start()
parentException: 
thrown: LifecycleException
exception comment: null
block: 
/** 
 * Prepare for the beginning of active use of the public methods of this component and implement the requirements of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  Iterator<Realm> iter=realms.iterator();
  while (iter.hasNext()) {
    Realm realm=iter.next();
    if (realm instanceof Lifecycle) {
      try {
        ((Lifecycle)realm).start();
      }
 catch (      LifecycleException e) {
        iter.remove();
        log.error(sm.getString("combinedRealm.realmStartFail",realm.getInfo()),e);
      }
    }
  }
  super.startInternal();
}

ID 3751=========================================================================type: 1
Method:org.apache.catalina.realm.CombinedRealm#authenticate(org.ietf.jgss.GSSContext, boolean)
Rmethod: org.ietf.jgss.GSSContext#getSrcName()
parentException: 
thrown: GSSException
exception comment: /** 
 * This exception is thrown whenever a GSS-API error occurs, including any mechanism specific error.  It may contain both the major and the minor GSS-API status codes.  Major error codes are those defined at the GSS-API level in this class. Minor error codes are mechanism specific error codes that can provide additional information. The underlying mechanism implementation is responsible for setting appropriate minor status codes when throwing this exception.  Aside from delivering the numeric error codes to the caller, this class performs the mapping from their numeric values to textual representations. <p>
 * @author Mayank Upadhyay
 * @since 1.4
 */

block: 
/** 
 * {@inheritDoc}
 */
@Override public Principal authenticate(GSSContext gssContext,boolean storeCreds){
  if (gssContext.isEstablished()) {
    Principal authenticatedUser=null;
    String username=null;
    GSSName name=null;
    try {
      name=gssContext.getSrcName();
    }
 catch (    GSSException e) {
      log.warn(sm.getString("realmBase.gssNameFail"),e);
      return null;
    }
    username=name.toString();
    for (    Realm realm : realms) {
      if (log.isDebugEnabled()) {
        log.debug(sm.getString("combinedRealm.authStart",username,realm.getInfo()));
      }
      authenticatedUser=realm.authenticate(gssContext,storeCreds);
      if (authenticatedUser == null) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("combinedRealm.authFail",username,realm.getInfo()));
        }
      }
 else {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("combinedRealm.authSuccess",username,realm.getInfo()));
        }
        break;
      }
    }
    return authenticatedUser;
  }
  return null;
}

ID 3754=========================================================================type: 1
Method:org.apache.catalina.realm.JAASMemoryLoginModule#login()
Rmethod: javax.security.auth.callback.CallbackHandler#handle(javax.security.auth.callback.Callback[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Phase 1 of authenticating a <code>Subject</code>.
 * @return <code>true</code> if the authentication succeeded, or<code>false</code> if this <code>LoginModule</code> should be ignored
 * @exception LoginException if the authentication fails
 */
@Override public boolean login() throws LoginException {
  if (callbackHandler == null)   throw new LoginException("No CallbackHandler specified");
  Callback callbacks[]=new Callback[9];
  callbacks[0]=new NameCallback("Username: ");
  callbacks[1]=new PasswordCallback("Password: ",false);
  callbacks[2]=new TextInputCallback("nonce");
  callbacks[3]=new TextInputCallback("nc");
  callbacks[4]=new TextInputCallback("cnonce");
  callbacks[5]=new TextInputCallback("qop");
  callbacks[6]=new TextInputCallback("realmName");
  callbacks[7]=new TextInputCallback("md5a2");
  callbacks[8]=new TextInputCallback("authMethod");
  String username=null;
  String password=null;
  String nonce=null;
  String nc=null;
  String cnonce=null;
  String qop=null;
  String realmName=null;
  String md5a2=null;
  String authMethod=null;
  try {
    callbackHandler.handle(callbacks);
    username=((NameCallback)callbacks[0]).getName();
    password=new String(((PasswordCallback)callbacks[1]).getPassword());
    nonce=((TextInputCallback)callbacks[2]).getText();
    nc=((TextInputCallback)callbacks[3]).getText();
    cnonce=((TextInputCallback)callbacks[4]).getText();
    qop=((TextInputCallback)callbacks[5]).getText();
    realmName=((TextInputCallback)callbacks[6]).getText();
    md5a2=((TextInputCallback)callbacks[7]).getText();
    authMethod=((TextInputCallback)callbacks[8]).getText();
  }
 catch (  IOException e) {
    throw new LoginException(e.toString());
  }
catch (  UnsupportedCallbackException e) {
    throw new LoginException(e.toString());
  }
  if (authMethod == null) {
    principal=super.authenticate(username,password);
  }
 else   if (authMethod.equals(HttpServletRequest.DIGEST_AUTH)) {
    principal=super.authenticate(username,password,nonce,nc,cnonce,qop,realmName,md5a2);
  }
 else   if (authMethod.equals(HttpServletRequest.CLIENT_CERT_AUTH)) {
    principal=super.getPrincipal(username);
  }
 else {
    throw new LoginException("Unknown authentication method");
  }
  log.debug("login " + username + " "+ principal);
  if (principal != null) {
    return (true);
  }
 else {
    throw new FailedLoginException("Username or password is incorrect");
  }
}

ID 3755=========================================================================type: 1
Method:org.apache.catalina.realm.JAASMemoryLoginModule#login()
Rmethod: javax.security.auth.callback.CallbackHandler#handle(javax.security.auth.callback.Callback[])
parentException: 
thrown: UnsupportedCallbackException
exception comment: /** 
 * Signals that a  {@code CallbackHandler} does notrecognize a particular  {@code Callback}.
 */

block: 
/** 
 * Phase 1 of authenticating a <code>Subject</code>.
 * @return <code>true</code> if the authentication succeeded, or<code>false</code> if this <code>LoginModule</code> should be ignored
 * @exception LoginException if the authentication fails
 */
@Override public boolean login() throws LoginException {
  if (callbackHandler == null)   throw new LoginException("No CallbackHandler specified");
  Callback callbacks[]=new Callback[9];
  callbacks[0]=new NameCallback("Username: ");
  callbacks[1]=new PasswordCallback("Password: ",false);
  callbacks[2]=new TextInputCallback("nonce");
  callbacks[3]=new TextInputCallback("nc");
  callbacks[4]=new TextInputCallback("cnonce");
  callbacks[5]=new TextInputCallback("qop");
  callbacks[6]=new TextInputCallback("realmName");
  callbacks[7]=new TextInputCallback("md5a2");
  callbacks[8]=new TextInputCallback("authMethod");
  String username=null;
  String password=null;
  String nonce=null;
  String nc=null;
  String cnonce=null;
  String qop=null;
  String realmName=null;
  String md5a2=null;
  String authMethod=null;
  try {
    callbackHandler.handle(callbacks);
    username=((NameCallback)callbacks[0]).getName();
    password=new String(((PasswordCallback)callbacks[1]).getPassword());
    nonce=((TextInputCallback)callbacks[2]).getText();
    nc=((TextInputCallback)callbacks[3]).getText();
    cnonce=((TextInputCallback)callbacks[4]).getText();
    qop=((TextInputCallback)callbacks[5]).getText();
    realmName=((TextInputCallback)callbacks[6]).getText();
    md5a2=((TextInputCallback)callbacks[7]).getText();
    authMethod=((TextInputCallback)callbacks[8]).getText();
  }
 catch (  IOException e) {
    throw new LoginException(e.toString());
  }
catch (  UnsupportedCallbackException e) {
    throw new LoginException(e.toString());
  }
  if (authMethod == null) {
    principal=super.authenticate(username,password);
  }
 else   if (authMethod.equals(HttpServletRequest.DIGEST_AUTH)) {
    principal=super.authenticate(username,password,nonce,nc,cnonce,qop,realmName,md5a2);
  }
 else   if (authMethod.equals(HttpServletRequest.CLIENT_CERT_AUTH)) {
    principal=super.getPrincipal(username);
  }
 else {
    throw new LoginException("Unknown authentication method");
  }
  log.debug("login " + username + " "+ principal);
  if (principal != null) {
    return (true);
  }
 else {
    throw new FailedLoginException("Username or password is incorrect");
  }
}

ID 3758=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#parseClassNames(java.lang.String, List<java.lang.String>)
Rmethod: java.lang.Class#forName(java.lang.String, boolean, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Parses a comma-delimited list of class names, and store the class names in the provided List. Each class must implement <code>java.security.Principal</code>.
 * @param classNamesString a comma-delimited list of fully qualified class names.
 * @param classNamesList the list in which the class names will be stored.The list is cleared before being populated.
 */
protected void parseClassNames(String classNamesString,List<String> classNamesList){
  classNamesList.clear();
  if (classNamesString == null)   return;
  ClassLoader loader=this.getClass().getClassLoader();
  if (isUseContextClassLoader())   loader=Thread.currentThread().getContextClassLoader();
  String[] classNames=classNamesString.split("[ ]*,[ ]*");
  for (int i=0; i < classNames.length; i++) {
    if (classNames[i].length() == 0)     continue;
    try {
      Class<?> principalClass=Class.forName(classNames[i],false,loader);
      if (Principal.class.isAssignableFrom(principalClass)) {
        classNamesList.add(classNames[i]);
      }
 else {
        log.error("Class " + classNames[i] + " is not implementing "+ "java.security.Principal! Class not added.");
      }
    }
 catch (    ClassNotFoundException e) {
      log.error("Class " + classNames[i] + " not found! Class not added.");
    }
  }
}

ID 3760=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#authenticate(java.lang.String, javax.security.auth.callback.CallbackHandler)
Rmethod: javax.security.auth.login.LoginContext#login()
parentException: GeneralSecurityException 
thrown: LoginException
exception comment: /** 
 * This is the basic login exception.
 * @see javax.security.auth.login.LoginContext
 */

block: 
/** 
 * Perform the actual JAAS authentication
 */
protected Principal authenticate(String username,CallbackHandler callbackHandler){
  try {
    LoginContext loginContext=null;
    if (appName == null)     appName="Tomcat";
    if (log.isDebugEnabled())     log.debug(sm.getString("jaasRealm.beginLogin",username,appName));
    ClassLoader ocl=null;
    if (!isUseContextClassLoader()) {
      ocl=Thread.currentThread().getContextClassLoader();
      Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
    }
    try {
      Configuration config=getConfig();
      loginContext=new LoginContext(appName,null,callbackHandler,config);
    }
 catch (    Throwable e) {
      ExceptionUtils.handleThrowable(e);
      log.error(sm.getString("jaasRealm.unexpectedError"),e);
      return (null);
    }
 finally {
      if (!isUseContextClassLoader()) {
        Thread.currentThread().setContextClassLoader(ocl);
      }
    }
    if (log.isDebugEnabled())     log.debug("Login context created " + username);
    Subject subject=null;
    try {
      loginContext.login();
      subject=loginContext.getSubject();
      if (subject == null) {
        if (log.isDebugEnabled())         log.debug(sm.getString("jaasRealm.failedLogin",username));
        return (null);
      }
    }
 catch (    AccountExpiredException e) {
      if (log.isDebugEnabled())       log.debug(sm.getString("jaasRealm.accountExpired",username));
      return (null);
    }
catch (    CredentialExpiredException e) {
      if (log.isDebugEnabled())       log.debug(sm.getString("jaasRealm.credentialExpired",username));
      return (null);
    }
catch (    FailedLoginException e) {
      if (log.isDebugEnabled())       log.debug(sm.getString("jaasRealm.failedLogin",username));
      return (null);
    }
catch (    LoginException e) {
      log.warn(sm.getString("jaasRealm.loginException",username),e);
      return (null);
    }
catch (    Throwable e) {
      ExceptionUtils.handleThrowable(e);
      log.error(sm.getString("jaasRealm.unexpectedError"),e);
      return (null);
    }
    if (log.isDebugEnabled())     log.debug(sm.getString("jaasRealm.loginContextCreated",username));
    Principal principal=createPrincipal(username,subject,loginContext);
    if (principal == null) {
      log.debug(sm.getString("jaasRealm.authenticateFailure",username));
      return (null);
    }
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("jaasRealm.authenticateSuccess",username));
    }
    return (principal);
  }
 catch (  Throwable t) {
    log.error("error ",t);
    return null;
  }
}

ID 3761=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.net.URL#toURI()
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3762=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3763=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.lang.Class#getConstructor(Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3764=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.lang.Class#getConstructor(Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3765=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3766=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3767=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3768=========================================================================type: 1
Method:org.apache.catalina.realm.JAASRealm#getConfig()
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Load custom JAAS Configuration
 */
protected Configuration getConfig(){
  try {
    if (jaasConfigurationLoaded) {
      return jaasConfiguration;
    }
synchronized (this) {
      if (configFile == null) {
        jaasConfigurationLoaded=true;
        return null;
      }
      URL resource=Thread.currentThread().getContextClassLoader().getResource(configFile);
      URI uri=resource.toURI();
      @SuppressWarnings("unchecked") Class<Configuration> sunConfigFile=(Class<Configuration>)Class.forName("com.sun.security.auth.login.ConfigFile");
      Constructor<Configuration> constructor=sunConfigFile.getConstructor(URI.class);
      Configuration config=constructor.newInstance(uri);
      this.jaasConfiguration=config;
      this.jaasConfigurationLoaded=true;
      return this.jaasConfiguration;
    }
  }
 catch (  URISyntaxException ex) {
    throw new RuntimeException(ex);
  }
catch (  NoSuchMethodException ex) {
    throw new RuntimeException(ex);
  }
catch (  SecurityException ex) {
    throw new RuntimeException(ex);
  }
catch (  InstantiationException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new RuntimeException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new RuntimeException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  ClassNotFoundException ex) {
    throw new RuntimeException(ex);
  }
}

ID 3769=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#close(java.sql.Connection)
Rmethod: java.sql.Connection#getAutoCommit()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 * @param dbConnection The connection to be closed
 */
protected void close(Connection dbConnection){
  if (dbConnection == null)   return;
  try {
    if (!dbConnection.getAutoCommit()) {
      dbConnection.commit();
    }
  }
 catch (  SQLException e) {
    containerLog.error("Exception committing connection before closing:",e);
  }
  try {
    dbConnection.close();
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.close"),e);
  }
}

ID 3770=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#close(java.sql.Connection)
Rmethod: java.sql.Connection#commit()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 * @param dbConnection The connection to be closed
 */
protected void close(Connection dbConnection){
  if (dbConnection == null)   return;
  try {
    if (!dbConnection.getAutoCommit()) {
      dbConnection.commit();
    }
  }
 catch (  SQLException e) {
    containerLog.error("Exception committing connection before closing:",e);
  }
  try {
    dbConnection.close();
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.close"),e);
  }
}

ID 3771=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#close(java.sql.Connection)
Rmethod: java.sql.Connection#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 * @param dbConnection The connection to be closed
 */
protected void close(Connection dbConnection){
  if (dbConnection == null)   return;
  try {
    if (!dbConnection.getAutoCommit()) {
      dbConnection.commit();
    }
  }
 catch (  SQLException e) {
    containerLog.error("Exception committing connection before closing:",e);
  }
  try {
    dbConnection.close();
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.close"),e);
  }
}

ID 3775=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getPassword(java.sql.Connection, java.lang.String)
Rmethod: org.apache.catalina.realm.DataSourceRealm#credentials(java.sql.Connection, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 * @param dbConnection The database connection to be used
 * @param username Username for which password should be retrieved
 */
protected String getPassword(Connection dbConnection,String username){
  ResultSet rs=null;
  PreparedStatement stmt=null;
  String dbCredentials=null;
  try {
    stmt=credentials(dbConnection,username);
    rs=stmt.executeQuery();
    if (rs.next()) {
      dbCredentials=rs.getString(1);
    }
    return (dbCredentials != null) ? dbCredentials.trim() : null;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
    }
  }
  return null;
}

ID 3776=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getPassword(java.sql.Connection, java.lang.String)
Rmethod: java.sql.PreparedStatement#executeQuery()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 * @param dbConnection The database connection to be used
 * @param username Username for which password should be retrieved
 */
protected String getPassword(Connection dbConnection,String username){
  ResultSet rs=null;
  PreparedStatement stmt=null;
  String dbCredentials=null;
  try {
    stmt=credentials(dbConnection,username);
    rs=stmt.executeQuery();
    if (rs.next()) {
      dbCredentials=rs.getString(1);
    }
    return (dbCredentials != null) ? dbCredentials.trim() : null;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
    }
  }
  return null;
}

ID 3777=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getPassword(java.sql.Connection, java.lang.String)
Rmethod: java.sql.ResultSet#next()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 * @param dbConnection The database connection to be used
 * @param username Username for which password should be retrieved
 */
protected String getPassword(Connection dbConnection,String username){
  ResultSet rs=null;
  PreparedStatement stmt=null;
  String dbCredentials=null;
  try {
    stmt=credentials(dbConnection,username);
    rs=stmt.executeQuery();
    if (rs.next()) {
      dbCredentials=rs.getString(1);
    }
    return (dbCredentials != null) ? dbCredentials.trim() : null;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
    }
  }
  return null;
}

ID 3778=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getPassword(java.sql.Connection, java.lang.String)
Rmethod: java.sql.ResultSet#getString(int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 * @param dbConnection The database connection to be used
 * @param username Username for which password should be retrieved
 */
protected String getPassword(Connection dbConnection,String username){
  ResultSet rs=null;
  PreparedStatement stmt=null;
  String dbCredentials=null;
  try {
    stmt=credentials(dbConnection,username);
    rs=stmt.executeQuery();
    if (rs.next()) {
      dbCredentials=rs.getString(1);
    }
    return (dbCredentials != null) ? dbCredentials.trim() : null;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
    }
  }
  return null;
}

ID 3779=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getPassword(java.sql.Connection, java.lang.String)
Rmethod: java.sql.ResultSet#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 * @param dbConnection The database connection to be used
 * @param username Username for which password should be retrieved
 */
protected String getPassword(Connection dbConnection,String username){
  ResultSet rs=null;
  PreparedStatement stmt=null;
  String dbCredentials=null;
  try {
    stmt=credentials(dbConnection,username);
    rs=stmt.executeQuery();
    if (rs.next()) {
      dbCredentials=rs.getString(1);
    }
    return (dbCredentials != null) ? dbCredentials.trim() : null;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
    }
  }
  return null;
}

ID 3780=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getPassword(java.sql.Connection, java.lang.String)
Rmethod: java.sql.Statement#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 * @param dbConnection The database connection to be used
 * @param username Username for which password should be retrieved
 */
protected String getPassword(Connection dbConnection,String username){
  ResultSet rs=null;
  PreparedStatement stmt=null;
  String dbCredentials=null;
  try {
    stmt=credentials(dbConnection,username);
    rs=stmt.executeQuery();
    if (rs.next()) {
      dbCredentials=rs.getString(1);
    }
    return (dbCredentials != null) ? dbCredentials.trim() : null;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getPassword.exception",username),e);
    }
  }
  return null;
}

ID 3781=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getRoles(java.sql.Connection, java.lang.String)
Rmethod: org.apache.catalina.realm.DataSourceRealm#roles(java.sql.Connection, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the given user name
 * @param dbConnection The database connection to be used
 * @param username Username for which roles should be retrieved
 */
protected ArrayList<String> getRoles(Connection dbConnection,String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  ResultSet rs=null;
  PreparedStatement stmt=null;
  ArrayList<String> list=null;
  try {
    stmt=roles(dbConnection,username);
    rs=stmt.executeQuery();
    list=new ArrayList<String>();
    while (rs.next()) {
      String role=rs.getString(1);
      if (role != null) {
        list.add(role.trim());
      }
    }
    return list;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
    }
  }
  return null;
}

ID 3782=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getRoles(java.sql.Connection, java.lang.String)
Rmethod: java.sql.PreparedStatement#executeQuery()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the given user name
 * @param dbConnection The database connection to be used
 * @param username Username for which roles should be retrieved
 */
protected ArrayList<String> getRoles(Connection dbConnection,String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  ResultSet rs=null;
  PreparedStatement stmt=null;
  ArrayList<String> list=null;
  try {
    stmt=roles(dbConnection,username);
    rs=stmt.executeQuery();
    list=new ArrayList<String>();
    while (rs.next()) {
      String role=rs.getString(1);
      if (role != null) {
        list.add(role.trim());
      }
    }
    return list;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
    }
  }
  return null;
}

ID 3783=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getRoles(java.sql.Connection, java.lang.String)
Rmethod: java.sql.ResultSet#next()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the given user name
 * @param dbConnection The database connection to be used
 * @param username Username for which roles should be retrieved
 */
protected ArrayList<String> getRoles(Connection dbConnection,String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  ResultSet rs=null;
  PreparedStatement stmt=null;
  ArrayList<String> list=null;
  try {
    stmt=roles(dbConnection,username);
    rs=stmt.executeQuery();
    list=new ArrayList<String>();
    while (rs.next()) {
      String role=rs.getString(1);
      if (role != null) {
        list.add(role.trim());
      }
    }
    return list;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
    }
  }
  return null;
}

ID 3784=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getRoles(java.sql.Connection, java.lang.String)
Rmethod: java.sql.ResultSet#getString(int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the given user name
 * @param dbConnection The database connection to be used
 * @param username Username for which roles should be retrieved
 */
protected ArrayList<String> getRoles(Connection dbConnection,String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  ResultSet rs=null;
  PreparedStatement stmt=null;
  ArrayList<String> list=null;
  try {
    stmt=roles(dbConnection,username);
    rs=stmt.executeQuery();
    list=new ArrayList<String>();
    while (rs.next()) {
      String role=rs.getString(1);
      if (role != null) {
        list.add(role.trim());
      }
    }
    return list;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
    }
  }
  return null;
}

ID 3785=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getRoles(java.sql.Connection, java.lang.String)
Rmethod: java.sql.ResultSet#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the given user name
 * @param dbConnection The database connection to be used
 * @param username Username for which roles should be retrieved
 */
protected ArrayList<String> getRoles(Connection dbConnection,String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  ResultSet rs=null;
  PreparedStatement stmt=null;
  ArrayList<String> list=null;
  try {
    stmt=roles(dbConnection,username);
    rs=stmt.executeQuery();
    list=new ArrayList<String>();
    while (rs.next()) {
      String role=rs.getString(1);
      if (role != null) {
        list.add(role.trim());
      }
    }
    return list;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
    }
  }
  return null;
}

ID 3786=========================================================================type: 1
Method:org.apache.catalina.realm.DataSourceRealm#getRoles(java.sql.Connection, java.lang.String)
Rmethod: java.sql.Statement#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the given user name
 * @param dbConnection The database connection to be used
 * @param username Username for which roles should be retrieved
 */
protected ArrayList<String> getRoles(Connection dbConnection,String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  ResultSet rs=null;
  PreparedStatement stmt=null;
  ArrayList<String> list=null;
  try {
    stmt=roles(dbConnection,username);
    rs=stmt.executeQuery();
    list=new ArrayList<String>();
    while (rs.next()) {
      String role=rs.getString(1);
      if (role != null) {
        list.add(role.trim());
      }
    }
    return list;
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
  }
 finally {
    try {
      if (rs != null) {
        rs.close();
      }
      if (stmt != null) {
        stmt.close();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("dataSourceRealm.getRoles.exception",username),e);
    }
  }
  return null;
}

ID 3791=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#authenticate(java.lang.String, java.lang.String)
Rmethod: org.apache.catalina.realm.JDBCRealm#open()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the Principal associated with the specified username and credentials, if there is one; otherwise return <code>null</code>. If there are any errors with the JDBC connection, executing the query or anything we return null (don't authenticate). This event is also logged, and the connection will be closed so that a subsequent request will automatically re-open it.
 * @param username Username of the Principal to look up
 * @param credentials Password or other credentials to use inauthenticating this username
 */
@Override public synchronized Principal authenticate(String username,String credentials){
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      Principal principal=authenticate(dbConnection,username,credentials);
      return (principal);
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
      if (dbConnection != null)       close(dbConnection);
    }
    numberOfTries--;
  }
  return null;
}

ID 3793=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#close(java.sql.Connection)
Rmethod: java.sql.Connection#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 * @param dbConnection The connection to be closed
 */
protected void close(Connection dbConnection){
  if (dbConnection == null)   return;
  try {
    preparedCredentials.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedCredentials=null;
  try {
    preparedRoles.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedRoles=null;
  try {
    dbConnection.close();
  }
 catch (  SQLException e) {
    containerLog.warn(sm.getString("jdbcRealm.close"),e);
  }
 finally {
    this.dbConnection=null;
  }
}

ID 3797=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getPassword(java.lang.String)
Rmethod: org.apache.catalina.realm.JDBCRealm#open()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 */
@Override protected synchronized String getPassword(String username){
  String dbCredentials=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      stmt=credentials(dbConnection,username);
      rs=stmt.executeQuery();
      if (rs.next()) {
        dbCredentials=rs.getString(1);
      }
      dbConnection.commit();
      if (dbCredentials != null) {
        dbCredentials=dbCredentials.trim();
      }
      return dbCredentials;
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
    }
 finally {
      if (rs != null) {
        try {
          rs.close();
        }
 catch (        SQLException e) {
          containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
        }
      }
    }
    if (dbConnection != null) {
      close(dbConnection);
    }
    numberOfTries--;
  }
  return (null);
}

ID 3798=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getPassword(java.lang.String)
Rmethod: org.apache.catalina.realm.JDBCRealm#credentials(java.sql.Connection, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 */
@Override protected synchronized String getPassword(String username){
  String dbCredentials=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      stmt=credentials(dbConnection,username);
      rs=stmt.executeQuery();
      if (rs.next()) {
        dbCredentials=rs.getString(1);
      }
      dbConnection.commit();
      if (dbCredentials != null) {
        dbCredentials=dbCredentials.trim();
      }
      return dbCredentials;
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
    }
 finally {
      if (rs != null) {
        try {
          rs.close();
        }
 catch (        SQLException e) {
          containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
        }
      }
    }
    if (dbConnection != null) {
      close(dbConnection);
    }
    numberOfTries--;
  }
  return (null);
}

ID 3799=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getPassword(java.lang.String)
Rmethod: java.sql.PreparedStatement#executeQuery()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 */
@Override protected synchronized String getPassword(String username){
  String dbCredentials=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      stmt=credentials(dbConnection,username);
      rs=stmt.executeQuery();
      if (rs.next()) {
        dbCredentials=rs.getString(1);
      }
      dbConnection.commit();
      if (dbCredentials != null) {
        dbCredentials=dbCredentials.trim();
      }
      return dbCredentials;
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
    }
 finally {
      if (rs != null) {
        try {
          rs.close();
        }
 catch (        SQLException e) {
          containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
        }
      }
    }
    if (dbConnection != null) {
      close(dbConnection);
    }
    numberOfTries--;
  }
  return (null);
}

ID 3800=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getPassword(java.lang.String)
Rmethod: java.sql.ResultSet#next()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 */
@Override protected synchronized String getPassword(String username){
  String dbCredentials=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      stmt=credentials(dbConnection,username);
      rs=stmt.executeQuery();
      if (rs.next()) {
        dbCredentials=rs.getString(1);
      }
      dbConnection.commit();
      if (dbCredentials != null) {
        dbCredentials=dbCredentials.trim();
      }
      return dbCredentials;
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
    }
 finally {
      if (rs != null) {
        try {
          rs.close();
        }
 catch (        SQLException e) {
          containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
        }
      }
    }
    if (dbConnection != null) {
      close(dbConnection);
    }
    numberOfTries--;
  }
  return (null);
}

ID 3801=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getPassword(java.lang.String)
Rmethod: java.sql.ResultSet#getString(int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 */
@Override protected synchronized String getPassword(String username){
  String dbCredentials=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      stmt=credentials(dbConnection,username);
      rs=stmt.executeQuery();
      if (rs.next()) {
        dbCredentials=rs.getString(1);
      }
      dbConnection.commit();
      if (dbCredentials != null) {
        dbCredentials=dbCredentials.trim();
      }
      return dbCredentials;
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
    }
 finally {
      if (rs != null) {
        try {
          rs.close();
        }
 catch (        SQLException e) {
          containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
        }
      }
    }
    if (dbConnection != null) {
      close(dbConnection);
    }
    numberOfTries--;
  }
  return (null);
}

ID 3802=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getPassword(java.lang.String)
Rmethod: java.sql.Connection#commit()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 */
@Override protected synchronized String getPassword(String username){
  String dbCredentials=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      stmt=credentials(dbConnection,username);
      rs=stmt.executeQuery();
      if (rs.next()) {
        dbCredentials=rs.getString(1);
      }
      dbConnection.commit();
      if (dbCredentials != null) {
        dbCredentials=dbCredentials.trim();
      }
      return dbCredentials;
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
    }
 finally {
      if (rs != null) {
        try {
          rs.close();
        }
 catch (        SQLException e) {
          containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
        }
      }
    }
    if (dbConnection != null) {
      close(dbConnection);
    }
    numberOfTries--;
  }
  return (null);
}

ID 3803=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getPassword(java.lang.String)
Rmethod: java.sql.ResultSet#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the password associated with the given principal's user name.
 */
@Override protected synchronized String getPassword(String username){
  String dbCredentials=null;
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      stmt=credentials(dbConnection,username);
      rs=stmt.executeQuery();
      if (rs.next()) {
        dbCredentials=rs.getString(1);
      }
      dbConnection.commit();
      if (dbCredentials != null) {
        dbCredentials=dbCredentials.trim();
      }
      return dbCredentials;
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
    }
 finally {
      if (rs != null) {
        try {
          rs.close();
        }
 catch (        SQLException e) {
          containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
        }
      }
    }
    if (dbConnection != null) {
      close(dbConnection);
    }
    numberOfTries--;
  }
  return (null);
}

ID 3804=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getRoles(java.lang.String)
Rmethod: org.apache.catalina.realm.JDBCRealm#open()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the gven user name.
 */
protected ArrayList<String> getRoles(String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      try {
        ArrayList<String> roleList=new ArrayList<String>();
        stmt=roles(dbConnection,username);
        rs=stmt.executeQuery();
        while (rs.next()) {
          String role=rs.getString(1);
          if (null != role) {
            roleList.add(role.trim());
          }
        }
        rs.close();
        rs=null;
        return (roleList);
      }
  finally {
        if (rs != null) {
          try {
            rs.close();
          }
 catch (          SQLException e) {
            containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
          }
        }
        dbConnection.commit();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
      if (dbConnection != null)       close(dbConnection);
    }
    numberOfTries--;
  }
  return null;
}

ID 3810=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#getRoles(java.lang.String)
Rmethod: java.sql.ResultSet#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return the roles associated with the gven user name.
 */
protected ArrayList<String> getRoles(String username){
  if (allRolesMode != AllRolesMode.STRICT_MODE && !isRoleStoreDefined()) {
    return null;
  }
  PreparedStatement stmt=null;
  ResultSet rs=null;
  int numberOfTries=2;
  while (numberOfTries > 0) {
    try {
      open();
      try {
        ArrayList<String> roleList=new ArrayList<String>();
        stmt=roles(dbConnection,username);
        rs=stmt.executeQuery();
        while (rs.next()) {
          String role=rs.getString(1);
          if (null != role) {
            roleList.add(role.trim());
          }
        }
        rs.close();
        rs=null;
        return (roleList);
      }
  finally {
        if (rs != null) {
          try {
            rs.close();
          }
 catch (          SQLException e) {
            containerLog.warn(sm.getString("jdbcRealm.abnormalCloseResultSet"));
          }
        }
        dbConnection.commit();
      }
    }
 catch (    SQLException e) {
      containerLog.error(sm.getString("jdbcRealm.exception"),e);
      if (dbConnection != null)       close(dbConnection);
    }
    numberOfTries--;
  }
  return null;
}

ID 3819=========================================================================type: 1
Method:org.apache.catalina.realm.JDBCRealm#startInternal()
Rmethod: org.apache.catalina.realm.JDBCRealm#open()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Prepare for the beginning of active use of the public methods of this component and implement the requirements of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
 * @exception LifecycleException if this component detects a fatal errorthat prevents this component from being used
 */
@Override protected void startInternal() throws LifecycleException {
  try {
    open();
  }
 catch (  SQLException e) {
    containerLog.error(sm.getString("jdbcRealm.open"),e);
  }
  super.startInternal();
}

ID 3826=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#clearStore()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Clear all sessions from the Store.
 */
public void clearStore(){
  if (store == null)   return;
  try {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        AccessController.doPrivileged(new PrivilegedStoreClear());
      }
 catch (      PrivilegedActionException ex) {
        Exception exception=ex.getException();
        log.error("Exception clearing the Store: " + exception,exception);
      }
    }
 else {
      store.clear();
    }
  }
 catch (  IOException e) {
    log.error("Exception clearing the Store: " + e,e);
  }
}

ID 3827=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#clearStore()
Rmethod: org.apache.catalina.Store#clear()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Clear all sessions from the Store.
 */
public void clearStore(){
  if (store == null)   return;
  try {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        AccessController.doPrivileged(new PrivilegedStoreClear());
      }
 catch (      PrivilegedActionException ex) {
        Exception exception=ex.getException();
        log.error("Exception clearing the Store: " + exception,exception);
      }
    }
 else {
      store.clear();
    }
  }
 catch (  IOException e) {
    log.error("Exception clearing the Store: " + e,e);
  }
}

ID 3829=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#load()
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Load all sessions found in the persistence mechanism, assuming they are marked as valid and have not passed their expiration limit. If persistence is not supported, this method returns without doing anything. <p> Note that by default, this method is not called by the MiddleManager class. In order to use it, a subclass must specifically call it, for example in the start() and/or processPersistenceChecks() methods.
 */
@Override public void load(){
  sessions.clear();
  if (store == null)   return;
  String[] ids=null;
  try {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        ids=AccessController.doPrivileged(new PrivilegedStoreKeys());
      }
 catch (      PrivilegedActionException ex) {
        Exception exception=ex.getException();
        log.error("Exception in the Store during load: " + exception,exception);
        return;
      }
    }
 else {
      ids=store.keys();
    }
  }
 catch (  IOException e) {
    log.error("Can't load sessions from store, " + e.getMessage(),e);
    return;
  }
  int n=ids.length;
  if (n == 0)   return;
  if (log.isDebugEnabled())   log.debug(sm.getString("persistentManager.loading",String.valueOf(n)));
  for (int i=0; i < n; i++)   try {
    swapIn(ids[i]);
  }
 catch (  IOException e) {
    log.error("Failed load session from store, " + e.getMessage(),e);
  }
}

ID 3830=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#load()
Rmethod: org.apache.catalina.Store#keys()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Load all sessions found in the persistence mechanism, assuming they are marked as valid and have not passed their expiration limit. If persistence is not supported, this method returns without doing anything. <p> Note that by default, this method is not called by the MiddleManager class. In order to use it, a subclass must specifically call it, for example in the start() and/or processPersistenceChecks() methods.
 */
@Override public void load(){
  sessions.clear();
  if (store == null)   return;
  String[] ids=null;
  try {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        ids=AccessController.doPrivileged(new PrivilegedStoreKeys());
      }
 catch (      PrivilegedActionException ex) {
        Exception exception=ex.getException();
        log.error("Exception in the Store during load: " + exception,exception);
        return;
      }
    }
 else {
      ids=store.keys();
    }
  }
 catch (  IOException e) {
    log.error("Can't load sessions from store, " + e.getMessage(),e);
    return;
  }
  int n=ids.length;
  if (n == 0)   return;
  if (log.isDebugEnabled())   log.debug(sm.getString("persistentManager.loading",String.valueOf(n)));
  for (int i=0; i < n; i++)   try {
    swapIn(ids[i]);
  }
 catch (  IOException e) {
    log.error("Failed load session from store, " + e.getMessage(),e);
  }
}

ID 3831=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#load()
Rmethod: org.apache.catalina.session.PersistentManagerBase#swapIn(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Load all sessions found in the persistence mechanism, assuming they are marked as valid and have not passed their expiration limit. If persistence is not supported, this method returns without doing anything. <p> Note that by default, this method is not called by the MiddleManager class. In order to use it, a subclass must specifically call it, for example in the start() and/or processPersistenceChecks() methods.
 */
@Override public void load(){
  sessions.clear();
  if (store == null)   return;
  String[] ids=null;
  try {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        ids=AccessController.doPrivileged(new PrivilegedStoreKeys());
      }
 catch (      PrivilegedActionException ex) {
        Exception exception=ex.getException();
        log.error("Exception in the Store during load: " + exception,exception);
        return;
      }
    }
 else {
      ids=store.keys();
    }
  }
 catch (  IOException e) {
    log.error("Can't load sessions from store, " + e.getMessage(),e);
    return;
  }
  int n=ids.length;
  if (n == 0)   return;
  if (log.isDebugEnabled())   log.debug(sm.getString("persistentManager.loading",String.valueOf(n)));
  for (int i=0; i < n; i++)   try {
    swapIn(ids[i]);
  }
 catch (  IOException e) {
    log.error("Failed load session from store, " + e.getMessage(),e);
  }
}

ID 3832=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#removeSession(java.lang.String)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
/** 
 * Remove this Session from the active Sessions for this Manager, and from the Store.
 * @param id Session's id to be removed
 */
protected void removeSession(String id){
  try {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        AccessController.doPrivileged(new PrivilegedStoreRemove(id));
      }
 catch (      PrivilegedActionException ex) {
        Exception exception=ex.getException();
        log.error("Exception in the Store during removeSession: " + exception,exception);
      }
    }
 else {
      store.remove(id);
    }
  }
 catch (  IOException e) {
    log.error("Exception removing session  " + e.getMessage(),e);
  }
}

ID 3833=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#removeSession(java.lang.String)
Rmethod: org.apache.catalina.Store#remove(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Remove this Session from the active Sessions for this Manager, and from the Store.
 * @param id Session's id to be removed
 */
protected void removeSession(String id){
  try {
    if (SecurityUtil.isPackageProtectionEnabled()) {
      try {
        AccessController.doPrivileged(new PrivilegedStoreRemove(id));
      }
 catch (      PrivilegedActionException ex) {
        Exception exception=ex.getException();
        log.error("Exception in the Store during removeSession: " + exception,exception);
      }
    }
 else {
      store.remove(id);
    }
  }
 catch (  IOException e) {
    log.error("Exception removing session  " + e.getMessage(),e);
  }
}

ID 3835=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#getActiveSessionsFull()
Rmethod: org.apache.catalina.Store#getSize()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int getActiveSessionsFull(){
  int result=getActiveSessions();
  try {
    result+=getStore().getSize();
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("persistentManager.storeSizeException"));
  }
  return result;
}

ID 3836=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#getSessionIdsFull()
Rmethod: org.apache.catalina.Store#keys()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public Set<String> getSessionIdsFull(){
  Set<String> sessionIds=new HashSet<String>();
  sessionIds.addAll(sessions.keySet());
  String[] storeKeys;
  try {
    storeKeys=getStore().keys();
    for (    String storeKey : storeKeys) {
      sessionIds.add(storeKey);
    }
  }
 catch (  IOException e) {
    log.warn(sm.getString("persistentManager.storeKeysException"));
  }
  return sessionIds;
}

ID 3838=========================================================================type: 1
Method:org.apache.catalina.session.PersistentManagerBase#swapIn(java.lang.String)
Rmethod: org.apache.catalina.Store#load(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Look for a session in the Store and, if found, restore it in the Manager's list of active sessions if appropriate. The session will be removed from the Store after swapping in, but will not be added to the active session list if it is invalid or past its expiration.
 * @return restored session, or {@code null}, if none is found
 */
protected Session swapIn(String id) throws IOException {
  if (store == null)   return null;
  Object swapInLock=null;
synchronized (this) {
    swapInLock=sessionSwapInLocks.get(id);
    if (swapInLock == null) {
      swapInLock=new Object();
      sessionSwapInLocks.put(id,swapInLock);
    }
  }
  Session session=null;
synchronized (swapInLock) {
    session=sessions.get(id);
    if (session == null) {
      try {
        if (SecurityUtil.isPackageProtectionEnabled()) {
          try {
            session=AccessController.doPrivileged(new PrivilegedStoreLoad(id));
          }
 catch (          PrivilegedActionException ex) {
            Exception e=ex.getException();
            log.error(sm.getString("persistentManager.swapInException",id),e);
            if (e instanceof IOException) {
              throw (IOException)e;
            }
 else             if (e instanceof ClassNotFoundException) {
              throw (ClassNotFoundException)e;
            }
          }
        }
 else {
          session=store.load(id);
        }
      }
 catch (      ClassNotFoundException e) {
        String msg=sm.getString("persistentManager.deserializeError",id);
        log.error(msg,e);
        throw new IllegalStateException(msg,e);
      }
      if (session != null && !session.isValid()) {
        log.error(sm.getString("persistentManager.swapInInvalid",id));
        session.expire();
        removeSession(id);
        session=null;
      }
      if (session != null) {
        if (log.isDebugEnabled())         log.debug(sm.getString("persistentManager.swapIn",id));
        session.setManager(this);
        ((StandardSession)session).tellNew();
        add(session);
        ((StandardSession)session).activate();
        session.access();
        session.endAccess();
      }
    }
  }
synchronized (this) {
    sessionSwapInLocks.remove(id);
  }
  return session;
}

ID 3856=========================================================================type: 1
Method:org.apache.catalina.session.StandardManager#doLoad()
Rmethod: java.io.FileInputStream#FileInputStream(java.lang.String)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Load any currently active sessions that were previously unloaded to the appropriate persistence mechanism, if any.  If persistence is not supported, this method returns without doing anything.
 * @exception ClassNotFoundException if a serialized class cannot befound during the reload
 * @exception IOException if an input/output error occurs
 */
protected void doLoad() throws ClassNotFoundException, IOException {
  if (log.isDebugEnabled()) {
    log.debug("Start: Loading persisted sessions");
  }
  sessions.clear();
  File file=file();
  if (file == null) {
    return;
  }
  if (log.isDebugEnabled()) {
    log.debug(sm.getString("standardManager.loading",pathname));
  }
  FileInputStream fis=null;
  BufferedInputStream bis=null;
  ObjectInputStream ois=null;
  Loader loader=null;
  ClassLoader classLoader=null;
  Log logger=null;
  try {
    fis=new FileInputStream(file.getAbsolutePath());
    bis=new BufferedInputStream(fis);
    loader=container.getLoader();
    logger=container.getLogger();
    if (loader != null) {
      classLoader=loader.getClassLoader();
    }
    if (classLoader == null) {
      classLoader=getClass().getClassLoader();
    }
    ois=new CustomObjectInputStream(bis,classLoader,logger,getSessionAttributeValueClassNamePattern(),getWarnOnSessionAttributeFilterFailure());
  }
 catch (  FileNotFoundException e) {
    if (log.isDebugEnabled()) {
      log.debug("No persisted data file found");
    }
    return;
  }
catch (  IOException e) {
    log.error(sm.getString("standardManager.loading.ioe",e),e);
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException f) {
      }
    }
    if (bis != null) {
      try {
        bis.close();
      }
 catch (      IOException f) {
      }
    }
    throw e;
  }
synchronized (sessions) {
    try {
      Integer count=(Integer)ois.readObject();
      int n=count.intValue();
      if (log.isDebugEnabled())       log.debug("Loading " + n + " persisted sessions");
      for (int i=0; i < n; i++) {
        StandardSession session=getNewSession();
        session.readObjectData(ois);
        session.setManager(this);
        sessions.put(session.getIdInternal(),session);
        session.activate();
        if (!session.isValidInternal()) {
          session.setValid(true);
          session.expire();
        }
        sessionCounter++;
      }
    }
 catch (    ClassNotFoundException e) {
      log.error(sm.getString("standardManager.loading.cnfe",e),e);
      try {
        ois.close();
      }
 catch (      IOException f) {
      }
      throw e;
    }
catch (    IOException e) {
      log.error(sm.getString("standardManager.loading.ioe",e),e);
      try {
        ois.close();
      }
 catch (      IOException f) {
      }
      throw e;
    }
 finally {
      try {
        ois.close();
      }
 catch (      IOException f) {
      }
      if (file.exists()) {
        file.delete();
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug("Finish: Loading persisted sessions");
  }
}

ID 3885=========================================================================type: 1
Method:org.apache.catalina.session.StoreBase#processExpires()
Rmethod: org.apache.catalina.session.StoreBase#expiredKeys()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Called by our background reaper thread to check if Sessions saved in our store are subject of being expired. If so expire the Session and remove it from the Store.
 */
public void processExpires(){
  String[] keys=null;
  if (!getState().isAvailable()) {
    return;
  }
  try {
    keys=expiredKeys();
  }
 catch (  IOException e) {
    manager.getContainer().getLogger().error("Error getting keys",e);
    return;
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(getStoreName() + ": processExpires check number of " + keys.length+ " sessions");
  }
  long timeNow=System.currentTimeMillis();
  for (int i=0; i < keys.length; i++) {
    try {
      StandardSession session=(StandardSession)load(keys[i]);
      if (session == null) {
        continue;
      }
      int timeIdle=(int)((timeNow - session.getThisAccessedTime()) / 1000L);
      if (timeIdle < session.getMaxInactiveInterval()) {
        continue;
      }
      if (manager.getContainer().getLogger().isDebugEnabled()) {
        manager.getContainer().getLogger().debug(getStoreName() + ": processExpires expire store session " + keys[i]);
      }
      boolean isLoaded=false;
      if (manager instanceof PersistentManagerBase) {
        isLoaded=((PersistentManagerBase)manager).isLoaded(keys[i]);
      }
 else {
        try {
          if (manager.findSession(keys[i]) != null) {
            isLoaded=true;
          }
        }
 catch (        IOException ioe) {
        }
      }
      if (isLoaded) {
        session.recycle();
      }
 else {
        session.expire();
      }
      remove(keys[i]);
    }
 catch (    Exception e) {
      manager.getContainer().getLogger().error("Session: " + keys[i] + "; ",e);
      try {
        remove(keys[i]);
      }
 catch (      IOException e2) {
        manager.getContainer().getLogger().error("Error removing key",e2);
      }
    }
  }
}

ID 3890=========================================================================type: 1
Method:org.apache.catalina.session.StoreBase#processExpires()
Rmethod: org.apache.catalina.Store#remove(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Called by our background reaper thread to check if Sessions saved in our store are subject of being expired. If so expire the Session and remove it from the Store.
 */
public void processExpires(){
  String[] keys=null;
  if (!getState().isAvailable()) {
    return;
  }
  try {
    keys=expiredKeys();
  }
 catch (  IOException e) {
    manager.getContainer().getLogger().error("Error getting keys",e);
    return;
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(getStoreName() + ": processExpires check number of " + keys.length+ " sessions");
  }
  long timeNow=System.currentTimeMillis();
  for (int i=0; i < keys.length; i++) {
    try {
      StandardSession session=(StandardSession)load(keys[i]);
      if (session == null) {
        continue;
      }
      int timeIdle=(int)((timeNow - session.getThisAccessedTime()) / 1000L);
      if (timeIdle < session.getMaxInactiveInterval()) {
        continue;
      }
      if (manager.getContainer().getLogger().isDebugEnabled()) {
        manager.getContainer().getLogger().debug(getStoreName() + ": processExpires expire store session " + keys[i]);
      }
      boolean isLoaded=false;
      if (manager instanceof PersistentManagerBase) {
        isLoaded=((PersistentManagerBase)manager).isLoaded(keys[i]);
      }
 else {
        try {
          if (manager.findSession(keys[i]) != null) {
            isLoaded=true;
          }
        }
 catch (        IOException ioe) {
        }
      }
      if (isLoaded) {
        session.recycle();
      }
 else {
        session.expire();
      }
      remove(keys[i]);
    }
 catch (    Exception e) {
      manager.getContainer().getLogger().error("Session: " + keys[i] + "; ",e);
      try {
        remove(keys[i]);
      }
 catch (      IOException e2) {
        manager.getContainer().getLogger().error("Error removing key",e2);
      }
    }
  }
}

ID 3895=========================================================================type: 1
Method:org.apache.catalina.session.StandardSession#expire(boolean)
Rmethod: org.apache.catalina.realm.GenericPrincipal#logout()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Perform the internal processing required to invalidate this session, without triggering an exception if the session has already expired.
 * @param notify Should we notify listeners about the demise ofthis session?
 */
public void expire(boolean notify){
  if (!isValid)   return;
synchronized (this) {
    if (expiring || !isValid)     return;
    if (manager == null)     return;
    expiring=true;
    Context context=(Context)manager.getContainer();
    ClassLoader oldTccl=null;
    if (context.getLoader() != null && context.getLoader().getClassLoader() != null) {
      oldTccl=Thread.currentThread().getContextClassLoader();
      if (Globals.IS_SECURITY_ENABLED) {
        PrivilegedAction<Void> pa=new PrivilegedSetTccl(context.getLoader().getClassLoader());
        AccessController.doPrivileged(pa);
      }
 else {
        Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader());
      }
    }
    try {
      Object listeners[]=context.getApplicationLifecycleListeners();
      if (notify && (listeners != null)) {
        HttpSessionEvent event=new HttpSessionEvent(getSession());
        for (int i=0; i < listeners.length; i++) {
          int j=(listeners.length - 1) - i;
          if (!(listeners[j] instanceof HttpSessionListener))           continue;
          HttpSessionListener listener=(HttpSessionListener)listeners[j];
          try {
            context.fireContainerEvent("beforeSessionDestroyed",listener);
            listener.sessionDestroyed(event);
            context.fireContainerEvent("afterSessionDestroyed",listener);
          }
 catch (          Throwable t) {
            ExceptionUtils.handleThrowable(t);
            try {
              context.fireContainerEvent("afterSessionDestroyed",listener);
            }
 catch (            Exception e) {
            }
            manager.getContainer().getLogger().error(sm.getString("standardSession.sessionEvent"),t);
          }
        }
      }
    }
  finally {
      if (oldTccl != null) {
        if (Globals.IS_SECURITY_ENABLED) {
          PrivilegedAction<Void> pa=new PrivilegedSetTccl(oldTccl);
          AccessController.doPrivileged(pa);
        }
 else {
          Thread.currentThread().setContextClassLoader(oldTccl);
        }
      }
    }
    if (ACTIVITY_CHECK) {
      accessCount.set(0);
    }
    manager.remove(this,true);
    if (notify) {
      fireSessionEvent(Session.SESSION_DESTROYED_EVENT,null);
    }
    if (principal instanceof GenericPrincipal) {
      GenericPrincipal gp=(GenericPrincipal)principal;
      try {
        gp.logout();
      }
 catch (      Exception e) {
        manager.getContainer().getLogger().error(sm.getString("standardSession.logoutfail"),e);
      }
    }
    setValid(false);
    expiring=false;
    String keys[]=keys();
    if (oldTccl != null) {
      if (Globals.IS_SECURITY_ENABLED) {
        PrivilegedAction<Void> pa=new PrivilegedSetTccl(context.getLoader().getClassLoader());
        AccessController.doPrivileged(pa);
      }
 else {
        Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader());
      }
    }
    try {
      for (int i=0; i < keys.length; i++) {
        removeAttributeInternal(keys[i],notify);
      }
    }
  finally {
      if (oldTccl != null) {
        if (Globals.IS_SECURITY_ENABLED) {
          PrivilegedAction<Void> pa=new PrivilegedSetTccl(oldTccl);
          AccessController.doPrivileged(pa);
        }
 else {
          Thread.currentThread().setContextClassLoader(oldTccl);
        }
      }
    }
  }
}

ID 3907=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#keys(boolean)
Rmethod: java.sql.Connection#prepareStatement(java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return an array containing the session identifiers of all Sessions currently saved in this Store.  If there are no such Sessions, a zero-length array is returned.
 * @param expiredOnly flag, whether only keys of expired sessions shouldbe returned
 * @return array containing the list of session IDs
 * @exception IOException if an input/output error occurred
 */
private String[] keys(boolean expiredOnly) throws IOException {
  String keys[]=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return new String[0];
      }
      try {
        String keysSql="SELECT " + sessionIdCol + " FROM "+ sessionTable+ " WHERE "+ sessionAppCol+ " = ?";
        if (expiredOnly) {
          keysSql+=" AND (" + sessionLastAccessedCol + " + "+ sessionMaxInactiveCol+ " * 1000 < ?)";
        }
        PreparedStatement preparedKeysSql=_conn.prepareStatement(keysSql);
        try {
          preparedKeysSql.setString(1,getName());
          if (expiredOnly) {
            preparedKeysSql.setLong(2,System.currentTimeMillis());
          }
          ResultSet rst=preparedKeysSql.executeQuery();
          try {
            ArrayList<String> tmpkeys=new ArrayList<String>();
            if (rst != null) {
              while (rst.next()) {
                tmpkeys.add(rst.getString(1));
              }
            }
            keys=tmpkeys.toArray(new String[tmpkeys.size()]);
            numberOfTries=0;
          }
  finally {
            if (rst != null) {
              rst.close();
            }
          }
        }
  finally {
          preparedKeysSql.close();
        }
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        keys=new String[0];
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return keys;
}

ID 3915=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#getSize()
Rmethod: java.sql.Connection#prepareStatement(java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return an integer containing a count of all Sessions currently saved in this Store.  If there are no Sessions, <code>0</code> is returned.
 * @return the count of all sessions currently saved in this Store
 * @exception IOException if an input/output error occurred
 */
@Override public int getSize() throws IOException {
  int size=0;
  ResultSet rst=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return size;
      }
      try {
        if (preparedSizeSql == null) {
          String sizeSql="SELECT COUNT(" + sessionIdCol + ") FROM "+ sessionTable+ " WHERE "+ sessionAppCol+ " = ?";
          preparedSizeSql=_conn.prepareStatement(sizeSql);
        }
        preparedSizeSql.setString(1,getName());
        rst=preparedSizeSql.executeQuery();
        if (rst.next()) {
          size=rst.getInt(1);
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null)           rst.close();
        }
 catch (        SQLException e) {
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return size;
}

ID 3916=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#getSize()
Rmethod: java.sql.PreparedStatement#setString(int, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return an integer containing a count of all Sessions currently saved in this Store.  If there are no Sessions, <code>0</code> is returned.
 * @return the count of all sessions currently saved in this Store
 * @exception IOException if an input/output error occurred
 */
@Override public int getSize() throws IOException {
  int size=0;
  ResultSet rst=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return size;
      }
      try {
        if (preparedSizeSql == null) {
          String sizeSql="SELECT COUNT(" + sessionIdCol + ") FROM "+ sessionTable+ " WHERE "+ sessionAppCol+ " = ?";
          preparedSizeSql=_conn.prepareStatement(sizeSql);
        }
        preparedSizeSql.setString(1,getName());
        rst=preparedSizeSql.executeQuery();
        if (rst.next()) {
          size=rst.getInt(1);
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null)           rst.close();
        }
 catch (        SQLException e) {
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return size;
}

ID 3917=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#getSize()
Rmethod: java.sql.PreparedStatement#executeQuery()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return an integer containing a count of all Sessions currently saved in this Store.  If there are no Sessions, <code>0</code> is returned.
 * @return the count of all sessions currently saved in this Store
 * @exception IOException if an input/output error occurred
 */
@Override public int getSize() throws IOException {
  int size=0;
  ResultSet rst=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return size;
      }
      try {
        if (preparedSizeSql == null) {
          String sizeSql="SELECT COUNT(" + sessionIdCol + ") FROM "+ sessionTable+ " WHERE "+ sessionAppCol+ " = ?";
          preparedSizeSql=_conn.prepareStatement(sizeSql);
        }
        preparedSizeSql.setString(1,getName());
        rst=preparedSizeSql.executeQuery();
        if (rst.next()) {
          size=rst.getInt(1);
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null)           rst.close();
        }
 catch (        SQLException e) {
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return size;
}

ID 3918=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#getSize()
Rmethod: java.sql.ResultSet#next()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return an integer containing a count of all Sessions currently saved in this Store.  If there are no Sessions, <code>0</code> is returned.
 * @return the count of all sessions currently saved in this Store
 * @exception IOException if an input/output error occurred
 */
@Override public int getSize() throws IOException {
  int size=0;
  ResultSet rst=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return size;
      }
      try {
        if (preparedSizeSql == null) {
          String sizeSql="SELECT COUNT(" + sessionIdCol + ") FROM "+ sessionTable+ " WHERE "+ sessionAppCol+ " = ?";
          preparedSizeSql=_conn.prepareStatement(sizeSql);
        }
        preparedSizeSql.setString(1,getName());
        rst=preparedSizeSql.executeQuery();
        if (rst.next()) {
          size=rst.getInt(1);
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null)           rst.close();
        }
 catch (        SQLException e) {
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return size;
}

ID 3919=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#getSize()
Rmethod: java.sql.ResultSet#getInt(int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Return an integer containing a count of all Sessions currently saved in this Store.  If there are no Sessions, <code>0</code> is returned.
 * @return the count of all sessions currently saved in this Store
 * @exception IOException if an input/output error occurred
 */
@Override public int getSize() throws IOException {
  int size=0;
  ResultSet rst=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return size;
      }
      try {
        if (preparedSizeSql == null) {
          String sizeSql="SELECT COUNT(" + sessionIdCol + ") FROM "+ sessionTable+ " WHERE "+ sessionAppCol+ " = ?";
          preparedSizeSql=_conn.prepareStatement(sizeSql);
        }
        preparedSizeSql.setString(1,getName());
        rst=preparedSizeSql.executeQuery();
        if (rst.next()) {
          size=rst.getInt(1);
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null)           rst.close();
        }
 catch (        SQLException e) {
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return size;
}

ID 3921=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#load(java.lang.String)
Rmethod: java.sql.Connection#prepareStatement(java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Load the Session associated with the id <code>id</code>. If no such session is found <code>null</code> is returned.
 * @param id a value of type <code>String</code>
 * @return the stored <code>Session</code>
 * @exception ClassNotFoundException if an error occurs
 * @exception IOException if an input/output error occurred
 */
@Override public Session load(String id) throws ClassNotFoundException, IOException {
  ResultSet rst=null;
  StandardSession _session=null;
  ClassLoader classLoader=null;
  ObjectInputStream ois=null;
  org.apache.catalina.Context context=(org.apache.catalina.Context)manager.getContainer();
  Log containerLog=context.getLogger();
  Loader loader=context.getLoader();
  if (loader != null) {
    classLoader=loader.getClassLoader();
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return null;
      }
      ClassLoader oldThreadContextCL=Thread.currentThread().getContextClassLoader();
      try {
        if (preparedLoadSql == null) {
          String loadSql="SELECT " + sessionIdCol + ", "+ sessionDataCol+ " FROM "+ sessionTable+ " WHERE "+ sessionIdCol+ " = ? AND "+ sessionAppCol+ " = ?";
          preparedLoadSql=_conn.prepareStatement(loadSql);
        }
        preparedLoadSql.setString(1,id);
        preparedLoadSql.setString(2,getName());
        rst=preparedLoadSql.executeQuery();
        if (rst.next()) {
          if (classLoader != null) {
            Thread.currentThread().setContextClassLoader(classLoader);
          }
          ois=getObjectInputStream(rst.getBinaryStream(2));
          if (containerLog.isDebugEnabled()) {
            containerLog.debug(sm.getString(getStoreName() + ".loading",id,sessionTable));
          }
          _session=(StandardSession)manager.createEmptySession();
          _session.readObjectData(ois);
          _session.setManager(manager);
        }
 else         if (containerLog.isDebugEnabled()) {
          containerLog.debug(getStoreName() + ": No persisted data object found");
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        containerLog.error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null) {
            rst.close();
          }
        }
 catch (        SQLException e) {
        }
        if (ois != null) {
          try {
            ois.close();
          }
 catch (          IOException e) {
          }
        }
        Thread.currentThread().setContextClassLoader(oldThreadContextCL);
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return _session;
}

ID 3922=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#load(java.lang.String)
Rmethod: java.sql.PreparedStatement#setString(int, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Load the Session associated with the id <code>id</code>. If no such session is found <code>null</code> is returned.
 * @param id a value of type <code>String</code>
 * @return the stored <code>Session</code>
 * @exception ClassNotFoundException if an error occurs
 * @exception IOException if an input/output error occurred
 */
@Override public Session load(String id) throws ClassNotFoundException, IOException {
  ResultSet rst=null;
  StandardSession _session=null;
  ClassLoader classLoader=null;
  ObjectInputStream ois=null;
  org.apache.catalina.Context context=(org.apache.catalina.Context)manager.getContainer();
  Log containerLog=context.getLogger();
  Loader loader=context.getLoader();
  if (loader != null) {
    classLoader=loader.getClassLoader();
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return null;
      }
      ClassLoader oldThreadContextCL=Thread.currentThread().getContextClassLoader();
      try {
        if (preparedLoadSql == null) {
          String loadSql="SELECT " + sessionIdCol + ", "+ sessionDataCol+ " FROM "+ sessionTable+ " WHERE "+ sessionIdCol+ " = ? AND "+ sessionAppCol+ " = ?";
          preparedLoadSql=_conn.prepareStatement(loadSql);
        }
        preparedLoadSql.setString(1,id);
        preparedLoadSql.setString(2,getName());
        rst=preparedLoadSql.executeQuery();
        if (rst.next()) {
          if (classLoader != null) {
            Thread.currentThread().setContextClassLoader(classLoader);
          }
          ois=getObjectInputStream(rst.getBinaryStream(2));
          if (containerLog.isDebugEnabled()) {
            containerLog.debug(sm.getString(getStoreName() + ".loading",id,sessionTable));
          }
          _session=(StandardSession)manager.createEmptySession();
          _session.readObjectData(ois);
          _session.setManager(manager);
        }
 else         if (containerLog.isDebugEnabled()) {
          containerLog.debug(getStoreName() + ": No persisted data object found");
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        containerLog.error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null) {
            rst.close();
          }
        }
 catch (        SQLException e) {
        }
        if (ois != null) {
          try {
            ois.close();
          }
 catch (          IOException e) {
          }
        }
        Thread.currentThread().setContextClassLoader(oldThreadContextCL);
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return _session;
}

ID 3923=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#load(java.lang.String)
Rmethod: java.sql.PreparedStatement#executeQuery()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Load the Session associated with the id <code>id</code>. If no such session is found <code>null</code> is returned.
 * @param id a value of type <code>String</code>
 * @return the stored <code>Session</code>
 * @exception ClassNotFoundException if an error occurs
 * @exception IOException if an input/output error occurred
 */
@Override public Session load(String id) throws ClassNotFoundException, IOException {
  ResultSet rst=null;
  StandardSession _session=null;
  ClassLoader classLoader=null;
  ObjectInputStream ois=null;
  org.apache.catalina.Context context=(org.apache.catalina.Context)manager.getContainer();
  Log containerLog=context.getLogger();
  Loader loader=context.getLoader();
  if (loader != null) {
    classLoader=loader.getClassLoader();
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return null;
      }
      ClassLoader oldThreadContextCL=Thread.currentThread().getContextClassLoader();
      try {
        if (preparedLoadSql == null) {
          String loadSql="SELECT " + sessionIdCol + ", "+ sessionDataCol+ " FROM "+ sessionTable+ " WHERE "+ sessionIdCol+ " = ? AND "+ sessionAppCol+ " = ?";
          preparedLoadSql=_conn.prepareStatement(loadSql);
        }
        preparedLoadSql.setString(1,id);
        preparedLoadSql.setString(2,getName());
        rst=preparedLoadSql.executeQuery();
        if (rst.next()) {
          if (classLoader != null) {
            Thread.currentThread().setContextClassLoader(classLoader);
          }
          ois=getObjectInputStream(rst.getBinaryStream(2));
          if (containerLog.isDebugEnabled()) {
            containerLog.debug(sm.getString(getStoreName() + ".loading",id,sessionTable));
          }
          _session=(StandardSession)manager.createEmptySession();
          _session.readObjectData(ois);
          _session.setManager(manager);
        }
 else         if (containerLog.isDebugEnabled()) {
          containerLog.debug(getStoreName() + ": No persisted data object found");
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        containerLog.error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null) {
            rst.close();
          }
        }
 catch (        SQLException e) {
        }
        if (ois != null) {
          try {
            ois.close();
          }
 catch (          IOException e) {
          }
        }
        Thread.currentThread().setContextClassLoader(oldThreadContextCL);
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return _session;
}

ID 3924=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#load(java.lang.String)
Rmethod: java.sql.ResultSet#next()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Load the Session associated with the id <code>id</code>. If no such session is found <code>null</code> is returned.
 * @param id a value of type <code>String</code>
 * @return the stored <code>Session</code>
 * @exception ClassNotFoundException if an error occurs
 * @exception IOException if an input/output error occurred
 */
@Override public Session load(String id) throws ClassNotFoundException, IOException {
  ResultSet rst=null;
  StandardSession _session=null;
  ClassLoader classLoader=null;
  ObjectInputStream ois=null;
  org.apache.catalina.Context context=(org.apache.catalina.Context)manager.getContainer();
  Log containerLog=context.getLogger();
  Loader loader=context.getLoader();
  if (loader != null) {
    classLoader=loader.getClassLoader();
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return null;
      }
      ClassLoader oldThreadContextCL=Thread.currentThread().getContextClassLoader();
      try {
        if (preparedLoadSql == null) {
          String loadSql="SELECT " + sessionIdCol + ", "+ sessionDataCol+ " FROM "+ sessionTable+ " WHERE "+ sessionIdCol+ " = ? AND "+ sessionAppCol+ " = ?";
          preparedLoadSql=_conn.prepareStatement(loadSql);
        }
        preparedLoadSql.setString(1,id);
        preparedLoadSql.setString(2,getName());
        rst=preparedLoadSql.executeQuery();
        if (rst.next()) {
          if (classLoader != null) {
            Thread.currentThread().setContextClassLoader(classLoader);
          }
          ois=getObjectInputStream(rst.getBinaryStream(2));
          if (containerLog.isDebugEnabled()) {
            containerLog.debug(sm.getString(getStoreName() + ".loading",id,sessionTable));
          }
          _session=(StandardSession)manager.createEmptySession();
          _session.readObjectData(ois);
          _session.setManager(manager);
        }
 else         if (containerLog.isDebugEnabled()) {
          containerLog.debug(getStoreName() + ": No persisted data object found");
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        containerLog.error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null) {
            rst.close();
          }
        }
 catch (        SQLException e) {
        }
        if (ois != null) {
          try {
            ois.close();
          }
 catch (          IOException e) {
          }
        }
        Thread.currentThread().setContextClassLoader(oldThreadContextCL);
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return _session;
}

ID 3925=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#load(java.lang.String)
Rmethod: java.sql.ResultSet#getBinaryStream(int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Load the Session associated with the id <code>id</code>. If no such session is found <code>null</code> is returned.
 * @param id a value of type <code>String</code>
 * @return the stored <code>Session</code>
 * @exception ClassNotFoundException if an error occurs
 * @exception IOException if an input/output error occurred
 */
@Override public Session load(String id) throws ClassNotFoundException, IOException {
  ResultSet rst=null;
  StandardSession _session=null;
  ClassLoader classLoader=null;
  ObjectInputStream ois=null;
  org.apache.catalina.Context context=(org.apache.catalina.Context)manager.getContainer();
  Log containerLog=context.getLogger();
  Loader loader=context.getLoader();
  if (loader != null) {
    classLoader=loader.getClassLoader();
  }
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return null;
      }
      ClassLoader oldThreadContextCL=Thread.currentThread().getContextClassLoader();
      try {
        if (preparedLoadSql == null) {
          String loadSql="SELECT " + sessionIdCol + ", "+ sessionDataCol+ " FROM "+ sessionTable+ " WHERE "+ sessionIdCol+ " = ? AND "+ sessionAppCol+ " = ?";
          preparedLoadSql=_conn.prepareStatement(loadSql);
        }
        preparedLoadSql.setString(1,id);
        preparedLoadSql.setString(2,getName());
        rst=preparedLoadSql.executeQuery();
        if (rst.next()) {
          if (classLoader != null) {
            Thread.currentThread().setContextClassLoader(classLoader);
          }
          ois=getObjectInputStream(rst.getBinaryStream(2));
          if (containerLog.isDebugEnabled()) {
            containerLog.debug(sm.getString(getStoreName() + ".loading",id,sessionTable));
          }
          _session=(StandardSession)manager.createEmptySession();
          _session.readObjectData(ois);
          _session.setManager(manager);
        }
 else         if (containerLog.isDebugEnabled()) {
          containerLog.debug(getStoreName() + ": No persisted data object found");
        }
        numberOfTries=0;
      }
 catch (      SQLException e) {
        containerLog.error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        try {
          if (rst != null) {
            rst.close();
          }
        }
 catch (        SQLException e) {
        }
        if (ois != null) {
          try {
            ois.close();
          }
 catch (          IOException e) {
          }
        }
        Thread.currentThread().setContextClassLoader(oldThreadContextCL);
        release(_conn);
      }
      numberOfTries--;
    }
  }
  return _session;
}

ID 3931=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#remove(java.lang.String)
Rmethod: org.apache.catalina.session.JDBCStore#remove(java.lang.String, java.sql.Connection)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Remove the Session with the specified session identifier from this Store, if present.  If no such Session is present, this method takes no action.
 * @param id Session identifier of the Session to be removed
 * @exception IOException if an input/output error occurs
 */
@Override public void remove(String id) throws IOException {
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(id,_conn);
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".removing",id,sessionTable));
  }
}

ID 3935=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#clear()
Rmethod: java.sql.Connection#prepareStatement(java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Remove all of the Sessions in this Store.
 * @exception IOException if an input/output error occurs
 */
@Override public void clear() throws IOException {
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        if (preparedClearSql == null) {
          String clearSql="DELETE FROM " + sessionTable + " WHERE "+ sessionAppCol+ " = ?";
          preparedClearSql=_conn.prepareStatement(clearSql);
        }
        preparedClearSql.setString(1,getName());
        preparedClearSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        release(_conn);
      }
      numberOfTries--;
    }
  }
}

ID 3936=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#clear()
Rmethod: java.sql.PreparedStatement#setString(int, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Remove all of the Sessions in this Store.
 * @exception IOException if an input/output error occurs
 */
@Override public void clear() throws IOException {
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        if (preparedClearSql == null) {
          String clearSql="DELETE FROM " + sessionTable + " WHERE "+ sessionAppCol+ " = ?";
          preparedClearSql=_conn.prepareStatement(clearSql);
        }
        preparedClearSql.setString(1,getName());
        preparedClearSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        release(_conn);
      }
      numberOfTries--;
    }
  }
}

ID 3937=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#clear()
Rmethod: java.sql.PreparedStatement#execute()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Remove all of the Sessions in this Store.
 * @exception IOException if an input/output error occurs
 */
@Override public void clear() throws IOException {
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        if (preparedClearSql == null) {
          String clearSql="DELETE FROM " + sessionTable + " WHERE "+ sessionAppCol+ " = ?";
          preparedClearSql=_conn.prepareStatement(clearSql);
        }
        preparedClearSql.setString(1,getName());
        preparedClearSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
 finally {
        release(_conn);
      }
      numberOfTries--;
    }
  }
}

ID 3938=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#save(org.apache.catalina.Session)
Rmethod: org.apache.catalina.session.JDBCStore#remove(java.lang.String, java.sql.Connection)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Save a session to the Store.
 * @param session the session to be stored
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  ObjectOutputStream oos=null;
  ByteArrayOutputStream bos=null;
  ByteArrayInputStream bis=null;
  InputStream in=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(session.getIdInternal(),_conn);
        bos=new ByteArrayOutputStream();
        oos=new ObjectOutputStream(new BufferedOutputStream(bos));
        ((StandardSession)session).writeObjectData(oos);
        oos.close();
        oos=null;
        byte[] obs=bos.toByteArray();
        int size=obs.length;
        bis=new ByteArrayInputStream(obs,0,size);
        in=new BufferedInputStream(bis,size);
        if (preparedSaveSql == null) {
          String saveSql="INSERT INTO " + sessionTable + " ("+ sessionIdCol+ ", "+ sessionAppCol+ ", "+ sessionDataCol+ ", "+ sessionValidCol+ ", "+ sessionMaxInactiveCol+ ", "+ sessionLastAccessedCol+ ") VALUES (?, ?, ?, ?, ?, ?)";
          preparedSaveSql=_conn.prepareStatement(saveSql);
        }
        preparedSaveSql.setString(1,session.getIdInternal());
        preparedSaveSql.setString(2,getName());
        preparedSaveSql.setBinaryStream(3,in,size);
        preparedSaveSql.setString(4,session.isValid() ? "1" : "0");
        preparedSaveSql.setInt(5,session.getMaxInactiveInterval());
        preparedSaveSql.setLong(6,session.getLastAccessedTime());
        preparedSaveSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
catch (      IOException e) {
      }
 finally {
        if (oos != null) {
          oos.close();
        }
        if (bis != null) {
          bis.close();
        }
        if (in != null) {
          in.close();
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),sessionTable));
  }
}

ID 3942=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#save(org.apache.catalina.Session)
Rmethod: java.sql.Connection#prepareStatement(java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Save a session to the Store.
 * @param session the session to be stored
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  ObjectOutputStream oos=null;
  ByteArrayOutputStream bos=null;
  ByteArrayInputStream bis=null;
  InputStream in=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(session.getIdInternal(),_conn);
        bos=new ByteArrayOutputStream();
        oos=new ObjectOutputStream(new BufferedOutputStream(bos));
        ((StandardSession)session).writeObjectData(oos);
        oos.close();
        oos=null;
        byte[] obs=bos.toByteArray();
        int size=obs.length;
        bis=new ByteArrayInputStream(obs,0,size);
        in=new BufferedInputStream(bis,size);
        if (preparedSaveSql == null) {
          String saveSql="INSERT INTO " + sessionTable + " ("+ sessionIdCol+ ", "+ sessionAppCol+ ", "+ sessionDataCol+ ", "+ sessionValidCol+ ", "+ sessionMaxInactiveCol+ ", "+ sessionLastAccessedCol+ ") VALUES (?, ?, ?, ?, ?, ?)";
          preparedSaveSql=_conn.prepareStatement(saveSql);
        }
        preparedSaveSql.setString(1,session.getIdInternal());
        preparedSaveSql.setString(2,getName());
        preparedSaveSql.setBinaryStream(3,in,size);
        preparedSaveSql.setString(4,session.isValid() ? "1" : "0");
        preparedSaveSql.setInt(5,session.getMaxInactiveInterval());
        preparedSaveSql.setLong(6,session.getLastAccessedTime());
        preparedSaveSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
catch (      IOException e) {
      }
 finally {
        if (oos != null) {
          oos.close();
        }
        if (bis != null) {
          bis.close();
        }
        if (in != null) {
          in.close();
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),sessionTable));
  }
}

ID 3943=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#save(org.apache.catalina.Session)
Rmethod: java.sql.PreparedStatement#setString(int, java.lang.String)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Save a session to the Store.
 * @param session the session to be stored
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  ObjectOutputStream oos=null;
  ByteArrayOutputStream bos=null;
  ByteArrayInputStream bis=null;
  InputStream in=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(session.getIdInternal(),_conn);
        bos=new ByteArrayOutputStream();
        oos=new ObjectOutputStream(new BufferedOutputStream(bos));
        ((StandardSession)session).writeObjectData(oos);
        oos.close();
        oos=null;
        byte[] obs=bos.toByteArray();
        int size=obs.length;
        bis=new ByteArrayInputStream(obs,0,size);
        in=new BufferedInputStream(bis,size);
        if (preparedSaveSql == null) {
          String saveSql="INSERT INTO " + sessionTable + " ("+ sessionIdCol+ ", "+ sessionAppCol+ ", "+ sessionDataCol+ ", "+ sessionValidCol+ ", "+ sessionMaxInactiveCol+ ", "+ sessionLastAccessedCol+ ") VALUES (?, ?, ?, ?, ?, ?)";
          preparedSaveSql=_conn.prepareStatement(saveSql);
        }
        preparedSaveSql.setString(1,session.getIdInternal());
        preparedSaveSql.setString(2,getName());
        preparedSaveSql.setBinaryStream(3,in,size);
        preparedSaveSql.setString(4,session.isValid() ? "1" : "0");
        preparedSaveSql.setInt(5,session.getMaxInactiveInterval());
        preparedSaveSql.setLong(6,session.getLastAccessedTime());
        preparedSaveSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
catch (      IOException e) {
      }
 finally {
        if (oos != null) {
          oos.close();
        }
        if (bis != null) {
          bis.close();
        }
        if (in != null) {
          in.close();
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),sessionTable));
  }
}

ID 3944=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#save(org.apache.catalina.Session)
Rmethod: java.sql.PreparedStatement#setBinaryStream(int, java.io.InputStream, int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Save a session to the Store.
 * @param session the session to be stored
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  ObjectOutputStream oos=null;
  ByteArrayOutputStream bos=null;
  ByteArrayInputStream bis=null;
  InputStream in=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(session.getIdInternal(),_conn);
        bos=new ByteArrayOutputStream();
        oos=new ObjectOutputStream(new BufferedOutputStream(bos));
        ((StandardSession)session).writeObjectData(oos);
        oos.close();
        oos=null;
        byte[] obs=bos.toByteArray();
        int size=obs.length;
        bis=new ByteArrayInputStream(obs,0,size);
        in=new BufferedInputStream(bis,size);
        if (preparedSaveSql == null) {
          String saveSql="INSERT INTO " + sessionTable + " ("+ sessionIdCol+ ", "+ sessionAppCol+ ", "+ sessionDataCol+ ", "+ sessionValidCol+ ", "+ sessionMaxInactiveCol+ ", "+ sessionLastAccessedCol+ ") VALUES (?, ?, ?, ?, ?, ?)";
          preparedSaveSql=_conn.prepareStatement(saveSql);
        }
        preparedSaveSql.setString(1,session.getIdInternal());
        preparedSaveSql.setString(2,getName());
        preparedSaveSql.setBinaryStream(3,in,size);
        preparedSaveSql.setString(4,session.isValid() ? "1" : "0");
        preparedSaveSql.setInt(5,session.getMaxInactiveInterval());
        preparedSaveSql.setLong(6,session.getLastAccessedTime());
        preparedSaveSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
catch (      IOException e) {
      }
 finally {
        if (oos != null) {
          oos.close();
        }
        if (bis != null) {
          bis.close();
        }
        if (in != null) {
          in.close();
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),sessionTable));
  }
}

ID 3945=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#save(org.apache.catalina.Session)
Rmethod: java.sql.PreparedStatement#setInt(int, int)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Save a session to the Store.
 * @param session the session to be stored
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  ObjectOutputStream oos=null;
  ByteArrayOutputStream bos=null;
  ByteArrayInputStream bis=null;
  InputStream in=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(session.getIdInternal(),_conn);
        bos=new ByteArrayOutputStream();
        oos=new ObjectOutputStream(new BufferedOutputStream(bos));
        ((StandardSession)session).writeObjectData(oos);
        oos.close();
        oos=null;
        byte[] obs=bos.toByteArray();
        int size=obs.length;
        bis=new ByteArrayInputStream(obs,0,size);
        in=new BufferedInputStream(bis,size);
        if (preparedSaveSql == null) {
          String saveSql="INSERT INTO " + sessionTable + " ("+ sessionIdCol+ ", "+ sessionAppCol+ ", "+ sessionDataCol+ ", "+ sessionValidCol+ ", "+ sessionMaxInactiveCol+ ", "+ sessionLastAccessedCol+ ") VALUES (?, ?, ?, ?, ?, ?)";
          preparedSaveSql=_conn.prepareStatement(saveSql);
        }
        preparedSaveSql.setString(1,session.getIdInternal());
        preparedSaveSql.setString(2,getName());
        preparedSaveSql.setBinaryStream(3,in,size);
        preparedSaveSql.setString(4,session.isValid() ? "1" : "0");
        preparedSaveSql.setInt(5,session.getMaxInactiveInterval());
        preparedSaveSql.setLong(6,session.getLastAccessedTime());
        preparedSaveSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
catch (      IOException e) {
      }
 finally {
        if (oos != null) {
          oos.close();
        }
        if (bis != null) {
          bis.close();
        }
        if (in != null) {
          in.close();
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),sessionTable));
  }
}

ID 3946=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#save(org.apache.catalina.Session)
Rmethod: java.sql.PreparedStatement#setLong(int, long)
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Save a session to the Store.
 * @param session the session to be stored
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  ObjectOutputStream oos=null;
  ByteArrayOutputStream bos=null;
  ByteArrayInputStream bis=null;
  InputStream in=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(session.getIdInternal(),_conn);
        bos=new ByteArrayOutputStream();
        oos=new ObjectOutputStream(new BufferedOutputStream(bos));
        ((StandardSession)session).writeObjectData(oos);
        oos.close();
        oos=null;
        byte[] obs=bos.toByteArray();
        int size=obs.length;
        bis=new ByteArrayInputStream(obs,0,size);
        in=new BufferedInputStream(bis,size);
        if (preparedSaveSql == null) {
          String saveSql="INSERT INTO " + sessionTable + " ("+ sessionIdCol+ ", "+ sessionAppCol+ ", "+ sessionDataCol+ ", "+ sessionValidCol+ ", "+ sessionMaxInactiveCol+ ", "+ sessionLastAccessedCol+ ") VALUES (?, ?, ?, ?, ?, ?)";
          preparedSaveSql=_conn.prepareStatement(saveSql);
        }
        preparedSaveSql.setString(1,session.getIdInternal());
        preparedSaveSql.setString(2,getName());
        preparedSaveSql.setBinaryStream(3,in,size);
        preparedSaveSql.setString(4,session.isValid() ? "1" : "0");
        preparedSaveSql.setInt(5,session.getMaxInactiveInterval());
        preparedSaveSql.setLong(6,session.getLastAccessedTime());
        preparedSaveSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
catch (      IOException e) {
      }
 finally {
        if (oos != null) {
          oos.close();
        }
        if (bis != null) {
          bis.close();
        }
        if (in != null) {
          in.close();
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),sessionTable));
  }
}

ID 3947=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#save(org.apache.catalina.Session)
Rmethod: java.sql.PreparedStatement#execute()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Save a session to the Store.
 * @param session the session to be stored
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  ObjectOutputStream oos=null;
  ByteArrayOutputStream bos=null;
  ByteArrayInputStream bis=null;
  InputStream in=null;
synchronized (this) {
    int numberOfTries=2;
    while (numberOfTries > 0) {
      Connection _conn=getConnection();
      if (_conn == null) {
        return;
      }
      try {
        remove(session.getIdInternal(),_conn);
        bos=new ByteArrayOutputStream();
        oos=new ObjectOutputStream(new BufferedOutputStream(bos));
        ((StandardSession)session).writeObjectData(oos);
        oos.close();
        oos=null;
        byte[] obs=bos.toByteArray();
        int size=obs.length;
        bis=new ByteArrayInputStream(obs,0,size);
        in=new BufferedInputStream(bis,size);
        if (preparedSaveSql == null) {
          String saveSql="INSERT INTO " + sessionTable + " ("+ sessionIdCol+ ", "+ sessionAppCol+ ", "+ sessionDataCol+ ", "+ sessionValidCol+ ", "+ sessionMaxInactiveCol+ ", "+ sessionLastAccessedCol+ ") VALUES (?, ?, ?, ?, ?, ?)";
          preparedSaveSql=_conn.prepareStatement(saveSql);
        }
        preparedSaveSql.setString(1,session.getIdInternal());
        preparedSaveSql.setString(2,getName());
        preparedSaveSql.setBinaryStream(3,in,size);
        preparedSaveSql.setString(4,session.isValid() ? "1" : "0");
        preparedSaveSql.setInt(5,session.getMaxInactiveInterval());
        preparedSaveSql.setLong(6,session.getLastAccessedTime());
        preparedSaveSql.execute();
        numberOfTries=0;
      }
 catch (      SQLException e) {
        manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".SQLException",e));
        if (dbConnection != null)         close(dbConnection);
      }
catch (      IOException e) {
      }
 finally {
        if (oos != null) {
          oos.close();
        }
        if (bis != null) {
          bis.close();
        }
        if (in != null) {
          in.close();
        }
        release(_conn);
      }
      numberOfTries--;
    }
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),sessionTable));
  }
}

ID 3950=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#getConnection()
Rmethod: org.apache.catalina.session.JDBCStore#open()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Check the connection associated with this store, if it's <code>null</code> or closed try to reopen it. Returns <code>null</code> if the connection could not be established.
 * @return <code>Connection</code> if the connection succeeded
 */
protected Connection getConnection(){
  Connection conn=null;
  try {
    conn=open();
    if (conn == null || conn.isClosed()) {
      manager.getContainer().getLogger().info(sm.getString(getStoreName() + ".checkConnectionDBClosed"));
      conn=open();
      if (conn == null || conn.isClosed()) {
        manager.getContainer().getLogger().info(sm.getString(getStoreName() + ".checkConnectionDBReOpenFail"));
      }
    }
  }
 catch (  SQLException ex) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionSQLException",ex.toString()));
  }
  return conn;
}

ID 3951=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#getConnection()
Rmethod: java.sql.Connection#isClosed()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Check the connection associated with this store, if it's <code>null</code> or closed try to reopen it. Returns <code>null</code> if the connection could not be established.
 * @return <code>Connection</code> if the connection succeeded
 */
protected Connection getConnection(){
  Connection conn=null;
  try {
    conn=open();
    if (conn == null || conn.isClosed()) {
      manager.getContainer().getLogger().info(sm.getString(getStoreName() + ".checkConnectionDBClosed"));
      conn=open();
      if (conn == null || conn.isClosed()) {
        manager.getContainer().getLogger().info(sm.getString(getStoreName() + ".checkConnectionDBReOpenFail"));
      }
    }
  }
 catch (  SQLException ex) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionSQLException",ex.toString()));
  }
  return conn;
}

ID 3952=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#open()
Rmethod: javax.naming.InitialContext#InitialContext()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Open (if necessary) and return a database connection for use by this Store.
 * @return database connection ready to use
 * @exception SQLException if a database error occurs
 */
protected Connection open() throws SQLException {
  if (dbConnection != null)   return dbConnection;
  if (dataSourceName != null && dataSource == null) {
    Context initCtx;
    try {
      initCtx=new InitialContext();
      Context envCtx=(Context)initCtx.lookup("java:comp/env");
      this.dataSource=(DataSource)envCtx.lookup(this.dataSourceName);
    }
 catch (    NamingException e) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".wrongDataSource",this.dataSourceName),e);
    }
  }
  if (dataSource != null) {
    return dataSource.getConnection();
  }
  if (driver == null) {
    try {
      Class<?> clazz=Class.forName(driverName);
      driver=(Driver)clazz.newInstance();
    }
 catch (    ClassNotFoundException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    InstantiationException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    IllegalAccessException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
  }
  Properties props=new Properties();
  if (connectionName != null)   props.put("user",connectionName);
  if (connectionPassword != null)   props.put("password",connectionPassword);
  dbConnection=driver.connect(connectionURL,props);
  dbConnection.setAutoCommit(true);
  return dbConnection;
}

ID 3953=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#open()
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Open (if necessary) and return a database connection for use by this Store.
 * @return database connection ready to use
 * @exception SQLException if a database error occurs
 */
protected Connection open() throws SQLException {
  if (dbConnection != null)   return dbConnection;
  if (dataSourceName != null && dataSource == null) {
    Context initCtx;
    try {
      initCtx=new InitialContext();
      Context envCtx=(Context)initCtx.lookup("java:comp/env");
      this.dataSource=(DataSource)envCtx.lookup(this.dataSourceName);
    }
 catch (    NamingException e) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".wrongDataSource",this.dataSourceName),e);
    }
  }
  if (dataSource != null) {
    return dataSource.getConnection();
  }
  if (driver == null) {
    try {
      Class<?> clazz=Class.forName(driverName);
      driver=(Driver)clazz.newInstance();
    }
 catch (    ClassNotFoundException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    InstantiationException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    IllegalAccessException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
  }
  Properties props=new Properties();
  if (connectionName != null)   props.put("user",connectionName);
  if (connectionPassword != null)   props.put("password",connectionPassword);
  dbConnection=driver.connect(connectionURL,props);
  dbConnection.setAutoCommit(true);
  return dbConnection;
}

ID 3955=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#open()
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Open (if necessary) and return a database connection for use by this Store.
 * @return database connection ready to use
 * @exception SQLException if a database error occurs
 */
protected Connection open() throws SQLException {
  if (dbConnection != null)   return dbConnection;
  if (dataSourceName != null && dataSource == null) {
    Context initCtx;
    try {
      initCtx=new InitialContext();
      Context envCtx=(Context)initCtx.lookup("java:comp/env");
      this.dataSource=(DataSource)envCtx.lookup(this.dataSourceName);
    }
 catch (    NamingException e) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".wrongDataSource",this.dataSourceName),e);
    }
  }
  if (dataSource != null) {
    return dataSource.getConnection();
  }
  if (driver == null) {
    try {
      Class<?> clazz=Class.forName(driverName);
      driver=(Driver)clazz.newInstance();
    }
 catch (    ClassNotFoundException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    InstantiationException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    IllegalAccessException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
  }
  Properties props=new Properties();
  if (connectionName != null)   props.put("user",connectionName);
  if (connectionPassword != null)   props.put("password",connectionPassword);
  dbConnection=driver.connect(connectionURL,props);
  dbConnection.setAutoCommit(true);
  return dbConnection;
}

ID 3956=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#open()
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Open (if necessary) and return a database connection for use by this Store.
 * @return database connection ready to use
 * @exception SQLException if a database error occurs
 */
protected Connection open() throws SQLException {
  if (dbConnection != null)   return dbConnection;
  if (dataSourceName != null && dataSource == null) {
    Context initCtx;
    try {
      initCtx=new InitialContext();
      Context envCtx=(Context)initCtx.lookup("java:comp/env");
      this.dataSource=(DataSource)envCtx.lookup(this.dataSourceName);
    }
 catch (    NamingException e) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".wrongDataSource",this.dataSourceName),e);
    }
  }
  if (dataSource != null) {
    return dataSource.getConnection();
  }
  if (driver == null) {
    try {
      Class<?> clazz=Class.forName(driverName);
      driver=(Driver)clazz.newInstance();
    }
 catch (    ClassNotFoundException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    InstantiationException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    IllegalAccessException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
  }
  Properties props=new Properties();
  if (connectionName != null)   props.put("user",connectionName);
  if (connectionPassword != null)   props.put("password",connectionPassword);
  dbConnection=driver.connect(connectionURL,props);
  dbConnection.setAutoCommit(true);
  return dbConnection;
}

ID 3957=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#open()
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Open (if necessary) and return a database connection for use by this Store.
 * @return database connection ready to use
 * @exception SQLException if a database error occurs
 */
protected Connection open() throws SQLException {
  if (dbConnection != null)   return dbConnection;
  if (dataSourceName != null && dataSource == null) {
    Context initCtx;
    try {
      initCtx=new InitialContext();
      Context envCtx=(Context)initCtx.lookup("java:comp/env");
      this.dataSource=(DataSource)envCtx.lookup(this.dataSourceName);
    }
 catch (    NamingException e) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".wrongDataSource",this.dataSourceName),e);
    }
  }
  if (dataSource != null) {
    return dataSource.getConnection();
  }
  if (driver == null) {
    try {
      Class<?> clazz=Class.forName(driverName);
      driver=(Driver)clazz.newInstance();
    }
 catch (    ClassNotFoundException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    InstantiationException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
catch (    IllegalAccessException ex) {
      manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".checkConnectionClassNotFoundException",ex.toString()));
      throw new SQLException(ex);
    }
  }
  Properties props=new Properties();
  if (connectionName != null)   props.put("user",connectionName);
  if (connectionPassword != null)   props.put("password",connectionPassword);
  dbConnection=driver.connect(connectionURL,props);
  dbConnection.setAutoCommit(true);
  return dbConnection;
}

ID 3961=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#close(java.sql.Connection)
Rmethod: java.sql.Connection#getAutoCommit()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 * @param dbConnection The connection to be closed
 */
protected void close(Connection dbConnection){
  if (dbConnection == null)   return;
  try {
    preparedSizeSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedSizeSql=null;
  try {
    preparedSaveSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedSaveSql=null;
  try {
    preparedClearSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  try {
    preparedRemoveSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedRemoveSql=null;
  try {
    preparedLoadSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedLoadSql=null;
  try {
    if (!dbConnection.getAutoCommit()) {
      dbConnection.commit();
    }
  }
 catch (  SQLException e) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".commitSQLException"),e);
  }
  try {
    dbConnection.close();
  }
 catch (  SQLException e) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".close",e.toString()));
  }
 finally {
    this.dbConnection=null;
  }
}

ID 3962=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#close(java.sql.Connection)
Rmethod: java.sql.Connection#commit()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 * @param dbConnection The connection to be closed
 */
protected void close(Connection dbConnection){
  if (dbConnection == null)   return;
  try {
    preparedSizeSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedSizeSql=null;
  try {
    preparedSaveSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedSaveSql=null;
  try {
    preparedClearSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  try {
    preparedRemoveSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedRemoveSql=null;
  try {
    preparedLoadSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedLoadSql=null;
  try {
    if (!dbConnection.getAutoCommit()) {
      dbConnection.commit();
    }
  }
 catch (  SQLException e) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".commitSQLException"),e);
  }
  try {
    dbConnection.close();
  }
 catch (  SQLException e) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".close",e.toString()));
  }
 finally {
    this.dbConnection=null;
  }
}

ID 3963=========================================================================type: 1
Method:org.apache.catalina.session.JDBCStore#close(java.sql.Connection)
Rmethod: java.sql.Connection#close()
parentException: 
thrown: SQLException
exception comment: /** 
 * Constructs a <code>SQLException</code> object with a given <code>reason</code>, <code>SQLState</code>  and <code>vendorCode</code>. The <code>cause</code> is not initialized, and may subsequently be initialized by a call to the {@link Throwable#initCause(java.lang.Throwable)} method.<p>
 * @param reason a description of the exception
 * @param SQLState an XOPEN or SQL:2003 code identifying the exception
 * @param vendorCode a database vendor-specific exception code
 */

block: 
/** 
 * Close the specified database connection.
 * @param dbConnection The connection to be closed
 */
protected void close(Connection dbConnection){
  if (dbConnection == null)   return;
  try {
    preparedSizeSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedSizeSql=null;
  try {
    preparedSaveSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedSaveSql=null;
  try {
    preparedClearSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  try {
    preparedRemoveSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedRemoveSql=null;
  try {
    preparedLoadSql.close();
  }
 catch (  Throwable f) {
    ExceptionUtils.handleThrowable(f);
  }
  this.preparedLoadSql=null;
  try {
    if (!dbConnection.getAutoCommit()) {
      dbConnection.commit();
    }
  }
 catch (  SQLException e) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".commitSQLException"),e);
  }
  try {
    dbConnection.close();
  }
 catch (  SQLException e) {
    manager.getContainer().getLogger().error(sm.getString(getStoreName() + ".close",e.toString()));
  }
 finally {
    this.dbConnection=null;
  }
}

ID 3970=========================================================================type: 1
Method:org.apache.catalina.session.FileStore#load(java.lang.String)
Rmethod: java.io.FileInputStream#FileInputStream(java.lang.String)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Load and return the Session associated with the specified session identifier from this Store, without removing it.  If there is no such stored Session, return <code>null</code>.
 * @param id Session identifier of the session to load
 * @exception ClassNotFoundException if a deserialization error occurs
 * @exception IOException if an input/output error occurs
 */
@Override public Session load(String id) throws ClassNotFoundException, IOException {
  File file=file(id);
  if (file == null) {
    return null;
  }
  if (!file.exists()) {
    return null;
  }
  Context context=(Context)getManager().getContainer();
  Log containerLog=context.getLogger();
  if (containerLog.isDebugEnabled()) {
    containerLog.debug(sm.getString(getStoreName() + ".loading",id,file.getAbsolutePath()));
  }
  FileInputStream fis=null;
  ObjectInputStream ois=null;
  Loader loader=null;
  ClassLoader classLoader=null;
  ClassLoader oldThreadContextCL=Thread.currentThread().getContextClassLoader();
  try {
    fis=new FileInputStream(file.getAbsolutePath());
    loader=context.getLoader();
    if (loader != null) {
      classLoader=loader.getClassLoader();
    }
    if (classLoader != null) {
      Thread.currentThread().setContextClassLoader(classLoader);
    }
    ois=getObjectInputStream(fis);
    StandardSession session=(StandardSession)manager.createEmptySession();
    session.readObjectData(ois);
    session.setManager(manager);
    return session;
  }
 catch (  FileNotFoundException e) {
    if (containerLog.isDebugEnabled()) {
      containerLog.debug("No persisted data file found");
    }
    return null;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException f) {
      }
    }
    if (ois != null) {
      try {
        ois.close();
      }
 catch (      IOException f) {
      }
    }
    Thread.currentThread().setContextClassLoader(oldThreadContextCL);
  }
}

ID 3978=========================================================================type: 1
Method:org.apache.catalina.session.FileStore#save(org.apache.catalina.Session)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.lang.String)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Save the specified Session into this Store.  Any previously saved information for the associated session identifier is replaced.
 * @param session Session to be saved
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  File file=file(session.getIdInternal());
  if (file == null) {
    return;
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),file.getAbsolutePath()));
  }
  FileOutputStream fos=null;
  ObjectOutputStream oos=null;
  try {
    fos=new FileOutputStream(file.getAbsolutePath());
    oos=new ObjectOutputStream(new BufferedOutputStream(fos));
  }
 catch (  IOException e) {
    if (fos != null) {
      try {
        fos.close();
      }
 catch (      IOException f) {
      }
    }
    throw e;
  }
  try {
    ((StandardSession)session).writeObjectData(oos);
  }
  finally {
    oos.close();
  }
}

ID 3979=========================================================================type: 1
Method:org.apache.catalina.session.FileStore#save(org.apache.catalina.Session)
Rmethod: java.io.ObjectOutputStream#ObjectOutputStream(java.io.OutputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Save the specified Session into this Store.  Any previously saved information for the associated session identifier is replaced.
 * @param session Session to be saved
 * @exception IOException if an input/output error occurs
 */
@Override public void save(Session session) throws IOException {
  File file=file(session.getIdInternal());
  if (file == null) {
    return;
  }
  if (manager.getContainer().getLogger().isDebugEnabled()) {
    manager.getContainer().getLogger().debug(sm.getString(getStoreName() + ".saving",session.getIdInternal(),file.getAbsolutePath()));
  }
  FileOutputStream fos=null;
  ObjectOutputStream oos=null;
  try {
    fos=new FileOutputStream(file.getAbsolutePath());
    oos=new ObjectOutputStream(new BufferedOutputStream(fos));
  }
 catch (  IOException e) {
    if (fos != null) {
      try {
        fos.close();
      }
 catch (      IOException f) {
      }
    }
    throw e;
  }
  try {
    ((StandardSession)session).writeObjectData(oos);
  }
  finally {
    oos.close();
  }
}

ID 3993=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#generateMask()
Rmethod: java.security.SecureRandom#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
static byte[] generateMask(){
  SecureRandom sr=randoms.poll();
  if (sr == null) {
    try {
      sr=SecureRandom.getInstance("SHA1PRNG");
    }
 catch (    NoSuchAlgorithmException e) {
      sr=new SecureRandom();
    }
  }
  byte[] result=new byte[4];
  sr.nextBytes(result);
  randoms.add(sr);
  return result;
}

ID 3994=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#getGenericType(Class<T>, Class<? extends T>)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
private static <T>TypeResult getGenericType(Class<T> type,Class<? extends T> clazz){
  Type[] interfaces=clazz.getGenericInterfaces();
  for (  Type iface : interfaces) {
    if (iface instanceof ParameterizedType) {
      ParameterizedType pi=(ParameterizedType)iface;
      if (pi.getRawType() instanceof Class) {
        if (type.isAssignableFrom((Class<?>)pi.getRawType())) {
          return getTypeParameter(clazz,pi.getActualTypeArguments()[0]);
        }
      }
    }
  }
  @SuppressWarnings("unchecked") Class<? extends T> superClazz=(Class<? extends T>)clazz.getSuperclass();
  if (superClazz == null) {
    return null;
  }
  TypeResult superClassTypeResult=getGenericType(type,superClazz);
  int dimension=superClassTypeResult.getDimension();
  if (superClassTypeResult.getIndex() == -1 && dimension == 0) {
    return superClassTypeResult;
  }
  if (superClassTypeResult.getIndex() > -1) {
    ParameterizedType superClassType=(ParameterizedType)clazz.getGenericSuperclass();
    TypeResult result=getTypeParameter(clazz,superClassType.getActualTypeArguments()[superClassTypeResult.getIndex()]);
    result.incrementDimension(superClassTypeResult.getDimension());
    if (result.getClazz() != null && result.getDimension() > 0) {
      superClassTypeResult=result;
    }
 else {
      return result;
    }
  }
  if (superClassTypeResult.getDimension() > 0) {
    StringBuilder className=new StringBuilder();
    for (int i=0; i < dimension; i++) {
      className.append('[');
    }
    className.append('L');
    className.append(superClassTypeResult.getClazz().getCanonicalName());
    className.append(';');
    Class<?> arrayClazz;
    try {
      arrayClazz=Class.forName(className.toString());
    }
 catch (    ClassNotFoundException e) {
      throw new IllegalArgumentException(e);
    }
    return new TypeResult(arrayClazz,-1,0);
  }
  return null;
}

ID 4001=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#getDecoders(List<Class<? extends javax.websocket.Decoder>>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
public static List<DecoderEntry> getDecoders(List<Class<? extends Decoder>> decoderClazzes) throws DeploymentException {
  List<DecoderEntry> result=new ArrayList<DecoderEntry>();
  if (decoderClazzes != null) {
    for (    Class<? extends Decoder> decoderClazz : decoderClazzes) {
      @SuppressWarnings("unused") Decoder instance;
      try {
        instance=decoderClazz.newInstance();
      }
 catch (      InstantiationException e) {
        throw new DeploymentException(sm.getString("pojoMethodMapping.invalidDecoder",decoderClazz.getName()),e);
      }
catch (      IllegalAccessException e) {
        throw new DeploymentException(sm.getString("pojoMethodMapping.invalidDecoder",decoderClazz.getName()),e);
      }
      DecoderEntry entry=new DecoderEntry(Util.getDecoderType(decoderClazz),decoderClazz);
      result.add(entry);
    }
  }
  return result;
}

ID 4002=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#getDecoders(List<Class<? extends javax.websocket.Decoder>>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
public static List<DecoderEntry> getDecoders(List<Class<? extends Decoder>> decoderClazzes) throws DeploymentException {
  List<DecoderEntry> result=new ArrayList<DecoderEntry>();
  if (decoderClazzes != null) {
    for (    Class<? extends Decoder> decoderClazz : decoderClazzes) {
      @SuppressWarnings("unused") Decoder instance;
      try {
        instance=decoderClazz.newInstance();
      }
 catch (      InstantiationException e) {
        throw new DeploymentException(sm.getString("pojoMethodMapping.invalidDecoder",decoderClazz.getName()),e);
      }
catch (      IllegalAccessException e) {
        throw new DeploymentException(sm.getString("pojoMethodMapping.invalidDecoder",decoderClazz.getName()),e);
      }
      DecoderEntry entry=new DecoderEntry(Util.getDecoderType(decoderClazz),decoderClazz);
      result.add(entry);
    }
  }
  return result;
}

ID 4003=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#matchDecoders(Class<?>, javax.websocket.EndpointConfig)
Rmethod: org.apache.tomcat.websocket.Util#getDecoders(List<Class<? extends javax.websocket.Decoder>>)
parentException: 
thrown: DeploymentException
exception comment: null
block: 
private static DecoderMatch matchDecoders(Class<?> target,EndpointConfig endpointConfig){
  DecoderMatch decoderMatch;
  try {
    List<Class<? extends Decoder>> decoders=endpointConfig.getDecoders();
    List<DecoderEntry> decoderEntries=getDecoders(decoders);
    decoderMatch=new DecoderMatch(target,decoderEntries);
  }
 catch (  DeploymentException e) {
    throw new IllegalArgumentException(e);
  }
  return decoderMatch;
}

ID 4004=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#getOnMessageMethod(javax.websocket.MessageHandler)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
private static Method getOnMessageMethod(MessageHandler listener){
  try {
    return listener.getClass().getMethod("onMessage",Object.class);
  }
 catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
}

ID 4005=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#getOnMessageMethod(javax.websocket.MessageHandler)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
private static Method getOnMessageMethod(MessageHandler listener){
  try {
    return listener.getClass().getMethod("onMessage",Object.class);
  }
 catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
}

ID 4006=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#getOnMessagePartialMethod(javax.websocket.MessageHandler)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
private static Method getOnMessagePartialMethod(MessageHandler listener){
  try {
    return listener.getClass().getMethod("onMessage",Object.class,Boolean.TYPE);
  }
 catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
}

ID 4007=========================================================================type: 1
Method:org.apache.tomcat.websocket.Util#getOnMessagePartialMethod(javax.websocket.MessageHandler)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
private static Method getOnMessagePartialMethod(MessageHandler listener){
  try {
    return listener.getClass().getMethod("onMessage",Object.class,Boolean.TYPE);
  }
 catch (  NoSuchMethodException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
catch (  SecurityException e) {
    throw new IllegalArgumentException(sm.getString("util.invalidMessageHandler"),e);
  }
}

ID 4009=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(java.lang.Object, java.net.URI)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Object pojo,URI path) throws DeploymentException {
  ClientEndpoint annotation=pojo.getClass().getAnnotation(ClientEndpoint.class);
  if (annotation == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.missingAnnotation",pojo.getClass().getName()));
  }
  Endpoint ep=new PojoEndpointClient(pojo,Arrays.asList(annotation.decoders()));
  Class<? extends ClientEndpointConfig.Configurator> configuratorClazz=annotation.configurator();
  ClientEndpointConfig.Configurator configurator=null;
  if (!ClientEndpointConfig.Configurator.class.equals(configuratorClazz)) {
    try {
      configurator=configuratorClazz.newInstance();
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.defaultConfiguratorFail"),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.defaultConfiguratorFail"),e);
    }
  }
  ClientEndpointConfig.Builder builder=ClientEndpointConfig.Builder.create();
  if (configurator != null) {
    builder.configurator(configurator);
  }
  ClientEndpointConfig config=builder.decoders(Arrays.asList(annotation.decoders())).encoders(Arrays.asList(annotation.encoders())).preferredSubprotocols(Arrays.asList(annotation.subprotocols())).build();
  return connectToServer(ep,config,path);
}

ID 4010=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(java.lang.Object, java.net.URI)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Object pojo,URI path) throws DeploymentException {
  ClientEndpoint annotation=pojo.getClass().getAnnotation(ClientEndpoint.class);
  if (annotation == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.missingAnnotation",pojo.getClass().getName()));
  }
  Endpoint ep=new PojoEndpointClient(pojo,Arrays.asList(annotation.decoders()));
  Class<? extends ClientEndpointConfig.Configurator> configuratorClazz=annotation.configurator();
  ClientEndpointConfig.Configurator configurator=null;
  if (!ClientEndpointConfig.Configurator.class.equals(configuratorClazz)) {
    try {
      configurator=configuratorClazz.newInstance();
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.defaultConfiguratorFail"),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.defaultConfiguratorFail"),e);
    }
  }
  ClientEndpointConfig.Builder builder=ClientEndpointConfig.Builder.create();
  if (configurator != null) {
    builder.configurator(configurator);
  }
  ClientEndpointConfig config=builder.decoders(Arrays.asList(annotation.decoders())).encoders(Arrays.asList(annotation.encoders())).preferredSubprotocols(Arrays.asList(annotation.subprotocols())).build();
  return connectToServer(ep,config,path);
}

ID 4012=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(Class<?>, java.net.URI)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Class<?> annotatedEndpointClass,URI path) throws DeploymentException {
  Object pojo;
  try {
    pojo=annotatedEndpointClass.newInstance();
  }
 catch (  InstantiationException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",annotatedEndpointClass.getName()),e);
  }
catch (  IllegalAccessException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",annotatedEndpointClass.getName()),e);
  }
  return connectToServer(pojo,path);
}

ID 4013=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(Class<?>, java.net.URI)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Class<?> annotatedEndpointClass,URI path) throws DeploymentException {
  Object pojo;
  try {
    pojo=annotatedEndpointClass.newInstance();
  }
 catch (  InstantiationException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",annotatedEndpointClass.getName()),e);
  }
catch (  IllegalAccessException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",annotatedEndpointClass.getName()),e);
  }
  return connectToServer(pojo,path);
}

ID 4015=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(Class<? extends javax.websocket.Endpoint>, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Class<? extends Endpoint> clazz,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  Endpoint endpoint;
  try {
    endpoint=clazz.newInstance();
  }
 catch (  InstantiationException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",clazz.getName()),e);
  }
catch (  IllegalAccessException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",clazz.getName()),e);
  }
  return connectToServer(endpoint,clientEndpointConfiguration,path);
}

ID 4016=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(Class<? extends javax.websocket.Endpoint>, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Class<? extends Endpoint> clazz,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  Endpoint endpoint;
  try {
    endpoint=clazz.newInstance();
  }
 catch (  InstantiationException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",clazz.getName()),e);
  }
catch (  IllegalAccessException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.endpointCreateFail",clazz.getName()),e);
  }
  return connectToServer(endpoint,clientEndpointConfiguration,path);
}

ID 4018=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: java.nio.channels.AsynchronousSocketChannel#open(java.nio.channels.AsynchronousChannelGroup)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4032=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4033=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4034=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4035=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.AsyncChannelWrapper#handshake()
parentException: IOException 
thrown: SSLException
exception comment: null
block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4036=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.WsWebSocketContainer#writeRequest(org.apache.tomcat.websocket.AsyncChannelWrapper, java.nio.ByteBuffer, long)
parentException: 
thrown: TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4037=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.WsWebSocketContainer#writeRequest(org.apache.tomcat.websocket.AsyncChannelWrapper, java.nio.ByteBuffer, long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4038=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.WsWebSocketContainer#writeRequest(org.apache.tomcat.websocket.AsyncChannelWrapper, java.nio.ByteBuffer, long)
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4039=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.WsWebSocketContainer#processResponse(java.nio.ByteBuffer, org.apache.tomcat.websocket.AsyncChannelWrapper, long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4040=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.WsWebSocketContainer#processResponse(java.nio.ByteBuffer, org.apache.tomcat.websocket.AsyncChannelWrapper, long)
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4041=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.WsWebSocketContainer#processResponse(java.nio.ByteBuffer, org.apache.tomcat.websocket.AsyncChannelWrapper, long)
parentException: IOException 
thrown: EOFException
exception comment: /** 
 * Signals that an end of file or end of stream has been reached unexpectedly during input. <p> This exception is mainly used by data input streams to signal end of stream. Note that many other input operations return a special value on end of stream rather than throwing an exception.
 * @author  Frank Yellin
 * @see java.io.DataInputStream
 * @see java.io.IOException
 * @since   JDK1.0
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4042=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#connectToServer(javax.websocket.Endpoint, javax.websocket.ClientEndpointConfig, java.net.URI)
Rmethod: org.apache.tomcat.websocket.WsWebSocketContainer#processResponse(java.nio.ByteBuffer, org.apache.tomcat.websocket.AsyncChannelWrapper, long)
parentException: 
thrown: TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

block: 
@Override public Session connectToServer(Endpoint endpoint,ClientEndpointConfig clientEndpointConfiguration,URI path) throws DeploymentException {
  boolean secure=false;
  ByteBuffer proxyConnect=null;
  URI proxyPath;
  String scheme=path.getScheme();
  if ("ws".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("http" + path.toString().substring(2));
  }
 else   if ("wss".equalsIgnoreCase(scheme)) {
    proxyPath=URI.create("https" + path.toString().substring(3));
    secure=true;
  }
 else {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathWrongScheme",scheme));
  }
  String host=path.getHost();
  if (host == null) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.pathNoHost"));
  }
  int port=path.getPort();
  SocketAddress sa=null;
  List<Proxy> proxies=ProxySelector.getDefault().select(proxyPath);
  Proxy selectedProxy=null;
  for (  Proxy proxy : proxies) {
    if (proxy.type().equals(Proxy.Type.HTTP)) {
      sa=proxy.address();
      if (sa instanceof InetSocketAddress) {
        InetSocketAddress inet=(InetSocketAddress)sa;
        if (inet.isUnresolved()) {
          sa=new InetSocketAddress(inet.getHostName(),inet.getPort());
        }
      }
      selectedProxy=proxy;
      break;
    }
  }
  if (sa == null) {
    if (port == -1) {
      if ("ws".equalsIgnoreCase(scheme)) {
        sa=new InetSocketAddress(host,80);
      }
 else {
        sa=new InetSocketAddress(host,443);
      }
    }
 else {
      sa=new InetSocketAddress(host,port);
    }
  }
 else {
    proxyConnect=createProxyRequest(host,port);
  }
  Map<String,List<String>> reqHeaders=createRequestHeaders(host,port,clientEndpointConfiguration.getPreferredSubprotocols(),clientEndpointConfiguration.getExtensions());
  clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);
  if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {
    List<String> originValues=new ArrayList<String>(1);
    originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);
    reqHeaders.put(Constants.ORIGIN_HEADER_NAME,originValues);
  }
  ByteBuffer request=createRequest(path,reqHeaders);
  AsynchronousSocketChannel socketChannel;
  try {
    socketChannel=AsynchronousSocketChannel.open(getAsynchronousChannelGroup());
  }
 catch (  IOException ioe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.asynchronousSocketChannelFail"),ioe);
  }
  long timeout=IO_TIMEOUT_MS_DEFAULT;
  String timeoutValue=(String)clientEndpointConfiguration.getUserProperties().get(IO_TIMEOUT_MS_PROPERTY);
  if (timeoutValue != null) {
    timeout=Long.valueOf(timeoutValue).intValue();
  }
  ByteBuffer response=ByteBuffer.allocate(maxBinaryMessageBufferSize);
  String subProtocol;
  boolean success=false;
  List<Extension> extensionsAgreed=new ArrayList<Extension>();
  Transformation transformation=null;
  Future<Void> fConnect=socketChannel.connect(sa);
  AsyncChannelWrapper channel=null;
  if (proxyConnect != null) {
    try {
      fConnect.get(timeout,TimeUnit.MILLISECONDS);
      channel=new AsyncChannelWrapperNonSecure(socketChannel);
      writeRequest(channel,proxyConnect,timeout);
      HttpResponse httpResponse=processResponse(response,channel,timeout);
      if (httpResponse.getStatus() != 200) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.proxyConnectFail",selectedProxy,Integer.toString(httpResponse.getStatus())));
      }
    }
 catch (    Exception e) {
      if (channel != null) {
        channel.close();
      }
      throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
    }
  }
  if (secure) {
    SSLEngine sslEngine=createSSLEngine(clientEndpointConfiguration.getUserProperties());
    channel=new AsyncChannelWrapperSecure(socketChannel,sslEngine);
  }
 else   if (channel == null) {
    channel=new AsyncChannelWrapperNonSecure(socketChannel);
  }
  try {
    fConnect.get(timeout,TimeUnit.MILLISECONDS);
    Future<Void> fHandshake=channel.handshake();
    fHandshake.get(timeout,TimeUnit.MILLISECONDS);
    writeRequest(channel,request,timeout);
    HttpResponse httpResponse=processResponse(response,channel,timeout);
    if (httpResponse.status != 101) {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",Integer.toString(httpResponse.status)));
    }
    HandshakeResponse handshakeResponse=httpResponse.getHandshakeResponse();
    clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);
    List<String> protocolHeaders=handshakeResponse.getHeaders().get(Constants.WS_PROTOCOL_HEADER_NAME);
    if (protocolHeaders == null || protocolHeaders.size() == 0) {
      subProtocol=null;
    }
 else     if (protocolHeaders.size() == 1) {
      subProtocol=protocolHeaders.get(0);
    }
 else {
      throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidSubProtocol"));
    }
    List<String> extHeaders=handshakeResponse.getHeaders().get(Constants.WS_EXTENSIONS_HEADER_NAME);
    if (extHeaders != null) {
      for (      String extHeader : extHeaders) {
        Util.parseExtensionHeader(extensionsAgreed,extHeader);
      }
    }
    TransformationFactory factory=TransformationFactory.getInstance();
    for (    Extension extension : extensionsAgreed) {
      List<List<Extension.Parameter>> wrapper=new ArrayList<List<Extension.Parameter>>(1);
      wrapper.add(extension.getParameters());
      Transformation t=factory.create(extension.getName(),wrapper,false);
      if (t == null) {
        throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidExtensionParameters"));
      }
      if (transformation == null) {
        transformation=t;
      }
 else {
        transformation.setNext(t);
      }
    }
    success=true;
  }
 catch (  ExecutionException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  InterruptedException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  SSLException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  EOFException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
catch (  TimeoutException e) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.httpRequestFailed"),e);
  }
 finally {
    if (!success) {
      channel.close();
    }
  }
  WsRemoteEndpointImplClient wsRemoteEndpointClient=new WsRemoteEndpointImplClient(channel);
  WsSession wsSession=new WsSession(endpoint,wsRemoteEndpointClient,this,null,null,null,null,null,extensionsAgreed,subProtocol,Collections.<String,String>emptyMap(),secure,clientEndpointConfiguration);
  WsFrameClient wsFrameClient=new WsFrameClient(response,channel,wsSession,transformation);
  wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());
  endpoint.onOpen(wsSession,clientEndpointConfiguration);
  registerSession(endpoint,wsSession);
  wsFrameClient.startInputProcessing();
  return wsSession;
}

ID 4054=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#parseStatus(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
private int parseStatus(String line) throws DeploymentException {
  String[] parts=line.trim().split(" ");
  if (parts.length < 2 || !("HTTP/1.0".equals(parts[0]) || "HTTP/1.1".equals(parts[0]))) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",line));
  }
  try {
    return Integer.parseInt(parts[1]);
  }
 catch (  NumberFormatException nfe) {
    throw new DeploymentException(sm.getString("wsWebSocketContainer.invalidStatus",line));
  }
}

ID 4065=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsWebSocketContainer#destroy()
Rmethod: org.apache.tomcat.websocket.WsSession#close(javax.websocket.CloseReason)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Cleans up the resources still in use by WebSocket sessions created from this container. This includes closing sessions and cancelling {@link Future}s associated with blocking read/writes.
 */
public void destroy(){
  CloseReason cr=new CloseReason(CloseCodes.GOING_AWAY,sm.getString("wsWebSocketContainer.shutdown"));
  for (  WsSession session : sessions.keySet()) {
    try {
      session.close(cr);
    }
 catch (    IOException ioe) {
      log.debug(sm.getString("wsWebSocketContainer.sessionCloseFail",session.getId()),ioe);
    }
  }
  if (asynchronousChannelGroup != null) {
synchronized (asynchronousChannelGroupLock) {
      if (asynchronousChannelGroup != null) {
        AsyncChannelGroupUtil.unregister();
        asynchronousChannelGroup=null;
      }
    }
  }
}

ID 4068=========================================================================type: 1
Method:org.apache.tomcat.websocket.PerMessageDeflate#getMoreData(byte, boolean, int, java.nio.ByteBuffer)
Rmethod: java.util.zip.Inflater#inflate(byte[], int, int)
parentException: 
thrown: DataFormatException
exception comment: /** 
 * Signals that a data format error has occurred.
 * @author      David Connelly
 */

block: 
@Override public TransformationResult getMoreData(byte opCode,boolean fin,int rsv,ByteBuffer dest) throws IOException {
  if (Util.isControl(opCode)) {
    return next.getMoreData(opCode,fin,rsv,dest);
  }
  if (!Util.isContinuation(opCode)) {
    skipDecompression=(rsv & RSV_BITMASK) == 0;
  }
  if (skipDecompression) {
    return next.getMoreData(opCode,fin,rsv,dest);
  }
  int written;
  boolean usedEomBytes=false;
  while (dest.remaining() > 0) {
    try {
      written=inflater.inflate(dest.array(),dest.arrayOffset() + dest.position(),dest.remaining());
    }
 catch (    DataFormatException e) {
      throw new IOException(sm.getString("perMessageDeflate.deflateFailed"),e);
    }
    dest.position(dest.position() + written);
    if (inflater.needsInput() && !usedEomBytes) {
      if (dest.hasRemaining()) {
        readBuffer.clear();
        TransformationResult nextResult=next.getMoreData(opCode,fin,(rsv ^ RSV_BITMASK),readBuffer);
        inflater.setInput(readBuffer.array(),readBuffer.arrayOffset(),readBuffer.position());
        if (TransformationResult.UNDERFLOW.equals(nextResult)) {
          return nextResult;
        }
 else         if (TransformationResult.END_OF_FRAME.equals(nextResult) && readBuffer.position() == 0) {
          if (fin) {
            inflater.setInput(EOM_BYTES);
            usedEomBytes=true;
          }
 else {
            return TransformationResult.END_OF_FRAME;
          }
        }
      }
    }
 else     if (written == 0) {
      if (fin && (isServer && !clientContextTakeover || !isServer && !serverContextTakeover)) {
        inflater.reset();
      }
      return TransformationResult.END_OF_FRAME;
    }
  }
  return TransformationResult.OVERFLOW;
}

ID 4075=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsSession#doClose(javax.websocket.CloseReason, javax.websocket.CloseReason)
Rmethod: org.apache.tomcat.websocket.WsRemoteEndpointImplBase#setBatchingAllowed(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * WebSocket 1.0. Section 2.1.5. Need internal close method as spec requires that the local endpoint receives a 1006 on timeout.
 */
public void doClose(CloseReason closeReasonMessage,CloseReason closeReasonLocal){
  if (state != State.OPEN) {
    return;
  }
synchronized (stateLock) {
    if (state != State.OPEN) {
      return;
    }
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("wsSession.doClose",id));
    }
    try {
      wsRemoteEndpoint.setBatchingAllowed(false);
    }
 catch (    IOException e) {
      log.warn(sm.getString("wsSession.flushFailOnClose"),e);
      fireEndpointOnError(e);
    }
    state=State.OUTPUT_CLOSED;
    sendCloseMessage(closeReasonMessage);
    fireEndpointOnClose(closeReasonLocal);
  }
  IOException ioe=new IOException(sm.getString("wsSession.messageFailed"));
  SendResult sr=new SendResult(ioe);
  for (  FutureToSendHandler f2sh : futures.keySet()) {
    f2sh.onResult(sr);
  }
}

ID 4076=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsSession#onClose(javax.websocket.CloseReason)
Rmethod: org.apache.tomcat.websocket.WsRemoteEndpointImplBase#setBatchingAllowed(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Called when a close message is received. Should only ever happen once. Also called after a protocol error when the ProtocolHandler needs to force the closing of the connection.
 */
public void onClose(CloseReason closeReason){
synchronized (stateLock) {
    if (state != State.CLOSED) {
      try {
        wsRemoteEndpoint.setBatchingAllowed(false);
      }
 catch (      IOException e) {
        log.warn(sm.getString("wsSession.flushFailOnClose"),e);
        fireEndpointOnError(e);
      }
      if (state == State.OPEN) {
        state=State.OUTPUT_CLOSED;
        sendCloseMessage(closeReason);
        fireEndpointOnClose(closeReason);
      }
      state=State.CLOSED;
      wsRemoteEndpoint.close();
    }
  }
}

ID 4079=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsSession#sendCloseMessage(javax.websocket.CloseReason)
Rmethod: org.apache.tomcat.websocket.WsRemoteEndpointImplBase#startMessageBlock(byte, java.nio.ByteBuffer, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void sendCloseMessage(CloseReason closeReason){
  ByteBuffer msg=ByteBuffer.allocate(125);
  CloseCode closeCode=closeReason.getCloseCode();
  if (closeCode == CloseCodes.CLOSED_ABNORMALLY) {
    msg.putShort((short)CloseCodes.PROTOCOL_ERROR.getCode());
  }
 else {
    msg.putShort((short)closeCode.getCode());
  }
  String reason=closeReason.getReasonPhrase();
  if (reason != null && reason.length() > 0) {
    appendCloseReasonWithTruncation(msg,reason);
  }
  msg.flip();
  try {
    wsRemoteEndpoint.startMessageBlock(Constants.OPCODE_CLOSE,msg,true);
  }
 catch (  IOException ioe) {
    handleCloseException(ioe,closeCode);
  }
catch (  WritePendingException wpe) {
    handleCloseException(wpe,closeCode);
  }
 finally {
    webSocketContainer.unregisterSession(localEndpoint,this);
  }
}

ID 4080=========================================================================type: 1
Method:org.apache.tomcat.websocket.AsyncChannelWrapperSecure#close()
Rmethod: java.nio.channels.AsynchronousChannel#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void close(){
  try {
    socketChannel.close();
  }
 catch (  IOException e) {
    log.info(sm.getString("asyncChannelWrapperSecure.closeFail"));
  }
  executor.shutdownNow();
}

ID 4087=========================================================================type: 1
Method:org.apache.tomcat.websocket.WebSocketSslHandshakeThread#run()
Rmethod: javax.net.ssl.SSLEngine#beginHandshake()
parentException: IOException 
thrown: SSLException
exception comment: null
block: 
@Override public void run(){
  try {
    sslEngine.beginHandshake();
    socketReadBuffer.position(socketReadBuffer.limit());
    handshakeStatus=sslEngine.getHandshakeStatus();
    resultStatus=Status.OK;
    boolean handshaking=true;
    while (handshaking) {
switch (handshakeStatus) {
case NEED_WRAP:
{
          socketWriteBuffer.clear();
          SSLEngineResult r=sslEngine.wrap(DUMMY,socketWriteBuffer);
          checkResult(r,true);
          socketWriteBuffer.flip();
          Future<Integer> fWrite=socketChannel.write(socketWriteBuffer);
          fWrite.get();
          break;
        }
case NEED_UNWRAP:
{
        socketReadBuffer.compact();
        if (socketReadBuffer.position() == 0 || resultStatus == Status.BUFFER_UNDERFLOW) {
          Future<Integer> fRead=socketChannel.read(socketReadBuffer);
          fRead.get();
        }
        socketReadBuffer.flip();
        SSLEngineResult r=sslEngine.unwrap(socketReadBuffer,DUMMY);
        checkResult(r,false);
        break;
      }
case NEED_TASK:
{
      Runnable r=null;
      while ((r=sslEngine.getDelegatedTask()) != null) {
        r.run();
      }
      handshakeStatus=sslEngine.getHandshakeStatus();
      break;
    }
case FINISHED:
{
    handshaking=false;
    break;
  }
default :
{
  throw new SSLException("TODO");
}
}
}
}
 catch (SSLException e) {
hFuture.fail(e);
}
catch (InterruptedException e) {
hFuture.fail(e);
}
catch (ExecutionException e) {
hFuture.fail(e);
}
hFuture.complete(null);
}

ID 4088=========================================================================type: 1
Method:org.apache.tomcat.websocket.WebSocketSslHandshakeThread#run()
Rmethod: javax.net.ssl.SSLEngine#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)
parentException: IOException 
thrown: SSLException
exception comment: null
block: 
@Override public void run(){
  try {
    sslEngine.beginHandshake();
    socketReadBuffer.position(socketReadBuffer.limit());
    handshakeStatus=sslEngine.getHandshakeStatus();
    resultStatus=Status.OK;
    boolean handshaking=true;
    while (handshaking) {
switch (handshakeStatus) {
case NEED_WRAP:
{
          socketWriteBuffer.clear();
          SSLEngineResult r=sslEngine.wrap(DUMMY,socketWriteBuffer);
          checkResult(r,true);
          socketWriteBuffer.flip();
          Future<Integer> fWrite=socketChannel.write(socketWriteBuffer);
          fWrite.get();
          break;
        }
case NEED_UNWRAP:
{
        socketReadBuffer.compact();
        if (socketReadBuffer.position() == 0 || resultStatus == Status.BUFFER_UNDERFLOW) {
          Future<Integer> fRead=socketChannel.read(socketReadBuffer);
          fRead.get();
        }
        socketReadBuffer.flip();
        SSLEngineResult r=sslEngine.unwrap(socketReadBuffer,DUMMY);
        checkResult(r,false);
        break;
      }
case NEED_TASK:
{
      Runnable r=null;
      while ((r=sslEngine.getDelegatedTask()) != null) {
        r.run();
      }
      handshakeStatus=sslEngine.getHandshakeStatus();
      break;
    }
case FINISHED:
{
    handshaking=false;
    break;
  }
default :
{
  throw new SSLException("TODO");
}
}
}
}
 catch (SSLException e) {
hFuture.fail(e);
}
catch (InterruptedException e) {
hFuture.fail(e);
}
catch (ExecutionException e) {
hFuture.fail(e);
}
hFuture.complete(null);
}

ID 4089=========================================================================type: 1
Method:org.apache.tomcat.websocket.WebSocketSslHandshakeThread#run()
Rmethod: org.apache.tomcat.websocket.WebSocketSslHandshakeThread#checkResult(javax.net.ssl.SSLEngineResult, boolean)
parentException: IOException 
thrown: SSLException
exception comment: null
block: 
@Override public void run(){
  try {
    sslEngine.beginHandshake();
    socketReadBuffer.position(socketReadBuffer.limit());
    handshakeStatus=sslEngine.getHandshakeStatus();
    resultStatus=Status.OK;
    boolean handshaking=true;
    while (handshaking) {
switch (handshakeStatus) {
case NEED_WRAP:
{
          socketWriteBuffer.clear();
          SSLEngineResult r=sslEngine.wrap(DUMMY,socketWriteBuffer);
          checkResult(r,true);
          socketWriteBuffer.flip();
          Future<Integer> fWrite=socketChannel.write(socketWriteBuffer);
          fWrite.get();
          break;
        }
case NEED_UNWRAP:
{
        socketReadBuffer.compact();
        if (socketReadBuffer.position() == 0 || resultStatus == Status.BUFFER_UNDERFLOW) {
          Future<Integer> fRead=socketChannel.read(socketReadBuffer);
          fRead.get();
        }
        socketReadBuffer.flip();
        SSLEngineResult r=sslEngine.unwrap(socketReadBuffer,DUMMY);
        checkResult(r,false);
        break;
      }
case NEED_TASK:
{
      Runnable r=null;
      while ((r=sslEngine.getDelegatedTask()) != null) {
        r.run();
      }
      handshakeStatus=sslEngine.getHandshakeStatus();
      break;
    }
case FINISHED:
{
    handshaking=false;
    break;
  }
default :
{
  throw new SSLException("TODO");
}
}
}
}
 catch (SSLException e) {
hFuture.fail(e);
}
catch (InterruptedException e) {
hFuture.fail(e);
}
catch (ExecutionException e) {
hFuture.fail(e);
}
hFuture.complete(null);
}

ID 4090=========================================================================type: 1
Method:org.apache.tomcat.websocket.WebSocketSslHandshakeThread#run()
Rmethod: java.util.concurrent.Future#get()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  try {
    sslEngine.beginHandshake();
    socketReadBuffer.position(socketReadBuffer.limit());
    handshakeStatus=sslEngine.getHandshakeStatus();
    resultStatus=Status.OK;
    boolean handshaking=true;
    while (handshaking) {
switch (handshakeStatus) {
case NEED_WRAP:
{
          socketWriteBuffer.clear();
          SSLEngineResult r=sslEngine.wrap(DUMMY,socketWriteBuffer);
          checkResult(r,true);
          socketWriteBuffer.flip();
          Future<Integer> fWrite=socketChannel.write(socketWriteBuffer);
          fWrite.get();
          break;
        }
case NEED_UNWRAP:
{
        socketReadBuffer.compact();
        if (socketReadBuffer.position() == 0 || resultStatus == Status.BUFFER_UNDERFLOW) {
          Future<Integer> fRead=socketChannel.read(socketReadBuffer);
          fRead.get();
        }
        socketReadBuffer.flip();
        SSLEngineResult r=sslEngine.unwrap(socketReadBuffer,DUMMY);
        checkResult(r,false);
        break;
      }
case NEED_TASK:
{
      Runnable r=null;
      while ((r=sslEngine.getDelegatedTask()) != null) {
        r.run();
      }
      handshakeStatus=sslEngine.getHandshakeStatus();
      break;
    }
case FINISHED:
{
    handshaking=false;
    break;
  }
default :
{
  throw new SSLException("TODO");
}
}
}
}
 catch (SSLException e) {
hFuture.fail(e);
}
catch (InterruptedException e) {
hFuture.fail(e);
}
catch (ExecutionException e) {
hFuture.fail(e);
}
hFuture.complete(null);
}

ID 4091=========================================================================type: 1
Method:org.apache.tomcat.websocket.WebSocketSslHandshakeThread#run()
Rmethod: java.util.concurrent.Future#get()
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
@Override public void run(){
  try {
    sslEngine.beginHandshake();
    socketReadBuffer.position(socketReadBuffer.limit());
    handshakeStatus=sslEngine.getHandshakeStatus();
    resultStatus=Status.OK;
    boolean handshaking=true;
    while (handshaking) {
switch (handshakeStatus) {
case NEED_WRAP:
{
          socketWriteBuffer.clear();
          SSLEngineResult r=sslEngine.wrap(DUMMY,socketWriteBuffer);
          checkResult(r,true);
          socketWriteBuffer.flip();
          Future<Integer> fWrite=socketChannel.write(socketWriteBuffer);
          fWrite.get();
          break;
        }
case NEED_UNWRAP:
{
        socketReadBuffer.compact();
        if (socketReadBuffer.position() == 0 || resultStatus == Status.BUFFER_UNDERFLOW) {
          Future<Integer> fRead=socketChannel.read(socketReadBuffer);
          fRead.get();
        }
        socketReadBuffer.flip();
        SSLEngineResult r=sslEngine.unwrap(socketReadBuffer,DUMMY);
        checkResult(r,false);
        break;
      }
case NEED_TASK:
{
      Runnable r=null;
      while ((r=sslEngine.getDelegatedTask()) != null) {
        r.run();
      }
      handshakeStatus=sslEngine.getHandshakeStatus();
      break;
    }
case FINISHED:
{
    handshaking=false;
    break;
  }
default :
{
  throw new SSLException("TODO");
}
}
}
}
 catch (SSLException e) {
hFuture.fail(e);
}
catch (InterruptedException e) {
hFuture.fail(e);
}
catch (ExecutionException e) {
hFuture.fail(e);
}
hFuture.complete(null);
}

ID 4092=========================================================================type: 1
Method:org.apache.tomcat.websocket.WebSocketSslHandshakeThread#run()
Rmethod: javax.net.ssl.SSLEngine#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)
parentException: IOException 
thrown: SSLException
exception comment: null
block: 
@Override public void run(){
  try {
    sslEngine.beginHandshake();
    socketReadBuffer.position(socketReadBuffer.limit());
    handshakeStatus=sslEngine.getHandshakeStatus();
    resultStatus=Status.OK;
    boolean handshaking=true;
    while (handshaking) {
switch (handshakeStatus) {
case NEED_WRAP:
{
          socketWriteBuffer.clear();
          SSLEngineResult r=sslEngine.wrap(DUMMY,socketWriteBuffer);
          checkResult(r,true);
          socketWriteBuffer.flip();
          Future<Integer> fWrite=socketChannel.write(socketWriteBuffer);
          fWrite.get();
          break;
        }
case NEED_UNWRAP:
{
        socketReadBuffer.compact();
        if (socketReadBuffer.position() == 0 || resultStatus == Status.BUFFER_UNDERFLOW) {
          Future<Integer> fRead=socketChannel.read(socketReadBuffer);
          fRead.get();
        }
        socketReadBuffer.flip();
        SSLEngineResult r=sslEngine.unwrap(socketReadBuffer,DUMMY);
        checkResult(r,false);
        break;
      }
case NEED_TASK:
{
      Runnable r=null;
      while ((r=sslEngine.getDelegatedTask()) != null) {
        r.run();
      }
      handshakeStatus=sslEngine.getHandshakeStatus();
      break;
    }
case FINISHED:
{
    handshaking=false;
    break;
  }
default :
{
  throw new SSLException("TODO");
}
}
}
}
 catch (SSLException e) {
hFuture.fail(e);
}
catch (InterruptedException e) {
hFuture.fail(e);
}
catch (ExecutionException e) {
hFuture.fail(e);
}
hFuture.complete(null);
}

ID 4100=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsHandshakeRequest#WsHandshakeRequest(javax.servlet.http.HttpServletRequest, Map<java.lang.String,java.lang.String>)
Rmethod: java.net.URI#URI(java.lang.String)
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
public WsHandshakeRequest(HttpServletRequest request,Map<String,String> pathParams){
  this.request=request;
  queryString=request.getQueryString();
  userPrincipal=request.getUserPrincipal();
  httpSession=request.getSession(false);
  StringBuilder sb=new StringBuilder(request.getRequestURI());
  if (queryString != null) {
    sb.append("?");
    sb.append(queryString);
  }
  try {
    requestUri=new URI(sb.toString());
  }
 catch (  URISyntaxException e) {
    throw new IllegalArgumentException(e);
  }
  Map<String,String[]> originalParameters=request.getParameterMap();
  Map<String,List<String>> newParameters=new HashMap<String,List<String>>(originalParameters.size());
  for (  Entry<String,String[]> entry : originalParameters.entrySet()) {
    newParameters.put(entry.getKey(),Collections.unmodifiableList(Arrays.asList(entry.getValue())));
  }
  for (  Entry<String,String> entry : pathParams.entrySet()) {
    newParameters.put(entry.getKey(),Collections.unmodifiableList(Arrays.asList(entry.getValue())));
  }
  parameterMap=Collections.unmodifiableMap(newParameters);
  Map<String,List<String>> newHeaders=new CaseInsensitiveKeyMap<List<String>>();
  Enumeration<String> headerNames=request.getHeaderNames();
  while (headerNames.hasMoreElements()) {
    String headerName=headerNames.nextElement();
    newHeaders.put(headerName,Collections.unmodifiableList(Collections.list(request.getHeaders(headerName))));
  }
  headers=Collections.unmodifiableMap(newHeaders);
}

ID 4101=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsSci#onStartup(Set<Class<?>>, javax.servlet.ServletContext)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public void onStartup(Set<Class<?>> clazzes,ServletContext ctx) throws ServletException {
  if (!isJava7OrLater()) {
    if (!logMessageWritten) {
      logMessageWritten=true;
      log.info(sm.getString("sci.noWebSocketSupport"));
    }
    return;
  }
  WsServerContainer sc=init(ctx,true);
  if (clazzes == null || clazzes.size() == 0) {
    return;
  }
  Set<ServerApplicationConfig> serverApplicationConfigs=new HashSet<ServerApplicationConfig>();
  Set<Class<? extends Endpoint>> scannedEndpointClazzes=new HashSet<Class<? extends Endpoint>>();
  Set<Class<?>> scannedPojoEndpoints=new HashSet<Class<?>>();
  try {
    String wsPackage=ContainerProvider.class.getName();
    wsPackage=wsPackage.substring(0,wsPackage.lastIndexOf('.') + 1);
    for (    Class<?> clazz : clazzes) {
      int modifiers=clazz.getModifiers();
      if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers)) {
        continue;
      }
      if (clazz.getName().startsWith(wsPackage)) {
        continue;
      }
      if (ServerApplicationConfig.class.isAssignableFrom(clazz)) {
        serverApplicationConfigs.add((ServerApplicationConfig)clazz.newInstance());
      }
      if (Endpoint.class.isAssignableFrom(clazz)) {
        @SuppressWarnings("unchecked") Class<? extends Endpoint> endpoint=(Class<? extends Endpoint>)clazz;
        scannedEndpointClazzes.add(endpoint);
      }
      if (clazz.isAnnotationPresent(ServerEndpoint.class)) {
        scannedPojoEndpoints.add(clazz);
      }
    }
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
  Set<ServerEndpointConfig> filteredEndpointConfigs=new HashSet<ServerEndpointConfig>();
  Set<Class<?>> filteredPojoEndpoints=new HashSet<Class<?>>();
  if (serverApplicationConfigs.isEmpty()) {
    filteredPojoEndpoints.addAll(scannedPojoEndpoints);
  }
 else {
    for (    ServerApplicationConfig config : serverApplicationConfigs) {
      Set<ServerEndpointConfig> configFilteredEndpoints=config.getEndpointConfigs(scannedEndpointClazzes);
      if (configFilteredEndpoints != null) {
        filteredEndpointConfigs.addAll(configFilteredEndpoints);
      }
      Set<Class<?>> configFilteredPojos=config.getAnnotatedEndpointClasses(scannedPojoEndpoints);
      if (configFilteredPojos != null) {
        filteredPojoEndpoints.addAll(configFilteredPojos);
      }
    }
  }
  try {
    for (    ServerEndpointConfig config : filteredEndpointConfigs) {
      sc.addEndpoint(config);
    }
    for (    Class<?> clazz : filteredPojoEndpoints) {
      sc.addEndpoint(clazz);
    }
  }
 catch (  DeploymentException e) {
    throw new ServletException(e);
  }
}

ID 4102=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsSci#onStartup(Set<Class<?>>, javax.servlet.ServletContext)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public void onStartup(Set<Class<?>> clazzes,ServletContext ctx) throws ServletException {
  if (!isJava7OrLater()) {
    if (!logMessageWritten) {
      logMessageWritten=true;
      log.info(sm.getString("sci.noWebSocketSupport"));
    }
    return;
  }
  WsServerContainer sc=init(ctx,true);
  if (clazzes == null || clazzes.size() == 0) {
    return;
  }
  Set<ServerApplicationConfig> serverApplicationConfigs=new HashSet<ServerApplicationConfig>();
  Set<Class<? extends Endpoint>> scannedEndpointClazzes=new HashSet<Class<? extends Endpoint>>();
  Set<Class<?>> scannedPojoEndpoints=new HashSet<Class<?>>();
  try {
    String wsPackage=ContainerProvider.class.getName();
    wsPackage=wsPackage.substring(0,wsPackage.lastIndexOf('.') + 1);
    for (    Class<?> clazz : clazzes) {
      int modifiers=clazz.getModifiers();
      if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers)) {
        continue;
      }
      if (clazz.getName().startsWith(wsPackage)) {
        continue;
      }
      if (ServerApplicationConfig.class.isAssignableFrom(clazz)) {
        serverApplicationConfigs.add((ServerApplicationConfig)clazz.newInstance());
      }
      if (Endpoint.class.isAssignableFrom(clazz)) {
        @SuppressWarnings("unchecked") Class<? extends Endpoint> endpoint=(Class<? extends Endpoint>)clazz;
        scannedEndpointClazzes.add(endpoint);
      }
      if (clazz.isAnnotationPresent(ServerEndpoint.class)) {
        scannedPojoEndpoints.add(clazz);
      }
    }
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
  Set<ServerEndpointConfig> filteredEndpointConfigs=new HashSet<ServerEndpointConfig>();
  Set<Class<?>> filteredPojoEndpoints=new HashSet<Class<?>>();
  if (serverApplicationConfigs.isEmpty()) {
    filteredPojoEndpoints.addAll(scannedPojoEndpoints);
  }
 else {
    for (    ServerApplicationConfig config : serverApplicationConfigs) {
      Set<ServerEndpointConfig> configFilteredEndpoints=config.getEndpointConfigs(scannedEndpointClazzes);
      if (configFilteredEndpoints != null) {
        filteredEndpointConfigs.addAll(configFilteredEndpoints);
      }
      Set<Class<?>> configFilteredPojos=config.getAnnotatedEndpointClasses(scannedPojoEndpoints);
      if (configFilteredPojos != null) {
        filteredPojoEndpoints.addAll(configFilteredPojos);
      }
    }
  }
  try {
    for (    ServerEndpointConfig config : filteredEndpointConfigs) {
      sc.addEndpoint(config);
    }
    for (    Class<?> clazz : filteredPojoEndpoints) {
      sc.addEndpoint(clazz);
    }
  }
 catch (  DeploymentException e) {
    throw new ServletException(e);
  }
}

ID 4103=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsSci#onStartup(Set<Class<?>>, javax.servlet.ServletContext)
Rmethod: org.apache.tomcat.websocket.server.WsServerContainer#addEndpoint(javax.websocket.server.ServerEndpointConfig)
parentException: 
thrown: DeploymentException
exception comment: null
block: 
@Override public void onStartup(Set<Class<?>> clazzes,ServletContext ctx) throws ServletException {
  if (!isJava7OrLater()) {
    if (!logMessageWritten) {
      logMessageWritten=true;
      log.info(sm.getString("sci.noWebSocketSupport"));
    }
    return;
  }
  WsServerContainer sc=init(ctx,true);
  if (clazzes == null || clazzes.size() == 0) {
    return;
  }
  Set<ServerApplicationConfig> serverApplicationConfigs=new HashSet<ServerApplicationConfig>();
  Set<Class<? extends Endpoint>> scannedEndpointClazzes=new HashSet<Class<? extends Endpoint>>();
  Set<Class<?>> scannedPojoEndpoints=new HashSet<Class<?>>();
  try {
    String wsPackage=ContainerProvider.class.getName();
    wsPackage=wsPackage.substring(0,wsPackage.lastIndexOf('.') + 1);
    for (    Class<?> clazz : clazzes) {
      int modifiers=clazz.getModifiers();
      if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers)) {
        continue;
      }
      if (clazz.getName().startsWith(wsPackage)) {
        continue;
      }
      if (ServerApplicationConfig.class.isAssignableFrom(clazz)) {
        serverApplicationConfigs.add((ServerApplicationConfig)clazz.newInstance());
      }
      if (Endpoint.class.isAssignableFrom(clazz)) {
        @SuppressWarnings("unchecked") Class<? extends Endpoint> endpoint=(Class<? extends Endpoint>)clazz;
        scannedEndpointClazzes.add(endpoint);
      }
      if (clazz.isAnnotationPresent(ServerEndpoint.class)) {
        scannedPojoEndpoints.add(clazz);
      }
    }
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
  Set<ServerEndpointConfig> filteredEndpointConfigs=new HashSet<ServerEndpointConfig>();
  Set<Class<?>> filteredPojoEndpoints=new HashSet<Class<?>>();
  if (serverApplicationConfigs.isEmpty()) {
    filteredPojoEndpoints.addAll(scannedPojoEndpoints);
  }
 else {
    for (    ServerApplicationConfig config : serverApplicationConfigs) {
      Set<ServerEndpointConfig> configFilteredEndpoints=config.getEndpointConfigs(scannedEndpointClazzes);
      if (configFilteredEndpoints != null) {
        filteredEndpointConfigs.addAll(configFilteredEndpoints);
      }
      Set<Class<?>> configFilteredPojos=config.getAnnotatedEndpointClasses(scannedPojoEndpoints);
      if (configFilteredPojos != null) {
        filteredPojoEndpoints.addAll(configFilteredPojos);
      }
    }
  }
  try {
    for (    ServerEndpointConfig config : filteredEndpointConfigs) {
      sc.addEndpoint(config);
    }
    for (    Class<?> clazz : filteredPojoEndpoints) {
      sc.addEndpoint(clazz);
    }
  }
 catch (  DeploymentException e) {
    throw new ServletException(e);
  }
}

ID 4104=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsSci#onStartup(Set<Class<?>>, javax.servlet.ServletContext)
Rmethod: org.apache.tomcat.websocket.server.WsServerContainer#addEndpoint(Class<?>)
parentException: 
thrown: DeploymentException
exception comment: null
block: 
@Override public void onStartup(Set<Class<?>> clazzes,ServletContext ctx) throws ServletException {
  if (!isJava7OrLater()) {
    if (!logMessageWritten) {
      logMessageWritten=true;
      log.info(sm.getString("sci.noWebSocketSupport"));
    }
    return;
  }
  WsServerContainer sc=init(ctx,true);
  if (clazzes == null || clazzes.size() == 0) {
    return;
  }
  Set<ServerApplicationConfig> serverApplicationConfigs=new HashSet<ServerApplicationConfig>();
  Set<Class<? extends Endpoint>> scannedEndpointClazzes=new HashSet<Class<? extends Endpoint>>();
  Set<Class<?>> scannedPojoEndpoints=new HashSet<Class<?>>();
  try {
    String wsPackage=ContainerProvider.class.getName();
    wsPackage=wsPackage.substring(0,wsPackage.lastIndexOf('.') + 1);
    for (    Class<?> clazz : clazzes) {
      int modifiers=clazz.getModifiers();
      if (!Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers)) {
        continue;
      }
      if (clazz.getName().startsWith(wsPackage)) {
        continue;
      }
      if (ServerApplicationConfig.class.isAssignableFrom(clazz)) {
        serverApplicationConfigs.add((ServerApplicationConfig)clazz.newInstance());
      }
      if (Endpoint.class.isAssignableFrom(clazz)) {
        @SuppressWarnings("unchecked") Class<? extends Endpoint> endpoint=(Class<? extends Endpoint>)clazz;
        scannedEndpointClazzes.add(endpoint);
      }
      if (clazz.isAnnotationPresent(ServerEndpoint.class)) {
        scannedPojoEndpoints.add(clazz);
      }
    }
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
catch (  IllegalAccessException e) {
    throw new ServletException(e);
  }
  Set<ServerEndpointConfig> filteredEndpointConfigs=new HashSet<ServerEndpointConfig>();
  Set<Class<?>> filteredPojoEndpoints=new HashSet<Class<?>>();
  if (serverApplicationConfigs.isEmpty()) {
    filteredPojoEndpoints.addAll(scannedPojoEndpoints);
  }
 else {
    for (    ServerApplicationConfig config : serverApplicationConfigs) {
      Set<ServerEndpointConfig> configFilteredEndpoints=config.getEndpointConfigs(scannedEndpointClazzes);
      if (configFilteredEndpoints != null) {
        filteredEndpointConfigs.addAll(configFilteredEndpoints);
      }
      Set<Class<?>> configFilteredPojos=config.getAnnotatedEndpointClasses(scannedPojoEndpoints);
      if (configFilteredPojos != null) {
        filteredPojoEndpoints.addAll(configFilteredPojos);
      }
    }
  }
  try {
    for (    ServerEndpointConfig config : filteredEndpointConfigs) {
      sc.addEndpoint(config);
    }
    for (    Class<?> clazz : filteredPojoEndpoints) {
      sc.addEndpoint(clazz);
    }
  }
 catch (  DeploymentException e) {
    throw new ServletException(e);
  }
}

ID 4105=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsSci#isJava7OrLater()
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
private static boolean isJava7OrLater(){
  try {
    Class.forName("java.nio.channels.AsynchronousSocketChannel");
  }
 catch (  ClassNotFoundException e) {
    return false;
  }
  return true;
}

ID 4106=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsHttpUpgradeHandler#init(org.apache.coyote.http11.upgrade.servlet31.WebConnection)
Rmethod: org.apache.coyote.http11.upgrade.servlet31.WebConnection#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void init(WebConnection connection){
  if (ep == null) {
    throw new IllegalStateException(sm.getString("wsHttpUpgradeHandler.noPreInit"));
  }
  this.connection=connection;
  AbstractServletInputStream sis;
  AbstractServletOutputStream sos;
  try {
    sis=connection.getInputStream();
    sos=connection.getOutputStream();
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
  String httpSessionId=null;
  Object session=handshakeRequest.getHttpSession();
  if (session != null) {
    httpSessionId=((HttpSession)session).getId();
  }
  Thread t=Thread.currentThread();
  ClassLoader cl=t.getContextClassLoader();
  t.setContextClassLoader(applicationClassLoader);
  try {
    WsRemoteEndpointImplServer wsRemoteEndpointServer=new WsRemoteEndpointImplServer(sos,webSocketContainer);
    wsSession=new WsSession(ep,wsRemoteEndpointServer,webSocketContainer,handshakeRequest.getRequestURI(),handshakeRequest.getParameterMap(),handshakeRequest.getQueryString(),handshakeRequest.getUserPrincipal(),httpSessionId,negotiatedExtensions,subProtocol,pathParameters,secure,endpointConfig);
    WsFrameServer wsFrame=new WsFrameServer(sis,wsSession,transformation);
    sos.setWriteListener(new WsWriteListener(this,wsRemoteEndpointServer));
    wsRemoteEndpointServer.setTransformation(wsFrame.getTransformation());
    ep.onOpen(wsSession,endpointConfig);
    webSocketContainer.registerSession(ep,wsSession);
    sis.setReadListener(new WsReadListener(this,wsFrame));
  }
 catch (  DeploymentException e) {
    throw new IllegalArgumentException(e);
  }
 finally {
    t.setContextClassLoader(cl);
  }
}

ID 4107=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsHttpUpgradeHandler#init(org.apache.coyote.http11.upgrade.servlet31.WebConnection)
Rmethod: org.apache.coyote.http11.upgrade.servlet31.WebConnection#getOutputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void init(WebConnection connection){
  if (ep == null) {
    throw new IllegalStateException(sm.getString("wsHttpUpgradeHandler.noPreInit"));
  }
  this.connection=connection;
  AbstractServletInputStream sis;
  AbstractServletOutputStream sos;
  try {
    sis=connection.getInputStream();
    sos=connection.getOutputStream();
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
  String httpSessionId=null;
  Object session=handshakeRequest.getHttpSession();
  if (session != null) {
    httpSessionId=((HttpSession)session).getId();
  }
  Thread t=Thread.currentThread();
  ClassLoader cl=t.getContextClassLoader();
  t.setContextClassLoader(applicationClassLoader);
  try {
    WsRemoteEndpointImplServer wsRemoteEndpointServer=new WsRemoteEndpointImplServer(sos,webSocketContainer);
    wsSession=new WsSession(ep,wsRemoteEndpointServer,webSocketContainer,handshakeRequest.getRequestURI(),handshakeRequest.getParameterMap(),handshakeRequest.getQueryString(),handshakeRequest.getUserPrincipal(),httpSessionId,negotiatedExtensions,subProtocol,pathParameters,secure,endpointConfig);
    WsFrameServer wsFrame=new WsFrameServer(sis,wsSession,transformation);
    sos.setWriteListener(new WsWriteListener(this,wsRemoteEndpointServer));
    wsRemoteEndpointServer.setTransformation(wsFrame.getTransformation());
    ep.onOpen(wsSession,endpointConfig);
    webSocketContainer.registerSession(ep,wsSession);
    sis.setReadListener(new WsReadListener(this,wsFrame));
  }
 catch (  DeploymentException e) {
    throw new IllegalArgumentException(e);
  }
 finally {
    t.setContextClassLoader(cl);
  }
}

ID 4108=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsHttpUpgradeHandler#init(org.apache.coyote.http11.upgrade.servlet31.WebConnection)
Rmethod: org.apache.tomcat.websocket.WsSession#WsSession(javax.websocket.Endpoint, org.apache.tomcat.websocket.WsRemoteEndpointImplBase, org.apache.tomcat.websocket.WsWebSocketContainer, java.net.URI, Map<java.lang.String,List<java.lang.String>>, java.lang.String, java.security.Principal, java.lang.String, List<javax.websocket.Extension>, java.lang.String, Map<java.lang.String,java.lang.String>, boolean, javax.websocket.EndpointConfig)
parentException: 
thrown: DeploymentException
exception comment: null
block: 
@Override public void init(WebConnection connection){
  if (ep == null) {
    throw new IllegalStateException(sm.getString("wsHttpUpgradeHandler.noPreInit"));
  }
  this.connection=connection;
  AbstractServletInputStream sis;
  AbstractServletOutputStream sos;
  try {
    sis=connection.getInputStream();
    sos=connection.getOutputStream();
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
  String httpSessionId=null;
  Object session=handshakeRequest.getHttpSession();
  if (session != null) {
    httpSessionId=((HttpSession)session).getId();
  }
  Thread t=Thread.currentThread();
  ClassLoader cl=t.getContextClassLoader();
  t.setContextClassLoader(applicationClassLoader);
  try {
    WsRemoteEndpointImplServer wsRemoteEndpointServer=new WsRemoteEndpointImplServer(sos,webSocketContainer);
    wsSession=new WsSession(ep,wsRemoteEndpointServer,webSocketContainer,handshakeRequest.getRequestURI(),handshakeRequest.getParameterMap(),handshakeRequest.getQueryString(),handshakeRequest.getUserPrincipal(),httpSessionId,negotiatedExtensions,subProtocol,pathParameters,secure,endpointConfig);
    WsFrameServer wsFrame=new WsFrameServer(sis,wsSession,transformation);
    sos.setWriteListener(new WsWriteListener(this,wsRemoteEndpointServer));
    wsRemoteEndpointServer.setTransformation(wsFrame.getTransformation());
    ep.onOpen(wsSession,endpointConfig);
    webSocketContainer.registerSession(ep,wsSession);
    sis.setReadListener(new WsReadListener(this,wsFrame));
  }
 catch (  DeploymentException e) {
    throw new IllegalArgumentException(e);
  }
 finally {
    t.setContextClassLoader(cl);
  }
}

ID 4109=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsHttpUpgradeHandler#destroy()
Rmethod: org.apache.coyote.http11.upgrade.servlet31.WebConnection#close()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void destroy(){
  if (connection != null) {
    try {
      connection.close();
    }
 catch (    Exception e) {
      log.error(sm.getString("wsHttpUpgradeHandler.destroyFailed"),e);
    }
  }
}

ID 4110=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsReadListener#onDataAvailable()
Rmethod: org.apache.tomcat.websocket.server.WsFrameServer#onDataAvailable()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void onDataAvailable(){
  try {
    wsFrame.onDataAvailable();
  }
 catch (  WsIOException ws) {
    wsProtocolHandler.close(ws.getCloseReason());
  }
catch (  IOException ioe) {
    onError(ioe);
    CloseReason cr=new CloseReason(CloseCodes.CLOSED_ABNORMALLY,ioe.getMessage());
    wsProtocolHandler.close(cr);
  }
}

ID 4112=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.DefaultServerEndpointConfigurator#getEndpointInstance(Class<T>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public <T>T getEndpointInstance(Class<T> clazz) throws InstantiationException {
  try {
    return clazz.newInstance();
  }
 catch (  IllegalAccessException e) {
    InstantiationException ie=new InstantiationException();
    ie.initCause(e);
    throw ie;
  }
}

ID 4114=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.UpgradeUtil#doUpgrade(org.apache.tomcat.websocket.server.WsServerContainer, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, javax.websocket.server.ServerEndpointConfig, Map<java.lang.String,java.lang.String>)
Rmethod: javax.websocket.server.Configurator#getEndpointInstance(Class<T>)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
public static void doUpgrade(WsServerContainer sc,HttpServletRequest req,HttpServletResponse resp,ServerEndpointConfig sec,Map<String,String> pathParams) throws ServletException, IOException {
  String key;
  String subProtocol=null;
  if (!headerContainsToken(req,Constants.CONNECTION_HEADER_NAME,Constants.CONNECTION_HEADER_VALUE)) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  if (!headerContainsToken(req,Constants.WS_VERSION_HEADER_NAME,Constants.WS_VERSION_HEADER_VALUE)) {
    resp.setStatus(426);
    resp.setHeader(Constants.WS_VERSION_HEADER_NAME,Constants.WS_VERSION_HEADER_VALUE);
    return;
  }
  key=req.getHeader(Constants.WS_KEY_HEADER_NAME);
  if (key == null) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  String origin=req.getHeader(Constants.ORIGIN_HEADER_NAME);
  if (!sec.getConfigurator().checkOrigin(origin)) {
    resp.sendError(HttpServletResponse.SC_FORBIDDEN);
    return;
  }
  List<String> subProtocols=getTokensFromHeader(req,Constants.WS_PROTOCOL_HEADER_NAME);
  subProtocol=sec.getConfigurator().getNegotiatedSubprotocol(sec.getSubprotocols(),subProtocols);
  List<Extension> extensionsRequested=new ArrayList<Extension>();
  Enumeration<String> extHeaders=req.getHeaders(Constants.WS_EXTENSIONS_HEADER_NAME);
  while (extHeaders.hasMoreElements()) {
    Util.parseExtensionHeader(extensionsRequested,extHeaders.nextElement());
  }
  List<Extension> installedExtensions=null;
  if (sec.getExtensions().size() == 0) {
    installedExtensions=Constants.INSTALLED_EXTENSIONS;
  }
 else {
    installedExtensions=new ArrayList<Extension>();
    installedExtensions.addAll(sec.getExtensions());
    installedExtensions.addAll(Constants.INSTALLED_EXTENSIONS);
  }
  List<Extension> negotiatedExtensionsPhase1=sec.getConfigurator().getNegotiatedExtensions(installedExtensions,extensionsRequested);
  List<Transformation> transformations=createTransformations(negotiatedExtensionsPhase1);
  List<Extension> negotiatedExtensionsPhase2;
  if (transformations.isEmpty()) {
    negotiatedExtensionsPhase2=Collections.emptyList();
  }
 else {
    negotiatedExtensionsPhase2=new ArrayList<Extension>(transformations.size());
    for (    Transformation t : transformations) {
      negotiatedExtensionsPhase2.add(t.getExtensionResponse());
    }
  }
  Transformation transformation=null;
  StringBuilder responseHeaderExtensions=new StringBuilder();
  boolean first=true;
  for (  Transformation t : transformations) {
    if (first) {
      first=false;
    }
 else {
      responseHeaderExtensions.append(',');
    }
    append(responseHeaderExtensions,t.getExtensionResponse());
    if (transformation == null) {
      transformation=t;
    }
 else {
      transformation.setNext(t);
    }
  }
  if (transformation != null && !transformation.validateRsvBits(0)) {
    throw new ServletException(sm.getString("upgradeUtil.incompatibleRsv"));
  }
  resp.setHeader(Constants.UPGRADE_HEADER_NAME,Constants.UPGRADE_HEADER_VALUE);
  resp.setHeader(Constants.CONNECTION_HEADER_NAME,Constants.CONNECTION_HEADER_VALUE);
  resp.setHeader(HandshakeResponse.SEC_WEBSOCKET_ACCEPT,getWebSocketAccept(key));
  if (subProtocol != null && subProtocol.length() > 0) {
    resp.setHeader(Constants.WS_PROTOCOL_HEADER_NAME,subProtocol);
  }
  if (!transformations.isEmpty()) {
    resp.setHeader(Constants.WS_EXTENSIONS_HEADER_NAME,responseHeaderExtensions.toString());
  }
  WsHandshakeRequest wsRequest=new WsHandshakeRequest(req,pathParams);
  WsHandshakeResponse wsResponse=new WsHandshakeResponse();
  WsPerSessionServerEndpointConfig perSessionServerEndpointConfig=new WsPerSessionServerEndpointConfig(sec);
  sec.getConfigurator().modifyHandshake(perSessionServerEndpointConfig,wsRequest,wsResponse);
  wsRequest.finished();
  for (  Entry<String,List<String>> entry : wsResponse.getHeaders().entrySet()) {
    for (    String headerValue : entry.getValue()) {
      resp.addHeader(entry.getKey(),headerValue);
    }
  }
  Endpoint ep;
  try {
    Class<?> clazz=sec.getEndpointClass();
    if (Endpoint.class.isAssignableFrom(clazz)) {
      ep=(Endpoint)sec.getConfigurator().getEndpointInstance(clazz);
    }
 else {
      ep=new PojoEndpointServer();
      perSessionServerEndpointConfig.getUserProperties().put(PojoEndpointServer.POJO_PATH_PARAM_KEY,pathParams);
    }
  }
 catch (  InstantiationException e) {
    throw new ServletException(e);
  }
  ServletRequest inner=req;
  while (inner instanceof ServletRequestWrapper) {
    inner=((ServletRequestWrapper)inner).getRequest();
  }
  if (inner instanceof RequestFacade) {
    WsHttpUpgradeHandler wsHandler=((RequestFacade)inner).upgrade(WsHttpUpgradeHandler.class);
    wsHandler.preInit(ep,perSessionServerEndpointConfig,sc,wsRequest,negotiatedExtensionsPhase2,subProtocol,transformation,pathParams,req.isSecure());
  }
 else {
    throw new ServletException("Upgrade failed");
  }
}

ID 4122=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsRemoteEndpointImplServer#onWritePossible(boolean)
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletOutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void onWritePossible(boolean useDispatch){
  boolean complete=true;
  try {
    while (sos.isReady()) {
      complete=true;
      for (      ByteBuffer buffer : buffers) {
        if (buffer.hasRemaining()) {
          complete=false;
          sos.write(buffer.array(),buffer.arrayOffset(),buffer.limit());
          buffer.position(buffer.limit());
          break;
        }
      }
      if (complete) {
        wsWriteTimeout.unregister(this);
        clearHandler(null,useDispatch);
        if (close) {
          close();
        }
        break;
      }
    }
  }
 catch (  IOException ioe) {
    wsWriteTimeout.unregister(this);
    clearHandler(ioe,useDispatch);
    close();
  }
  if (!complete) {
    long timeout=getSendTimeout();
    if (timeout > 0) {
      timeoutExpiry=timeout + System.currentTimeMillis();
      wsWriteTimeout.register(this);
    }
  }
}

ID 4123=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsRemoteEndpointImplServer#doClose()
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletOutputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override protected void doClose(){
  if (handler != null) {
    clearHandler(new EOFException(),true);
  }
  try {
    sos.close();
  }
 catch (  IOException e) {
    if (log.isInfoEnabled()) {
      log.info(sm.getString("wsRemoteEndpointServer.closeFailed"),e);
    }
  }
  wsWriteTimeout.unregister(this);
}

ID 4127=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsServerContainer#addEndpoint(Class<?>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Provides the equivalent of  {@link #addEndpoint(ServerEndpointConfig)}for publishing plain old java objects (POJOs) that have been annotated as WebSocket endpoints.
 * @param pojo   The annotated POJO
 */
@Override public void addEndpoint(Class<?> pojo) throws DeploymentException {
  ServerEndpoint annotation=pojo.getAnnotation(ServerEndpoint.class);
  if (annotation == null) {
    throw new DeploymentException(sm.getString("serverContainer.missingAnnotation",pojo.getName()));
  }
  String path=annotation.value();
  validateEncoders(annotation.encoders());
  ServerEndpointConfig sec;
  Class<? extends Configurator> configuratorClazz=annotation.configurator();
  Configurator configurator=null;
  if (!configuratorClazz.equals(Configurator.class)) {
    try {
      configurator=annotation.configurator().newInstance();
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("serverContainer.configuratorFail",annotation.configurator().getName(),pojo.getClass().getName()),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("serverContainer.configuratorFail",annotation.configurator().getName(),pojo.getClass().getName()),e);
    }
  }
  sec=ServerEndpointConfig.Builder.create(pojo,path).decoders(Arrays.asList(annotation.decoders())).encoders(Arrays.asList(annotation.encoders())).subprotocols(Arrays.asList(annotation.subprotocols())).configurator(configurator).build();
  addEndpoint(sec);
}

ID 4128=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsServerContainer#addEndpoint(Class<?>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Provides the equivalent of  {@link #addEndpoint(ServerEndpointConfig)}for publishing plain old java objects (POJOs) that have been annotated as WebSocket endpoints.
 * @param pojo   The annotated POJO
 */
@Override public void addEndpoint(Class<?> pojo) throws DeploymentException {
  ServerEndpoint annotation=pojo.getAnnotation(ServerEndpoint.class);
  if (annotation == null) {
    throw new DeploymentException(sm.getString("serverContainer.missingAnnotation",pojo.getName()));
  }
  String path=annotation.value();
  validateEncoders(annotation.encoders());
  ServerEndpointConfig sec;
  Class<? extends Configurator> configuratorClazz=annotation.configurator();
  Configurator configurator=null;
  if (!configuratorClazz.equals(Configurator.class)) {
    try {
      configurator=annotation.configurator().newInstance();
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("serverContainer.configuratorFail",annotation.configurator().getName(),pojo.getClass().getName()),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("serverContainer.configuratorFail",annotation.configurator().getName(),pojo.getClass().getName()),e);
    }
  }
  sec=ServerEndpointConfig.Builder.create(pojo,path).decoders(Arrays.asList(annotation.decoders())).encoders(Arrays.asList(annotation.encoders())).subprotocols(Arrays.asList(annotation.subprotocols())).configurator(configurator).build();
  addEndpoint(sec);
}

ID 4132=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsServerContainer#findMapping(java.lang.String)
Rmethod: org.apache.tomcat.websocket.server.UriTemplate#UriTemplate(java.lang.String)
parentException: 
thrown: DeploymentException
exception comment: null
block: 
public WsMappingResult findMapping(String path){
  if (addAllowed) {
    addAllowed=false;
  }
  ServerEndpointConfig sec=configExactMatchMap.get(path);
  if (sec != null) {
    return new WsMappingResult(sec,Collections.<String,String>emptyMap());
  }
  UriTemplate pathUriTemplate=null;
  try {
    pathUriTemplate=new UriTemplate(path);
  }
 catch (  DeploymentException e) {
    return null;
  }
  Integer key=Integer.valueOf(pathUriTemplate.getSegmentCount());
  SortedSet<TemplatePathMatch> templateMatches=configTemplateMatchMap.get(key);
  if (templateMatches == null) {
    return null;
  }
  Map<String,String> pathParams=null;
  for (  TemplatePathMatch templateMatch : templateMatches) {
    pathParams=templateMatch.getUriTemplate().match(pathUriTemplate);
    if (pathParams != null) {
      sec=templateMatch.getConfig();
      break;
    }
  }
  if (sec == null) {
    return null;
  }
  return new WsMappingResult(sec,pathParams);
}

ID 4135=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsServerContainer#validateEncoders(Class<? extends javax.websocket.Encoder>[])
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
private static void validateEncoders(Class<? extends Encoder>[] encoders) throws DeploymentException {
  for (  Class<? extends Encoder> encoder : encoders) {
    @SuppressWarnings("unused") Encoder instance;
    try {
      encoder.newInstance();
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("serverContainer.encoderFail",encoder.getName()),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("serverContainer.encoderFail",encoder.getName()),e);
    }
  }
}

ID 4136=========================================================================type: 1
Method:org.apache.tomcat.websocket.server.WsServerContainer#validateEncoders(Class<? extends javax.websocket.Encoder>[])
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
private static void validateEncoders(Class<? extends Encoder>[] encoders) throws DeploymentException {
  for (  Class<? extends Encoder> encoder : encoders) {
    @SuppressWarnings("unused") Encoder instance;
    try {
      encoder.newInstance();
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("serverContainer.encoderFail",encoder.getName()),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("serverContainer.encoderFail",encoder.getName()),e);
    }
  }
}

ID 4137=========================================================================type: 1
Method:org.apache.tomcat.websocket.AsyncChannelGroupUtil#createAsynchronousChannelGroup()
Rmethod: java.nio.channels.AsynchronousChannelGroup#withCachedThreadPool(java.util.concurrent.ExecutorService, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private static AsynchronousChannelGroup createAsynchronousChannelGroup(){
  ClassLoader original=Thread.currentThread().getContextClassLoader();
  try {
    Thread.currentThread().setContextClassLoader(AsyncIOThreadFactory.class.getClassLoader());
    int initialSize=Runtime.getRuntime().availableProcessors();
    ExecutorService executorService=new ThreadPoolExecutor(0,Integer.MAX_VALUE,Long.MAX_VALUE,TimeUnit.MILLISECONDS,new SynchronousQueue<Runnable>(),new AsyncIOThreadFactory());
    try {
      return AsynchronousChannelGroup.withCachedThreadPool(executorService,initialSize);
    }
 catch (    IOException e) {
      throw new IllegalStateException(sm.getString("asyncChannelGroup.createFail"));
    }
  }
  finally {
    Thread.currentThread().setContextClassLoader(original);
  }
}

ID 4164=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsFrameClient#startInputProcessing()
Rmethod: org.apache.tomcat.websocket.WsFrameClient#processSocketRead()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
void startInputProcessing(){
  try {
    processSocketRead();
  }
 catch (  IOException e) {
    close(e);
  }
}

ID 4167=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsFrameClientCompletionHandler#completed(java.lang.Integer, java.lang.Void)
Rmethod: org.apache.tomcat.websocket.WsFrameClient#processSocketRead()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void completed(Integer result,Void attachment){
  if (result.intValue() == -1) {
    if (isOpen()) {
      close(new EOFException());
    }
    return;
  }
  response.flip();
  try {
    processSocketRead();
  }
 catch (  IOException e) {
    if (isOpen()) {
      log.debug(sm.getString("wsFrameClient.ioe",e));
      close(e);
    }
  }
}

ID 4168=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsFrameClientCompletionHandler#failed(java.lang.Throwable, java.lang.Void)
Rmethod: org.apache.tomcat.websocket.WsFrameClient#processSocketRead()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void failed(Throwable exc,Void attachment){
  if (exc instanceof ReadBufferOverflowException) {
    response=ByteBuffer.allocate(((ReadBufferOverflowException)exc).getMinBufferSize());
    response.flip();
    try {
      processSocketRead();
    }
 catch (    IOException e) {
      close(e);
    }
  }
 else {
    close(exc);
  }
}

ID 4178=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#sendPartialString(java.nio.CharBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
void sendPartialString(CharBuffer part,boolean last) throws IOException {
  try {
    long timeout=getBlockingSendTimeout();
    FutureToSendHandler f2sh=new FutureToSendHandler(wsSession);
    TextMessageSendHandler tmsh=new TextMessageSendHandler(f2sh,part,last,encoder,encoderBuffer,this);
    tmsh.write();
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4179=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#sendPartialString(java.nio.CharBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get()
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
void sendPartialString(CharBuffer part,boolean last) throws IOException {
  try {
    long timeout=getBlockingSendTimeout();
    FutureToSendHandler f2sh=new FutureToSendHandler(wsSession);
    TextMessageSendHandler tmsh=new TextMessageSendHandler(f2sh,part,last,encoder,encoderBuffer,this);
    tmsh.write();
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4180=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#sendPartialString(java.nio.CharBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
void sendPartialString(CharBuffer part,boolean last) throws IOException {
  try {
    long timeout=getBlockingSendTimeout();
    FutureToSendHandler f2sh=new FutureToSendHandler(wsSession);
    TextMessageSendHandler tmsh=new TextMessageSendHandler(f2sh,part,last,encoder,encoderBuffer,this);
    tmsh.write();
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4181=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#sendPartialString(java.nio.CharBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
void sendPartialString(CharBuffer part,boolean last) throws IOException {
  try {
    long timeout=getBlockingSendTimeout();
    FutureToSendHandler f2sh=new FutureToSendHandler(wsSession);
    TextMessageSendHandler tmsh=new TextMessageSendHandler(f2sh,part,last,encoder,encoderBuffer,this);
    tmsh.write();
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4182=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#sendPartialString(java.nio.CharBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

block: 
void sendPartialString(CharBuffer part,boolean last) throws IOException {
  try {
    long timeout=getBlockingSendTimeout();
    FutureToSendHandler f2sh=new FutureToSendHandler(wsSession);
    TextMessageSendHandler tmsh=new TextMessageSendHandler(f2sh,part,last,encoder,encoderBuffer,this);
    tmsh.write();
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4184=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#startMessageBlock(byte, java.nio.ByteBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
void startMessageBlock(byte opCode,ByteBuffer payload,boolean last) throws IOException {
  long timeout=getBlockingSendTimeout();
  FutureToSendHandler f2sh=new FutureToSendHandler(wsSession,opCode == Constants.OPCODE_CLOSE);
  startMessage(opCode,payload,last,f2sh);
  try {
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4185=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#startMessageBlock(byte, java.nio.ByteBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get()
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
void startMessageBlock(byte opCode,ByteBuffer payload,boolean last) throws IOException {
  long timeout=getBlockingSendTimeout();
  FutureToSendHandler f2sh=new FutureToSendHandler(wsSession,opCode == Constants.OPCODE_CLOSE);
  startMessage(opCode,payload,last,f2sh);
  try {
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4186=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#startMessageBlock(byte, java.nio.ByteBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
void startMessageBlock(byte opCode,ByteBuffer payload,boolean last) throws IOException {
  long timeout=getBlockingSendTimeout();
  FutureToSendHandler f2sh=new FutureToSendHandler(wsSession,opCode == Constants.OPCODE_CLOSE);
  startMessage(opCode,payload,last,f2sh);
  try {
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4187=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#startMessageBlock(byte, java.nio.ByteBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
void startMessageBlock(byte opCode,ByteBuffer payload,boolean last) throws IOException {
  long timeout=getBlockingSendTimeout();
  FutureToSendHandler f2sh=new FutureToSendHandler(wsSession,opCode == Constants.OPCODE_CLOSE);
  startMessage(opCode,payload,last,f2sh);
  try {
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4188=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#startMessageBlock(byte, java.nio.ByteBuffer, boolean)
Rmethod: org.apache.tomcat.websocket.FutureToSendHandler#get(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: TimeoutException
exception comment: /** 
 * Exception thrown when a blocking operation times out.  Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then  {@code TimeoutException} should bedeclared and thrown.
 * @since 1.5
 * @author Doug Lea
 */

block: 
void startMessageBlock(byte opCode,ByteBuffer payload,boolean last) throws IOException {
  long timeout=getBlockingSendTimeout();
  FutureToSendHandler f2sh=new FutureToSendHandler(wsSession,opCode == Constants.OPCODE_CLOSE);
  startMessage(opCode,payload,last,f2sh);
  try {
    if (timeout == -1) {
      f2sh.get();
    }
 else {
      f2sh.get(timeout,TimeUnit.MILLISECONDS);
    }
  }
 catch (  InterruptedException e) {
    handleSendFailure(e);
  }
catch (  ExecutionException e) {
    throw new IOException(e);
  }
catch (  TimeoutException e) {
    throw new IOException(e);
  }
}

ID 4190=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#sendObject(java.lang.Object)
Rmethod: java.util.concurrent.Future#get()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
public void sendObject(Object obj) throws IOException, EncodeException {
  Future<Void> f=sendObjectByFuture(obj);
  try {
    f.get();
  }
 catch (  InterruptedException e) {
    handleSendFailureWithEncode(e);
  }
catch (  ExecutionException e) {
    handleSendFailureWithEncode(e);
  }
}

ID 4191=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#sendObject(java.lang.Object)
Rmethod: java.util.concurrent.Future#get()
parentException: 
thrown: ExecutionException
exception comment: /** 
 * Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the  {@link #getCause()} method.
 * @see Future
 * @since 1.5
 * @author Doug Lea
 */

block: 
public void sendObject(Object obj) throws IOException, EncodeException {
  Future<Void> f=sendObjectByFuture(obj);
  try {
    f.get();
  }
 catch (  InterruptedException e) {
    handleSendFailureWithEncode(e);
  }
catch (  ExecutionException e) {
    handleSendFailureWithEncode(e);
  }
}

ID 4195=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#handleSendFailure(java.lang.Throwable)
Rmethod: org.apache.tomcat.websocket.WsRemoteEndpointImplBase#handleSendFailureWithEncode(java.lang.Throwable)
parentException: 
thrown: EncodeException
exception comment: null
block: 
private void handleSendFailure(Throwable t) throws IOException {
  try {
    handleSendFailureWithEncode(t);
  }
 catch (  EncodeException e) {
    throw new IOException(e);
  }
}

ID 4204=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#setEncoders(javax.websocket.EndpointConfig)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
protected void setEncoders(EndpointConfig endpointConfig) throws DeploymentException {
  encoderEntries.clear();
  for (  Class<? extends Encoder> encoderClazz : endpointConfig.getEncoders()) {
    Encoder instance;
    try {
      instance=encoderClazz.newInstance();
      instance.init(endpointConfig);
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("wsRemoteEndpoint.invalidEncoder",encoderClazz.getName()),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("wsRemoteEndpoint.invalidEncoder",encoderClazz.getName()),e);
    }
    EncoderEntry entry=new EncoderEntry(Util.getEncoderType(encoderClazz),instance);
    encoderEntries.add(entry);
  }
}

ID 4205=========================================================================type: 1
Method:org.apache.tomcat.websocket.WsRemoteEndpointImplBase#setEncoders(javax.websocket.EndpointConfig)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
protected void setEncoders(EndpointConfig endpointConfig) throws DeploymentException {
  encoderEntries.clear();
  for (  Class<? extends Encoder> encoderClazz : endpointConfig.getEncoders()) {
    Encoder instance;
    try {
      instance=encoderClazz.newInstance();
      instance.init(endpointConfig);
    }
 catch (    InstantiationException e) {
      throw new DeploymentException(sm.getString("wsRemoteEndpoint.invalidEncoder",encoderClazz.getName()),e);
    }
catch (    IllegalAccessException e) {
      throw new DeploymentException(sm.getString("wsRemoteEndpoint.invalidEncoder",encoderClazz.getName()),e);
    }
    EncoderEntry entry=new EncoderEntry(Util.getEncoderType(encoderClazz),instance);
    encoderEntries.add(entry);
  }
}

ID 4217=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoEndpointServer#onOpen(javax.websocket.Session, javax.websocket.EndpointConfig)
Rmethod: javax.websocket.server.Configurator#getEndpointInstance(Class<T>)
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
@Override public void onOpen(Session session,EndpointConfig endpointConfig){
  ServerEndpointConfig sec=(ServerEndpointConfig)endpointConfig;
  Object pojo;
  try {
    pojo=sec.getConfigurator().getEndpointInstance(sec.getEndpointClass());
  }
 catch (  InstantiationException e) {
    throw new IllegalArgumentException(sm.getString("pojoEndpointServer.getPojoInstanceFail",sec.getEndpointClass().getName()),e);
  }
  setPojo(pojo);
  @SuppressWarnings("unchecked") Map<String,String> pathParameters=(Map<String,String>)sec.getUserProperties().get(POJO_PATH_PARAM_KEY);
  setPathParameters(pathParameters);
  PojoMethodMapping methodMapping=(PojoMethodMapping)sec.getUserProperties().get(POJO_METHOD_MAPPING_KEY);
  setMethodMapping(methodMapping);
  doOnOpen(session,endpointConfig);
}

ID 4219=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerBase#processResult(java.lang.Object)
Rmethod: javax.websocket.Basic#sendText(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected final void processResult(Object result){
  if (result == null) {
    return;
  }
  RemoteEndpoint.Basic remoteEndpoint=session.getBasicRemote();
  try {
    if (result instanceof String) {
      remoteEndpoint.sendText((String)result);
    }
 else     if (result instanceof ByteBuffer) {
      remoteEndpoint.sendBinary((ByteBuffer)result);
    }
 else     if (result instanceof byte[]) {
      remoteEndpoint.sendBinary(ByteBuffer.wrap((byte[])result));
    }
 else {
      remoteEndpoint.sendObject(result);
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
catch (  EncodeException ee) {
    throw new IllegalStateException(ee);
  }
}

ID 4220=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerBase#processResult(java.lang.Object)
Rmethod: javax.websocket.Basic#sendBinary(java.nio.ByteBuffer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected final void processResult(Object result){
  if (result == null) {
    return;
  }
  RemoteEndpoint.Basic remoteEndpoint=session.getBasicRemote();
  try {
    if (result instanceof String) {
      remoteEndpoint.sendText((String)result);
    }
 else     if (result instanceof ByteBuffer) {
      remoteEndpoint.sendBinary((ByteBuffer)result);
    }
 else     if (result instanceof byte[]) {
      remoteEndpoint.sendBinary(ByteBuffer.wrap((byte[])result));
    }
 else {
      remoteEndpoint.sendObject(result);
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
catch (  EncodeException ee) {
    throw new IllegalStateException(ee);
  }
}

ID 4221=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerBase#processResult(java.lang.Object)
Rmethod: javax.websocket.Basic#sendObject(java.lang.Object)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected final void processResult(Object result){
  if (result == null) {
    return;
  }
  RemoteEndpoint.Basic remoteEndpoint=session.getBasicRemote();
  try {
    if (result instanceof String) {
      remoteEndpoint.sendText((String)result);
    }
 else     if (result instanceof ByteBuffer) {
      remoteEndpoint.sendBinary((ByteBuffer)result);
    }
 else     if (result instanceof byte[]) {
      remoteEndpoint.sendBinary(ByteBuffer.wrap((byte[])result));
    }
 else {
      remoteEndpoint.sendObject(result);
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
catch (  EncodeException ee) {
    throw new IllegalStateException(ee);
  }
}

ID 4222=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerBase#processResult(java.lang.Object)
Rmethod: javax.websocket.Basic#sendObject(java.lang.Object)
parentException: 
thrown: EncodeException
exception comment: null
block: 
protected final void processResult(Object result){
  if (result == null) {
    return;
  }
  RemoteEndpoint.Basic remoteEndpoint=session.getBasicRemote();
  try {
    if (result instanceof String) {
      remoteEndpoint.sendText((String)result);
    }
 else     if (result instanceof ByteBuffer) {
      remoteEndpoint.sendBinary((ByteBuffer)result);
    }
 else     if (result instanceof byte[]) {
      remoteEndpoint.sendBinary(ByteBuffer.wrap((byte[])result));
    }
 else {
      remoteEndpoint.sendObject(result);
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException(ioe);
  }
catch (  EncodeException ee) {
    throw new IllegalStateException(ee);
  }
}

ID 4225=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoEndpointBase#doOnOpen(javax.websocket.Session, javax.websocket.EndpointConfig)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
protected final void doOnOpen(Session session,EndpointConfig config){
  PojoMethodMapping methodMapping=getMethodMapping();
  Object pojo=getPojo();
  Map<String,String> pathParameters=getPathParameters();
  for (  MessageHandler mh : methodMapping.getMessageHandlers(pojo,pathParameters,session,config)) {
    session.addMessageHandler(mh);
  }
  if (methodMapping.getOnOpen() != null) {
    try {
      methodMapping.getOnOpen().invoke(pojo,methodMapping.getOnOpenArgs(pathParameters,session,config));
    }
 catch (    IllegalAccessException e) {
      log.error(sm.getString("pojoEndpointBase.onOpenFail",pojo.getClass().getName()),e);
      handleOnOpenError(session,e);
      return;
    }
catch (    InvocationTargetException e) {
      Throwable cause=e.getCause();
      handleOnOpenError(session,cause);
      return;
    }
catch (    Throwable t) {
      handleOnOpenError(session,t);
      return;
    }
  }
}

ID 4227=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoEndpointBase#doOnOpen(javax.websocket.Session, javax.websocket.EndpointConfig)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
protected final void doOnOpen(Session session,EndpointConfig config){
  PojoMethodMapping methodMapping=getMethodMapping();
  Object pojo=getPojo();
  Map<String,String> pathParameters=getPathParameters();
  for (  MessageHandler mh : methodMapping.getMessageHandlers(pojo,pathParameters,session,config)) {
    session.addMessageHandler(mh);
  }
  if (methodMapping.getOnOpen() != null) {
    try {
      methodMapping.getOnOpen().invoke(pojo,methodMapping.getOnOpenArgs(pathParameters,session,config));
    }
 catch (    IllegalAccessException e) {
      log.error(sm.getString("pojoEndpointBase.onOpenFail",pojo.getClass().getName()),e);
      handleOnOpenError(session,e);
      return;
    }
catch (    InvocationTargetException e) {
      Throwable cause=e.getCause();
      handleOnOpenError(session,cause);
      return;
    }
catch (    Throwable t) {
      handleOnOpenError(session,t);
      return;
    }
  }
}

ID 4228=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoEndpointBase#handleOnOpenError(javax.websocket.Session, java.lang.Throwable)
Rmethod: javax.websocket.Session#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void handleOnOpenError(Session session,Throwable t){
  ExceptionUtils.handleThrowable(t);
  onError(session,t);
  try {
    session.close();
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("pojoEndpointBase.closeSessionFail"),ioe);
  }
}

ID 4237=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerPartialBase#onMessage(T, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public final void onMessage(T message,boolean last){
  if (params.length == 1 && params[0] instanceof DecodeException) {
    ((WsSession)session).getLocal().onError(session,(DecodeException)params[0]);
    return;
  }
  Object[] parameters=params.clone();
  if (indexBoolean != -1) {
    parameters[indexBoolean]=Boolean.valueOf(last);
  }
  if (indexSession != -1) {
    parameters[indexSession]=session;
  }
  if (convert) {
    parameters[indexPayload]=((ByteBuffer)message).array();
  }
 else {
    parameters[indexPayload]=message;
  }
  Object result=null;
  try {
    result=method.invoke(pojo,parameters);
  }
 catch (  IllegalAccessException e) {
    handlePojoMethodException(e);
  }
catch (  InvocationTargetException e) {
    handlePojoMethodException(e);
  }
  processResult(result);
}

ID 4239=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerPartialBase#onMessage(T, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public final void onMessage(T message,boolean last){
  if (params.length == 1 && params[0] instanceof DecodeException) {
    ((WsSession)session).getLocal().onError(session,(DecodeException)params[0]);
    return;
  }
  Object[] parameters=params.clone();
  if (indexBoolean != -1) {
    parameters[indexBoolean]=Boolean.valueOf(last);
  }
  if (indexSession != -1) {
    parameters[indexSession]=session;
  }
  if (convert) {
    parameters[indexPayload]=((ByteBuffer)message).array();
  }
 else {
    parameters[indexPayload]=message;
  }
  Object result=null;
  try {
    result=method.invoke(pojo,parameters);
  }
 catch (  IllegalAccessException e) {
    handlePojoMethodException(e);
  }
catch (  InvocationTargetException e) {
    handlePojoMethodException(e);
  }
  processResult(result);
}

ID 4240=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeText#PojoMessageHandlerWholeText(java.lang.Object, java.lang.reflect.Method, javax.websocket.Session, javax.websocket.EndpointConfig, List<Class<? extends javax.websocket.Decoder>>, java.lang.Object[], int, boolean, int, long)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
public PojoMessageHandlerWholeText(Object pojo,Method method,Session session,EndpointConfig config,List<Class<? extends Decoder>> decoderClazzes,Object[] params,int indexPayload,boolean convert,int indexSession,long maxMessageSize){
  super(pojo,method,session,params,indexPayload,convert,indexSession,maxMessageSize);
  if (maxMessageSize > -1 && maxMessageSize > session.getMaxTextMessageBufferSize()) {
    if (maxMessageSize > Integer.MAX_VALUE) {
      throw new IllegalArgumentException(sm.getString("pojoMessageHandlerWhole.maxBufferSize"));
    }
    session.setMaxTextMessageBufferSize((int)maxMessageSize);
  }
  Class<?> type=method.getParameterTypes()[indexPayload];
  if (Util.isPrimitive(type)) {
    primitiveType=type;
    return;
  }
 else {
    primitiveType=null;
  }
  try {
    if (decoderClazzes != null) {
      for (      Class<? extends Decoder> decoderClazz : decoderClazzes) {
        if (Text.class.isAssignableFrom(decoderClazz)) {
          Text<?> decoder=(Text<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else         if (TextStream.class.isAssignableFrom(decoderClazz)) {
          TextStream<?> decoder=(TextStream<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else {
        }
      }
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(e);
  }
}

ID 4241=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeText#PojoMessageHandlerWholeText(java.lang.Object, java.lang.reflect.Method, javax.websocket.Session, javax.websocket.EndpointConfig, List<Class<? extends javax.websocket.Decoder>>, java.lang.Object[], int, boolean, int, long)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
public PojoMessageHandlerWholeText(Object pojo,Method method,Session session,EndpointConfig config,List<Class<? extends Decoder>> decoderClazzes,Object[] params,int indexPayload,boolean convert,int indexSession,long maxMessageSize){
  super(pojo,method,session,params,indexPayload,convert,indexSession,maxMessageSize);
  if (maxMessageSize > -1 && maxMessageSize > session.getMaxTextMessageBufferSize()) {
    if (maxMessageSize > Integer.MAX_VALUE) {
      throw new IllegalArgumentException(sm.getString("pojoMessageHandlerWhole.maxBufferSize"));
    }
    session.setMaxTextMessageBufferSize((int)maxMessageSize);
  }
  Class<?> type=method.getParameterTypes()[indexPayload];
  if (Util.isPrimitive(type)) {
    primitiveType=type;
    return;
  }
 else {
    primitiveType=null;
  }
  try {
    if (decoderClazzes != null) {
      for (      Class<? extends Decoder> decoderClazz : decoderClazzes) {
        if (Text.class.isAssignableFrom(decoderClazz)) {
          Text<?> decoder=(Text<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else         if (TextStream.class.isAssignableFrom(decoderClazz)) {
          TextStream<?> decoder=(TextStream<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else {
        }
      }
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(e);
  }
}

ID 4244=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeText#decode(java.lang.String)
Rmethod: javax.websocket.TextStream#decode(java.io.Reader)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override protected Object decode(String message) throws DecodeException {
  if (primitiveType != null) {
    return Util.coerceToType(primitiveType,message);
  }
  for (  Decoder decoder : decoders) {
    if (decoder instanceof Text) {
      if (((Text<?>)decoder).willDecode(message)) {
        return ((Text<?>)decoder).decode(message);
      }
    }
 else {
      StringReader r=new StringReader(message);
      try {
        return ((TextStream<?>)decoder).decode(r);
      }
 catch (      IOException ioe) {
        throw new DecodeException(message,sm.getString("pojoMessageHandlerWhole.decodeIoFail"),ioe);
      }
    }
  }
  return null;
}

ID 4245=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBase#onMessage(T)
Rmethod: org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBase#decode(T)
parentException: 
thrown: DecodeException
exception comment: null
block: 
@Override public final void onMessage(T message){
  if (params.length == 1 && params[0] instanceof DecodeException) {
    ((WsSession)session).getLocal().onError(session,(DecodeException)params[0]);
    return;
  }
  Object payload;
  try {
    payload=decode(message);
  }
 catch (  DecodeException de) {
    ((WsSession)session).getLocal().onError(session,de);
    return;
  }
  if (payload == null) {
    if (convert) {
      payload=convert(message);
    }
 else {
      payload=message;
    }
  }
  Object[] parameters=params.clone();
  if (indexSession != -1) {
    parameters[indexSession]=session;
  }
  parameters[indexPayload]=payload;
  Object result=null;
  try {
    result=method.invoke(pojo,parameters);
  }
 catch (  IllegalAccessException e) {
    handlePojoMethodException(e);
  }
catch (  InvocationTargetException e) {
    handlePojoMethodException(e);
  }
  processResult(result);
}

ID 4246=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBase#onMessage(T)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public final void onMessage(T message){
  if (params.length == 1 && params[0] instanceof DecodeException) {
    ((WsSession)session).getLocal().onError(session,(DecodeException)params[0]);
    return;
  }
  Object payload;
  try {
    payload=decode(message);
  }
 catch (  DecodeException de) {
    ((WsSession)session).getLocal().onError(session,de);
    return;
  }
  if (payload == null) {
    if (convert) {
      payload=convert(message);
    }
 else {
      payload=message;
    }
  }
  Object[] parameters=params.clone();
  if (indexSession != -1) {
    parameters[indexSession]=session;
  }
  parameters[indexPayload]=payload;
  Object result=null;
  try {
    result=method.invoke(pojo,parameters);
  }
 catch (  IllegalAccessException e) {
    handlePojoMethodException(e);
  }
catch (  InvocationTargetException e) {
    handlePojoMethodException(e);
  }
  processResult(result);
}

ID 4248=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBase#onMessage(T)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public final void onMessage(T message){
  if (params.length == 1 && params[0] instanceof DecodeException) {
    ((WsSession)session).getLocal().onError(session,(DecodeException)params[0]);
    return;
  }
  Object payload;
  try {
    payload=decode(message);
  }
 catch (  DecodeException de) {
    ((WsSession)session).getLocal().onError(session,de);
    return;
  }
  if (payload == null) {
    if (convert) {
      payload=convert(message);
    }
 else {
      payload=message;
    }
  }
  Object[] parameters=params.clone();
  if (indexSession != -1) {
    parameters[indexSession]=session;
  }
  parameters[indexPayload]=payload;
  Object result=null;
  try {
    result=method.invoke(pojo,parameters);
  }
 catch (  IllegalAccessException e) {
    handlePojoMethodException(e);
  }
catch (  InvocationTargetException e) {
    handlePojoMethodException(e);
  }
  processResult(result);
}

ID 4249=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBinary#PojoMessageHandlerWholeBinary(java.lang.Object, java.lang.reflect.Method, javax.websocket.Session, javax.websocket.EndpointConfig, List<Class<? extends javax.websocket.Decoder>>, java.lang.Object[], int, boolean, int, boolean, long)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
public PojoMessageHandlerWholeBinary(Object pojo,Method method,Session session,EndpointConfig config,List<Class<? extends Decoder>> decoderClazzes,Object[] params,int indexPayload,boolean convert,int indexSession,boolean isForInputStream,long maxMessageSize){
  super(pojo,method,session,params,indexPayload,convert,indexSession,maxMessageSize);
  if (maxMessageSize > -1 && maxMessageSize > session.getMaxBinaryMessageBufferSize()) {
    if (maxMessageSize > Integer.MAX_VALUE) {
      throw new IllegalArgumentException(sm.getString("pojoMessageHandlerWhole.maxBufferSize"));
    }
    session.setMaxBinaryMessageBufferSize((int)maxMessageSize);
  }
  try {
    if (decoderClazzes != null) {
      for (      Class<? extends Decoder> decoderClazz : decoderClazzes) {
        if (Binary.class.isAssignableFrom(decoderClazz)) {
          Binary<?> decoder=(Binary<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else         if (BinaryStream.class.isAssignableFrom(decoderClazz)) {
          BinaryStream<?> decoder=(BinaryStream<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else {
        }
      }
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(e);
  }
  this.isForInputStream=isForInputStream;
}

ID 4250=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBinary#PojoMessageHandlerWholeBinary(java.lang.Object, java.lang.reflect.Method, javax.websocket.Session, javax.websocket.EndpointConfig, List<Class<? extends javax.websocket.Decoder>>, java.lang.Object[], int, boolean, int, boolean, long)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
public PojoMessageHandlerWholeBinary(Object pojo,Method method,Session session,EndpointConfig config,List<Class<? extends Decoder>> decoderClazzes,Object[] params,int indexPayload,boolean convert,int indexSession,boolean isForInputStream,long maxMessageSize){
  super(pojo,method,session,params,indexPayload,convert,indexSession,maxMessageSize);
  if (maxMessageSize > -1 && maxMessageSize > session.getMaxBinaryMessageBufferSize()) {
    if (maxMessageSize > Integer.MAX_VALUE) {
      throw new IllegalArgumentException(sm.getString("pojoMessageHandlerWhole.maxBufferSize"));
    }
    session.setMaxBinaryMessageBufferSize((int)maxMessageSize);
  }
  try {
    if (decoderClazzes != null) {
      for (      Class<? extends Decoder> decoderClazz : decoderClazzes) {
        if (Binary.class.isAssignableFrom(decoderClazz)) {
          Binary<?> decoder=(Binary<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else         if (BinaryStream.class.isAssignableFrom(decoderClazz)) {
          BinaryStream<?> decoder=(BinaryStream<?>)decoderClazz.newInstance();
          decoder.init(config);
          decoders.add(decoder);
        }
 else {
        }
      }
    }
  }
 catch (  IllegalAccessException e) {
    throw new IllegalArgumentException(e);
  }
catch (  InstantiationException e) {
    throw new IllegalArgumentException(e);
  }
  this.isForInputStream=isForInputStream;
}

ID 4253=========================================================================type: 1
Method:org.apache.tomcat.websocket.pojo.PojoMessageHandlerWholeBinary#decode(java.nio.ByteBuffer)
Rmethod: javax.websocket.BinaryStream#decode(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override protected Object decode(ByteBuffer message) throws DecodeException {
  for (  Decoder decoder : decoders) {
    if (decoder instanceof Binary) {
      if (((Binary<?>)decoder).willDecode(message)) {
        return ((Binary<?>)decoder).decode(message);
      }
    }
 else {
      byte[] array=new byte[message.limit() - message.position()];
      message.get(array);
      ByteArrayInputStream bais=new ByteArrayInputStream(array);
      try {
        return ((BinaryStream<?>)decoder).decode(bais);
      }
 catch (      IOException ioe) {
        throw new DecodeException(message,sm.getString("pojoMessageHandlerWhole.decodeIoFail"),ioe);
      }
    }
  }
  return null;
}

ID 4265=========================================================================type: 1
Method:org.apache.tomcat.util.compat.Jre8Compat#setUseServerCipherSuitesOrder(javax.net.ssl.SSLServerSocket, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public void setUseServerCipherSuitesOrder(SSLServerSocket socket,boolean useCipherSuitesOrder){
  try {
    Object sslParameters=getSSLParametersMethod.invoke(socket);
    setUseCipherSuitesOrderMethod.invoke(sslParameters,Boolean.valueOf(useCipherSuitesOrder));
    setSSLParametersMethod.invoke(socket,sslParameters);
    return;
  }
 catch (  IllegalArgumentException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  IllegalAccessException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  InvocationTargetException e) {
    throw new UnsupportedOperationException(e);
  }
}

ID 4266=========================================================================type: 1
Method:org.apache.tomcat.util.compat.Jre8Compat#setUseServerCipherSuitesOrder(javax.net.ssl.SSLServerSocket, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
@Override public void setUseServerCipherSuitesOrder(SSLServerSocket socket,boolean useCipherSuitesOrder){
  try {
    Object sslParameters=getSSLParametersMethod.invoke(socket);
    setUseCipherSuitesOrderMethod.invoke(sslParameters,Boolean.valueOf(useCipherSuitesOrder));
    setSSLParametersMethod.invoke(socket,sslParameters);
    return;
  }
 catch (  IllegalArgumentException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  IllegalAccessException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  InvocationTargetException e) {
    throw new UnsupportedOperationException(e);
  }
}

ID 4267=========================================================================type: 1
Method:org.apache.tomcat.util.compat.Jre8Compat#setUseServerCipherSuitesOrder(javax.net.ssl.SSLServerSocket, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public void setUseServerCipherSuitesOrder(SSLServerSocket socket,boolean useCipherSuitesOrder){
  try {
    Object sslParameters=getSSLParametersMethod.invoke(socket);
    setUseCipherSuitesOrderMethod.invoke(sslParameters,Boolean.valueOf(useCipherSuitesOrder));
    setSSLParametersMethod.invoke(socket,sslParameters);
    return;
  }
 catch (  IllegalArgumentException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  IllegalAccessException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  InvocationTargetException e) {
    throw new UnsupportedOperationException(e);
  }
}

ID 4268=========================================================================type: 1
Method:org.apache.tomcat.util.compat.Jre8Compat#setUseServerCipherSuitesOrder(javax.net.ssl.SSLEngine, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public void setUseServerCipherSuitesOrder(SSLEngine engine,boolean useCipherSuitesOrder){
  SSLParameters sslParameters=engine.getSSLParameters();
  try {
    setUseCipherSuitesOrderMethod.invoke(sslParameters,Boolean.valueOf(useCipherSuitesOrder));
    engine.setSSLParameters(sslParameters);
  }
 catch (  IllegalArgumentException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  IllegalAccessException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  InvocationTargetException e) {
    throw new UnsupportedOperationException(e);
  }
}

ID 4269=========================================================================type: 1
Method:org.apache.tomcat.util.compat.Jre8Compat#setUseServerCipherSuitesOrder(javax.net.ssl.SSLEngine, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
@Override public void setUseServerCipherSuitesOrder(SSLEngine engine,boolean useCipherSuitesOrder){
  SSLParameters sslParameters=engine.getSSLParameters();
  try {
    setUseCipherSuitesOrderMethod.invoke(sslParameters,Boolean.valueOf(useCipherSuitesOrder));
    engine.setSSLParameters(sslParameters);
  }
 catch (  IllegalArgumentException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  IllegalAccessException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  InvocationTargetException e) {
    throw new UnsupportedOperationException(e);
  }
}

ID 4270=========================================================================type: 1
Method:org.apache.tomcat.util.compat.Jre8Compat#setUseServerCipherSuitesOrder(javax.net.ssl.SSLEngine, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public void setUseServerCipherSuitesOrder(SSLEngine engine,boolean useCipherSuitesOrder){
  SSLParameters sslParameters=engine.getSSLParameters();
  try {
    setUseCipherSuitesOrderMethod.invoke(sslParameters,Boolean.valueOf(useCipherSuitesOrder));
    engine.setSSLParameters(sslParameters);
  }
 catch (  IllegalArgumentException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  IllegalAccessException e) {
    throw new UnsupportedOperationException(e);
  }
catch (  InvocationTargetException e) {
    throw new UnsupportedOperationException(e);
  }
}

ID 4274=========================================================================type: 1
Method:org.apache.tomcat.util.net.Acceptor#run()
Rmethod: org.apache.tomcat.util.net.ServerSocketFactory#acceptSocket(java.net.ServerSocket)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  int errorDelay=0;
  while (running) {
    while (paused && running) {
      state=AcceptorState.PAUSED;
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
      }
    }
    if (!running) {
      break;
    }
    state=AcceptorState.RUNNING;
    try {
      countUpOrAwaitConnection();
      Socket socket=null;
      try {
        socket=serverSocketFactory.acceptSocket(serverSocket);
      }
 catch (      IOException ioe) {
        countDownConnection();
        errorDelay=handleExceptionWithDelay(errorDelay);
        throw ioe;
      }
      errorDelay=0;
      if (running && !paused && setSocketOptions(socket)) {
        if (!processSocket(socket)) {
          countDownConnection();
          closeSocket(socket);
        }
      }
 else {
        countDownConnection();
        closeSocket(socket);
      }
    }
 catch (    IOException x) {
      if (running) {
        log.error(sm.getString("endpoint.accept.fail"),x);
      }
    }
catch (    NullPointerException npe) {
      if (running) {
        log.error(sm.getString("endpoint.accept.fail"),npe);
      }
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.error(sm.getString("endpoint.accept.fail"),t);
    }
  }
  state=AcceptorState.ENDED;
}

ID 4284=========================================================================type: 1
Method:org.apache.tomcat.util.net.JIoEndpoint#setSocketOptions(java.net.Socket)
Rmethod: org.apache.tomcat.util.net.SocketProperties#setProperties(java.net.Socket)
parentException: IOException 
thrown: SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

block: 
/** 
 * Configure the socket.
 */
protected boolean setSocketOptions(Socket socket){
  try {
    socketProperties.setProperties(socket);
  }
 catch (  SocketException s) {
    if (log.isDebugEnabled()) {
      log.debug(sm.getString("endpoint.err.unexpected"),s);
    }
    return false;
  }
catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    log.error(sm.getString("endpoint.err.unexpected"),t);
    return false;
  }
  return true;
}

ID 4285=========================================================================type: 1
Method:org.apache.tomcat.util.net.AprEndpoint#getLocalPort()
Rmethod: org.apache.tomcat.jni.Address#get(int, long)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Port in use.
 */
@Override public int getLocalPort(){
  long s=serverSock;
  if (s == 0) {
    return -1;
  }
 else {
    long sa;
    try {
      sa=Address.get(Socket.APR_LOCAL,s);
      Sockaddr addr=Address.getInfo(sa);
      return addr.port;
    }
 catch (    Exception e) {
      return -1;
    }
  }
}

ID 4288=========================================================================type: 1
Method:org.apache.tomcat.util.net.AprEndpoint#bind()
Rmethod: org.apache.tomcat.jni.SSLContext#make(long, int, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Initialize the endpoint.
 */
@Override public void bind() throws Exception {
  try {
    rootPool=Pool.create(0);
  }
 catch (  UnsatisfiedLinkError e) {
    throw new Exception(sm.getString("endpoint.init.notavail"));
  }
  serverSockPool=Pool.create(rootPool);
  String addressStr=null;
  if (getAddress() != null) {
    addressStr=getAddress().getHostAddress();
  }
  int family=Socket.APR_INET;
  if (Library.APR_HAVE_IPV6) {
    if (addressStr == null) {
      if (!OS.IS_BSD && !OS.IS_WIN32 && !OS.IS_WIN64)       family=Socket.APR_UNSPEC;
    }
 else     if (addressStr.indexOf(':') >= 0) {
      family=Socket.APR_UNSPEC;
    }
  }
  long inetAddress=Address.info(addressStr,family,getPort(),0,rootPool);
  serverSock=Socket.create(Address.getInfo(inetAddress).family,Socket.SOCK_STREAM,Socket.APR_PROTO_TCP,rootPool);
  if (OS.IS_UNIX) {
    Socket.optSet(serverSock,Socket.APR_SO_REUSEADDR,1);
  }
  Socket.optSet(serverSock,Socket.APR_SO_KEEPALIVE,1);
  int ret=Socket.bind(serverSock,inetAddress);
  if (ret != 0) {
    throw new Exception(sm.getString("endpoint.init.bind","" + ret,Error.strerror(ret)));
  }
  ret=Socket.listen(serverSock,getBacklog());
  if (ret != 0) {
    throw new Exception(sm.getString("endpoint.init.listen","" + ret,Error.strerror(ret)));
  }
  if (OS.IS_WIN32 || OS.IS_WIN64) {
    Socket.optSet(serverSock,Socket.APR_SO_REUSEADDR,1);
  }
  if (useSendfile && !Library.APR_HAS_SENDFILE) {
    useSendfile=false;
  }
  if (acceptorThreadCount == 0) {
    acceptorThreadCount=1;
  }
  if (deferAccept) {
    if (Socket.optSet(serverSock,Socket.APR_TCP_DEFER_ACCEPT,1) == Status.APR_ENOTIMPL) {
      deferAccept=false;
    }
  }
  if (isSSLEnabled()) {
    if (SSLCertificateFile == null) {
      throw new Exception(sm.getString("endpoint.apr.noSslCertFile"));
    }
    int value=SSL.SSL_PROTOCOL_NONE;
    if (SSLProtocol == null || SSLProtocol.length() == 0) {
      value=SSL.SSL_PROTOCOL_ALL;
    }
 else {
      Set<String> protocols=new HashSet<String>();
      for (      String protocol : SSLProtocol.split("(?=[-+])")) {
        String trimmed=protocol.trim();
        if (trimmed.length() > 1) {
          if (trimmed.charAt(0) == '-') {
            trimmed=trimmed.substring(1).trim();
            if (trimmed.equalsIgnoreCase(Constants.SSL_PROTO_ALL)) {
              protocols.removeAll(SSL_PROTO_ALL);
            }
 else {
              protocols.remove(trimmed);
            }
          }
 else {
            if (trimmed.charAt(0) == '+') {
              trimmed=trimmed.substring(1).trim();
            }
            if (trimmed.equalsIgnoreCase(Constants.SSL_PROTO_ALL)) {
              protocols.addAll(SSL_PROTO_ALL);
            }
 else {
              protocols.add(trimmed);
            }
          }
        }
      }
      for (      String protocol : protocols) {
        if (Constants.SSL_PROTO_SSLv2.equalsIgnoreCase(protocol)) {
          value|=SSL.SSL_PROTOCOL_SSLV2;
        }
 else         if (Constants.SSL_PROTO_SSLv3.equalsIgnoreCase(protocol)) {
          value|=SSL.SSL_PROTOCOL_SSLV3;
        }
 else         if (Constants.SSL_PROTO_TLSv1.equalsIgnoreCase(protocol)) {
          value|=SSL.SSL_PROTOCOL_TLSV1;
        }
 else         if (Constants.SSL_PROTO_TLSv1_1.equalsIgnoreCase(protocol)) {
          value|=SSL.SSL_PROTOCOL_TLSV1_1;
        }
 else         if (Constants.SSL_PROTO_TLSv1_2.equalsIgnoreCase(protocol)) {
          value|=SSL.SSL_PROTOCOL_TLSV1_2;
        }
 else {
          throw new Exception(sm.getString("endpoint.apr.invalidSslProtocol",SSLProtocol));
        }
      }
    }
    try {
      sslContext=SSLContext.make(rootPool,value,SSL.SSL_MODE_SERVER);
    }
 catch (    Exception e) {
      throw new Exception(sm.getString("endpoint.apr.failSslContextMake"),e);
    }
    if (SSLInsecureRenegotiation) {
      boolean legacyRenegSupported=false;
      try {
        legacyRenegSupported=SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
        if (legacyRenegSupported)         SSLContext.setOptions(sslContext,SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
      }
 catch (      UnsatisfiedLinkError e) {
      }
      if (!legacyRenegSupported) {
        log.warn(sm.getString("endpoint.warn.noInsecureReneg",SSL.versionString()));
      }
    }
    if (SSLHonorCipherOrder) {
      boolean orderCiphersSupported=false;
      try {
        orderCiphersSupported=SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
        if (orderCiphersSupported)         SSLContext.setOptions(sslContext,SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
      }
 catch (      UnsatisfiedLinkError e) {
      }
      if (!orderCiphersSupported) {
        log.warn(sm.getString("endpoint.warn.noHonorCipherOrder",SSL.versionString()));
      }
    }
    if (SSLDisableCompression) {
      boolean disableCompressionSupported=false;
      try {
        disableCompressionSupported=SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);
        if (disableCompressionSupported)         SSLContext.setOptions(sslContext,SSL.SSL_OP_NO_COMPRESSION);
      }
 catch (      UnsatisfiedLinkError e) {
      }
      if (!disableCompressionSupported) {
        log.warn(sm.getString("endpoint.warn.noDisableCompression",SSL.versionString()));
      }
    }
    SSLContext.setCipherSuite(sslContext,SSLCipherSuite);
    SSLContext.setCertificate(sslContext,SSLCertificateFile,SSLCertificateKeyFile,SSLPassword,SSL.SSL_AIDX_RSA);
    SSLContext.setCertificateChainFile(sslContext,SSLCertificateChainFile,false);
    SSLContext.setCACertificate(sslContext,SSLCACertificateFile,SSLCACertificatePath);
    SSLContext.setCARevocation(sslContext,SSLCARevocationFile,SSLCARevocationPath);
    value=SSL.SSL_CVERIFY_NONE;
    if ("optional".equalsIgnoreCase(SSLVerifyClient)) {
      value=SSL.SSL_CVERIFY_OPTIONAL;
    }
 else     if ("require".equalsIgnoreCase(SSLVerifyClient)) {
      value=SSL.SSL_CVERIFY_REQUIRE;
    }
 else     if ("optionalNoCA".equalsIgnoreCase(SSLVerifyClient)) {
      value=SSL.SSL_CVERIFY_OPTIONAL_NO_CA;
    }
    SSLContext.setVerify(sslContext,value,SSLVerifyDepth);
    useSendfile=false;
  }
}

ID 4295=========================================================================type: 1
Method:org.apache.tomcat.util.net.AprEndpoint#setSocketOptions(long)
Rmethod: org.apache.tomcat.jni.SSLSocket#attach(long, long)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process the specified connection.
 */
protected boolean setSocketOptions(long socket){
  int step=1;
  try {
    if (socketProperties.getSoLingerOn() && socketProperties.getSoLingerTime() >= 0)     Socket.optSet(socket,Socket.APR_SO_LINGER,socketProperties.getSoLingerTime());
    if (socketProperties.getTcpNoDelay())     Socket.optSet(socket,Socket.APR_TCP_NODELAY,(socketProperties.getTcpNoDelay() ? 1 : 0));
    Socket.timeoutSet(socket,socketProperties.getSoTimeout() * 1000);
    step=2;
    if (sslContext != 0) {
      SSLSocket.attach(sslContext,socket);
      if (SSLSocket.handshake(socket) != 0) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("endpoint.err.handshake") + ": " + SSL.getLastError());
        }
        return false;
      }
    }
  }
 catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    if (log.isDebugEnabled()) {
      if (step == 2) {
        log.debug(sm.getString("endpoint.err.handshake"),t);
      }
 else {
        log.debug(sm.getString("endpoint.err.unexpected"),t);
      }
    }
    return false;
  }
  return true;
}

ID 4298=========================================================================type: 1
Method:org.apache.tomcat.util.net.Acceptor#run()
Rmethod: org.apache.tomcat.jni.Socket#accept(long)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  int errorDelay=0;
  while (running) {
    while (paused && running) {
      state=AcceptorState.PAUSED;
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
      }
    }
    if (!running) {
      break;
    }
    state=AcceptorState.RUNNING;
    try {
      countUpOrAwaitConnection();
      long socket=0;
      try {
        socket=Socket.accept(serverSock);
        if (log.isDebugEnabled()) {
          long sa=Address.get(Socket.APR_REMOTE,socket);
          Sockaddr addr=Address.getInfo(sa);
          log.debug(sm.getString("endpoint.apr.remoteport",Long.valueOf(socket),Long.valueOf(addr.port)));
        }
      }
 catch (      Exception e) {
        countDownConnection();
        errorDelay=handleExceptionWithDelay(errorDelay);
        throw e;
      }
      errorDelay=0;
      if (running && !paused) {
        if (!processSocketWithOptions(socket)) {
          closeSocket(socket);
        }
      }
 else {
        destroySocket(socket);
      }
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      if (running) {
        String msg=sm.getString("endpoint.accept.fail");
        if (t instanceof Error) {
          Error e=(Error)t;
          if (e.getError() == 233) {
            log.warn(msg,t);
          }
 else {
            log.error(msg,t);
          }
        }
 else {
          log.error(msg,t);
        }
      }
    }
  }
  state=AcceptorState.ENDED;
}

ID 4299=========================================================================type: 1
Method:org.apache.tomcat.util.net.Acceptor#run()
Rmethod: org.apache.tomcat.jni.Address#get(int, long)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  int errorDelay=0;
  while (running) {
    while (paused && running) {
      state=AcceptorState.PAUSED;
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
      }
    }
    if (!running) {
      break;
    }
    state=AcceptorState.RUNNING;
    try {
      countUpOrAwaitConnection();
      long socket=0;
      try {
        socket=Socket.accept(serverSock);
        if (log.isDebugEnabled()) {
          long sa=Address.get(Socket.APR_REMOTE,socket);
          Sockaddr addr=Address.getInfo(sa);
          log.debug(sm.getString("endpoint.apr.remoteport",Long.valueOf(socket),Long.valueOf(addr.port)));
        }
      }
 catch (      Exception e) {
        countDownConnection();
        errorDelay=handleExceptionWithDelay(errorDelay);
        throw e;
      }
      errorDelay=0;
      if (running && !paused) {
        if (!processSocketWithOptions(socket)) {
          closeSocket(socket);
        }
      }
 else {
        destroySocket(socket);
      }
    }
 catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      if (running) {
        String msg=sm.getString("endpoint.accept.fail");
        if (t instanceof Error) {
          Error e=(Error)t;
          if (e.getError() == 233) {
            log.warn(msg,t);
          }
 else {
            log.error(msg,t);
          }
        }
 else {
          log.error(msg,t);
        }
      }
    }
  }
  state=AcceptorState.ENDED;
}

ID 4305=========================================================================type: 1
Method:org.apache.tomcat.util.net.Sendfile#add(org.apache.tomcat.util.net.AprEndpoint.SendfileData)
Rmethod: org.apache.tomcat.jni.Socket#pool(long)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Add the sendfile data to the sendfile poller. Note that in most cases, the initial non blocking calls to sendfile will return right away, and will be handled asynchronously inside the kernel. As a result, the poller will never be used.
 * @param data containing the reference to the data which should be snet
 * @return true if all the data has been sent right away, and falseotherwise
 */
public boolean add(SendfileData data){
  try {
    data.fdpool=Socket.pool(data.socket);
    data.fd=File.open(data.fileName,File.APR_FOPEN_READ | File.APR_FOPEN_SENDFILE_ENABLED | File.APR_FOPEN_BINARY,0,data.fdpool);
    data.pos=data.start;
    Socket.timeoutSet(data.socket,0);
    while (true) {
      long nw=Socket.sendfilen(data.socket,data.fd,data.pos,data.end - data.pos,0);
      if (nw < 0) {
        if (!(-nw == Status.EAGAIN)) {
          Pool.destroy(data.fdpool);
          data.socket=0;
          return false;
        }
 else {
          break;
        }
      }
 else {
        data.pos=data.pos + nw;
        if (data.pos >= data.end) {
          Pool.destroy(data.fdpool);
          Socket.timeoutSet(data.socket,getSoTimeout() * 1000);
          return true;
        }
      }
    }
  }
 catch (  Exception e) {
    log.warn(sm.getString("endpoint.sendfile.error"),e);
    return false;
  }
synchronized (this) {
    addS.add(data);
    this.notify();
  }
  return false;
}

ID 4324=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#JSSESocketFactory(AbstractEndpoint<?>)
Rmethod: javax.net.ssl.SSLContext#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
public JSSESocketFactory(AbstractEndpoint<?> endpoint){
  this.endpoint=endpoint;
  String sslProtocol=endpoint.getSslProtocol();
  if (sslProtocol == null) {
    sslProtocol=defaultProtocol;
  }
  SSLContext context;
  try {
    context=SSLContext.getInstance(sslProtocol);
    context.init(null,null,null);
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalArgumentException(e);
  }
catch (  KeyManagementException e) {
    throw new IllegalArgumentException(e);
  }
  SSLServerSocketFactory ssf=context.getServerSocketFactory();
  String supportedCiphers[]=ssf.getSupportedCipherSuites();
  boolean found=false;
  for (  String cipher : supportedCiphers) {
    if ("TLS_EMPTY_RENEGOTIATION_INFO_SCSV".equals(cipher)) {
      found=true;
      break;
    }
  }
  rfc5746Supported=found;
  SSLServerSocket socket;
  try {
    socket=(SSLServerSocket)ssf.createServerSocket();
  }
 catch (  IOException e) {
    defaultServerCipherSuites=new String[0];
    defaultServerProtocols=new String[0];
    log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    return;
  }
  try {
    List<String> filteredCiphers=new ArrayList<String>();
    for (    String cipher : socket.getEnabledCipherSuites()) {
      if (cipher.toUpperCase(Locale.ENGLISH).contains("EXP")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_DES_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_RC4_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (!JreCompat.isJre8Available() && cipher.toUpperCase(Locale.ENGLISH).contains("_DHE_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (JreCompat.isJre7Available() && (cipher.toUpperCase(Locale.ENGLISH).startsWith("TLS_RSA_") || cipher.toUpperCase(Locale.ENGLISH).startsWith("SSL_RSA_"))) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      filteredCiphers.add(cipher);
    }
    defaultServerCipherSuites=filteredCiphers.toArray(new String[filteredCiphers.size()]);
    if (defaultServerCipherSuites.length == 0) {
      log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    }
    List<String> filteredProtocols=new ArrayList<String>();
    for (    String protocol : socket.getEnabledProtocols()) {
      if (protocol.toUpperCase(Locale.ENGLISH).contains("SSL")) {
        log.debug(sm.getString("jsse.excludeDefaultProtocol",protocol));
        continue;
      }
      filteredProtocols.add(protocol);
    }
    defaultServerProtocols=filteredProtocols.toArray(new String[filteredProtocols.size()]);
    if (defaultServerProtocols.length == 0) {
      log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    }
  }
  finally {
    try {
      socket.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("jsse.exceptionOnClose"),e);
    }
  }
}

ID 4325=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#JSSESocketFactory(AbstractEndpoint<?>)
Rmethod: javax.net.ssl.SSLContext#init(javax.net.ssl.KeyManager[], javax.net.ssl.TrustManager[], java.security.SecureRandom)
parentException: KeyException GeneralSecurityException 
thrown: KeyManagementException
exception comment: /** 
 * This is the general key management exception for all operations dealing with key management. Examples of subclasses of KeyManagementException that developers might create for giving more detailed information could include: <ul> <li>KeyIDConflictException <li>KeyAuthorizationFailureException <li>ExpiredKeyException </ul>
 * @author Benjamin Renaud
 * @see Key
 * @see KeyException
 */

block: 
public JSSESocketFactory(AbstractEndpoint<?> endpoint){
  this.endpoint=endpoint;
  String sslProtocol=endpoint.getSslProtocol();
  if (sslProtocol == null) {
    sslProtocol=defaultProtocol;
  }
  SSLContext context;
  try {
    context=SSLContext.getInstance(sslProtocol);
    context.init(null,null,null);
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalArgumentException(e);
  }
catch (  KeyManagementException e) {
    throw new IllegalArgumentException(e);
  }
  SSLServerSocketFactory ssf=context.getServerSocketFactory();
  String supportedCiphers[]=ssf.getSupportedCipherSuites();
  boolean found=false;
  for (  String cipher : supportedCiphers) {
    if ("TLS_EMPTY_RENEGOTIATION_INFO_SCSV".equals(cipher)) {
      found=true;
      break;
    }
  }
  rfc5746Supported=found;
  SSLServerSocket socket;
  try {
    socket=(SSLServerSocket)ssf.createServerSocket();
  }
 catch (  IOException e) {
    defaultServerCipherSuites=new String[0];
    defaultServerProtocols=new String[0];
    log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    return;
  }
  try {
    List<String> filteredCiphers=new ArrayList<String>();
    for (    String cipher : socket.getEnabledCipherSuites()) {
      if (cipher.toUpperCase(Locale.ENGLISH).contains("EXP")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_DES_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_RC4_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (!JreCompat.isJre8Available() && cipher.toUpperCase(Locale.ENGLISH).contains("_DHE_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (JreCompat.isJre7Available() && (cipher.toUpperCase(Locale.ENGLISH).startsWith("TLS_RSA_") || cipher.toUpperCase(Locale.ENGLISH).startsWith("SSL_RSA_"))) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      filteredCiphers.add(cipher);
    }
    defaultServerCipherSuites=filteredCiphers.toArray(new String[filteredCiphers.size()]);
    if (defaultServerCipherSuites.length == 0) {
      log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    }
    List<String> filteredProtocols=new ArrayList<String>();
    for (    String protocol : socket.getEnabledProtocols()) {
      if (protocol.toUpperCase(Locale.ENGLISH).contains("SSL")) {
        log.debug(sm.getString("jsse.excludeDefaultProtocol",protocol));
        continue;
      }
      filteredProtocols.add(protocol);
    }
    defaultServerProtocols=filteredProtocols.toArray(new String[filteredProtocols.size()]);
    if (defaultServerProtocols.length == 0) {
      log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    }
  }
  finally {
    try {
      socket.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("jsse.exceptionOnClose"),e);
    }
  }
}

ID 4326=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#JSSESocketFactory(AbstractEndpoint<?>)
Rmethod: javax.net.ServerSocketFactory#createServerSocket()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public JSSESocketFactory(AbstractEndpoint<?> endpoint){
  this.endpoint=endpoint;
  String sslProtocol=endpoint.getSslProtocol();
  if (sslProtocol == null) {
    sslProtocol=defaultProtocol;
  }
  SSLContext context;
  try {
    context=SSLContext.getInstance(sslProtocol);
    context.init(null,null,null);
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalArgumentException(e);
  }
catch (  KeyManagementException e) {
    throw new IllegalArgumentException(e);
  }
  SSLServerSocketFactory ssf=context.getServerSocketFactory();
  String supportedCiphers[]=ssf.getSupportedCipherSuites();
  boolean found=false;
  for (  String cipher : supportedCiphers) {
    if ("TLS_EMPTY_RENEGOTIATION_INFO_SCSV".equals(cipher)) {
      found=true;
      break;
    }
  }
  rfc5746Supported=found;
  SSLServerSocket socket;
  try {
    socket=(SSLServerSocket)ssf.createServerSocket();
  }
 catch (  IOException e) {
    defaultServerCipherSuites=new String[0];
    defaultServerProtocols=new String[0];
    log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    return;
  }
  try {
    List<String> filteredCiphers=new ArrayList<String>();
    for (    String cipher : socket.getEnabledCipherSuites()) {
      if (cipher.toUpperCase(Locale.ENGLISH).contains("EXP")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_DES_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_RC4_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (!JreCompat.isJre8Available() && cipher.toUpperCase(Locale.ENGLISH).contains("_DHE_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (JreCompat.isJre7Available() && (cipher.toUpperCase(Locale.ENGLISH).startsWith("TLS_RSA_") || cipher.toUpperCase(Locale.ENGLISH).startsWith("SSL_RSA_"))) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      filteredCiphers.add(cipher);
    }
    defaultServerCipherSuites=filteredCiphers.toArray(new String[filteredCiphers.size()]);
    if (defaultServerCipherSuites.length == 0) {
      log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    }
    List<String> filteredProtocols=new ArrayList<String>();
    for (    String protocol : socket.getEnabledProtocols()) {
      if (protocol.toUpperCase(Locale.ENGLISH).contains("SSL")) {
        log.debug(sm.getString("jsse.excludeDefaultProtocol",protocol));
        continue;
      }
      filteredProtocols.add(protocol);
    }
    defaultServerProtocols=filteredProtocols.toArray(new String[filteredProtocols.size()]);
    if (defaultServerProtocols.length == 0) {
      log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    }
  }
  finally {
    try {
      socket.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("jsse.exceptionOnClose"),e);
    }
  }
}

ID 4327=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#JSSESocketFactory(AbstractEndpoint<?>)
Rmethod: java.net.ServerSocket#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public JSSESocketFactory(AbstractEndpoint<?> endpoint){
  this.endpoint=endpoint;
  String sslProtocol=endpoint.getSslProtocol();
  if (sslProtocol == null) {
    sslProtocol=defaultProtocol;
  }
  SSLContext context;
  try {
    context=SSLContext.getInstance(sslProtocol);
    context.init(null,null,null);
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalArgumentException(e);
  }
catch (  KeyManagementException e) {
    throw new IllegalArgumentException(e);
  }
  SSLServerSocketFactory ssf=context.getServerSocketFactory();
  String supportedCiphers[]=ssf.getSupportedCipherSuites();
  boolean found=false;
  for (  String cipher : supportedCiphers) {
    if ("TLS_EMPTY_RENEGOTIATION_INFO_SCSV".equals(cipher)) {
      found=true;
      break;
    }
  }
  rfc5746Supported=found;
  SSLServerSocket socket;
  try {
    socket=(SSLServerSocket)ssf.createServerSocket();
  }
 catch (  IOException e) {
    defaultServerCipherSuites=new String[0];
    defaultServerProtocols=new String[0];
    log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    return;
  }
  try {
    List<String> filteredCiphers=new ArrayList<String>();
    for (    String cipher : socket.getEnabledCipherSuites()) {
      if (cipher.toUpperCase(Locale.ENGLISH).contains("EXP")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_DES_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (cipher.toUpperCase(Locale.ENGLISH).contains("_RC4_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (!JreCompat.isJre8Available() && cipher.toUpperCase(Locale.ENGLISH).contains("_DHE_")) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      if (JreCompat.isJre7Available() && (cipher.toUpperCase(Locale.ENGLISH).startsWith("TLS_RSA_") || cipher.toUpperCase(Locale.ENGLISH).startsWith("SSL_RSA_"))) {
        log.debug(sm.getString("jsse.excludeDefaultCipher",cipher));
        continue;
      }
      filteredCiphers.add(cipher);
    }
    defaultServerCipherSuites=filteredCiphers.toArray(new String[filteredCiphers.size()]);
    if (defaultServerCipherSuites.length == 0) {
      log.warn(sm.getString("jsse.noDefaultCiphers",endpoint.getName()));
    }
    List<String> filteredProtocols=new ArrayList<String>();
    for (    String protocol : socket.getEnabledProtocols()) {
      if (protocol.toUpperCase(Locale.ENGLISH).contains("SSL")) {
        log.debug(sm.getString("jsse.excludeDefaultProtocol",protocol));
        continue;
      }
      filteredProtocols.add(protocol);
    }
    defaultServerProtocols=filteredProtocols.toArray(new String[filteredProtocols.size()]);
    if (defaultServerProtocols.length == 0) {
      log.warn(sm.getString("jsse.noDefaultProtocols",endpoint.getName()));
    }
  }
  finally {
    try {
      socket.close();
    }
 catch (    IOException e) {
      log.warn(sm.getString("jsse.exceptionOnClose"),e);
    }
  }
}

ID 4340=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#getStore(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
Rmethod: org.apache.tomcat.util.file.ConfigFileLoader#getInputStream(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private KeyStore getStore(String type,String provider,String path,String pass) throws IOException {
  KeyStore ks=null;
  InputStream istream=null;
  try {
    if (provider == null) {
      ks=KeyStore.getInstance(type);
    }
 else {
      ks=KeyStore.getInstance(type,provider);
    }
    if (!("PKCS11".equalsIgnoreCase(type) || "".equalsIgnoreCase(path))) {
      istream=ConfigFileLoader.getInputStream(path);
    }
    char[] storePass=null;
    if (pass != null && !"".equals(pass)) {
      storePass=pass.toCharArray();
    }
    ks.load(istream,storePass);
  }
 catch (  FileNotFoundException fnfe) {
    log.error(sm.getString("jsse.keystore_load_failed",type,path,fnfe.getMessage()),fnfe);
    throw fnfe;
  }
catch (  IOException ioe) {
    throw ioe;
  }
catch (  Exception ex) {
    String msg=sm.getString("jsse.keystore_load_failed",type,path,ex.getMessage());
    log.error(msg,ex);
    throw new IOException(msg);
  }
 finally {
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
  return ks;
}

ID 4341=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#getStore(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
Rmethod: java.security.KeyStore#load(java.io.InputStream, char[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private KeyStore getStore(String type,String provider,String path,String pass) throws IOException {
  KeyStore ks=null;
  InputStream istream=null;
  try {
    if (provider == null) {
      ks=KeyStore.getInstance(type);
    }
 else {
      ks=KeyStore.getInstance(type,provider);
    }
    if (!("PKCS11".equalsIgnoreCase(type) || "".equalsIgnoreCase(path))) {
      istream=ConfigFileLoader.getInputStream(path);
    }
    char[] storePass=null;
    if (pass != null && !"".equals(pass)) {
      storePass=pass.toCharArray();
    }
    ks.load(istream,storePass);
  }
 catch (  FileNotFoundException fnfe) {
    log.error(sm.getString("jsse.keystore_load_failed",type,path,fnfe.getMessage()),fnfe);
    throw fnfe;
  }
catch (  IOException ioe) {
    throw ioe;
  }
catch (  Exception ex) {
    String msg=sm.getString("jsse.keystore_load_failed",type,path,ex.getMessage());
    log.error(msg,ex);
    throw new IOException(msg);
  }
 finally {
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
  return ks;
}

ID 4345=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#init()
Rmethod: org.apache.tomcat.util.net.jsse.JSSESocketFactory#createSSLContext()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Reads the keystore and initializes the SSL socket factory.
 */
void init() throws IOException {
  try {
    String clientAuthStr=endpoint.getClientAuth();
    if ("true".equalsIgnoreCase(clientAuthStr) || "yes".equalsIgnoreCase(clientAuthStr)) {
      requireClientAuth=true;
    }
 else     if ("want".equalsIgnoreCase(clientAuthStr)) {
      wantClientAuth=true;
    }
    SSLContext context=createSSLContext();
    context.init(getKeyManagers(),getTrustManagers(),null);
    SSLSessionContext sessionContext=context.getServerSessionContext();
    if (sessionContext != null) {
      configureSessionContext(sessionContext);
    }
    sslProxy=context.getServerSocketFactory();
    enabledCiphers=getEnableableCiphers(context);
    enabledProtocols=getEnableableProtocols(context);
    allowUnsafeLegacyRenegotiation="true".equals(endpoint.getAllowUnsafeLegacyRenegotiation());
    checkConfig();
  }
 catch (  Exception e) {
    if (e instanceof IOException)     throw (IOException)e;
    throw new IOException(e.getMessage(),e);
  }
}

ID 4346=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#init()
Rmethod: org.apache.tomcat.util.net.jsse.JSSESocketFactory#getKeyManagers()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Reads the keystore and initializes the SSL socket factory.
 */
void init() throws IOException {
  try {
    String clientAuthStr=endpoint.getClientAuth();
    if ("true".equalsIgnoreCase(clientAuthStr) || "yes".equalsIgnoreCase(clientAuthStr)) {
      requireClientAuth=true;
    }
 else     if ("want".equalsIgnoreCase(clientAuthStr)) {
      wantClientAuth=true;
    }
    SSLContext context=createSSLContext();
    context.init(getKeyManagers(),getTrustManagers(),null);
    SSLSessionContext sessionContext=context.getServerSessionContext();
    if (sessionContext != null) {
      configureSessionContext(sessionContext);
    }
    sslProxy=context.getServerSocketFactory();
    enabledCiphers=getEnableableCiphers(context);
    enabledProtocols=getEnableableProtocols(context);
    allowUnsafeLegacyRenegotiation="true".equals(endpoint.getAllowUnsafeLegacyRenegotiation());
    checkConfig();
  }
 catch (  Exception e) {
    if (e instanceof IOException)     throw (IOException)e;
    throw new IOException(e.getMessage(),e);
  }
}

ID 4347=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#init()
Rmethod: org.apache.tomcat.util.net.jsse.JSSESocketFactory#getTrustManagers()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Reads the keystore and initializes the SSL socket factory.
 */
void init() throws IOException {
  try {
    String clientAuthStr=endpoint.getClientAuth();
    if ("true".equalsIgnoreCase(clientAuthStr) || "yes".equalsIgnoreCase(clientAuthStr)) {
      requireClientAuth=true;
    }
 else     if ("want".equalsIgnoreCase(clientAuthStr)) {
      wantClientAuth=true;
    }
    SSLContext context=createSSLContext();
    context.init(getKeyManagers(),getTrustManagers(),null);
    SSLSessionContext sessionContext=context.getServerSessionContext();
    if (sessionContext != null) {
      configureSessionContext(sessionContext);
    }
    sslProxy=context.getServerSocketFactory();
    enabledCiphers=getEnableableCiphers(context);
    enabledProtocols=getEnableableProtocols(context);
    allowUnsafeLegacyRenegotiation="true".equals(endpoint.getAllowUnsafeLegacyRenegotiation());
    checkConfig();
  }
 catch (  Exception e) {
    if (e instanceof IOException)     throw (IOException)e;
    throw new IOException(e.getMessage(),e);
  }
}

ID 4375=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#getCRLs(java.lang.String)
Rmethod: java.security.cert.CertificateFactory#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: CertificateException
exception comment: /** 
 * This exception indicates one of a variety of certificate problems. <p><em>Note: The classes in the package  {@code javax.security.cert}exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE). New applications should instead use the standard Java SE certificate classes located in {@code java.security.cert}.</em></p>
 * @author Hemma Prafullchandra
 * @since 1.4
 * @see Certificate
 */

block: 
/** 
 * Load the collection of CRLs.
 */
protected Collection<? extends CRL> getCRLs(String crlf) throws IOException, CRLException, CertificateException {
  Collection<? extends CRL> crls=null;
  InputStream is=null;
  try {
    CertificateFactory cf=CertificateFactory.getInstance("X.509");
    is=ConfigFileLoader.getInputStream(crlf);
    crls=cf.generateCRLs(is);
  }
 catch (  IOException iex) {
    throw iex;
  }
catch (  CRLException crle) {
    throw crle;
  }
catch (  CertificateException ce) {
    throw ce;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      Exception ex) {
      }
    }
  }
  return crls;
}

ID 4376=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#getCRLs(java.lang.String)
Rmethod: org.apache.tomcat.util.file.ConfigFileLoader#getInputStream(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Load the collection of CRLs.
 */
protected Collection<? extends CRL> getCRLs(String crlf) throws IOException, CRLException, CertificateException {
  Collection<? extends CRL> crls=null;
  InputStream is=null;
  try {
    CertificateFactory cf=CertificateFactory.getInstance("X.509");
    is=ConfigFileLoader.getInputStream(crlf);
    crls=cf.generateCRLs(is);
  }
 catch (  IOException iex) {
    throw iex;
  }
catch (  CRLException crle) {
    throw crle;
  }
catch (  CertificateException ce) {
    throw ce;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      Exception ex) {
      }
    }
  }
  return crls;
}

ID 4377=========================================================================type: 1
Method:org.apache.tomcat.util.net.jsse.JSSESocketFactory#getCRLs(java.lang.String)
Rmethod: java.security.cert.CertificateFactory#generateCRLs(java.io.InputStream)
parentException: GeneralSecurityException 
thrown: CRLException
exception comment: /** 
 * CRL (Certificate Revocation List) Exception.
 * @author Hemma Prafullchandra
 */

block: 
/** 
 * Load the collection of CRLs.
 */
protected Collection<? extends CRL> getCRLs(String crlf) throws IOException, CRLException, CertificateException {
  Collection<? extends CRL> crls=null;
  InputStream is=null;
  try {
    CertificateFactory cf=CertificateFactory.getInstance("X.509");
    is=ConfigFileLoader.getInputStream(crlf);
    crls=cf.generateCRLs(is);
  }
 catch (  IOException iex) {
    throw iex;
  }
catch (  CRLException crle) {
    throw crle;
  }
catch (  CertificateException ce) {
    throw ce;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      Exception ex) {
      }
    }
  }
  return crls;
}

ID 4420=========================================================================type: 1
Method:org.apache.tomcat.util.net.Acceptor#run()
Rmethod: java.nio.channels.ServerSocketChannel#accept()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  int errorDelay=0;
  while (running) {
    while (paused && running) {
      state=AcceptorState.PAUSED;
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
      }
    }
    if (!running) {
      break;
    }
    state=AcceptorState.RUNNING;
    try {
      countUpOrAwaitConnection();
      SocketChannel socket=null;
      try {
        socket=serverSock.accept();
      }
 catch (      IOException ioe) {
        countDownConnection();
        errorDelay=handleExceptionWithDelay(errorDelay);
        throw ioe;
      }
      errorDelay=0;
      if (running && !paused) {
        if (!setSocketOptions(socket)) {
          countDownConnection();
          closeSocket(socket);
        }
      }
 else {
        countDownConnection();
        closeSocket(socket);
      }
    }
 catch (    SocketTimeoutException sx) {
    }
catch (    IOException x) {
      if (running) {
        log.error(sm.getString("endpoint.accept.fail"),x);
      }
    }
catch (    OutOfMemoryError oom) {
      try {
        oomParachuteData=null;
        releaseCaches();
        log.error("",oom);
      }
 catch (      Throwable oomt) {
        try {
          try {
            System.err.println(oomParachuteMsg);
            oomt.printStackTrace();
          }
 catch (          Throwable letsHopeWeDontGetHere) {
            ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
          }
        }
 catch (        Throwable letsHopeWeDontGetHere) {
          ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
        }
      }
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.error(sm.getString("endpoint.accept.fail"),t);
    }
  }
  state=AcceptorState.ENDED;
}

ID 4421=========================================================================type: 1
Method:org.apache.tomcat.util.net.NioEndpoint#closeSocket(java.nio.channels.SocketChannel)
Rmethod: java.net.Socket#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void closeSocket(SocketChannel socket){
  try {
    socket.socket().close();
  }
 catch (  IOException ioe) {
    if (log.isDebugEnabled()) {
      log.debug("",ioe);
    }
  }
  try {
    socket.close();
  }
 catch (  IOException ioe) {
    if (log.isDebugEnabled()) {
      log.debug("",ioe);
    }
  }
}

ID 4422=========================================================================type: 1
Method:org.apache.tomcat.util.net.NioEndpoint#closeSocket(java.nio.channels.SocketChannel)
Rmethod: java.nio.channels.spi.AbstractInterruptibleChannel#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void closeSocket(SocketChannel socket){
  try {
    socket.socket().close();
  }
 catch (  IOException ioe) {
    if (log.isDebugEnabled()) {
      log.debug("",ioe);
    }
  }
  try {
    socket.close();
  }
 catch (  IOException ioe) {
    if (log.isDebugEnabled()) {
      log.debug("",ioe);
    }
  }
}

ID 4428=========================================================================type: 1
Method:org.apache.tomcat.util.net.Poller#run()
Rmethod: java.nio.channels.Selector#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * The background thread that listens for incoming TCP/IP connections and hands them off to an appropriate processor.
 */
@Override public void run(){
  while (true) {
    try {
      while (paused && (!close)) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
        }
      }
      boolean hasEvents=false;
      if (close) {
        events();
        timeout(0,false);
        try {
          selector.close();
        }
 catch (        IOException ioe) {
          log.error(sm.getString("endpoint.nio.selectorCloseFail"),ioe);
        }
        break;
      }
 else {
        hasEvents=events();
      }
      try {
        if (!close) {
          if (wakeupCounter.getAndSet(-1) > 0) {
            keyCount=selector.selectNow();
          }
 else {
            keyCount=selector.select(selectorTimeout);
          }
          wakeupCounter.set(0);
        }
        if (close) {
          events();
          timeout(0,false);
          try {
            selector.close();
          }
 catch (          IOException ioe) {
            log.error(sm.getString("endpoint.nio.selectorCloseFail"),ioe);
          }
          break;
        }
      }
 catch (      NullPointerException x) {
        if (log.isDebugEnabled())         log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5",x);
        if (wakeupCounter == null || selector == null)         throw x;
        continue;
      }
catch (      CancelledKeyException x) {
        if (log.isDebugEnabled())         log.debug("Possibly encountered sun bug 5076772 on windows JDK 1.5",x);
        if (wakeupCounter == null || selector == null)         throw x;
        continue;
      }
catch (      Throwable x) {
        ExceptionUtils.handleThrowable(x);
        log.error("",x);
        continue;
      }
      if (keyCount == 0)       hasEvents=(hasEvents | events());
      Iterator<SelectionKey> iterator=keyCount > 0 ? selector.selectedKeys().iterator() : null;
      while (iterator != null && iterator.hasNext()) {
        SelectionKey sk=iterator.next();
        KeyAttachment attachment=(KeyAttachment)sk.attachment();
        if (attachment == null) {
          iterator.remove();
        }
 else {
          attachment.access();
          iterator.remove();
          processKey(sk,attachment);
        }
      }
      timeout(keyCount,hasEvents);
      if (oomParachute > 0 && oomParachuteData == null)       checkParachute();
    }
 catch (    OutOfMemoryError oom) {
      try {
        oomParachuteData=null;
        releaseCaches();
        log.error("",oom);
      }
 catch (      Throwable oomt) {
        try {
          System.err.println(oomParachuteMsg);
          oomt.printStackTrace();
        }
 catch (        Throwable letsHopeWeDontGetHere) {
          ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
        }
      }
    }
  }
synchronized (this) {
    this.notifyAll();
  }
  stopLatch.countDown();
}

ID 4431=========================================================================type: 1
Method:org.apache.tomcat.util.net.Poller#processSendfile(java.nio.channels.SelectionKey, org.apache.tomcat.util.net.NioEndpoint.KeyAttachment, boolean)
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public SendfileState processSendfile(SelectionKey sk,KeyAttachment attachment,boolean calledByProcessor){
  NioChannel sc=null;
  try {
    unreg(sk,attachment,sk.readyOps());
    SendfileData sd=attachment.getSendfileData();
    if (log.isTraceEnabled()) {
      log.trace("Processing send file for: " + sd.fileName);
    }
    if (sd.fchannel == null) {
      File f=new File(sd.fileName);
      if (!f.exists()) {
        cancelledKey(sk,SocketStatus.ERROR,false);
        return SendfileState.ERROR;
      }
      @SuppressWarnings("resource") FileInputStream fis=new FileInputStream(f);
      sd.fchannel=fis.getChannel();
    }
    sc=attachment.getChannel();
    WritableByteChannel wc=((sc instanceof SecureNioChannel) ? sc : sc.getIOChannel());
    if (sc.getOutboundRemaining() > 0) {
      if (sc.flushOutbound()) {
        attachment.access();
      }
    }
 else {
      long written=sd.fchannel.transferTo(sd.pos,sd.length,wc);
      if (written > 0) {
        sd.pos+=written;
        sd.length-=written;
        attachment.access();
      }
 else {
        if (sd.fchannel.size() <= sd.pos) {
          throw new IOException("Sendfile configured to " + "send more data than was available");
        }
      }
    }
    if (sd.length <= 0 && sc.getOutboundRemaining() <= 0) {
      if (log.isDebugEnabled()) {
        log.debug("Send file complete for: " + sd.fileName);
      }
      attachment.setSendfileData(null);
      try {
        sd.fchannel.close();
      }
 catch (      Exception ignore) {
      }
      if (!calledByProcessor) {
        if (sd.keepAlive) {
          if (log.isDebugEnabled()) {
            log.debug("Connection is keep alive, registering back for OP_READ");
          }
          reg(sk,attachment,SelectionKey.OP_READ);
        }
 else {
          if (log.isDebugEnabled()) {
            log.debug("Send file connection is being closed");
          }
          cancelledKey(sk,SocketStatus.STOP,false);
        }
      }
      return SendfileState.DONE;
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("OP_WRITE for sendfile: " + sd.fileName);
      }
      if (calledByProcessor) {
        add(attachment.getChannel(),SelectionKey.OP_WRITE);
      }
 else {
        reg(sk,attachment,SelectionKey.OP_WRITE);
      }
      return SendfileState.PENDING;
    }
  }
 catch (  IOException x) {
    if (log.isDebugEnabled())     log.debug("Unable to complete sendfile request:",x);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
catch (  Throwable t) {
    log.error("",t);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
}

ID 4432=========================================================================type: 1
Method:org.apache.tomcat.util.net.Poller#processSendfile(java.nio.channels.SelectionKey, org.apache.tomcat.util.net.NioEndpoint.KeyAttachment, boolean)
Rmethod: org.apache.tomcat.util.net.NioChannel#flushOutbound()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public SendfileState processSendfile(SelectionKey sk,KeyAttachment attachment,boolean calledByProcessor){
  NioChannel sc=null;
  try {
    unreg(sk,attachment,sk.readyOps());
    SendfileData sd=attachment.getSendfileData();
    if (log.isTraceEnabled()) {
      log.trace("Processing send file for: " + sd.fileName);
    }
    if (sd.fchannel == null) {
      File f=new File(sd.fileName);
      if (!f.exists()) {
        cancelledKey(sk,SocketStatus.ERROR,false);
        return SendfileState.ERROR;
      }
      @SuppressWarnings("resource") FileInputStream fis=new FileInputStream(f);
      sd.fchannel=fis.getChannel();
    }
    sc=attachment.getChannel();
    WritableByteChannel wc=((sc instanceof SecureNioChannel) ? sc : sc.getIOChannel());
    if (sc.getOutboundRemaining() > 0) {
      if (sc.flushOutbound()) {
        attachment.access();
      }
    }
 else {
      long written=sd.fchannel.transferTo(sd.pos,sd.length,wc);
      if (written > 0) {
        sd.pos+=written;
        sd.length-=written;
        attachment.access();
      }
 else {
        if (sd.fchannel.size() <= sd.pos) {
          throw new IOException("Sendfile configured to " + "send more data than was available");
        }
      }
    }
    if (sd.length <= 0 && sc.getOutboundRemaining() <= 0) {
      if (log.isDebugEnabled()) {
        log.debug("Send file complete for: " + sd.fileName);
      }
      attachment.setSendfileData(null);
      try {
        sd.fchannel.close();
      }
 catch (      Exception ignore) {
      }
      if (!calledByProcessor) {
        if (sd.keepAlive) {
          if (log.isDebugEnabled()) {
            log.debug("Connection is keep alive, registering back for OP_READ");
          }
          reg(sk,attachment,SelectionKey.OP_READ);
        }
 else {
          if (log.isDebugEnabled()) {
            log.debug("Send file connection is being closed");
          }
          cancelledKey(sk,SocketStatus.STOP,false);
        }
      }
      return SendfileState.DONE;
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("OP_WRITE for sendfile: " + sd.fileName);
      }
      if (calledByProcessor) {
        add(attachment.getChannel(),SelectionKey.OP_WRITE);
      }
 else {
        reg(sk,attachment,SelectionKey.OP_WRITE);
      }
      return SendfileState.PENDING;
    }
  }
 catch (  IOException x) {
    if (log.isDebugEnabled())     log.debug("Unable to complete sendfile request:",x);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
catch (  Throwable t) {
    log.error("",t);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
}

ID 4433=========================================================================type: 1
Method:org.apache.tomcat.util.net.Poller#processSendfile(java.nio.channels.SelectionKey, org.apache.tomcat.util.net.NioEndpoint.KeyAttachment, boolean)
Rmethod: java.nio.channels.FileChannel#transferTo(long, long, java.nio.channels.WritableByteChannel)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public SendfileState processSendfile(SelectionKey sk,KeyAttachment attachment,boolean calledByProcessor){
  NioChannel sc=null;
  try {
    unreg(sk,attachment,sk.readyOps());
    SendfileData sd=attachment.getSendfileData();
    if (log.isTraceEnabled()) {
      log.trace("Processing send file for: " + sd.fileName);
    }
    if (sd.fchannel == null) {
      File f=new File(sd.fileName);
      if (!f.exists()) {
        cancelledKey(sk,SocketStatus.ERROR,false);
        return SendfileState.ERROR;
      }
      @SuppressWarnings("resource") FileInputStream fis=new FileInputStream(f);
      sd.fchannel=fis.getChannel();
    }
    sc=attachment.getChannel();
    WritableByteChannel wc=((sc instanceof SecureNioChannel) ? sc : sc.getIOChannel());
    if (sc.getOutboundRemaining() > 0) {
      if (sc.flushOutbound()) {
        attachment.access();
      }
    }
 else {
      long written=sd.fchannel.transferTo(sd.pos,sd.length,wc);
      if (written > 0) {
        sd.pos+=written;
        sd.length-=written;
        attachment.access();
      }
 else {
        if (sd.fchannel.size() <= sd.pos) {
          throw new IOException("Sendfile configured to " + "send more data than was available");
        }
      }
    }
    if (sd.length <= 0 && sc.getOutboundRemaining() <= 0) {
      if (log.isDebugEnabled()) {
        log.debug("Send file complete for: " + sd.fileName);
      }
      attachment.setSendfileData(null);
      try {
        sd.fchannel.close();
      }
 catch (      Exception ignore) {
      }
      if (!calledByProcessor) {
        if (sd.keepAlive) {
          if (log.isDebugEnabled()) {
            log.debug("Connection is keep alive, registering back for OP_READ");
          }
          reg(sk,attachment,SelectionKey.OP_READ);
        }
 else {
          if (log.isDebugEnabled()) {
            log.debug("Send file connection is being closed");
          }
          cancelledKey(sk,SocketStatus.STOP,false);
        }
      }
      return SendfileState.DONE;
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("OP_WRITE for sendfile: " + sd.fileName);
      }
      if (calledByProcessor) {
        add(attachment.getChannel(),SelectionKey.OP_WRITE);
      }
 else {
        reg(sk,attachment,SelectionKey.OP_WRITE);
      }
      return SendfileState.PENDING;
    }
  }
 catch (  IOException x) {
    if (log.isDebugEnabled())     log.debug("Unable to complete sendfile request:",x);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
catch (  Throwable t) {
    log.error("",t);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
}

ID 4434=========================================================================type: 1
Method:org.apache.tomcat.util.net.Poller#processSendfile(java.nio.channels.SelectionKey, org.apache.tomcat.util.net.NioEndpoint.KeyAttachment, boolean)
Rmethod: java.nio.channels.FileChannel#size()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public SendfileState processSendfile(SelectionKey sk,KeyAttachment attachment,boolean calledByProcessor){
  NioChannel sc=null;
  try {
    unreg(sk,attachment,sk.readyOps());
    SendfileData sd=attachment.getSendfileData();
    if (log.isTraceEnabled()) {
      log.trace("Processing send file for: " + sd.fileName);
    }
    if (sd.fchannel == null) {
      File f=new File(sd.fileName);
      if (!f.exists()) {
        cancelledKey(sk,SocketStatus.ERROR,false);
        return SendfileState.ERROR;
      }
      @SuppressWarnings("resource") FileInputStream fis=new FileInputStream(f);
      sd.fchannel=fis.getChannel();
    }
    sc=attachment.getChannel();
    WritableByteChannel wc=((sc instanceof SecureNioChannel) ? sc : sc.getIOChannel());
    if (sc.getOutboundRemaining() > 0) {
      if (sc.flushOutbound()) {
        attachment.access();
      }
    }
 else {
      long written=sd.fchannel.transferTo(sd.pos,sd.length,wc);
      if (written > 0) {
        sd.pos+=written;
        sd.length-=written;
        attachment.access();
      }
 else {
        if (sd.fchannel.size() <= sd.pos) {
          throw new IOException("Sendfile configured to " + "send more data than was available");
        }
      }
    }
    if (sd.length <= 0 && sc.getOutboundRemaining() <= 0) {
      if (log.isDebugEnabled()) {
        log.debug("Send file complete for: " + sd.fileName);
      }
      attachment.setSendfileData(null);
      try {
        sd.fchannel.close();
      }
 catch (      Exception ignore) {
      }
      if (!calledByProcessor) {
        if (sd.keepAlive) {
          if (log.isDebugEnabled()) {
            log.debug("Connection is keep alive, registering back for OP_READ");
          }
          reg(sk,attachment,SelectionKey.OP_READ);
        }
 else {
          if (log.isDebugEnabled()) {
            log.debug("Send file connection is being closed");
          }
          cancelledKey(sk,SocketStatus.STOP,false);
        }
      }
      return SendfileState.DONE;
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug("OP_WRITE for sendfile: " + sd.fileName);
      }
      if (calledByProcessor) {
        add(attachment.getChannel(),SelectionKey.OP_WRITE);
      }
 else {
        reg(sk,attachment,SelectionKey.OP_WRITE);
      }
      return SendfileState.PENDING;
    }
  }
 catch (  IOException x) {
    if (log.isDebugEnabled())     log.debug("Unable to complete sendfile request:",x);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
catch (  Throwable t) {
    log.error("",t);
    cancelledKey(sk,SocketStatus.ERROR,false);
    return SendfileState.ERROR;
  }
}

ID 4439=========================================================================type: 1
Method:org.apache.tomcat.util.net.SocketProcessor#doRun(java.nio.channels.SelectionKey, org.apache.tomcat.util.net.NioEndpoint.KeyAttachment)
Rmethod: org.apache.tomcat.util.net.NioChannel#handshake(boolean, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void doRun(SelectionKey key,KeyAttachment ka){
  try {
    int handshake=-1;
    try {
      if (key != null) {
        if (socket.isHandshakeComplete() || status == SocketStatus.STOP) {
          handshake=0;
        }
 else {
          handshake=socket.handshake(key.isReadable(),key.isWritable());
          status=SocketStatus.OPEN_READ;
        }
      }
    }
 catch (    IOException x) {
      handshake=-1;
      if (log.isDebugEnabled())       log.debug("Error during SSL handshake",x);
    }
catch (    CancelledKeyException ckx) {
      handshake=-1;
    }
    if (handshake == 0) {
      SocketState state=SocketState.OPEN;
      if (status == null) {
        state=handler.process(ka,SocketStatus.OPEN_READ);
      }
 else {
        state=handler.process(ka,status);
      }
      if (state == SocketState.CLOSED) {
        close(ka,socket,key,SocketStatus.ERROR);
      }
    }
 else     if (handshake == -1) {
      close(ka,socket,key,SocketStatus.DISCONNECT);
    }
 else {
      ka.getPoller().add(socket,handshake);
    }
  }
 catch (  CancelledKeyException cx) {
    socket.getPoller().cancelledKey(key,null,false);
  }
catch (  OutOfMemoryError oom) {
    try {
      oomParachuteData=null;
      log.error("",oom);
      if (socket != null) {
        socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
      }
      releaseCaches();
    }
 catch (    Throwable oomt) {
      try {
        System.err.println(oomParachuteMsg);
        oomt.printStackTrace();
      }
 catch (      Throwable letsHopeWeDontGetHere) {
        ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);
      }
    }
  }
catch (  VirtualMachineError vme) {
    ExceptionUtils.handleThrowable(vme);
  }
catch (  Throwable t) {
    log.error("",t);
    if (socket != null) {
      socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
    }
  }
 finally {
    socket=null;
    status=null;
    if (running && !paused) {
      processorCache.offer(this);
    }
  }
}

ID 4440=========================================================================type: 1
Method:org.apache.tomcat.util.net.URL#URL(org.apache.tomcat.util.net.URL, java.lang.String)
Rmethod: org.apache.tomcat.util.net.URL#parse(java.lang.String, int, int)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Create a URL object by parsing a string representation relative to a specified context.  Based on logic from JDK 1.3.1's <code>java.net.URL</code>.
 * @param context URL against which the relative representationis resolved
 * @param spec String representation of the URL (usually relative)
 * @exception MalformedURLException if the string representationcannot be parsed successfully
 */
public URL(URL context,String spec) throws MalformedURLException {
  String original=spec;
  int i, limit, c;
  int start=0;
  String newProtocol=null;
  boolean aRef=false;
  try {
    limit=spec.length();
    while ((limit > 0) && (spec.charAt(limit - 1) <= ' ')) {
      limit--;
    }
    while ((start < limit) && (spec.charAt(start) <= ' ')) {
      start++;
    }
    if (spec.regionMatches(true,start,"url:",0,4)) {
      start+=4;
    }
    if ((start < spec.length()) && (spec.charAt(start) == '#')) {
      aRef=true;
    }
    for (i=start; !aRef && (i < limit); i++) {
      c=spec.charAt(i);
      if (c == ':') {
        String s=spec.substring(start,i).toLowerCase(Locale.ENGLISH);
        newProtocol=s;
        start=i + 1;
        break;
      }
 else       if (c == '#') {
        aRef=true;
      }
 else       if (!isSchemeChar((char)c)) {
        break;
      }
    }
    protocol=newProtocol;
    if ((context != null) && ((newProtocol == null) || newProtocol.equalsIgnoreCase(context.getProtocol()))) {
      if ((context.getPath() != null) && (context.getPath().startsWith("/")))       newProtocol=null;
      if (newProtocol == null) {
        protocol=context.getProtocol();
        authority=context.getAuthority();
        userInfo=context.getUserInfo();
        host=context.getHost();
        port=context.getPort();
        file=context.getFile();
        int question=file.lastIndexOf('?');
        if (question < 0)         path=file;
 else         path=file.substring(0,question);
      }
    }
    if (protocol == null)     throw new MalformedURLException("no protocol: " + original);
    i=spec.indexOf('#',start);
    if (i >= 0) {
      ref=spec.substring(i + 1,limit);
      limit=i;
    }
    parse(spec,start,limit);
    if (context != null)     normalize();
  }
 catch (  MalformedURLException e) {
    throw e;
  }
catch (  Exception e) {
    throw new MalformedURLException(e.toString());
  }
}

ID 4441=========================================================================type: 1
Method:org.apache.tomcat.util.net.URL#URL(org.apache.tomcat.util.net.URL, java.lang.String)
Rmethod: org.apache.tomcat.util.net.URL#normalize()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Create a URL object by parsing a string representation relative to a specified context.  Based on logic from JDK 1.3.1's <code>java.net.URL</code>.
 * @param context URL against which the relative representationis resolved
 * @param spec String representation of the URL (usually relative)
 * @exception MalformedURLException if the string representationcannot be parsed successfully
 */
public URL(URL context,String spec) throws MalformedURLException {
  String original=spec;
  int i, limit, c;
  int start=0;
  String newProtocol=null;
  boolean aRef=false;
  try {
    limit=spec.length();
    while ((limit > 0) && (spec.charAt(limit - 1) <= ' ')) {
      limit--;
    }
    while ((start < limit) && (spec.charAt(start) <= ' ')) {
      start++;
    }
    if (spec.regionMatches(true,start,"url:",0,4)) {
      start+=4;
    }
    if ((start < spec.length()) && (spec.charAt(start) == '#')) {
      aRef=true;
    }
    for (i=start; !aRef && (i < limit); i++) {
      c=spec.charAt(i);
      if (c == ':') {
        String s=spec.substring(start,i).toLowerCase(Locale.ENGLISH);
        newProtocol=s;
        start=i + 1;
        break;
      }
 else       if (c == '#') {
        aRef=true;
      }
 else       if (!isSchemeChar((char)c)) {
        break;
      }
    }
    protocol=newProtocol;
    if ((context != null) && ((newProtocol == null) || newProtocol.equalsIgnoreCase(context.getProtocol()))) {
      if ((context.getPath() != null) && (context.getPath().startsWith("/")))       newProtocol=null;
      if (newProtocol == null) {
        protocol=context.getProtocol();
        authority=context.getAuthority();
        userInfo=context.getUserInfo();
        host=context.getHost();
        port=context.getPort();
        file=context.getFile();
        int question=file.lastIndexOf('?');
        if (question < 0)         path=file;
 else         path=file.substring(0,question);
      }
    }
    if (protocol == null)     throw new MalformedURLException("no protocol: " + original);
    i=spec.indexOf('#',start);
    if (i >= 0) {
      ref=spec.substring(i + 1,limit);
      limit=i;
    }
    parse(spec,start,limit);
    if (context != null)     normalize();
  }
 catch (  MalformedURLException e) {
    throw e;
  }
catch (  Exception e) {
    throw new MalformedURLException(e.toString());
  }
}

ID 4442=========================================================================type: 1
Method:org.apache.tomcat.util.net.URL#parse(java.lang.String, int, int)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Parse the specified portion of the string representation of a URL, assuming that it has a format similar to that for <code>http</code>. <p><strong>FIXME</strong> - This algorithm can undoubtedly be optimized for performance.  However, that needs to wait until after sufficient unit tests are implemented to guarantee correct behavior with no regressions.</p>
 * @param spec String representation being parsed
 * @param start Starting offset, which will be just after the ':' (ifthere is one) that determined the protocol name
 * @param limit Ending position, which will be the position of the '#'(if there is one) that delimited the anchor
 * @exception MalformedURLException if a parsing error occurs
 */
private void parse(String spec,int start,int limit) throws MalformedURLException {
  int question=spec.lastIndexOf('?',limit - 1);
  if ((question >= 0) && (question < limit)) {
    query=spec.substring(question + 1,limit);
    limit=question;
  }
 else {
    query=null;
  }
  if (spec.indexOf("//",start) == start) {
    int pathStart=spec.indexOf('/',start + 2);
    if ((pathStart >= 0) && (pathStart < limit)) {
      authority=spec.substring(start + 2,pathStart);
      start=pathStart;
    }
 else {
      authority=spec.substring(start + 2,limit);
      start=limit;
    }
    if (authority.length() > 0) {
      int at=authority.indexOf('@');
      if (at >= 0) {
        userInfo=authority.substring(0,at);
      }
      int ipv6=authority.indexOf('[',at + 1);
      int hStart=at + 1;
      if (ipv6 >= 0) {
        hStart=ipv6;
        ipv6=authority.indexOf(']',ipv6);
        if (ipv6 < 0) {
          throw new MalformedURLException("Closing ']' not found in IPV6 address: " + authority);
        }
 else {
          at=ipv6 - 1;
        }
      }
      int colon=authority.indexOf(':',at + 1);
      if (colon >= 0) {
        try {
          port=Integer.parseInt(authority.substring(colon + 1));
        }
 catch (        NumberFormatException e) {
          throw new MalformedURLException(e.toString());
        }
        host=authority.substring(hStart,colon);
      }
 else {
        host=authority.substring(hStart);
        port=-1;
      }
    }
  }
  if (spec.indexOf('/',start) == start) {
    path=spec.substring(start,limit);
    if (query != null)     file=path + "?" + query;
 else     file=path;
    return;
  }
  if (path == null) {
    if (query != null)     file="?" + query;
 else     file=null;
    return;
  }
  if (!path.startsWith("/"))   throw new MalformedURLException("Base path does not start with '/'");
  if (!path.endsWith("/"))   path+="/../";
  path+=spec.substring(start,limit);
  if (query != null)   file=path + "?" + query;
 else   file=path;
  return;
}

ID 4476=========================================================================type: 1
Method:org.apache.tomcat.util.net.NioBlockingSelector#write(java.nio.ByteBuffer, org.apache.tomcat.util.net.NioChannel, long)
Rmethod: org.apache.tomcat.util.net.KeyAttachment#awaitWriteLatch(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Performs a blocking write using the bytebuffer for data to be written If the <code>selector</code> parameter is null, then it will perform a busy write that could take up a lot of CPU cycles.
 * @param buf ByteBuffer - the buffer containing the data, we will write as long as <code>(buf.hasRemaining()==true)</code>
 * @param socket SocketChannel - the socket to write data to
 * @param writeTimeout long - the timeout for this write operation in milliseconds, -1 means no timeout
 * @return int - returns the number of bytes written
 * @throws EOFException if write returns -1
 * @throws SocketTimeoutException if the write times out
 * @throws IOException if an IO Exception occurs in the underlying socket logic
 */
public int write(ByteBuffer buf,NioChannel socket,long writeTimeout) throws IOException {
  SelectionKey key=socket.getIOChannel().keyFor(socket.getPoller().getSelector());
  if (key == null)   throw new IOException("Key no longer registered");
  KeyReference reference=keyReferenceQueue.poll();
  if (reference == null) {
    reference=new KeyReference();
  }
  KeyAttachment att=(KeyAttachment)key.attachment();
  int written=0;
  boolean timedout=false;
  int keycount=1;
  long time=System.currentTimeMillis();
  try {
    while ((!timedout) && buf.hasRemaining()) {
      if (keycount > 0) {
        int cnt=socket.write(buf);
        if (cnt == -1)         throw new EOFException();
        written+=cnt;
        if (cnt > 0) {
          time=System.currentTimeMillis();
          continue;
        }
      }
      try {
        if (att.getWriteLatch() == null || att.getWriteLatch().getCount() == 0)         att.startWriteLatch(1);
        poller.add(att,SelectionKey.OP_WRITE,reference);
        if (writeTimeout < 0) {
          att.awaitWriteLatch(Long.MAX_VALUE,TimeUnit.MILLISECONDS);
        }
 else {
          att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);
        }
      }
 catch (      InterruptedException ignore) {
        Thread.interrupted();
      }
      if (att.getWriteLatch() != null && att.getWriteLatch().getCount() > 0) {
        keycount=0;
      }
 else {
        keycount=1;
        att.resetWriteLatch();
      }
      if (writeTimeout > 0 && (keycount == 0))       timedout=(System.currentTimeMillis() - time) >= writeTimeout;
    }
    if (timedout)     throw new SocketTimeoutException();
  }
  finally {
    poller.remove(att,SelectionKey.OP_WRITE);
    if (timedout && reference.key != null) {
      poller.cancelKey(reference.key);
    }
    reference.key=null;
    keyReferenceQueue.add(reference);
  }
  return written;
}

ID 4478=========================================================================type: 1
Method:org.apache.tomcat.util.net.NioBlockingSelector#read(java.nio.ByteBuffer, org.apache.tomcat.util.net.NioChannel, long)
Rmethod: org.apache.tomcat.util.net.KeyAttachment#awaitReadLatch(long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Performs a blocking read using the bytebuffer for data to be read If the <code>selector</code> parameter is null, then it will perform a busy read that could take up a lot of CPU cycles.
 * @param buf ByteBuffer - the buffer containing the data, we will read as until we have read at least one byte or we timed out
 * @param socket SocketChannel - the socket to write data to
 * @param readTimeout long - the timeout for this read operation in milliseconds, -1 means no timeout
 * @return int - returns the number of bytes read
 * @throws EOFException if read returns -1
 * @throws SocketTimeoutException if the read times out
 * @throws IOException if an IO Exception occurs in the underlying socket logic
 */
public int read(ByteBuffer buf,NioChannel socket,long readTimeout) throws IOException {
  SelectionKey key=socket.getIOChannel().keyFor(socket.getPoller().getSelector());
  if (key == null)   throw new IOException("Key no longer registered");
  KeyReference reference=keyReferenceQueue.poll();
  if (reference == null) {
    reference=new KeyReference();
  }
  KeyAttachment att=(KeyAttachment)key.attachment();
  int read=0;
  boolean timedout=false;
  int keycount=1;
  long time=System.currentTimeMillis();
  try {
    while (!timedout) {
      if (keycount > 0) {
        read=socket.read(buf);
        if (read == -1)         throw new EOFException();
        if (read > 0)         break;
      }
      try {
        if (att.getReadLatch() == null || att.getReadLatch().getCount() == 0)         att.startReadLatch(1);
        poller.add(att,SelectionKey.OP_READ,reference);
        if (readTimeout < 0) {
          att.awaitReadLatch(Long.MAX_VALUE,TimeUnit.MILLISECONDS);
        }
 else {
          att.awaitReadLatch(readTimeout,TimeUnit.MILLISECONDS);
        }
      }
 catch (      InterruptedException ignore) {
        Thread.interrupted();
      }
      if (att.getReadLatch() != null && att.getReadLatch().getCount() > 0) {
        keycount=0;
      }
 else {
        keycount=1;
        att.resetReadLatch();
      }
      if (readTimeout >= 0 && (keycount == 0))       timedout=(System.currentTimeMillis() - time) >= readTimeout;
    }
    if (timedout)     throw new SocketTimeoutException();
  }
  finally {
    poller.remove(att,SelectionKey.OP_READ);
    if (timedout && reference.key != null) {
      poller.cancelKey(reference.key);
    }
    reference.key=null;
    keyReferenceQueue.add(reference);
  }
  return read;
}

ID 4479=========================================================================type: 1
Method:org.apache.tomcat.util.net.BlockPoller#add(org.apache.tomcat.util.net.NioEndpoint.KeyAttachment, int, org.apache.tomcat.util.net.NioBlockingSelector.KeyReference)
Rmethod: java.nio.channels.spi.AbstractSelectableChannel#register(java.nio.channels.Selector, int, java.lang.Object)
parentException: IOException 
thrown: ClosedChannelException
exception comment: /** 
 * Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.  That this exception is thrown does not necessarily imply that the channel is completely closed.  A socket channel whose write half has been shut down, for example, may still be open for reading.
 * @since 1.4
 */

block: 
public void add(final KeyAttachment key,final int ops,final KeyReference ref){
  Runnable r=new Runnable(){
    @Override public void run(){
      if (key == null)       return;
      NioChannel nch=key.getChannel();
      if (nch == null)       return;
      SocketChannel ch=nch.getIOChannel();
      if (ch == null)       return;
      SelectionKey sk=ch.keyFor(selector);
      try {
        if (sk == null) {
          sk=ch.register(selector,ops,key);
          ref.key=sk;
        }
 else         if (!sk.isValid()) {
          cancel(sk,key,ops);
        }
 else {
          sk.interestOps(sk.interestOps() | ops);
        }
      }
 catch (      CancelledKeyException cx) {
        cancel(sk,key,ops);
      }
catch (      ClosedChannelException cx) {
        cancel(sk,key,ops);
      }
    }
  }
;
  events.offer(r);
  wakeup();
}

ID 4480=========================================================================type: 1
Method:org.apache.tomcat.util.net#run()
Rmethod: java.nio.channels.spi.AbstractSelectableChannel#register(java.nio.channels.Selector, int, java.lang.Object)
parentException: IOException 
thrown: ClosedChannelException
exception comment: /** 
 * Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.  That this exception is thrown does not necessarily imply that the channel is completely closed.  A socket channel whose write half has been shut down, for example, may still be open for reading.
 * @since 1.4
 */

block: 
@Override public void run(){
  if (key == null)   return;
  NioChannel nch=key.getChannel();
  if (nch == null)   return;
  SocketChannel ch=nch.getIOChannel();
  if (ch == null)   return;
  SelectionKey sk=ch.keyFor(selector);
  try {
    if (sk == null) {
      sk=ch.register(selector,ops,key);
      ref.key=sk;
    }
 else     if (!sk.isValid()) {
      cancel(sk,key,ops);
    }
 else {
      sk.interestOps(sk.interestOps() | ops);
    }
  }
 catch (  CancelledKeyException cx) {
    cancel(sk,key,ops);
  }
catch (  ClosedChannelException cx) {
    cancel(sk,key,ops);
  }
}

ID 4496=========================================================================type: 1
Method:org.apache.tomcat.util.net.SecureNioChannel#rehandshake(long)
Rmethod: org.apache.tomcat.util.net.SecureNioChannel#handshake(boolean, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Force a blocking handshake to take place for this key. This requires that both network and application buffers have been emptied out prior to this call taking place, or a IOException will be thrown.
 * @param timeout - timeout in milliseconds for each socket operation
 * @throws IOException - if an IO exception occurs or if application or network buffers contain data
 * @throws SocketTimeoutException - if a socket operation timed out
 */
public void rehandshake(long timeout) throws IOException {
  if (netInBuffer.position() > 0 && netInBuffer.position() < netInBuffer.limit())   throw new IOException("Network input buffer still contains data. Handshake will fail.");
  if (netOutBuffer.position() > 0 && netOutBuffer.position() < netOutBuffer.limit())   throw new IOException("Network output buffer still contains data. Handshake will fail.");
  if (getBufHandler().getReadBuffer().position() > 0 && getBufHandler().getReadBuffer().position() < getBufHandler().getReadBuffer().limit())   throw new IOException("Application input buffer still contains data. Data would have been lost.");
  if (getBufHandler().getWriteBuffer().position() > 0 && getBufHandler().getWriteBuffer().position() < getBufHandler().getWriteBuffer().limit())   throw new IOException("Application output buffer still contains data. Data would have been lost.");
  reset();
  boolean isReadable=true;
  boolean isWriteable=true;
  boolean handshaking=true;
  Selector selector=null;
  SelectionKey key=null;
  try {
    while (handshaking) {
      int hsStatus=this.handshake(isReadable,isWriteable);
switch (hsStatus) {
case -1:
        throw new EOFException("EOF during handshake.");
case 0:
      handshaking=false;
    break;
default :
{
    long now=System.currentTimeMillis();
    if (selector == null) {
synchronized (Selector.class) {
        selector=Selector.open();
      }
      key=getIOChannel().register(selector,hsStatus);
    }
 else {
      key.interestOps(hsStatus);
    }
    int keyCount=selector.select(timeout);
    if (keyCount == 0 && ((System.currentTimeMillis() - now) >= timeout)) {
      throw new SocketTimeoutException("Handshake operation timed out.");
    }
    isReadable=key.isReadable();
    isWriteable=key.isWritable();
  }
}
}
}
 catch (IOException x) {
throw x;
}
catch (Exception cx) {
IOException x=new IOException(cx);
throw x;
}
 finally {
if (key != null) try {
key.cancel();
}
 catch (Exception ignore) {
}
if (selector != null) try {
selector.close();
}
 catch (Exception ignore) {
}
}
}

ID 4497=========================================================================type: 1
Method:org.apache.tomcat.util.net.SecureNioChannel#rehandshake(long)
Rmethod: java.nio.channels.Selector#open()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Force a blocking handshake to take place for this key. This requires that both network and application buffers have been emptied out prior to this call taking place, or a IOException will be thrown.
 * @param timeout - timeout in milliseconds for each socket operation
 * @throws IOException - if an IO exception occurs or if application or network buffers contain data
 * @throws SocketTimeoutException - if a socket operation timed out
 */
public void rehandshake(long timeout) throws IOException {
  if (netInBuffer.position() > 0 && netInBuffer.position() < netInBuffer.limit())   throw new IOException("Network input buffer still contains data. Handshake will fail.");
  if (netOutBuffer.position() > 0 && netOutBuffer.position() < netOutBuffer.limit())   throw new IOException("Network output buffer still contains data. Handshake will fail.");
  if (getBufHandler().getReadBuffer().position() > 0 && getBufHandler().getReadBuffer().position() < getBufHandler().getReadBuffer().limit())   throw new IOException("Application input buffer still contains data. Data would have been lost.");
  if (getBufHandler().getWriteBuffer().position() > 0 && getBufHandler().getWriteBuffer().position() < getBufHandler().getWriteBuffer().limit())   throw new IOException("Application output buffer still contains data. Data would have been lost.");
  reset();
  boolean isReadable=true;
  boolean isWriteable=true;
  boolean handshaking=true;
  Selector selector=null;
  SelectionKey key=null;
  try {
    while (handshaking) {
      int hsStatus=this.handshake(isReadable,isWriteable);
switch (hsStatus) {
case -1:
        throw new EOFException("EOF during handshake.");
case 0:
      handshaking=false;
    break;
default :
{
    long now=System.currentTimeMillis();
    if (selector == null) {
synchronized (Selector.class) {
        selector=Selector.open();
      }
      key=getIOChannel().register(selector,hsStatus);
    }
 else {
      key.interestOps(hsStatus);
    }
    int keyCount=selector.select(timeout);
    if (keyCount == 0 && ((System.currentTimeMillis() - now) >= timeout)) {
      throw new SocketTimeoutException("Handshake operation timed out.");
    }
    isReadable=key.isReadable();
    isWriteable=key.isWritable();
  }
}
}
}
 catch (IOException x) {
throw x;
}
catch (Exception cx) {
IOException x=new IOException(cx);
throw x;
}
 finally {
if (key != null) try {
key.cancel();
}
 catch (Exception ignore) {
}
if (selector != null) try {
selector.close();
}
 catch (Exception ignore) {
}
}
}

ID 4498=========================================================================type: 1
Method:org.apache.tomcat.util.net.SecureNioChannel#rehandshake(long)
Rmethod: java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)
parentException: IOException 
thrown: ClosedChannelException
exception comment: /** 
 * Checked exception thrown when an attempt is made to invoke or complete an I/O operation upon channel that is closed, or at least closed to that operation.  That this exception is thrown does not necessarily imply that the channel is completely closed.  A socket channel whose write half has been shut down, for example, may still be open for reading.
 * @since 1.4
 */

block: 
/** 
 * Force a blocking handshake to take place for this key. This requires that both network and application buffers have been emptied out prior to this call taking place, or a IOException will be thrown.
 * @param timeout - timeout in milliseconds for each socket operation
 * @throws IOException - if an IO exception occurs or if application or network buffers contain data
 * @throws SocketTimeoutException - if a socket operation timed out
 */
public void rehandshake(long timeout) throws IOException {
  if (netInBuffer.position() > 0 && netInBuffer.position() < netInBuffer.limit())   throw new IOException("Network input buffer still contains data. Handshake will fail.");
  if (netOutBuffer.position() > 0 && netOutBuffer.position() < netOutBuffer.limit())   throw new IOException("Network output buffer still contains data. Handshake will fail.");
  if (getBufHandler().getReadBuffer().position() > 0 && getBufHandler().getReadBuffer().position() < getBufHandler().getReadBuffer().limit())   throw new IOException("Application input buffer still contains data. Data would have been lost.");
  if (getBufHandler().getWriteBuffer().position() > 0 && getBufHandler().getWriteBuffer().position() < getBufHandler().getWriteBuffer().limit())   throw new IOException("Application output buffer still contains data. Data would have been lost.");
  reset();
  boolean isReadable=true;
  boolean isWriteable=true;
  boolean handshaking=true;
  Selector selector=null;
  SelectionKey key=null;
  try {
    while (handshaking) {
      int hsStatus=this.handshake(isReadable,isWriteable);
switch (hsStatus) {
case -1:
        throw new EOFException("EOF during handshake.");
case 0:
      handshaking=false;
    break;
default :
{
    long now=System.currentTimeMillis();
    if (selector == null) {
synchronized (Selector.class) {
        selector=Selector.open();
      }
      key=getIOChannel().register(selector,hsStatus);
    }
 else {
      key.interestOps(hsStatus);
    }
    int keyCount=selector.select(timeout);
    if (keyCount == 0 && ((System.currentTimeMillis() - now) >= timeout)) {
      throw new SocketTimeoutException("Handshake operation timed out.");
    }
    isReadable=key.isReadable();
    isWriteable=key.isWritable();
  }
}
}
}
 catch (IOException x) {
throw x;
}
catch (Exception cx) {
IOException x=new IOException(cx);
throw x;
}
 finally {
if (key != null) try {
key.cancel();
}
 catch (Exception ignore) {
}
if (selector != null) try {
selector.close();
}
 catch (Exception ignore) {
}
}
}

ID 4499=========================================================================type: 1
Method:org.apache.tomcat.util.net.SecureNioChannel#rehandshake(long)
Rmethod: java.nio.channels.Selector#select(long)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Force a blocking handshake to take place for this key. This requires that both network and application buffers have been emptied out prior to this call taking place, or a IOException will be thrown.
 * @param timeout - timeout in milliseconds for each socket operation
 * @throws IOException - if an IO exception occurs or if application or network buffers contain data
 * @throws SocketTimeoutException - if a socket operation timed out
 */
public void rehandshake(long timeout) throws IOException {
  if (netInBuffer.position() > 0 && netInBuffer.position() < netInBuffer.limit())   throw new IOException("Network input buffer still contains data. Handshake will fail.");
  if (netOutBuffer.position() > 0 && netOutBuffer.position() < netOutBuffer.limit())   throw new IOException("Network output buffer still contains data. Handshake will fail.");
  if (getBufHandler().getReadBuffer().position() > 0 && getBufHandler().getReadBuffer().position() < getBufHandler().getReadBuffer().limit())   throw new IOException("Application input buffer still contains data. Data would have been lost.");
  if (getBufHandler().getWriteBuffer().position() > 0 && getBufHandler().getWriteBuffer().position() < getBufHandler().getWriteBuffer().limit())   throw new IOException("Application output buffer still contains data. Data would have been lost.");
  reset();
  boolean isReadable=true;
  boolean isWriteable=true;
  boolean handshaking=true;
  Selector selector=null;
  SelectionKey key=null;
  try {
    while (handshaking) {
      int hsStatus=this.handshake(isReadable,isWriteable);
switch (hsStatus) {
case -1:
        throw new EOFException("EOF during handshake.");
case 0:
      handshaking=false;
    break;
default :
{
    long now=System.currentTimeMillis();
    if (selector == null) {
synchronized (Selector.class) {
        selector=Selector.open();
      }
      key=getIOChannel().register(selector,hsStatus);
    }
 else {
      key.interestOps(hsStatus);
    }
    int keyCount=selector.select(timeout);
    if (keyCount == 0 && ((System.currentTimeMillis() - now) >= timeout)) {
      throw new SocketTimeoutException("Handshake operation timed out.");
    }
    isReadable=key.isReadable();
    isWriteable=key.isWritable();
  }
}
}
}
 catch (IOException x) {
throw x;
}
catch (Exception cx) {
IOException x=new IOException(cx);
throw x;
}
 finally {
if (key != null) try {
key.cancel();
}
 catch (Exception ignore) {
}
if (selector != null) try {
selector.close();
}
 catch (Exception ignore) {
}
}
}

ID 4605=========================================================================type: 1
Method:org.apache.tomcat.util.security.ConcurrentMessageDigest#digest(java.lang.String, byte[][])
Rmethod: java.security.MessageDigest#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchAlgorithmException
exception comment: /** 
 * This exception is thrown when a particular cryptographic algorithm is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
public static byte[] digest(String algorithm,byte[]... input){
  Queue<MessageDigest> queue=queues.get(algorithm);
  if (queue == null) {
    throw new IllegalStateException("Must call init() first");
  }
  MessageDigest md=queue.poll();
  if (md == null) {
    try {
      md=MessageDigest.getInstance(algorithm);
    }
 catch (    NoSuchAlgorithmException e) {
      throw new IllegalStateException("Must call init() first");
    }
  }
  for (  byte[] bytes : input) {
    md.update(bytes);
  }
  byte[] result=md.digest();
  queue.add(md);
  return result;
}

ID 4621=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4622=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4623=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4624=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.Integer#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4625=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.Long#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4626=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.net.InetAddress#getByName(java.lang.String)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4628=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4630=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4631=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#setProperty(java.lang.Object, java.lang.String, java.lang.String, boolean)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
public static boolean setProperty(Object o,String name,String value,boolean invokeSetProperty){
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: setProperty(" + o.getClass() + " "+ name+ "="+ value+ ")");
  String setter="set" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method setPropertyMethodVoid=null;
    Method setPropertyMethodBool=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (setter.equals(methods[i].getName()) && paramT.length == 1 && "java.lang.String".equals(paramT[0].getName())) {
        methods[i].invoke(o,new Object[]{value});
        return true;
      }
    }
    for (int i=0; i < methods.length; i++) {
      boolean ok=true;
      if (setter.equals(methods[i].getName()) && methods[i].getParameterTypes().length == 1) {
        Class<?> paramType=methods[i].getParameterTypes()[0];
        Object params[]=new Object[1];
        if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
          try {
            params[0]=Integer.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Long".equals(paramType.getName()) || "long".equals(paramType.getName())) {
          try {
            params[0]=Long.valueOf(value);
          }
 catch (          NumberFormatException ex) {
            ok=false;
          }
        }
 else         if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
          params[0]=Boolean.valueOf(value);
        }
 else         if ("java.net.InetAddress".equals(paramType.getName())) {
          try {
            params[0]=InetAddress.getByName(value);
          }
 catch (          UnknownHostException exc) {
            if (log.isDebugEnabled())             log.debug("IntrospectionUtils: Unable to resolve host name:" + value);
            ok=false;
          }
        }
 else {
          if (log.isDebugEnabled())           log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
        }
        if (ok) {
          methods[i].invoke(o,params);
          return true;
        }
      }
      if ("setProperty".equals(methods[i].getName())) {
        if (methods[i].getReturnType() == Boolean.TYPE) {
          setPropertyMethodBool=methods[i];
        }
 else {
          setPropertyMethodVoid=methods[i];
        }
      }
    }
    if (invokeSetProperty && (setPropertyMethodBool != null || setPropertyMethodVoid != null)) {
      Object params[]=new Object[2];
      params[0]=name;
      params[1]=value;
      if (setPropertyMethodBool != null) {
        try {
          return ((Boolean)setPropertyMethodBool.invoke(o,params)).booleanValue();
        }
 catch (        IllegalArgumentException biae) {
          if (setPropertyMethodVoid != null) {
            setPropertyMethodVoid.invoke(o,params);
            return true;
          }
 else {
            throw biae;
          }
        }
      }
 else {
        setPropertyMethodVoid.invoke(o,params);
        return true;
      }
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name+ " "+ value,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ "="+ value+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ "="+ value+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ "="+ value+ ")",ie);
  }
  return false;
}

ID 4632=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#getProperty(java.lang.Object, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
public static Object getProperty(Object o,String name){
  String getter="get" + capitalize(name);
  String isGetter="is" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method getPropertyMethod=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (getter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if ("getProperty".equals(methods[i].getName())) {
        getPropertyMethod=methods[i];
      }
    }
    if (getPropertyMethod != null) {
      Object params[]=new Object[1];
      params[0]=name;
      return getPropertyMethod.invoke(o,params);
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ ")",ie);
  }
  return null;
}

ID 4633=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#getProperty(java.lang.Object, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public static Object getProperty(Object o,String name){
  String getter="get" + capitalize(name);
  String isGetter="is" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method getPropertyMethod=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (getter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if ("getProperty".equals(methods[i].getName())) {
        getPropertyMethod=methods[i];
      }
    }
    if (getPropertyMethod != null) {
      Object params[]=new Object[1];
      params[0]=name;
      return getPropertyMethod.invoke(o,params);
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ ")",ie);
  }
  return null;
}

ID 4634=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#getProperty(java.lang.Object, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
public static Object getProperty(Object o,String name){
  String getter="get" + capitalize(name);
  String isGetter="is" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method getPropertyMethod=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (getter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if ("getProperty".equals(methods[i].getName())) {
        getPropertyMethod=methods[i];
      }
    }
    if (getPropertyMethod != null) {
      Object params[]=new Object[1];
      params[0]=name;
      return getPropertyMethod.invoke(o,params);
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ ")",ie);
  }
  return null;
}

ID 4635=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#getProperty(java.lang.Object, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
public static Object getProperty(Object o,String name){
  String getter="get" + capitalize(name);
  String isGetter="is" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method getPropertyMethod=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (getter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if ("getProperty".equals(methods[i].getName())) {
        getPropertyMethod=methods[i];
      }
    }
    if (getPropertyMethod != null) {
      Object params[]=new Object[1];
      params[0]=name;
      return getPropertyMethod.invoke(o,params);
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ ")",ie);
  }
  return null;
}

ID 4636=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#getProperty(java.lang.Object, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public static Object getProperty(Object o,String name){
  String getter="get" + capitalize(name);
  String isGetter="is" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method getPropertyMethod=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (getter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if ("getProperty".equals(methods[i].getName())) {
        getPropertyMethod=methods[i];
      }
    }
    if (getPropertyMethod != null) {
      Object params[]=new Object[1];
      params[0]=name;
      return getPropertyMethod.invoke(o,params);
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ ")",ie);
  }
  return null;
}

ID 4637=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#getProperty(java.lang.Object, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
public static Object getProperty(Object o,String name){
  String getter="get" + capitalize(name);
  String isGetter="is" + capitalize(name);
  try {
    Method methods[]=findMethods(o.getClass());
    Method getPropertyMethod=null;
    for (int i=0; i < methods.length; i++) {
      Class<?> paramT[]=methods[i].getParameterTypes();
      if (getter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {
        return methods[i].invoke(o,(Object[])null);
      }
      if ("getProperty".equals(methods[i].getName())) {
        getPropertyMethod=methods[i];
      }
    }
    if (getPropertyMethod != null) {
      Object params[]=new Object[1];
      params[0]=name;
      return getPropertyMethod.invoke(o,params);
    }
  }
 catch (  IllegalArgumentException ex2) {
    log.warn("IAE " + o + " "+ name,ex2);
  }
catch (  SecurityException ex1) {
    log.warn("IntrospectionUtils: SecurityException for " + o.getClass() + " "+ name+ ")",ex1);
  }
catch (  IllegalAccessException iae) {
    log.warn("IntrospectionUtils: IllegalAccessException for " + o.getClass() + " "+ name+ ")",iae);
  }
catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    log.warn("IntrospectionUtils: InvocationTargetException for " + o.getClass() + " "+ name+ ")",ie);
  }
  return null;
}

ID 4641=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#addToolsJar(Vector<java.net.URL>)
Rmethod: java.net.URL#URL(java.lang.String, java.lang.String, java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * @deprecated Is used only by deprecated method
 */
@Deprecated public static void addToolsJar(Vector<URL> v){
  try {
    File f=new File(System.getProperty("java.home") + "/../lib/tools.jar");
    if (!f.exists()) {
      f=new File(System.getProperty("java.home") + "/lib/tools.jar");
      if (f.exists()) {
        if (log.isDebugEnabled())         log.debug("Detected strange java.home value " + System.getProperty("java.home") + ", it should point to jre");
      }
    }
    URL url=new URL("file","",f.getAbsolutePath());
    v.addElement(url);
  }
 catch (  MalformedURLException ex) {
    ex.printStackTrace();
  }
}

ID 4656=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#callMethod1(java.lang.Object, java.lang.String, java.lang.Object, java.lang.String, java.lang.ClassLoader)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
public static Object callMethod1(Object target,String methodN,Object param1,String typeParam1,ClassLoader cl) throws Exception {
  if (target == null || param1 == null) {
    if (log.isDebugEnabled())     log.debug("IntrospectionUtils: Assert: Illegal params " + target + " "+ param1);
  }
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: callMethod1 " + target.getClass().getName() + " "+ param1.getClass().getName()+ " "+ typeParam1);
  Class<?> params[]=new Class[1];
  if (typeParam1 == null)   params[0]=param1.getClass();
 else   params[0]=cl.loadClass(typeParam1);
  Method m=findMethod(target.getClass(),methodN,params);
  if (m == null)   throw new NoSuchMethodException(target.getClass().getName() + " " + methodN);
  try {
    return m.invoke(target,new Object[]{param1});
  }
 catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    throw ie;
  }
}

ID 4659=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#callMethod0(java.lang.Object, java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * @deprecated Not used, though compliments callMethod1 and callMethodN here
 */
@Deprecated public static Object callMethod0(Object target,String methodN) throws Exception {
  if (target == null) {
    if (log.isDebugEnabled())     log.debug("IntrospectionUtils: Assert: Illegal params " + target);
    return null;
  }
  if (log.isDebugEnabled())   log.debug("IntrospectionUtils: callMethod0 " + target.getClass().getName() + "."+ methodN);
  Class<?> params[]=new Class[0];
  Method m=findMethod(target.getClass(),methodN,params);
  if (m == null)   throw new NoSuchMethodException(target.getClass().getName() + " " + methodN);
  try {
    return m.invoke(target,emptyArray);
  }
 catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    throw ie;
  }
}

ID 4662=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#callMethodN(java.lang.Object, java.lang.String, java.lang.Object[], Class<?>[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
public static Object callMethodN(Object target,String methodN,Object params[],Class<?> typeParams[]) throws Exception {
  Method m=null;
  m=findMethod(target.getClass(),methodN,typeParams);
  if (m == null) {
    if (log.isDebugEnabled())     log.debug("IntrospectionUtils: Can't find method " + methodN + " in "+ target+ " CLASS "+ target.getClass());
    return null;
  }
  try {
    Object o=m.invoke(target,params);
    if (log.isDebugEnabled()) {
      StringBuilder sb=new StringBuilder();
      sb.append(target.getClass().getName()).append('.').append(methodN).append("( ");
      for (int i=0; i < params.length; i++) {
        if (i > 0)         sb.append(", ");
        sb.append(params[i]);
      }
      sb.append(")");
      log.debug("IntrospectionUtils:" + sb.toString());
    }
    return o;
  }
 catch (  InvocationTargetException ie) {
    ExceptionUtils.handleThrowable(ie.getCause());
    throw ie;
  }
}

ID 4664=========================================================================type: 1
Method:org.apache.tomcat.util.IntrospectionUtils#convert(java.lang.String, Class<?>)
Rmethod: java.net.InetAddress#getByName(java.lang.String)
parentException: IOException 
thrown: UnknownHostException
exception comment: /** 
 * An <code>UnknownHostException</code> is thrown if a <code>java.net.UnknownHostException</code> occurs while creating a connection to the remote host for a remote method call.
 * @since   JDK1.1
 */

block: 
public static Object convert(String object,Class<?> paramType){
  Object result=null;
  if ("java.lang.String".equals(paramType.getName())) {
    result=object;
  }
 else   if ("java.lang.Integer".equals(paramType.getName()) || "int".equals(paramType.getName())) {
    try {
      result=Integer.valueOf(object);
    }
 catch (    NumberFormatException ex) {
    }
  }
 else   if ("java.lang.Boolean".equals(paramType.getName()) || "boolean".equals(paramType.getName())) {
    result=Boolean.valueOf(object);
  }
 else   if ("java.net.InetAddress".equals(paramType.getName())) {
    try {
      result=InetAddress.getByName(object);
    }
 catch (    UnknownHostException exc) {
      if (log.isDebugEnabled())       log.debug("IntrospectionUtils: Unable to resolve host name:" + object);
    }
  }
 else {
    if (log.isDebugEnabled())     log.debug("IntrospectionUtils: Unknown type " + paramType.getName());
  }
  if (result == null) {
    throw new IllegalArgumentException("Can't convert argument: " + object);
  }
  return result;
}

ID 4676=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.ManagedBean#createMBean(java.lang.Object)
Rmethod: org.apache.tomcat.util.modeler.BaseModelMBean#setManagedResource(java.lang.Object, java.lang.String)
parentException: OperationsException JMException 
thrown: InstanceNotFoundException
exception comment: /** 
 * The specified MBean does not exist in the repository.
 * @since 1.5
 */

block: 
/** 
 * Create and return a <code>ModelMBean</code> that has been preconfigured with the <code>ModelMBeanInfo</code> information for this managed bean, and is associated with the specified managed object instance.  The returned <code>ModelMBean</code> will <strong>NOT</strong> have been registered with our <code>MBeanServer</code>.
 * @param instance Instanced of the managed object, or <code>null</code>for no associated instance
 * @exception InstanceNotFoundException if the managed resourceobject cannot be found
 * @exception MBeanException if a problem occurs instantiating the<code>ModelMBean</code> instance
 * @exception RuntimeOperationsException if a JMX runtime error occurs
 */
public DynamicMBean createMBean(Object instance) throws InstanceNotFoundException, MBeanException, RuntimeOperationsException {
  BaseModelMBean mbean=null;
  if (getClassName().equals(BASE_MBEAN)) {
    mbean=new BaseModelMBean();
  }
 else {
    Class<?> clazz=null;
    Exception ex=null;
    try {
      clazz=Class.forName(getClassName());
    }
 catch (    Exception e) {
    }
    if (clazz == null) {
      try {
        ClassLoader cl=Thread.currentThread().getContextClassLoader();
        if (cl != null)         clazz=cl.loadClass(getClassName());
      }
 catch (      Exception e) {
        ex=e;
      }
    }
    if (clazz == null) {
      throw new MBeanException(ex,"Cannot load ModelMBean class " + getClassName());
    }
    try {
      mbean=(BaseModelMBean)clazz.newInstance();
    }
 catch (    RuntimeOperationsException e) {
      throw e;
    }
catch (    Exception e) {
      throw new MBeanException(e,"Cannot instantiate ModelMBean of class " + getClassName());
    }
  }
  mbean.setManagedBean(this);
  try {
    if (instance != null)     mbean.setManagedResource(instance,"ObjectReference");
  }
 catch (  InstanceNotFoundException e) {
    throw e;
  }
  return (mbean);
}

ID 4679=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.ManagedBean#getGetter(java.lang.String, org.apache.tomcat.util.modeler.BaseModelMBean, java.lang.Object)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
Method getGetter(String aname,BaseModelMBean mbean,Object resource) throws AttributeNotFoundException, ReflectionException {
  Method m=null;
  AttributeInfo attrInfo=attributes.get(aname);
  if (attrInfo == null)   throw new AttributeNotFoundException(" Cannot find attribute " + aname + " for "+ resource);
  String getMethod=attrInfo.getGetMethod();
  if (getMethod == null)   throw new AttributeNotFoundException("Cannot find attribute " + aname + " get method name");
  Object object=null;
  NoSuchMethodException exception=null;
  try {
    object=mbean;
    m=object.getClass().getMethod(getMethod,NO_ARGS_PARAM_SIG);
  }
 catch (  NoSuchMethodException e) {
    exception=e;
  }
  if (m == null && resource != null) {
    try {
      object=resource;
      m=object.getClass().getMethod(getMethod,NO_ARGS_PARAM_SIG);
      exception=null;
    }
 catch (    NoSuchMethodException e) {
      exception=e;
    }
  }
  if (exception != null)   throw new ReflectionException(exception,"Cannot find getter method " + getMethod);
  return m;
}

ID 4682=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.ManagedBean#getSetter(java.lang.String, org.apache.tomcat.util.modeler.BaseModelMBean, java.lang.Object)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
public Method getSetter(String aname,BaseModelMBean bean,Object resource) throws AttributeNotFoundException, ReflectionException {
  Method m=null;
  AttributeInfo attrInfo=attributes.get(aname);
  if (attrInfo == null)   throw new AttributeNotFoundException(" Cannot find attribute " + aname);
  String setMethod=attrInfo.getSetMethod();
  if (setMethod == null)   throw new AttributeNotFoundException("Cannot find attribute " + aname + " set method name");
  String argType=attrInfo.getType();
  Class<?> signature[]=new Class[]{BaseModelMBean.getAttributeClass(argType)};
  Object object=null;
  NoSuchMethodException exception=null;
  try {
    object=bean;
    m=object.getClass().getMethod(setMethod,signature);
  }
 catch (  NoSuchMethodException e) {
    exception=e;
  }
  if (m == null && resource != null) {
    try {
      object=resource;
      m=object.getClass().getMethod(setMethod,signature);
      exception=null;
    }
 catch (    NoSuchMethodException e) {
      exception=e;
    }
  }
  if (exception != null)   throw new ReflectionException(exception,"Cannot find setter method " + setMethod + " "+ resource);
  return m;
}

ID 4685=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.ManagedBean#getInvoke(java.lang.String, java.lang.Object[], java.lang.String[], org.apache.tomcat.util.modeler.BaseModelMBean, java.lang.Object)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
public Method getInvoke(String aname,Object[] params,String[] signature,BaseModelMBean bean,Object resource) throws MBeanException, ReflectionException {
  Method method=null;
  if (params == null)   params=new Object[0];
  if (signature == null)   signature=new String[0];
  if (params.length != signature.length)   throw new RuntimeOperationsException(new IllegalArgumentException("Inconsistent arguments and signature"),"Inconsistent arguments and signature");
  OperationInfo opInfo=operations.get(createOperationKey(aname,signature));
  if (opInfo == null)   throw new MBeanException(new ServiceNotFoundException("Cannot find operation " + aname),"Cannot find operation " + aname);
  Class<?> types[]=new Class[signature.length];
  for (int i=0; i < signature.length; i++) {
    types[i]=BaseModelMBean.getAttributeClass(signature[i]);
  }
  Object object=null;
  Exception exception=null;
  try {
    object=bean;
    method=object.getClass().getMethod(aname,types);
  }
 catch (  NoSuchMethodException e) {
    exception=e;
  }
  try {
    if ((method == null) && (resource != null)) {
      object=resource;
      method=object.getClass().getMethod(aname,types);
    }
  }
 catch (  NoSuchMethodException e) {
    exception=e;
  }
  if (method == null) {
    throw new ReflectionException(exception,"Cannot find method " + aname + " with this signature");
  }
  return method;
}

ID 4694=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.BaseModelMBean#getAttribute(java.lang.String)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Obtain and return the value of a specific attribute of this MBean.
 * @param name Name of the requested attribute
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public Object getAttribute(String name) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  if ((resource instanceof DynamicMBean) && !(resource instanceof BaseModelMBean)) {
    return ((DynamicMBean)resource).getAttribute(name);
  }
  Method m=managedBean.getGetter(name,this,resource);
  Object result=null;
  try {
    Class<?> declaring=m.getDeclaringClass();
    if (declaring.isAssignableFrom(this.getClass())) {
      result=m.invoke(this,NO_ARGS_PARAM);
    }
 else {
      result=m.invoke(resource,NO_ARGS_PARAM);
    }
  }
 catch (  InvocationTargetException e) {
    Throwable t=e.getTargetException();
    if (t == null)     t=e;
    if (t instanceof RuntimeException)     throw new RuntimeOperationsException((RuntimeException)t,"Exception invoking method " + name);
 else     if (t instanceof Error)     throw new RuntimeErrorException((Error)t,"Error invoking method " + name);
 else     throw new MBeanException(e,"Exception invoking method " + name);
  }
catch (  Exception e) {
    throw new MBeanException(e,"Exception invoking method " + name);
  }
  return (result);
}

ID 4704=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.BaseModelMBean#invoke(java.lang.String, java.lang.Object[], java.lang.String[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Invoke a particular method on this MBean, and return any returned value. <p><strong>IMPLEMENTATION NOTE</strong> - This implementation will attempt to invoke this method on the MBean itself, or (if not available) on the managed resource object associated with this MBean.</p>
 * @param name Name of the operation to be invoked
 * @param params Array containing the method parameters of this operation
 * @param signature Array containing the class names representingthe signature of this operation
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking a method
 */
@Override public Object invoke(String name,Object params[],String signature[]) throws MBeanException, ReflectionException {
  if ((resource instanceof DynamicMBean) && !(resource instanceof BaseModelMBean)) {
    return ((DynamicMBean)resource).invoke(name,params,signature);
  }
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Method name is null"),"Method name is null");
  if (log.isDebugEnabled())   log.debug("Invoke " + name);
  Method method=managedBean.getInvoke(name,params,signature,this,resource);
  Object result=null;
  try {
    if (method.getDeclaringClass().isAssignableFrom(this.getClass())) {
      result=method.invoke(this,params);
    }
 else {
      result=method.invoke(resource,params);
    }
  }
 catch (  InvocationTargetException e) {
    Throwable t=e.getTargetException();
    log.error("Exception invoking method " + name,t);
    if (t == null)     t=e;
    if (t instanceof RuntimeException)     throw new RuntimeOperationsException((RuntimeException)t,"Exception invoking method " + name);
 else     if (t instanceof Error)     throw new RuntimeErrorException((Error)t,"Error invoking method " + name);
 else     throw new MBeanException((Exception)t,"Exception invoking method " + name);
  }
catch (  Exception e) {
    log.error("Exception invoking method " + name,e);
    throw new MBeanException(e,"Exception invoking method " + name);
  }
  return (result);
}

ID 4706=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.BaseModelMBean#getAttributeClass(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
static Class<?> getAttributeClass(String signature) throws ReflectionException {
  if (signature.equals(Boolean.TYPE.getName()))   return Boolean.TYPE;
 else   if (signature.equals(Byte.TYPE.getName()))   return Byte.TYPE;
 else   if (signature.equals(Character.TYPE.getName()))   return Character.TYPE;
 else   if (signature.equals(Double.TYPE.getName()))   return Double.TYPE;
 else   if (signature.equals(Float.TYPE.getName()))   return Float.TYPE;
 else   if (signature.equals(Integer.TYPE.getName()))   return Integer.TYPE;
 else   if (signature.equals(Long.TYPE.getName()))   return Long.TYPE;
 else   if (signature.equals(Short.TYPE.getName()))   return Short.TYPE;
 else {
    try {
      ClassLoader cl=Thread.currentThread().getContextClassLoader();
      if (cl != null)       return cl.loadClass(signature);
    }
 catch (    ClassNotFoundException e) {
    }
    try {
      return Class.forName(signature);
    }
 catch (    ClassNotFoundException e) {
      throw new ReflectionException(e,"Cannot find Class for " + signature);
    }
  }
}

ID 4708=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.BaseModelMBean#setAttribute(javax.management.Attribute)
Rmethod: javax.management.DynamicMBean#setAttribute(javax.management.Attribute)
parentException: OperationsException JMException 
thrown: InvalidAttributeValueException
exception comment: /** 
 * This class is thrown when an attempt is made to add to an attribute a value that conflicts with the attribute's schema definition.  This could happen, for example, if attempting to add an attribute with no value when the attribute is required to have at least one value, or if attempting to add more than one value to a single valued-attribute, or if attempting to add a value that conflicts with the syntax of the attribute. <p> Synchronization and serialization issues that apply to NamingException apply directly here.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (log.isDebugEnabled())   log.debug("Setting attribute " + this + " "+ attribute);
  if ((resource instanceof DynamicMBean) && !(resource instanceof BaseModelMBean)) {
    try {
      ((DynamicMBean)resource).setAttribute(attribute);
    }
 catch (    InvalidAttributeValueException e) {
      throw new MBeanException(e);
    }
    return;
  }
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  Object oldValue=null;
  Method m=managedBean.getSetter(name,this,resource);
  try {
    if (m.getDeclaringClass().isAssignableFrom(this.getClass())) {
      m.invoke(this,new Object[]{value});
    }
 else {
      m.invoke(resource,new Object[]{value});
    }
  }
 catch (  InvocationTargetException e) {
    Throwable t=e.getTargetException();
    if (t == null)     t=e;
    if (t instanceof RuntimeException)     throw new RuntimeOperationsException((RuntimeException)t,"Exception invoking method " + name);
 else     if (t instanceof Error)     throw new RuntimeErrorException((Error)t,"Error invoking method " + name);
 else     throw new MBeanException(e,"Exception invoking method " + name);
  }
catch (  Exception e) {
    log.error("Exception invoking method " + name,e);
    throw new MBeanException(e,"Exception invoking method " + name);
  }
  try {
    sendAttributeChangeNotification(new Attribute(name,oldValue),attribute);
  }
 catch (  Exception ex) {
    log.error("Error sending notification " + name,ex);
  }
}

ID 4715=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.BaseModelMBean#setAttribute(javax.management.Attribute)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Set the value of a specific attribute of this MBean.
 * @param attribute The identification of the attribute to be setand the new value
 * @exception AttributeNotFoundException if this attribute is notsupported by this MBean
 * @exception MBeanException if the initializer of an objectthrows an exception
 * @exception ReflectionException if a Java reflection exceptionoccurs when invoking the getter
 */
@Override public void setAttribute(Attribute attribute) throws AttributeNotFoundException, MBeanException, ReflectionException {
  if (log.isDebugEnabled())   log.debug("Setting attribute " + this + " "+ attribute);
  if ((resource instanceof DynamicMBean) && !(resource instanceof BaseModelMBean)) {
    try {
      ((DynamicMBean)resource).setAttribute(attribute);
    }
 catch (    InvalidAttributeValueException e) {
      throw new MBeanException(e);
    }
    return;
  }
  if (attribute == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute is null"),"Attribute is null");
  String name=attribute.getName();
  Object value=attribute.getValue();
  if (name == null)   throw new RuntimeOperationsException(new IllegalArgumentException("Attribute name is null"),"Attribute name is null");
  Object oldValue=null;
  Method m=managedBean.getSetter(name,this,resource);
  try {
    if (m.getDeclaringClass().isAssignableFrom(this.getClass())) {
      m.invoke(this,new Object[]{value});
    }
 else {
      m.invoke(resource,new Object[]{value});
    }
  }
 catch (  InvocationTargetException e) {
    Throwable t=e.getTargetException();
    if (t == null)     t=e;
    if (t instanceof RuntimeException)     throw new RuntimeOperationsException((RuntimeException)t,"Exception invoking method " + name);
 else     if (t instanceof Error)     throw new RuntimeErrorException((Error)t,"Error invoking method " + name);
 else     throw new MBeanException(e,"Exception invoking method " + name);
  }
catch (  Exception e) {
    log.error("Exception invoking method " + name,e);
    throw new MBeanException(e,"Exception invoking method " + name);
  }
  try {
    sendAttributeChangeNotification(new Attribute(name,oldValue),attribute);
  }
 catch (  Exception ex) {
    log.error("Error sending notification " + name,ex);
  }
}

ID 4758=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.modules.MbeansSource#save()
Rmethod: java.io.FileOutputStream#FileOutputStream(java.lang.String)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Store the mbeans.  XXX add a background thread to store it periodically 
 */
@Override public void save(){
  long time=System.currentTimeMillis();
  if (location != null && time - lastUpdate > updateInterval) {
    lastUpdate=time;
    try {
      FileOutputStream fos=new FileOutputStream(location);
      DomUtil.writeXml(document,fos);
    }
 catch (    TransformerException e) {
      log.error("Error writing");
    }
catch (    FileNotFoundException e) {
      log.error("Error writing",e);
    }
  }
}

ID 4759=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.modules.MbeansSource#save()
Rmethod: org.apache.tomcat.util.DomUtil#writeXml(org.w3c.dom.Node, java.io.OutputStream)
parentException: 
thrown: TransformerException
exception comment: /** 
 * Method getLocator retrieves an instance of a SourceLocator object that specifies where an error occurred.
 * @return A SourceLocator object, or null if none was specified.
 */

block: 
/** 
 * Store the mbeans.  XXX add a background thread to store it periodically 
 */
@Override public void save(){
  long time=System.currentTimeMillis();
  if (location != null && time - lastUpdate > updateInterval) {
    lastUpdate=time;
    try {
      FileOutputStream fos=new FileOutputStream(location);
      DomUtil.writeXml(document,fos);
    }
 catch (    TransformerException e) {
      log.error("Error writing");
    }
catch (    FileNotFoundException e) {
      log.error("Error writing",e);
    }
  }
}

ID 4781=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.modules.MbeansDescriptorsIntrospectionSource#isBeanCompatible(Class<?>)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
/** 
 * Check if this class conforms to JavaBeans specifications. If the class is conformant, returns true.
 * @param javaType The class to check
 * @return boolean True if the class is compatible.
 */
protected boolean isBeanCompatible(Class<?> javaType){
  if (javaType.isArray() || javaType.isPrimitive()) {
    return false;
  }
  if (javaType.getName().startsWith("java.") || javaType.getName().startsWith("javax.")) {
    return false;
  }
  try {
    javaType.getConstructor(new Class[]{});
  }
 catch (  java.lang.NoSuchMethodException e) {
    return false;
  }
  Class<?> superClass=javaType.getSuperclass();
  if (superClass != null && superClass != java.lang.Object.class && superClass != java.lang.Exception.class && superClass != java.lang.Throwable.class) {
    if (!isBeanCompatible(superClass)) {
      return false;
    }
  }
  return true;
}

ID 4792=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.Registry#unregisterComponent(java.lang.String)
Rmethod: javax.management.ObjectName#ObjectName(java.lang.String)
parentException: OperationsException JMException 
thrown: MalformedObjectNameException
exception comment: /** 
 * The format of the string does not correspond to a valid ObjectName.
 * @since 1.5
 */

block: 
/** 
 * Unregister a component. We'll first check if it is registered, and mask all errors. This is mostly a helper.
 * @param oname
 * @since 1.1
 */
@Override public void unregisterComponent(String oname){
  try {
    unregisterComponent(new ObjectName(oname));
  }
 catch (  MalformedObjectNameException e) {
    log.info("Error creating object name " + e);
  }
}

ID 4819=========================================================================type: 1
Method:org.apache.tomcat.util.modeler.Registry#loadDescriptors(java.lang.String, java.lang.ClassLoader)
Rmethod: org.apache.tomcat.util.modeler.Registry#loadDescriptors(java.lang.String, java.lang.Object, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Lookup the component descriptor in the package and in the parent packages.
 * @param packageName
 */
public void loadDescriptors(String packageName,ClassLoader classLoader){
  String res=packageName.replace('.','/');
  if (log.isTraceEnabled()) {
    log.trace("Finding descriptor " + res);
  }
  if (searchedPaths.get(packageName) != null) {
    return;
  }
  String descriptors=res + "/mbeans-descriptors.ser";
  URL dURL=classLoader.getResource(descriptors);
  if (dURL == null) {
    descriptors=res + "/mbeans-descriptors.xml";
    dURL=classLoader.getResource(descriptors);
  }
  if (dURL == null) {
    return;
  }
  log.debug("Found " + dURL);
  searchedPaths.put(packageName,dURL);
  try {
    if (descriptors.endsWith(".xml"))     loadDescriptors("MbeansDescriptorsDigesterSource",dURL,null);
 else     loadDescriptors("MbeansDescriptorsSerSource",dURL,null);
    return;
  }
 catch (  Exception ex) {
    log.error("Error loading " + dURL);
  }
  return;
}

ID 4882=========================================================================type: 1
Method:org.apache.tomcat.util.scan.StandardJarScanner#scan(javax.servlet.ServletContext, java.lang.ClassLoader, org.apache.tomcat.JarScannerCallback, Set<java.lang.String>)
Rmethod: javax.servlet.ServletContext#getResource(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Scan the provided ServletContext and classloader for JAR files. Each JAR file found will be passed to the callback handler to be processed.
 * @param context       The ServletContext - used to locate and accessWEB-INF/lib
 * @param classloader   The classloader - used to access JARs not inWEB-INF/lib
 * @param callback      The handler to process any JARs found
 * @param jarsToSkip    List of JARs to ignore. If this list is null, adefault list will be read from the system property defined by  {@link Constants#SKIP_JARS_PROPERTY}
 */
@Override public void scan(ServletContext context,ClassLoader classloader,JarScannerCallback callback,Set<String> jarsToSkip){
  if (log.isTraceEnabled()) {
    log.trace(sm.getString("jarScan.webinflibStart"));
  }
  final Set<String> ignoredJars;
  if (jarsToSkip == null) {
    ignoredJars=defaultJarsToSkip;
  }
 else {
    ignoredJars=jarsToSkip;
  }
  Set<String> dirList=context.getResourcePaths(Constants.WEB_INF_LIB);
  if (dirList != null) {
    Iterator<String> it=dirList.iterator();
    while (it.hasNext()) {
      String path=it.next();
      if (path.endsWith(Constants.JAR_EXT) && !Matcher.matchName(ignoredJars,path.substring(path.lastIndexOf('/') + 1))) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("jarScan.webinflibJarScan",path));
        }
        URL url=null;
        try {
          String realPath=context.getRealPath(path);
          if (realPath == null) {
            url=context.getResource(path);
          }
 else {
            url=(new File(realPath)).toURI().toURL();
          }
          process(callback,url);
        }
 catch (        IOException e) {
          log.warn(sm.getString("jarScan.webinflibFail",url),e);
        }
      }
 else {
        if (log.isTraceEnabled()) {
          log.trace(sm.getString("jarScan.webinflibJarNoScan",path));
        }
      }
    }
  }
  if (scanClassPath && classloader != null) {
    if (log.isTraceEnabled()) {
      log.trace(sm.getString("jarScan.classloaderStart"));
    }
    ClassLoader loader=classloader;
    ClassLoader stopLoader=null;
    if (!scanBootstrapClassPath) {
      stopLoader=ClassLoader.getSystemClassLoader().getParent();
    }
    while (loader != null && loader != stopLoader) {
      if (loader instanceof URLClassLoader) {
        URL[] urls=((URLClassLoader)loader).getURLs();
        for (int i=0; i < urls.length; i++) {
          String jarName=getJarName(urls[i]);
          if (jarName != null && !(Matcher.matchName(ignoredJars,jarName) || urls[i].toString().contains(Constants.WEB_INF_LIB + jarName))) {
            if (log.isDebugEnabled()) {
              log.debug(sm.getString("jarScan.classloaderJarScan",urls[i]));
            }
            try {
              process(callback,urls[i]);
            }
 catch (            IOException ioe) {
              log.warn(sm.getString("jarScan.classloaderFail",urls[i]),ioe);
            }
          }
 else {
            if (log.isTraceEnabled()) {
              log.trace(sm.getString("jarScan.classloaderJarNoScan",urls[i]));
            }
          }
        }
      }
      loader=loader.getParent();
    }
  }
}

ID 4883=========================================================================type: 1
Method:org.apache.tomcat.util.scan.StandardJarScanner#scan(javax.servlet.ServletContext, java.lang.ClassLoader, org.apache.tomcat.JarScannerCallback, Set<java.lang.String>)
Rmethod: java.net.URI#toURL()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Scan the provided ServletContext and classloader for JAR files. Each JAR file found will be passed to the callback handler to be processed.
 * @param context       The ServletContext - used to locate and accessWEB-INF/lib
 * @param classloader   The classloader - used to access JARs not inWEB-INF/lib
 * @param callback      The handler to process any JARs found
 * @param jarsToSkip    List of JARs to ignore. If this list is null, adefault list will be read from the system property defined by  {@link Constants#SKIP_JARS_PROPERTY}
 */
@Override public void scan(ServletContext context,ClassLoader classloader,JarScannerCallback callback,Set<String> jarsToSkip){
  if (log.isTraceEnabled()) {
    log.trace(sm.getString("jarScan.webinflibStart"));
  }
  final Set<String> ignoredJars;
  if (jarsToSkip == null) {
    ignoredJars=defaultJarsToSkip;
  }
 else {
    ignoredJars=jarsToSkip;
  }
  Set<String> dirList=context.getResourcePaths(Constants.WEB_INF_LIB);
  if (dirList != null) {
    Iterator<String> it=dirList.iterator();
    while (it.hasNext()) {
      String path=it.next();
      if (path.endsWith(Constants.JAR_EXT) && !Matcher.matchName(ignoredJars,path.substring(path.lastIndexOf('/') + 1))) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("jarScan.webinflibJarScan",path));
        }
        URL url=null;
        try {
          String realPath=context.getRealPath(path);
          if (realPath == null) {
            url=context.getResource(path);
          }
 else {
            url=(new File(realPath)).toURI().toURL();
          }
          process(callback,url);
        }
 catch (        IOException e) {
          log.warn(sm.getString("jarScan.webinflibFail",url),e);
        }
      }
 else {
        if (log.isTraceEnabled()) {
          log.trace(sm.getString("jarScan.webinflibJarNoScan",path));
        }
      }
    }
  }
  if (scanClassPath && classloader != null) {
    if (log.isTraceEnabled()) {
      log.trace(sm.getString("jarScan.classloaderStart"));
    }
    ClassLoader loader=classloader;
    ClassLoader stopLoader=null;
    if (!scanBootstrapClassPath) {
      stopLoader=ClassLoader.getSystemClassLoader().getParent();
    }
    while (loader != null && loader != stopLoader) {
      if (loader instanceof URLClassLoader) {
        URL[] urls=((URLClassLoader)loader).getURLs();
        for (int i=0; i < urls.length; i++) {
          String jarName=getJarName(urls[i]);
          if (jarName != null && !(Matcher.matchName(ignoredJars,jarName) || urls[i].toString().contains(Constants.WEB_INF_LIB + jarName))) {
            if (log.isDebugEnabled()) {
              log.debug(sm.getString("jarScan.classloaderJarScan",urls[i]));
            }
            try {
              process(callback,urls[i]);
            }
 catch (            IOException ioe) {
              log.warn(sm.getString("jarScan.classloaderFail",urls[i]),ioe);
            }
          }
 else {
            if (log.isTraceEnabled()) {
              log.trace(sm.getString("jarScan.classloaderJarNoScan",urls[i]));
            }
          }
        }
      }
      loader=loader.getParent();
    }
  }
}

ID 4884=========================================================================type: 1
Method:org.apache.tomcat.util.scan.StandardJarScanner#scan(javax.servlet.ServletContext, java.lang.ClassLoader, org.apache.tomcat.JarScannerCallback, Set<java.lang.String>)
Rmethod: org.apache.tomcat.util.scan.StandardJarScanner#process(org.apache.tomcat.JarScannerCallback, java.net.URL)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Scan the provided ServletContext and classloader for JAR files. Each JAR file found will be passed to the callback handler to be processed.
 * @param context       The ServletContext - used to locate and accessWEB-INF/lib
 * @param classloader   The classloader - used to access JARs not inWEB-INF/lib
 * @param callback      The handler to process any JARs found
 * @param jarsToSkip    List of JARs to ignore. If this list is null, adefault list will be read from the system property defined by  {@link Constants#SKIP_JARS_PROPERTY}
 */
@Override public void scan(ServletContext context,ClassLoader classloader,JarScannerCallback callback,Set<String> jarsToSkip){
  if (log.isTraceEnabled()) {
    log.trace(sm.getString("jarScan.webinflibStart"));
  }
  final Set<String> ignoredJars;
  if (jarsToSkip == null) {
    ignoredJars=defaultJarsToSkip;
  }
 else {
    ignoredJars=jarsToSkip;
  }
  Set<String> dirList=context.getResourcePaths(Constants.WEB_INF_LIB);
  if (dirList != null) {
    Iterator<String> it=dirList.iterator();
    while (it.hasNext()) {
      String path=it.next();
      if (path.endsWith(Constants.JAR_EXT) && !Matcher.matchName(ignoredJars,path.substring(path.lastIndexOf('/') + 1))) {
        if (log.isDebugEnabled()) {
          log.debug(sm.getString("jarScan.webinflibJarScan",path));
        }
        URL url=null;
        try {
          String realPath=context.getRealPath(path);
          if (realPath == null) {
            url=context.getResource(path);
          }
 else {
            url=(new File(realPath)).toURI().toURL();
          }
          process(callback,url);
        }
 catch (        IOException e) {
          log.warn(sm.getString("jarScan.webinflibFail",url),e);
        }
      }
 else {
        if (log.isTraceEnabled()) {
          log.trace(sm.getString("jarScan.webinflibJarNoScan",path));
        }
      }
    }
  }
  if (scanClassPath && classloader != null) {
    if (log.isTraceEnabled()) {
      log.trace(sm.getString("jarScan.classloaderStart"));
    }
    ClassLoader loader=classloader;
    ClassLoader stopLoader=null;
    if (!scanBootstrapClassPath) {
      stopLoader=ClassLoader.getSystemClassLoader().getParent();
    }
    while (loader != null && loader != stopLoader) {
      if (loader instanceof URLClassLoader) {
        URL[] urls=((URLClassLoader)loader).getURLs();
        for (int i=0; i < urls.length; i++) {
          String jarName=getJarName(urls[i]);
          if (jarName != null && !(Matcher.matchName(ignoredJars,jarName) || urls[i].toString().contains(Constants.WEB_INF_LIB + jarName))) {
            if (log.isDebugEnabled()) {
              log.debug(sm.getString("jarScan.classloaderJarScan",urls[i]));
            }
            try {
              process(callback,urls[i]);
            }
 catch (            IOException ioe) {
              log.warn(sm.getString("jarScan.classloaderFail",urls[i]),ioe);
            }
          }
 else {
            if (log.isTraceEnabled()) {
              log.trace(sm.getString("jarScan.classloaderJarNoScan",urls[i]));
            }
          }
        }
      }
      loader=loader.getParent();
    }
  }
}

ID 4905=========================================================================type: 1
Method:org.apache.tomcat.util.scan.UrlJar#nextEntry()
Rmethod: java.util.jar.JarInputStream#getNextJarEntry()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void nextEntry(){
  try {
    entry=jarInputStream.getNextJarEntry();
  }
 catch (  IOException ioe) {
    entry=null;
  }
}

ID 4908=========================================================================type: 1
Method:org.apache.tomcat.util.threads.ThreadPoolExecutor#execute(java.lang.Runnable, long, java.util.concurrent.TimeUnit)
Rmethod: org.apache.tomcat.util.threads.TaskQueue#force(java.lang.Runnable, long, java.util.concurrent.TimeUnit)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
/** 
 * Executes the given command at some time in the future.  The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the <tt>Executor</tt> implementation. If no threads are available, it will be added to the work queue. If the work queue is full, the system will wait for the specified time and it throw a RejectedExecutionException if the queue is still full after that.
 * @param command the runnable task
 * @throws RejectedExecutionException if this task cannot beaccepted for execution - the queue is full
 * @throws NullPointerException if command or unit is null
 */
public void execute(Runnable command,long timeout,TimeUnit unit){
  submittedCount.incrementAndGet();
  try {
    super.execute(command);
  }
 catch (  RejectedExecutionException rx) {
    if (super.getQueue() instanceof TaskQueue) {
      final TaskQueue queue=(TaskQueue)super.getQueue();
      try {
        if (!queue.force(command,timeout,unit)) {
          submittedCount.decrementAndGet();
          throw new RejectedExecutionException("Queue capacity is full.");
        }
      }
 catch (      InterruptedException x) {
        submittedCount.decrementAndGet();
        Thread.interrupted();
        throw new RejectedExecutionException(x);
      }
    }
 else {
      submittedCount.decrementAndGet();
      throw rx;
    }
  }
}

ID 4924=========================================================================type: 1
Method:org.apache.tomcat.util.digester.XercesParser#configureOldXerces(javax.xml.parsers.SAXParser, java.util.Properties)
Rmethod: javax.xml.parsers.SAXParser#setProperty(java.lang.String, java.lang.Object)
parentException: SAXException 
thrown: SAXNotRecognizedException
exception comment: /** 
 * Exception class for an unrecognized identifier. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>An XMLReader will throw this exception when it finds an unrecognized feature or property identifier; SAX applications and extensions may use this class for other, similar purposes.</p>
 * @since SAX 2.0
 * @author David Megginson
 * @see org.xml.sax.SAXNotSupportedException
 */

block: 
/** 
 * Configure schema validation as recommended by the JAXP 1.2 spec. The <code>properties</code> object may contains information about the schema local and language. 
 * @param properties parser optional info
 */
private static void configureOldXerces(SAXParser parser,Properties properties) throws ParserConfigurationException, SAXNotSupportedException {
  String schemaLocation=(String)properties.get("schemaLocation");
  String schemaLanguage=(String)properties.get("schemaLanguage");
  try {
    if (schemaLocation != null) {
      parser.setProperty(JAXP_SCHEMA_LANGUAGE,schemaLanguage);
      parser.setProperty(JAXP_SCHEMA_SOURCE,schemaLocation);
    }
  }
 catch (  SAXNotRecognizedException e) {
    log.info(parser.getClass().getName() + ": " + e.getMessage()+ " not supported.");
  }
}

ID 4935=========================================================================type: 1
Method:org.apache.tomcat.util.digester.FactoryCreateRule#begin(java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.apache.tomcat.util.digester.FactoryCreateRule#getFactory(org.xml.sax.Attributes)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process the beginning of this element.
 * @param attributes The attribute list of this element
 */
@Override public void begin(String namespace,String name,Attributes attributes) throws Exception {
  if (ignoreCreateExceptions) {
    if (exceptionIgnoredStack == null) {
      exceptionIgnoredStack=new ArrayStack<Boolean>();
    }
    try {
      Object instance=getFactory(attributes).createObject(attributes);
      if (digester.log.isDebugEnabled()) {
        digester.log.debug("[FactoryCreateRule]{" + digester.match + "} New "+ instance.getClass().getName());
      }
      digester.push(instance);
      exceptionIgnoredStack.push(Boolean.FALSE);
    }
 catch (    Exception e) {
      if (digester.log.isInfoEnabled()) {
        digester.log.info("[FactoryCreateRule] Create exception ignored: " + ((e.getMessage() == null) ? e.getClass().getName() : e.getMessage()));
        if (digester.log.isDebugEnabled()) {
          digester.log.debug("[FactoryCreateRule] Ignored exception:",e);
        }
      }
      exceptionIgnoredStack.push(Boolean.TRUE);
    }
  }
 else {
    Object instance=getFactory(attributes).createObject(attributes);
    if (digester.log.isDebugEnabled()) {
      digester.log.debug("[FactoryCreateRule]{" + digester.match + "} New "+ instance.getClass().getName());
    }
    digester.push(instance);
  }
}

ID 4936=========================================================================type: 1
Method:org.apache.tomcat.util.digester.FactoryCreateRule#begin(java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.apache.tomcat.util.digester.ObjectCreationFactory#createObject(org.xml.sax.Attributes)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process the beginning of this element.
 * @param attributes The attribute list of this element
 */
@Override public void begin(String namespace,String name,Attributes attributes) throws Exception {
  if (ignoreCreateExceptions) {
    if (exceptionIgnoredStack == null) {
      exceptionIgnoredStack=new ArrayStack<Boolean>();
    }
    try {
      Object instance=getFactory(attributes).createObject(attributes);
      if (digester.log.isDebugEnabled()) {
        digester.log.debug("[FactoryCreateRule]{" + digester.match + "} New "+ instance.getClass().getName());
      }
      digester.push(instance);
      exceptionIgnoredStack.push(Boolean.FALSE);
    }
 catch (    Exception e) {
      if (digester.log.isInfoEnabled()) {
        digester.log.info("[FactoryCreateRule] Create exception ignored: " + ((e.getMessage() == null) ? e.getClass().getName() : e.getMessage()));
        if (digester.log.isDebugEnabled()) {
          digester.log.debug("[FactoryCreateRule] Ignored exception:",e);
        }
      }
      exceptionIgnoredStack.push(Boolean.TRUE);
    }
  }
 else {
    Object instance=getFactory(attributes).createObject(attributes);
    if (digester.log.isDebugEnabled()) {
      digester.log.debug("[FactoryCreateRule]{" + digester.match + "} New "+ instance.getClass().getName());
    }
    digester.push(instance);
  }
}

ID 4945=========================================================================type: 1
Method:org.apache.tomcat.util.digester.CallMethodRule#setDigester(org.apache.tomcat.util.digester.Digester)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Set the associated digester. If needed, this class loads the parameter classes from their names.
 */
@Override public void setDigester(Digester digester){
  super.setDigester(digester);
  if (this.paramClassNames != null) {
    this.paramTypes=new Class[paramClassNames.length];
    for (int i=0; i < this.paramClassNames.length; i++) {
      try {
        this.paramTypes[i]=digester.getClassLoader().loadClass(this.paramClassNames[i]);
      }
 catch (      ClassNotFoundException e) {
        digester.getLogger().error("(CallMethodRule) Cannot load class " + this.paramClassNames[i],e);
        this.paramTypes[i]=null;
      }
    }
  }
}

ID 4948=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#characters(char[], int, int)
Rmethod: org.w3c.dom.Node#appendChild(org.w3c.dom.Node)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Appends a  {@link org.w3c.dom.Text Text} node to the current node.
 * @param ch the characters from the XML document
 * @param start the start position in the array
 * @param length the number of characters to read from the array
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void characters(char[] ch,int start,int length) throws SAXException {
  try {
    String str=new String(ch,start,length);
    if (str.trim().length() > 0) {
      top.appendChild(doc.createTextNode(str));
    }
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4951=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#processingInstruction(java.lang.String, java.lang.String)
Rmethod: org.w3c.dom.Document#createProcessingInstruction(java.lang.String, java.lang.String)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new {@link org.w3c.dom.ProcessingInstruction ProcessingInstruction} to the current node.
 * @param target the processing instruction target
 * @param data the processing instruction data, or null if none was supplied
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void processingInstruction(String target,String data) throws SAXException {
  try {
    top.appendChild(doc.createProcessingInstruction(target,data));
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4952=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#processingInstruction(java.lang.String, java.lang.String)
Rmethod: org.w3c.dom.Node#appendChild(org.w3c.dom.Node)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new {@link org.w3c.dom.ProcessingInstruction ProcessingInstruction} to the current node.
 * @param target the processing instruction target
 * @param data the processing instruction data, or null if none was supplied
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void processingInstruction(String target,String data) throws SAXException {
  try {
    top.appendChild(doc.createProcessingInstruction(target,data));
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4953=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Document#createElement(java.lang.String)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4954=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Document#createElementNS(java.lang.String, java.lang.String)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4955=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Document#createAttribute(java.lang.String)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4956=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Node#setNodeValue(java.lang.String)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4957=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Element#setAttributeNode(org.w3c.dom.Attr)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4958=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Document#createAttributeNS(java.lang.String, java.lang.String)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4959=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Element#setAttributeNodeNS(org.w3c.dom.Attr)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4960=========================================================================type: 1
Method:org.apache.tomcat.util.digester.NodeBuilder#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
Rmethod: org.w3c.dom.Node#appendChild(org.w3c.dom.Node)
parentException: RuntimeException 
thrown: DOMException
exception comment: /** 
 * If an attempt is made to use an object that is not, or is no longer, usable.
 * @since DOM Level 2
 */

block: 
/** 
 * Adds a new child  {@link org.w3c.dom.Element Element} to the currentnode.
 * @param namespaceURI the namespace URI
 * @param localName the local name
 * @param qName the qualified (prefixed) name
 * @param atts the list of attributes
 * @throws SAXException if the DOM implementation throws an exception
 */
@Override public void startElement(String namespaceURI,String localName,String qName,Attributes atts) throws SAXException {
  try {
    Node previousTop=top;
    if ((localName == null) || (localName.length() == 0)) {
      top=doc.createElement(qName);
    }
 else {
      top=doc.createElementNS(namespaceURI,localName);
    }
    for (int i=0; i < atts.getLength(); i++) {
      Attr attr=null;
      if ((atts.getLocalName(i) == null) || (atts.getLocalName(i).length() == 0)) {
        attr=doc.createAttribute(atts.getQName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNode(attr);
      }
 else {
        attr=doc.createAttributeNS(atts.getURI(i),atts.getLocalName(i));
        attr.setNodeValue(atts.getValue(i));
        ((Element)top).setAttributeNodeNS(attr);
      }
    }
    previousTop.appendChild(top);
    depth++;
  }
 catch (  DOMException e) {
    throw new SAXException(e.getMessage(),e);
  }
}

ID 4972=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#findNamespaceURI(java.lang.String)
Rmethod: org.apache.tomcat.util.digester.ArrayStack#peek()
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * Return the currently mapped namespace URI for the specified prefix, if any; otherwise return <code>null</code>.  These mappings come and go dynamically as the document is parsed.
 * @param prefix Prefix to look up
 */
public String findNamespaceURI(String prefix){
  ArrayStack<String> stack=namespaces.get(prefix);
  if (stack == null) {
    return (null);
  }
  try {
    return stack.peek();
  }
 catch (  EmptyStackException e) {
    return (null);
  }
}

ID 5004=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#endPrefixMapping(java.lang.String)
Rmethod: org.apache.tomcat.util.digester.ArrayStack#pop()
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * Process notification that a namespace prefix is going out of scope.
 * @param prefix Prefix that is going out of scope
 * @exception SAXException if a parsing error is to be reported
 */
@Override public void endPrefixMapping(String prefix) throws SAXException {
  if (saxLog.isDebugEnabled()) {
    saxLog.debug("endPrefixMapping(" + prefix + ")");
  }
  ArrayStack<String> stack=namespaces.get(prefix);
  if (stack == null) {
    return;
  }
  try {
    stack.pop();
    if (stack.empty())     namespaces.remove(prefix);
  }
 catch (  EmptyStackException e) {
    throw createSAXException("endPrefixMapping popped too many times");
  }
}

ID 5006=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#resolveEntity(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
Rmethod: java.net.URI#URI(java.lang.String)
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
@Override public InputSource resolveEntity(String name,String publicId,String baseURI,String systemId) throws SAXException, IOException {
  if (saxLog.isDebugEnabled()) {
    saxLog.debug("resolveEntity('" + publicId + "', '"+ systemId+ "', '"+ baseURI+ "')");
  }
  String entityURL=null;
  if (publicId != null) {
    entityURL=entityValidator.get(publicId);
  }
  if (entityURL == null) {
    if (systemId == null) {
      if (log.isDebugEnabled()) {
        log.debug(" Cannot resolve entity: '" + publicId + "'");
      }
      return (null);
    }
 else {
      if (log.isDebugEnabled()) {
        log.debug(" Trying to resolve using system ID '" + systemId + "'");
      }
      entityURL=systemId;
      if (baseURI != null) {
        try {
          URI uri=new URI(systemId);
          if (!uri.isAbsolute()) {
            entityURL=new URI(baseURI).resolve(uri).toString();
          }
        }
 catch (        URISyntaxException e) {
          if (log.isDebugEnabled()) {
            log.debug("Invalid URI '" + baseURI + "' or '"+ systemId+ "'");
          }
        }
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(" Resolving to alternate DTD '" + entityURL + "'");
  }
  try {
    return (new InputSource(entityURL));
  }
 catch (  Exception e) {
    throw createSAXException(e);
  }
}

ID 5026=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#peek()
Rmethod: org.apache.tomcat.util.digester.ArrayStack#peek()
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * Return the top object on the stack without removing it.  If there are no objects on the stack, return <code>null</code>.
 */
public Object peek(){
  try {
    return (stack.peek());
  }
 catch (  EmptyStackException e) {
    log.warn("Empty stack (returning null)");
    return (null);
  }
}

ID 5027=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#peek(int)
Rmethod: org.apache.tomcat.util.digester.ArrayStack#peek(int)
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * Return the n'th object down the stack, where 0 is the top element and [getCount()-1] is the bottom element.  If the specified index is out of range, return <code>null</code>.
 * @param n Index of the desired element, where 0 is the top of the stack,1 is the next element down, and so on.
 */
public Object peek(int n){
  try {
    return (stack.peek(n));
  }
 catch (  EmptyStackException e) {
    log.warn("Empty stack (returning null)");
    return (null);
  }
}

ID 5028=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#pop()
Rmethod: org.apache.tomcat.util.digester.ArrayStack#pop()
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * Pop the top object off of the stack, and return it.  If there are no objects on the stack, return <code>null</code>.
 */
public Object pop(){
  try {
    return (stack.pop());
  }
 catch (  EmptyStackException e) {
    log.warn("Empty stack (returning null)");
    return (null);
  }
}

ID 5031=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#peekParams()
Rmethod: org.apache.tomcat.util.digester.ArrayStack#peek()
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * <p>Return the top object on the parameters stack without removing it.  If there are no objects on the stack, return <code>null</code>.</p> <p>The parameters stack is used to store <code>CallMethodRule</code> parameters.  See  {@link #params}.</p>
 */
public Object peekParams(){
  try {
    return (params.peek());
  }
 catch (  EmptyStackException e) {
    log.warn("Empty stack (returning null)");
    return (null);
  }
}

ID 5032=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#peekParams(int)
Rmethod: org.apache.tomcat.util.digester.ArrayStack#peek(int)
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * <p>Return the n'th object down the parameters stack, where 0 is the top element and [getCount()-1] is the bottom element.  If the specified index is out of range, return <code>null</code>.</p> <p>The parameters stack is used to store <code>CallMethodRule</code> parameters.  See  {@link #params}.</p>
 * @param n Index of the desired element, where 0 is the top of the stack,1 is the next element down, and so on.
 */
public Object peekParams(int n){
  try {
    return (params.peek(n));
  }
 catch (  EmptyStackException e) {
    log.warn("Empty stack (returning null)");
    return (null);
  }
}

ID 5033=========================================================================type: 1
Method:org.apache.tomcat.util.digester.Digester#popParams()
Rmethod: org.apache.tomcat.util.digester.ArrayStack#pop()
parentException: RuntimeException 
thrown: EmptyStackException
exception comment: /** 
 * Thrown by methods in the <code>Stack</code> class to indicate that the stack is empty.
 * @author  Jonathan Payne
 * @see java.util.Stack
 * @since   JDK1.0
 */

block: 
/** 
 * <p>Pop the top object off of the parameters stack, and return it.  If there are no objects on the stack, return <code>null</code>.</p> <p>The parameters stack is used to store <code>CallMethodRule</code> parameters.  See  {@link #params}.</p>
 */
public Object popParams(){
  try {
    if (log.isTraceEnabled()) {
      log.trace("Popping params");
    }
    return (params.pop());
  }
 catch (  EmptyStackException e) {
    log.warn("Empty stack (returning null)");
    return (null);
  }
}

ID 5037=========================================================================type: 1
Method:org.apache.tomcat.util.digester.GenericParser#newSAXParser(java.util.Properties)
Rmethod: javax.xml.parsers.SAXParser#setProperty(java.lang.String, java.lang.Object)
parentException: SAXException 
thrown: SAXNotRecognizedException
exception comment: /** 
 * Exception class for an unrecognized identifier. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>An XMLReader will throw this exception when it finds an unrecognized feature or property identifier; SAX applications and extensions may use this class for other, similar purposes.</p>
 * @since SAX 2.0
 * @author David Megginson
 * @see org.xml.sax.SAXNotSupportedException
 */

block: 
/** 
 * Create a <code>SAXParser</code> configured to support XML Schema and DTD
 * @param properties parser specific properties/features
 * @return an XML Schema/DTD enabled <code>SAXParser</code>
 */
public static SAXParser newSAXParser(Properties properties) throws ParserConfigurationException, SAXException, SAXNotRecognizedException {
  SAXParserFactory factory=(SAXParserFactory)properties.get("SAXParserFactory");
  SAXParser parser=factory.newSAXParser();
  String schemaLocation=(String)properties.get("schemaLocation");
  String schemaLanguage=(String)properties.get("schemaLanguage");
  try {
    if (schemaLocation != null) {
      parser.setProperty(JAXP_SCHEMA_LANGUAGE,schemaLanguage);
      parser.setProperty(JAXP_SCHEMA_SOURCE,schemaLocation);
    }
  }
 catch (  SAXNotRecognizedException e) {
    log.info(parser.getClass().getName() + ": " + e.getMessage()+ " not supported.");
  }
  return parser;
}

ID 5053=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.servlet.ServletRequestContext#contentLength()
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Retrieve the content length of the request.
 * @return The content length of the request.
 * @since 1.3
 */
@Override public long contentLength(){
  long size;
  try {
    size=Long.parseLong(request.getHeader(FileUploadBase.CONTENT_LENGTH));
  }
 catch (  NumberFormatException e) {
    size=request.getContentLength();
  }
  return size;
}

ID 5058=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest(org.apache.tomcat.util.http.fileupload.RequestContext)
Rmethod: org.apache.tomcat.util.http.fileupload.FileUploadBase#getItemIterator(org.apache.tomcat.util.http.fileupload.RequestContext)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Processes an <a href="http://www.ietf.org/rfc/rfc1867.txt">RFC 1867</a> compliant <code>multipart/form-data</code> stream.
 * @param ctx The context for the request to be parsed.
 * @return A list of <code>FileItem</code> instances parsed from therequest, in the order that they were transmitted.
 * @throws FileUploadException if there are problems reading/parsingthe request or storing files.
 */
public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
  List<FileItem> items=new ArrayList<FileItem>();
  boolean successful=false;
  try {
    FileItemIterator iter=getItemIterator(ctx);
    FileItemFactory fac=getFileItemFactory();
    if (fac == null) {
      throw new NullPointerException("No FileItemFactory has been set.");
    }
    while (iter.hasNext()) {
      final FileItemStream item=iter.next();
      final String fileName=((FileItemIteratorImpl.FileItemStreamImpl)item).name;
      FileItem fileItem=fac.createItem(item.getFieldName(),item.getContentType(),item.isFormField(),fileName);
      items.add(fileItem);
      try {
        Streams.copy(item.openStream(),fileItem.getOutputStream(),true);
      }
 catch (      FileUploadIOException e) {
        throw (FileUploadException)e.getCause();
      }
catch (      IOException e) {
        throw new IOFileUploadException(String.format("Processing of %s request failed. %s",MULTIPART_FORM_DATA,e.getMessage()),e);
      }
      final FileItemHeaders fih=item.getHeaders();
      fileItem.setHeaders(fih);
    }
    successful=true;
    return items;
  }
 catch (  FileUploadIOException e) {
    throw (FileUploadException)e.getCause();
  }
catch (  IOException e) {
    throw new FileUploadException(e.getMessage(),e);
  }
 finally {
    if (!successful) {
      for (      FileItem fileItem : items) {
        try {
          fileItem.delete();
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
}

ID 5060=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest(org.apache.tomcat.util.http.fileupload.RequestContext)
Rmethod: org.apache.tomcat.util.http.fileupload.FileItemIterator#hasNext()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Processes an <a href="http://www.ietf.org/rfc/rfc1867.txt">RFC 1867</a> compliant <code>multipart/form-data</code> stream.
 * @param ctx The context for the request to be parsed.
 * @return A list of <code>FileItem</code> instances parsed from therequest, in the order that they were transmitted.
 * @throws FileUploadException if there are problems reading/parsingthe request or storing files.
 */
public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
  List<FileItem> items=new ArrayList<FileItem>();
  boolean successful=false;
  try {
    FileItemIterator iter=getItemIterator(ctx);
    FileItemFactory fac=getFileItemFactory();
    if (fac == null) {
      throw new NullPointerException("No FileItemFactory has been set.");
    }
    while (iter.hasNext()) {
      final FileItemStream item=iter.next();
      final String fileName=((FileItemIteratorImpl.FileItemStreamImpl)item).name;
      FileItem fileItem=fac.createItem(item.getFieldName(),item.getContentType(),item.isFormField(),fileName);
      items.add(fileItem);
      try {
        Streams.copy(item.openStream(),fileItem.getOutputStream(),true);
      }
 catch (      FileUploadIOException e) {
        throw (FileUploadException)e.getCause();
      }
catch (      IOException e) {
        throw new IOFileUploadException(String.format("Processing of %s request failed. %s",MULTIPART_FORM_DATA,e.getMessage()),e);
      }
      final FileItemHeaders fih=item.getHeaders();
      fileItem.setHeaders(fih);
    }
    successful=true;
    return items;
  }
 catch (  FileUploadIOException e) {
    throw (FileUploadException)e.getCause();
  }
catch (  IOException e) {
    throw new FileUploadException(e.getMessage(),e);
  }
 finally {
    if (!successful) {
      for (      FileItem fileItem : items) {
        try {
          fileItem.delete();
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
}

ID 5062=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest(org.apache.tomcat.util.http.fileupload.RequestContext)
Rmethod: org.apache.tomcat.util.http.fileupload.FileItemIterator#next()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Processes an <a href="http://www.ietf.org/rfc/rfc1867.txt">RFC 1867</a> compliant <code>multipart/form-data</code> stream.
 * @param ctx The context for the request to be parsed.
 * @return A list of <code>FileItem</code> instances parsed from therequest, in the order that they were transmitted.
 * @throws FileUploadException if there are problems reading/parsingthe request or storing files.
 */
public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
  List<FileItem> items=new ArrayList<FileItem>();
  boolean successful=false;
  try {
    FileItemIterator iter=getItemIterator(ctx);
    FileItemFactory fac=getFileItemFactory();
    if (fac == null) {
      throw new NullPointerException("No FileItemFactory has been set.");
    }
    while (iter.hasNext()) {
      final FileItemStream item=iter.next();
      final String fileName=((FileItemIteratorImpl.FileItemStreamImpl)item).name;
      FileItem fileItem=fac.createItem(item.getFieldName(),item.getContentType(),item.isFormField(),fileName);
      items.add(fileItem);
      try {
        Streams.copy(item.openStream(),fileItem.getOutputStream(),true);
      }
 catch (      FileUploadIOException e) {
        throw (FileUploadException)e.getCause();
      }
catch (      IOException e) {
        throw new IOFileUploadException(String.format("Processing of %s request failed. %s",MULTIPART_FORM_DATA,e.getMessage()),e);
      }
      final FileItemHeaders fih=item.getHeaders();
      fileItem.setHeaders(fih);
    }
    successful=true;
    return items;
  }
 catch (  FileUploadIOException e) {
    throw (FileUploadException)e.getCause();
  }
catch (  IOException e) {
    throw new FileUploadException(e.getMessage(),e);
  }
 finally {
    if (!successful) {
      for (      FileItem fileItem : items) {
        try {
          fileItem.delete();
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
}

ID 5063=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest(org.apache.tomcat.util.http.fileupload.RequestContext)
Rmethod: org.apache.tomcat.util.http.fileupload.FileItemStream#openStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Processes an <a href="http://www.ietf.org/rfc/rfc1867.txt">RFC 1867</a> compliant <code>multipart/form-data</code> stream.
 * @param ctx The context for the request to be parsed.
 * @return A list of <code>FileItem</code> instances parsed from therequest, in the order that they were transmitted.
 * @throws FileUploadException if there are problems reading/parsingthe request or storing files.
 */
public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
  List<FileItem> items=new ArrayList<FileItem>();
  boolean successful=false;
  try {
    FileItemIterator iter=getItemIterator(ctx);
    FileItemFactory fac=getFileItemFactory();
    if (fac == null) {
      throw new NullPointerException("No FileItemFactory has been set.");
    }
    while (iter.hasNext()) {
      final FileItemStream item=iter.next();
      final String fileName=((FileItemIteratorImpl.FileItemStreamImpl)item).name;
      FileItem fileItem=fac.createItem(item.getFieldName(),item.getContentType(),item.isFormField(),fileName);
      items.add(fileItem);
      try {
        Streams.copy(item.openStream(),fileItem.getOutputStream(),true);
      }
 catch (      FileUploadIOException e) {
        throw (FileUploadException)e.getCause();
      }
catch (      IOException e) {
        throw new IOFileUploadException(String.format("Processing of %s request failed. %s",MULTIPART_FORM_DATA,e.getMessage()),e);
      }
      final FileItemHeaders fih=item.getHeaders();
      fileItem.setHeaders(fih);
    }
    successful=true;
    return items;
  }
 catch (  FileUploadIOException e) {
    throw (FileUploadException)e.getCause();
  }
catch (  IOException e) {
    throw new FileUploadException(e.getMessage(),e);
  }
 finally {
    if (!successful) {
      for (      FileItem fileItem : items) {
        try {
          fileItem.delete();
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
}

ID 5064=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest(org.apache.tomcat.util.http.fileupload.RequestContext)
Rmethod: org.apache.tomcat.util.http.fileupload.FileItem#getOutputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Processes an <a href="http://www.ietf.org/rfc/rfc1867.txt">RFC 1867</a> compliant <code>multipart/form-data</code> stream.
 * @param ctx The context for the request to be parsed.
 * @return A list of <code>FileItem</code> instances parsed from therequest, in the order that they were transmitted.
 * @throws FileUploadException if there are problems reading/parsingthe request or storing files.
 */
public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
  List<FileItem> items=new ArrayList<FileItem>();
  boolean successful=false;
  try {
    FileItemIterator iter=getItemIterator(ctx);
    FileItemFactory fac=getFileItemFactory();
    if (fac == null) {
      throw new NullPointerException("No FileItemFactory has been set.");
    }
    while (iter.hasNext()) {
      final FileItemStream item=iter.next();
      final String fileName=((FileItemIteratorImpl.FileItemStreamImpl)item).name;
      FileItem fileItem=fac.createItem(item.getFieldName(),item.getContentType(),item.isFormField(),fileName);
      items.add(fileItem);
      try {
        Streams.copy(item.openStream(),fileItem.getOutputStream(),true);
      }
 catch (      FileUploadIOException e) {
        throw (FileUploadException)e.getCause();
      }
catch (      IOException e) {
        throw new IOFileUploadException(String.format("Processing of %s request failed. %s",MULTIPART_FORM_DATA,e.getMessage()),e);
      }
      final FileItemHeaders fih=item.getHeaders();
      fileItem.setHeaders(fih);
    }
    successful=true;
    return items;
  }
 catch (  FileUploadIOException e) {
    throw (FileUploadException)e.getCause();
  }
catch (  IOException e) {
    throw new FileUploadException(e.getMessage(),e);
  }
 finally {
    if (!successful) {
      for (      FileItem fileItem : items) {
        try {
          fileItem.delete();
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
}

ID 5065=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUploadBase#parseRequest(org.apache.tomcat.util.http.fileupload.RequestContext)
Rmethod: org.apache.tomcat.util.http.fileupload.util.Streams#copy(java.io.InputStream, java.io.OutputStream, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Processes an <a href="http://www.ietf.org/rfc/rfc1867.txt">RFC 1867</a> compliant <code>multipart/form-data</code> stream.
 * @param ctx The context for the request to be parsed.
 * @return A list of <code>FileItem</code> instances parsed from therequest, in the order that they were transmitted.
 * @throws FileUploadException if there are problems reading/parsingthe request or storing files.
 */
public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
  List<FileItem> items=new ArrayList<FileItem>();
  boolean successful=false;
  try {
    FileItemIterator iter=getItemIterator(ctx);
    FileItemFactory fac=getFileItemFactory();
    if (fac == null) {
      throw new NullPointerException("No FileItemFactory has been set.");
    }
    while (iter.hasNext()) {
      final FileItemStream item=iter.next();
      final String fileName=((FileItemIteratorImpl.FileItemStreamImpl)item).name;
      FileItem fileItem=fac.createItem(item.getFieldName(),item.getContentType(),item.isFormField(),fileName);
      items.add(fileItem);
      try {
        Streams.copy(item.openStream(),fileItem.getOutputStream(),true);
      }
 catch (      FileUploadIOException e) {
        throw (FileUploadException)e.getCause();
      }
catch (      IOException e) {
        throw new IOFileUploadException(String.format("Processing of %s request failed. %s",MULTIPART_FORM_DATA,e.getMessage()),e);
      }
      final FileItemHeaders fih=item.getHeaders();
      fileItem.setHeaders(fih);
    }
    successful=true;
    return items;
  }
 catch (  FileUploadIOException e) {
    throw (FileUploadException)e.getCause();
  }
catch (  IOException e) {
    throw new FileUploadException(e.getMessage(),e);
  }
 finally {
    if (!successful) {
      for (      FileItem fileItem : items) {
        try {
          fileItem.delete();
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
}

ID 5092=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.util.mime.MimeUtility#decodeWord(java.lang.String)
Rmethod: java.lang.String#getBytes(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Parse a string using the RFC 2047 rules for an "encoded-word" type.  This encoding has the syntax: encoded-word = "=?" charset "?" encoding "?" encoded-text "?="
 * @param word   The possibly encoded word value.
 * @return The decoded word.
 * @throws ParseException
 * @throws UnsupportedEncodingException
 */
private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
  if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
    throw new ParseException("Invalid RFC 2047 encoded-word: " + word);
  }
  int charsetPos=word.indexOf('?',2);
  if (charsetPos == -1) {
    throw new ParseException("Missing charset in RFC 2047 encoded-word: " + word);
  }
  String charset=word.substring(2,charsetPos).toLowerCase(Locale.ENGLISH);
  int encodingPos=word.indexOf('?',charsetPos + 1);
  if (encodingPos == -1) {
    throw new ParseException("Missing encoding in RFC 2047 encoded-word: " + word);
  }
  String encoding=word.substring(charsetPos + 1,encodingPos);
  int encodedTextPos=word.indexOf(ENCODED_TOKEN_FINISHER,encodingPos + 1);
  if (encodedTextPos == -1) {
    throw new ParseException("Missing encoded text in RFC 2047 encoded-word: " + word);
  }
  String encodedText=word.substring(encodingPos + 1,encodedTextPos);
  if (encodedText.length() == 0) {
    return "";
  }
  try {
    ByteArrayOutputStream out=new ByteArrayOutputStream(encodedText.length());
    byte[] decodedData;
    if (encoding.equals(BASE64_ENCODING_MARKER)) {
      decodedData=Base64.decodeBase64(encodedText);
    }
 else     if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
      byte[] encodedData=encodedText.getBytes(US_ASCII_CHARSET);
      QuotedPrintableDecoder.decode(encodedData,out);
      decodedData=out.toByteArray();
    }
 else {
      throw new UnsupportedEncodingException("Unknown RFC 2047 encoding: " + encoding);
    }
    return new String(decodedData,javaCharset(charset));
  }
 catch (  IOException e) {
    throw new UnsupportedEncodingException("Invalid RFC 2047 encoding");
  }
}

ID 5093=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.util.mime.MimeUtility#decodeWord(java.lang.String)
Rmethod: org.apache.tomcat.util.http.fileupload.util.mime.QuotedPrintableDecoder#decode(byte[], java.io.OutputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Parse a string using the RFC 2047 rules for an "encoded-word" type.  This encoding has the syntax: encoded-word = "=?" charset "?" encoding "?" encoded-text "?="
 * @param word   The possibly encoded word value.
 * @return The decoded word.
 * @throws ParseException
 * @throws UnsupportedEncodingException
 */
private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
  if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
    throw new ParseException("Invalid RFC 2047 encoded-word: " + word);
  }
  int charsetPos=word.indexOf('?',2);
  if (charsetPos == -1) {
    throw new ParseException("Missing charset in RFC 2047 encoded-word: " + word);
  }
  String charset=word.substring(2,charsetPos).toLowerCase(Locale.ENGLISH);
  int encodingPos=word.indexOf('?',charsetPos + 1);
  if (encodingPos == -1) {
    throw new ParseException("Missing encoding in RFC 2047 encoded-word: " + word);
  }
  String encoding=word.substring(charsetPos + 1,encodingPos);
  int encodedTextPos=word.indexOf(ENCODED_TOKEN_FINISHER,encodingPos + 1);
  if (encodedTextPos == -1) {
    throw new ParseException("Missing encoded text in RFC 2047 encoded-word: " + word);
  }
  String encodedText=word.substring(encodingPos + 1,encodedTextPos);
  if (encodedText.length() == 0) {
    return "";
  }
  try {
    ByteArrayOutputStream out=new ByteArrayOutputStream(encodedText.length());
    byte[] decodedData;
    if (encoding.equals(BASE64_ENCODING_MARKER)) {
      decodedData=Base64.decodeBase64(encodedText);
    }
 else     if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
      byte[] encodedData=encodedText.getBytes(US_ASCII_CHARSET);
      QuotedPrintableDecoder.decode(encodedData,out);
      decodedData=out.toByteArray();
    }
 else {
      throw new UnsupportedEncodingException("Unknown RFC 2047 encoding: " + encoding);
    }
    return new String(decodedData,javaCharset(charset));
  }
 catch (  IOException e) {
    throw new UnsupportedEncodingException("Invalid RFC 2047 encoding");
  }
}

ID 5094=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.util.mime.MimeUtility#decodeWord(java.lang.String)
Rmethod: java.lang.String#String(byte[], java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Parse a string using the RFC 2047 rules for an "encoded-word" type.  This encoding has the syntax: encoded-word = "=?" charset "?" encoding "?" encoded-text "?="
 * @param word   The possibly encoded word value.
 * @return The decoded word.
 * @throws ParseException
 * @throws UnsupportedEncodingException
 */
private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {
  if (!word.startsWith(ENCODED_TOKEN_MARKER)) {
    throw new ParseException("Invalid RFC 2047 encoded-word: " + word);
  }
  int charsetPos=word.indexOf('?',2);
  if (charsetPos == -1) {
    throw new ParseException("Missing charset in RFC 2047 encoded-word: " + word);
  }
  String charset=word.substring(2,charsetPos).toLowerCase(Locale.ENGLISH);
  int encodingPos=word.indexOf('?',charsetPos + 1);
  if (encodingPos == -1) {
    throw new ParseException("Missing encoding in RFC 2047 encoded-word: " + word);
  }
  String encoding=word.substring(charsetPos + 1,encodingPos);
  int encodedTextPos=word.indexOf(ENCODED_TOKEN_FINISHER,encodingPos + 1);
  if (encodedTextPos == -1) {
    throw new ParseException("Missing encoded text in RFC 2047 encoded-word: " + word);
  }
  String encodedText=word.substring(encodingPos + 1,encodedTextPos);
  if (encodedText.length() == 0) {
    return "";
  }
  try {
    ByteArrayOutputStream out=new ByteArrayOutputStream(encodedText.length());
    byte[] decodedData;
    if (encoding.equals(BASE64_ENCODING_MARKER)) {
      decodedData=Base64.decodeBase64(encodedText);
    }
 else     if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) {
      byte[] encodedData=encodedText.getBytes(US_ASCII_CHARSET);
      QuotedPrintableDecoder.decode(encodedData,out);
      decodedData=out.toByteArray();
    }
 else {
      throw new UnsupportedEncodingException("Unknown RFC 2047 encoding: " + encoding);
    }
    return new String(decodedData,javaCharset(charset));
  }
 catch (  IOException e) {
    throw new UnsupportedEncodingException("Invalid RFC 2047 encoding");
  }
}

ID 5107=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.MultipartStream#readBoundary()
Rmethod: org.apache.tomcat.util.http.fileupload.MultipartStream#readByte()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Skips a <code>boundary</code> token, and checks whether more <code>encapsulations</code> are contained in the stream.
 * @return <code>true</code> if there are more encapsulations inthis stream; <code>false</code> otherwise.
 * @throws FileUploadIOException if the bytes read from the stream exceeded the size limits
 * @throws MalformedStreamException if the stream ends unexpectedly orfails to follow required syntax.
 */
public boolean readBoundary() throws FileUploadIOException, MalformedStreamException {
  byte[] marker=new byte[2];
  boolean nextChunk=false;
  head+=boundaryLength;
  try {
    marker[0]=readByte();
    if (marker[0] == LF) {
      return true;
    }
    marker[1]=readByte();
    if (arrayequals(marker,STREAM_TERMINATOR,2)) {
      nextChunk=false;
    }
 else     if (arrayequals(marker,FIELD_SEPARATOR,2)) {
      nextChunk=true;
    }
 else {
      throw new MalformedStreamException("Unexpected characters follow a boundary");
    }
  }
 catch (  FileUploadIOException e) {
    throw e;
  }
catch (  IOException e) {
    throw new MalformedStreamException("Stream ended unexpectedly");
  }
  return nextChunk;
}

ID 5108=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.MultipartStream#readHeaders()
Rmethod: org.apache.tomcat.util.http.fileupload.MultipartStream#readByte()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * <p>Reads the <code>header-part</code> of the current <code>encapsulation</code>. <p>Headers are returned verbatim to the input stream, including the trailing <code>CRLF</code> marker. Parsing is left to the application. <p><strong>TODO</strong> allow limiting maximum header size to protect against abuse.
 * @return The <code>header-part</code> of the current encapsulation.
 * @throws FileUploadIOException if the bytes read from the stream exceeded the size limits.
 * @throws MalformedStreamException if the stream ends unexpectedly.
 */
public String readHeaders() throws FileUploadIOException, MalformedStreamException {
  int i=0;
  byte b;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int size=0;
  while (i < HEADER_SEPARATOR.length) {
    try {
      b=readByte();
    }
 catch (    FileUploadIOException e) {
      throw e;
    }
catch (    IOException e) {
      throw new MalformedStreamException("Stream ended unexpectedly");
    }
    if (++size > HEADER_PART_SIZE_MAX) {
      throw new MalformedStreamException(String.format("Header section has more than %s bytes (maybe it is not properly terminated)",Integer.valueOf(HEADER_PART_SIZE_MAX)));
    }
    if (b == HEADER_SEPARATOR[i]) {
      i++;
    }
 else {
      i=0;
    }
    baos.write(b);
  }
  String headers=null;
  if (headerEncoding != null) {
    try {
      headers=baos.toString(headerEncoding);
    }
 catch (    UnsupportedEncodingException e) {
      headers=baos.toString();
    }
  }
 else {
    headers=baos.toString();
  }
  return headers;
}

ID 5109=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.MultipartStream#readHeaders()
Rmethod: java.io.ByteArrayOutputStream#toString(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * <p>Reads the <code>header-part</code> of the current <code>encapsulation</code>. <p>Headers are returned verbatim to the input stream, including the trailing <code>CRLF</code> marker. Parsing is left to the application. <p><strong>TODO</strong> allow limiting maximum header size to protect against abuse.
 * @return The <code>header-part</code> of the current encapsulation.
 * @throws FileUploadIOException if the bytes read from the stream exceeded the size limits.
 * @throws MalformedStreamException if the stream ends unexpectedly.
 */
public String readHeaders() throws FileUploadIOException, MalformedStreamException {
  int i=0;
  byte b;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int size=0;
  while (i < HEADER_SEPARATOR.length) {
    try {
      b=readByte();
    }
 catch (    FileUploadIOException e) {
      throw e;
    }
catch (    IOException e) {
      throw new MalformedStreamException("Stream ended unexpectedly");
    }
    if (++size > HEADER_PART_SIZE_MAX) {
      throw new MalformedStreamException(String.format("Header section has more than %s bytes (maybe it is not properly terminated)",Integer.valueOf(HEADER_PART_SIZE_MAX)));
    }
    if (b == HEADER_SEPARATOR[i]) {
      i++;
    }
 else {
      i=0;
    }
    baos.write(b);
  }
  String headers=null;
  if (headerEncoding != null) {
    try {
      headers=baos.toString(headerEncoding);
    }
 catch (    UnsupportedEncodingException e) {
      headers=baos.toString();
    }
  }
 else {
    headers=baos.toString();
  }
  return headers;
}

ID 5113=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.MultipartStream#skipPreamble()
Rmethod: org.apache.tomcat.util.http.fileupload.MultipartStream#discardBodyData()
parentException: IOException 
thrown: MalformedStreamException
exception comment: null
block: 
/** 
 * Finds the beginning of the first <code>encapsulation</code>.
 * @return <code>true</code> if an <code>encapsulation</code> was found inthe stream.
 * @throws IOException if an i/o error occurs.
 */
public boolean skipPreamble() throws IOException {
  System.arraycopy(boundary,2,boundary,0,boundary.length - 2);
  boundaryLength=boundary.length - 2;
  computeBoundaryTable();
  try {
    discardBodyData();
    return readBoundary();
  }
 catch (  MalformedStreamException e) {
    return false;
  }
 finally {
    System.arraycopy(boundary,0,boundary,2,boundary.length - 2);
    boundaryLength=boundary.length;
    boundary[0]=CR;
    boundary[1]=LF;
    computeBoundaryTable();
  }
}

ID 5116=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.MultipartStream#skipPreamble()
Rmethod: org.apache.tomcat.util.http.fileupload.MultipartStream#readBoundary()
parentException: IOException 
thrown: MalformedStreamException
exception comment: null
block: 
/** 
 * Finds the beginning of the first <code>encapsulation</code>.
 * @return <code>true</code> if an <code>encapsulation</code> was found inthe stream.
 * @throws IOException if an i/o error occurs.
 */
public boolean skipPreamble() throws IOException {
  System.arraycopy(boundary,2,boundary,0,boundary.length - 2);
  boundaryLength=boundary.length - 2;
  computeBoundaryTable();
  try {
    discardBodyData();
    return readBoundary();
  }
 catch (  MalformedStreamException e) {
    return false;
  }
 finally {
    System.arraycopy(boundary,0,boundary,2,boundary.length - 2);
    boundaryLength=boundary.length;
    boundary[0]=CR;
    boundary[1]=LF;
    computeBoundaryTable();
  }
}

ID 5132=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUtils#cleanDirectory(java.io.File)
Rmethod: org.apache.tomcat.util.http.fileupload.FileUtils#forceDelete(java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Cleans a directory without deleting it.
 * @param directory directory to clean
 * @throws IOException in case cleaning is unsuccessful
 */
public static void cleanDirectory(File directory) throws IOException {
  if (!directory.exists()) {
    String message=directory + " does not exist";
    throw new IllegalArgumentException(message);
  }
  if (!directory.isDirectory()) {
    String message=directory + " is not a directory";
    throw new IllegalArgumentException(message);
  }
  File[] files=directory.listFiles();
  if (files == null) {
    throw new IOException("Failed to list contents of " + directory);
  }
  IOException exception=null;
  for (  File file : files) {
    try {
      forceDelete(file);
    }
 catch (    IOException ioe) {
      exception=ioe;
    }
  }
  if (null != exception) {
    throw exception;
  }
}

ID 5137=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.FileUtils#cleanDirectoryOnExit(java.io.File)
Rmethod: org.apache.tomcat.util.http.fileupload.FileUtils#forceDeleteOnExit(java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Cleans a directory without deleting it.
 * @param directory  directory to clean, must not be {@code null}
 * @throws NullPointerException if the directory is {@code null}
 * @throws IOException in case cleaning is unsuccessful
 */
private static void cleanDirectoryOnExit(File directory) throws IOException {
  if (!directory.exists()) {
    String message=directory + " does not exist";
    throw new IllegalArgumentException(message);
  }
  if (!directory.isDirectory()) {
    String message=directory + " is not a directory";
    throw new IllegalArgumentException(message);
  }
  File[] files=directory.listFiles();
  if (files == null) {
    throw new IOException("Failed to list contents of " + directory);
  }
  IOException exception=null;
  for (  File file : files) {
    try {
      forceDeleteOnExit(file);
    }
 catch (    IOException ioe) {
      exception=ioe;
    }
  }
  if (null != exception) {
    throw exception;
  }
}

ID 5155=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.disk.DiskFileItem#get()
Rmethod: java.io.FileInputStream#FileInputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Returns the contents of the file as an array of bytes.  If the contents of the file were not yet cached in memory, they will be loaded from the disk storage and cached.
 * @return The contents of the file as an array of bytesor  {@code null} if the data cannot be read
 */
@Override public byte[] get(){
  if (isInMemory()) {
    if (cachedContent == null && dfos != null) {
      cachedContent=dfos.getData();
    }
    return cachedContent;
  }
  byte[] fileData=new byte[(int)getSize()];
  InputStream fis=null;
  try {
    fis=new FileInputStream(dfos.getFile());
    IOUtils.readFully(fis,fileData);
  }
 catch (  IOException e) {
    fileData=null;
  }
 finally {
    IOUtils.closeQuietly(fis);
  }
  return fileData;
}

ID 5156=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.disk.DiskFileItem#get()
Rmethod: org.apache.tomcat.util.http.fileupload.IOUtils#readFully(java.io.InputStream, byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Returns the contents of the file as an array of bytes.  If the contents of the file were not yet cached in memory, they will be loaded from the disk storage and cached.
 * @return The contents of the file as an array of bytesor  {@code null} if the data cannot be read
 */
@Override public byte[] get(){
  if (isInMemory()) {
    if (cachedContent == null && dfos != null) {
      cachedContent=dfos.getData();
    }
    return cachedContent;
  }
  byte[] fileData=new byte[(int)getSize()];
  InputStream fis=null;
  try {
    fis=new FileInputStream(dfos.getFile());
    IOUtils.readFully(fis,fileData);
  }
 catch (  IOException e) {
    fileData=null;
  }
 finally {
    IOUtils.closeQuietly(fis);
  }
  return fileData;
}

ID 5158=========================================================================type: 1
Method:org.apache.tomcat.util.http.fileupload.disk.DiskFileItem#getString()
Rmethod: java.lang.String#String(byte[], java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Returns the contents of the file as a String, using the default character encoding.  This method uses  {@link #get()} to retrieve thecontents of the file. <b>TODO</b> Consider making this method throw UnsupportedEncodingException.
 * @return The contents of the file, as a string.
 */
@Override public String getString(){
  byte[] rawdata=get();
  String charset=getCharSet();
  if (charset == null) {
    charset=DEFAULT_CHARSET;
  }
  try {
    return new String(rawdata,charset);
  }
 catch (  UnsupportedEncodingException e) {
    return new String(rawdata);
  }
}

ID 5216=========================================================================type: 1
Method:org.apache.tomcat.util.http.Parameters#handleQueryParameters()
Rmethod: org.apache.tomcat.util.buf.MessageBytes#duplicate(org.apache.tomcat.util.buf.MessageBytes)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process the query string into parameters
 */
public void handleQueryParameters(){
  if (didQueryParameters) {
    return;
  }
  didQueryParameters=true;
  if (queryMB == null || queryMB.isNull()) {
    return;
  }
  if (log.isDebugEnabled()) {
    log.debug("Decoding query " + decodedQuery + " "+ queryStringEncoding);
  }
  try {
    decodedQuery.duplicate(queryMB);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  processParameters(decodedQuery,queryStringEncoding);
}

ID 5217=========================================================================type: 1
Method:org.apache.tomcat.util.http.Parameters#processParameters(byte[], int, int, java.nio.charset.Charset)
Rmethod: org.apache.tomcat.util.buf.ByteChunk#append(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void processParameters(byte bytes[],int start,int len,Charset charset){
  if (log.isDebugEnabled()) {
    log.debug(sm.getString("parameters.bytes",new String(bytes,start,len,DEFAULT_CHARSET)));
  }
  int decodeFailCount=0;
  int pos=start;
  int end=start + len;
  while (pos < end) {
    int nameStart=pos;
    int nameEnd=-1;
    int valueStart=-1;
    int valueEnd=-1;
    boolean parsingName=true;
    boolean decodeName=false;
    boolean decodeValue=false;
    boolean parameterComplete=false;
    do {
switch (bytes[pos]) {
case '=':
        if (parsingName) {
          nameEnd=pos;
          parsingName=false;
          valueStart=++pos;
        }
 else {
          pos++;
        }
      break;
case '&':
    if (parsingName) {
      nameEnd=pos;
    }
 else {
      valueEnd=pos;
    }
  parameterComplete=true;
pos++;
break;
case '%':
case '+':
if (parsingName) {
decodeName=true;
}
 else {
decodeValue=true;
}
pos++;
break;
default :
pos++;
break;
}
}
 while (!parameterComplete && pos < end);
if (pos == end) {
if (nameEnd == -1) {
nameEnd=pos;
}
 else if (valueStart > -1 && valueEnd == -1) {
valueEnd=pos;
}
}
if (log.isDebugEnabled() && valueStart == -1) {
log.debug(sm.getString("parameters.noequal",Integer.valueOf(nameStart),Integer.valueOf(nameEnd),new String(bytes,nameStart,nameEnd - nameStart,DEFAULT_CHARSET)));
}
if (nameEnd <= nameStart) {
if (valueStart == -1) {
if (log.isDebugEnabled()) {
log.debug(sm.getString("parameters.emptyChunk"));
}
continue;
}
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String extract;
if (valueEnd > nameStart) {
extract=new String(bytes,nameStart,valueEnd - nameStart,DEFAULT_CHARSET);
}
 else {
extract="";
}
String message=sm.getString("parameters.invalidChunk",Integer.valueOf(nameStart),Integer.valueOf(valueEnd),extract);
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
setParseFailedReason(FailReason.NO_NAME);
continue;
}
tmpName.setBytes(bytes,nameStart,nameEnd - nameStart);
if (valueStart >= 0) {
tmpValue.setBytes(bytes,valueStart,valueEnd - valueStart);
}
 else {
tmpValue.setBytes(bytes,0,0);
}
if (log.isDebugEnabled()) {
try {
origName.append(bytes,nameStart,nameEnd - nameStart);
if (valueStart >= 0) {
origValue.append(bytes,valueStart,valueEnd - valueStart);
}
 else {
origValue.append(bytes,0,0);
}
}
 catch (IOException ioe) {
log.error(sm.getString("parameters.copyFail"),ioe);
}
}
try {
String name;
String value;
if (decodeName) {
urlDecode(tmpName);
}
tmpName.setCharset(charset);
name=tmpName.toString();
if (valueStart >= 0) {
if (decodeValue) {
urlDecode(tmpValue);
}
tmpValue.setCharset(charset);
value=tmpValue.toString();
}
 else {
value="";
}
try {
addParameter(name,value);
}
 catch (IllegalStateException ise) {
UserDataHelper.Mode logMode=maxParamCountLog.getNextMode();
if (logMode != null) {
String message=ise.getMessage();
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.maxCountFail.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
break;
}
}
 catch (IOException e) {
setParseFailedReason(FailReason.URL_DECODING);
decodeFailCount++;
if (decodeFailCount == 1 || log.isDebugEnabled()) {
if (log.isDebugEnabled()) {
log.debug(sm.getString("parameters.decodeFail.debug",origName.toString(),origValue.toString()),e);
}
 else if (log.isInfoEnabled()) {
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String message=sm.getString("parameters.decodeFail.info",tmpName.toString(),tmpValue.toString());
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
}
}
}
tmpName.recycle();
tmpValue.recycle();
if (log.isDebugEnabled()) {
origName.recycle();
origValue.recycle();
}
}
if (decodeFailCount > 1 && !log.isDebugEnabled()) {
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String message=sm.getString("parameters.multipleDecodingFail",Integer.valueOf(decodeFailCount));
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
}
}

ID 5218=========================================================================type: 1
Method:org.apache.tomcat.util.http.Parameters#processParameters(byte[], int, int, java.nio.charset.Charset)
Rmethod: org.apache.tomcat.util.http.Parameters#urlDecode(org.apache.tomcat.util.buf.ByteChunk)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void processParameters(byte bytes[],int start,int len,Charset charset){
  if (log.isDebugEnabled()) {
    log.debug(sm.getString("parameters.bytes",new String(bytes,start,len,DEFAULT_CHARSET)));
  }
  int decodeFailCount=0;
  int pos=start;
  int end=start + len;
  while (pos < end) {
    int nameStart=pos;
    int nameEnd=-1;
    int valueStart=-1;
    int valueEnd=-1;
    boolean parsingName=true;
    boolean decodeName=false;
    boolean decodeValue=false;
    boolean parameterComplete=false;
    do {
switch (bytes[pos]) {
case '=':
        if (parsingName) {
          nameEnd=pos;
          parsingName=false;
          valueStart=++pos;
        }
 else {
          pos++;
        }
      break;
case '&':
    if (parsingName) {
      nameEnd=pos;
    }
 else {
      valueEnd=pos;
    }
  parameterComplete=true;
pos++;
break;
case '%':
case '+':
if (parsingName) {
decodeName=true;
}
 else {
decodeValue=true;
}
pos++;
break;
default :
pos++;
break;
}
}
 while (!parameterComplete && pos < end);
if (pos == end) {
if (nameEnd == -1) {
nameEnd=pos;
}
 else if (valueStart > -1 && valueEnd == -1) {
valueEnd=pos;
}
}
if (log.isDebugEnabled() && valueStart == -1) {
log.debug(sm.getString("parameters.noequal",Integer.valueOf(nameStart),Integer.valueOf(nameEnd),new String(bytes,nameStart,nameEnd - nameStart,DEFAULT_CHARSET)));
}
if (nameEnd <= nameStart) {
if (valueStart == -1) {
if (log.isDebugEnabled()) {
log.debug(sm.getString("parameters.emptyChunk"));
}
continue;
}
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String extract;
if (valueEnd > nameStart) {
extract=new String(bytes,nameStart,valueEnd - nameStart,DEFAULT_CHARSET);
}
 else {
extract="";
}
String message=sm.getString("parameters.invalidChunk",Integer.valueOf(nameStart),Integer.valueOf(valueEnd),extract);
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
setParseFailedReason(FailReason.NO_NAME);
continue;
}
tmpName.setBytes(bytes,nameStart,nameEnd - nameStart);
if (valueStart >= 0) {
tmpValue.setBytes(bytes,valueStart,valueEnd - valueStart);
}
 else {
tmpValue.setBytes(bytes,0,0);
}
if (log.isDebugEnabled()) {
try {
origName.append(bytes,nameStart,nameEnd - nameStart);
if (valueStart >= 0) {
origValue.append(bytes,valueStart,valueEnd - valueStart);
}
 else {
origValue.append(bytes,0,0);
}
}
 catch (IOException ioe) {
log.error(sm.getString("parameters.copyFail"),ioe);
}
}
try {
String name;
String value;
if (decodeName) {
urlDecode(tmpName);
}
tmpName.setCharset(charset);
name=tmpName.toString();
if (valueStart >= 0) {
if (decodeValue) {
urlDecode(tmpValue);
}
tmpValue.setCharset(charset);
value=tmpValue.toString();
}
 else {
value="";
}
try {
addParameter(name,value);
}
 catch (IllegalStateException ise) {
UserDataHelper.Mode logMode=maxParamCountLog.getNextMode();
if (logMode != null) {
String message=ise.getMessage();
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.maxCountFail.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
break;
}
}
 catch (IOException e) {
setParseFailedReason(FailReason.URL_DECODING);
decodeFailCount++;
if (decodeFailCount == 1 || log.isDebugEnabled()) {
if (log.isDebugEnabled()) {
log.debug(sm.getString("parameters.decodeFail.debug",origName.toString(),origValue.toString()),e);
}
 else if (log.isInfoEnabled()) {
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String message=sm.getString("parameters.decodeFail.info",tmpName.toString(),tmpValue.toString());
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
}
}
}
tmpName.recycle();
tmpValue.recycle();
if (log.isDebugEnabled()) {
origName.recycle();
origValue.recycle();
}
}
if (decodeFailCount > 1 && !log.isDebugEnabled()) {
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String message=sm.getString("parameters.multipleDecodingFail",Integer.valueOf(decodeFailCount));
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
}
}

ID 5219=========================================================================type: 1
Method:org.apache.tomcat.util.http.Parameters#processParameters(byte[], int, int, java.nio.charset.Charset)
Rmethod: org.apache.tomcat.util.http.Parameters#addParameter(java.lang.String, java.lang.String)
parentException: RuntimeException 
thrown: IllegalStateException
exception comment: /** 
 * Signals that a method has been invoked at an illegal or inappropriate time.  In other words, the Java environment or Java application is not in an appropriate state for the requested operation.
 * @author  Jonni Kanerva
 * @since   JDK1.1
 */

block: 
private void processParameters(byte bytes[],int start,int len,Charset charset){
  if (log.isDebugEnabled()) {
    log.debug(sm.getString("parameters.bytes",new String(bytes,start,len,DEFAULT_CHARSET)));
  }
  int decodeFailCount=0;
  int pos=start;
  int end=start + len;
  while (pos < end) {
    int nameStart=pos;
    int nameEnd=-1;
    int valueStart=-1;
    int valueEnd=-1;
    boolean parsingName=true;
    boolean decodeName=false;
    boolean decodeValue=false;
    boolean parameterComplete=false;
    do {
switch (bytes[pos]) {
case '=':
        if (parsingName) {
          nameEnd=pos;
          parsingName=false;
          valueStart=++pos;
        }
 else {
          pos++;
        }
      break;
case '&':
    if (parsingName) {
      nameEnd=pos;
    }
 else {
      valueEnd=pos;
    }
  parameterComplete=true;
pos++;
break;
case '%':
case '+':
if (parsingName) {
decodeName=true;
}
 else {
decodeValue=true;
}
pos++;
break;
default :
pos++;
break;
}
}
 while (!parameterComplete && pos < end);
if (pos == end) {
if (nameEnd == -1) {
nameEnd=pos;
}
 else if (valueStart > -1 && valueEnd == -1) {
valueEnd=pos;
}
}
if (log.isDebugEnabled() && valueStart == -1) {
log.debug(sm.getString("parameters.noequal",Integer.valueOf(nameStart),Integer.valueOf(nameEnd),new String(bytes,nameStart,nameEnd - nameStart,DEFAULT_CHARSET)));
}
if (nameEnd <= nameStart) {
if (valueStart == -1) {
if (log.isDebugEnabled()) {
log.debug(sm.getString("parameters.emptyChunk"));
}
continue;
}
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String extract;
if (valueEnd > nameStart) {
extract=new String(bytes,nameStart,valueEnd - nameStart,DEFAULT_CHARSET);
}
 else {
extract="";
}
String message=sm.getString("parameters.invalidChunk",Integer.valueOf(nameStart),Integer.valueOf(valueEnd),extract);
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
setParseFailedReason(FailReason.NO_NAME);
continue;
}
tmpName.setBytes(bytes,nameStart,nameEnd - nameStart);
if (valueStart >= 0) {
tmpValue.setBytes(bytes,valueStart,valueEnd - valueStart);
}
 else {
tmpValue.setBytes(bytes,0,0);
}
if (log.isDebugEnabled()) {
try {
origName.append(bytes,nameStart,nameEnd - nameStart);
if (valueStart >= 0) {
origValue.append(bytes,valueStart,valueEnd - valueStart);
}
 else {
origValue.append(bytes,0,0);
}
}
 catch (IOException ioe) {
log.error(sm.getString("parameters.copyFail"),ioe);
}
}
try {
String name;
String value;
if (decodeName) {
urlDecode(tmpName);
}
tmpName.setCharset(charset);
name=tmpName.toString();
if (valueStart >= 0) {
if (decodeValue) {
urlDecode(tmpValue);
}
tmpValue.setCharset(charset);
value=tmpValue.toString();
}
 else {
value="";
}
try {
addParameter(name,value);
}
 catch (IllegalStateException ise) {
UserDataHelper.Mode logMode=maxParamCountLog.getNextMode();
if (logMode != null) {
String message=ise.getMessage();
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.maxCountFail.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
break;
}
}
 catch (IOException e) {
setParseFailedReason(FailReason.URL_DECODING);
decodeFailCount++;
if (decodeFailCount == 1 || log.isDebugEnabled()) {
if (log.isDebugEnabled()) {
log.debug(sm.getString("parameters.decodeFail.debug",origName.toString(),origValue.toString()),e);
}
 else if (log.isInfoEnabled()) {
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String message=sm.getString("parameters.decodeFail.info",tmpName.toString(),tmpValue.toString());
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
}
}
}
tmpName.recycle();
tmpValue.recycle();
if (log.isDebugEnabled()) {
origName.recycle();
origValue.recycle();
}
}
if (decodeFailCount > 1 && !log.isDebugEnabled()) {
UserDataHelper.Mode logMode=userDataLog.getNextMode();
if (logMode != null) {
String message=sm.getString("parameters.multipleDecodingFail",Integer.valueOf(decodeFailCount));
switch (logMode) {
case INFO_THEN_DEBUG:
message+=sm.getString("parameters.fallToDebug");
case INFO:
log.info(message);
break;
case DEBUG:
log.debug(message);
}
}
}
}

ID 5221=========================================================================type: 1
Method:org.apache.tomcat.util.http.Parameters#getCharset(java.lang.String)
Rmethod: org.apache.tomcat.util.buf.B2CConverter#getCharset(java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
private Charset getCharset(String encoding){
  if (encoding == null) {
    return DEFAULT_CHARSET;
  }
  try {
    return B2CConverter.getCharset(encoding);
  }
 catch (  UnsupportedEncodingException e) {
    return DEFAULT_CHARSET;
  }
}

ID 5233=========================================================================type: 1
Method:org.apache.tomcat.util.descriptor.LocalResolver#resolveEntity(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
Rmethod: java.net.URI#URI(java.lang.String)
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
@Override public InputSource resolveEntity(String name,String publicId,String base,String systemId) throws SAXException, IOException {
  String resolved=publicIds.get(publicId);
  if (resolved != null) {
    InputSource is=new InputSource(resolved);
    is.setPublicId(publicId);
    return is;
  }
  if (systemId == null) {
    throw new FileNotFoundException(sm.getString("localResolver.unresolvedEntity",name,publicId,systemId,base));
  }
  resolved=systemIds.get(systemId);
  if (resolved != null) {
    InputSource is=new InputSource(resolved);
    is.setPublicId(publicId);
    return is;
  }
  for (  String javaEENamespace : JAVA_EE_NAMESPACES) {
    String javaEESystemId=javaEENamespace + '/' + systemId;
    resolved=systemIds.get(javaEESystemId);
    if (resolved != null) {
      InputSource is=new InputSource(resolved);
      is.setPublicId(publicId);
      return is;
    }
  }
  URI systemUri;
  try {
    if (base == null) {
      systemUri=new URI(systemId);
    }
 else {
      URI baseUri=new URI(base);
      systemUri=new URL(baseUri.toURL(),systemId).toURI();
    }
    systemUri=systemUri.normalize();
  }
 catch (  URISyntaxException e) {
    if (blockExternal) {
      throw new MalformedURLException(e.getMessage());
    }
 else {
      return new InputSource(systemId);
    }
  }
  if (systemUri.isAbsolute()) {
    resolved=systemIds.get(systemUri.toString());
    if (resolved != null) {
      InputSource is=new InputSource(resolved);
      is.setPublicId(publicId);
      return is;
    }
    if (!blockExternal) {
      InputSource is=new InputSource(systemUri.toString());
      is.setPublicId(publicId);
      return is;
    }
  }
  throw new FileNotFoundException(sm.getString("localResolver.unresolvedEntity",name,publicId,systemId,base));
}

ID 5236=========================================================================type: 1
Method:org.apache.tomcat.util.descriptor.LocalResolver#resolveEntity(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
Rmethod: java.net.URL#toURI()
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
@Override public InputSource resolveEntity(String name,String publicId,String base,String systemId) throws SAXException, IOException {
  String resolved=publicIds.get(publicId);
  if (resolved != null) {
    InputSource is=new InputSource(resolved);
    is.setPublicId(publicId);
    return is;
  }
  if (systemId == null) {
    throw new FileNotFoundException(sm.getString("localResolver.unresolvedEntity",name,publicId,systemId,base));
  }
  resolved=systemIds.get(systemId);
  if (resolved != null) {
    InputSource is=new InputSource(resolved);
    is.setPublicId(publicId);
    return is;
  }
  for (  String javaEENamespace : JAVA_EE_NAMESPACES) {
    String javaEESystemId=javaEENamespace + '/' + systemId;
    resolved=systemIds.get(javaEESystemId);
    if (resolved != null) {
      InputSource is=new InputSource(resolved);
      is.setPublicId(publicId);
      return is;
    }
  }
  URI systemUri;
  try {
    if (base == null) {
      systemUri=new URI(systemId);
    }
 else {
      URI baseUri=new URI(base);
      systemUri=new URL(baseUri.toURL(),systemId).toURI();
    }
    systemUri=systemUri.normalize();
  }
 catch (  URISyntaxException e) {
    if (blockExternal) {
      throw new MalformedURLException(e.getMessage());
    }
 else {
      return new InputSource(systemId);
    }
  }
  if (systemUri.isAbsolute()) {
    resolved=systemIds.get(systemUri.toString());
    if (resolved != null) {
      InputSource is=new InputSource(resolved);
      is.setPublicId(publicId);
      return is;
    }
    if (!blockExternal) {
      InputSource is=new InputSource(systemUri.toString());
      is.setPublicId(publicId);
      return is;
    }
  }
  throw new FileNotFoundException(sm.getString("localResolver.unresolvedEntity",name,publicId,systemId,base));
}

ID 5239=========================================================================type: 1
Method:org.apache.tomcat.buildutil.Txt2Html#execute()
Rmethod: org.apache.tomcat.buildutil.Txt2Html#convert(java.io.File, java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Perform the conversion
 * @throws BuildException if an error occurs during execution ofthis task.
 */
@Override public void execute() throws BuildException {
  int count=0;
  Iterator<FileSet> iter=filesets.iterator();
  while (iter.hasNext()) {
    FileSet fs=iter.next();
    DirectoryScanner ds=fs.getDirectoryScanner(getProject());
    File basedir=ds.getBasedir();
    String[] files=ds.getIncludedFiles();
    for (int i=0; i < files.length; i++) {
      File from=new File(basedir,files[i]);
      File to=new File(todir,files[i] + ".html");
      if (!to.exists() || (from.lastModified() > to.lastModified())) {
        log("Converting file '" + from.getAbsolutePath() + "' to '"+ to.getAbsolutePath(),Project.MSG_VERBOSE);
        try {
          convert(from,to);
        }
 catch (        IOException e) {
          throw new BuildException("Could not convert '" + from.getAbsolutePath() + "' to '"+ to.getAbsolutePath()+ "'",e);
        }
        count++;
      }
    }
    if (count > 0) {
      log("Converted " + count + " file"+ (count > 1 ? "s" : "")+ " to "+ todir.getAbsolutePath());
    }
  }
}

ID 5244=========================================================================type: 1
Method:org.apache.tomcat.buildutil.CheckEol#execute()
Rmethod: org.apache.tomcat.buildutil.CheckEol#check(java.io.File, List<org.apache.tomcat.buildutil.CheckEol.CheckFailure>, org.apache.tomcat.buildutil.CheckEol.Mode)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Perform the check
 * @throws BuildException if an error occurs during execution ofthis task.
 */
@Override public void execute() throws BuildException {
  Mode mode=null;
  if ("\n".equals(eoln)) {
    mode=Mode.LF;
  }
 else   if ("\r\n".equals(eoln)) {
    mode=Mode.CRLF;
  }
 else {
    log("Line ends check skipped, because OS line ends setting is neither LF nor CRLF.",Project.MSG_VERBOSE);
    return;
  }
  int count=0;
  List<CheckFailure> errors=new ArrayList<CheckFailure>();
  for (  FileSet fs : filesets) {
    DirectoryScanner ds=fs.getDirectoryScanner(getProject());
    File basedir=ds.getBasedir();
    String[] files=ds.getIncludedFiles();
    if (files.length > 0) {
      log("Checking line ends in " + files.length + " file(s)");
      for (int i=0; i < files.length; i++) {
        File file=new File(basedir,files[i]);
        log("Checking file '" + file + "' for correct line ends",Project.MSG_DEBUG);
        try {
          check(file,errors,mode);
        }
 catch (        IOException e) {
          throw new BuildException("Could not check file '" + file.getAbsolutePath() + "'",e);
        }
        count++;
      }
    }
  }
  if (count > 0) {
    log("Done line ends check in " + count + " file(s), "+ errors.size()+ " error(s) found.");
  }
  if (errors.size() > 0) {
    String message="The following files have wrong line ends: " + errors;
    log(message,Project.MSG_ERR);
    throw new BuildException(message);
  }
}

ID 5252=========================================================================type: 1
Method:org.apache.coyote.AbstractProtocol#init()
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void init() throws Exception {
  if (getLog().isInfoEnabled())   getLog().info(sm.getString("abstractProtocolHandler.init",getName()));
  if (oname == null) {
    oname=createObjectName();
    if (oname != null) {
      Registry.getRegistry(null,null).registerComponent(this,oname,null);
    }
  }
  if (this.domain != null) {
    try {
      tpOname=new ObjectName(domain + ":" + "type=ThreadPool,name="+ getName());
      Registry.getRegistry(null,null).registerComponent(endpoint,tpOname,null);
    }
 catch (    Exception e) {
      getLog().error(sm.getString("abstractProtocolHandler.mbeanRegistrationFailed",tpOname,getName()),e);
    }
    rgOname=new ObjectName(domain + ":type=GlobalRequestProcessor,name=" + getName());
    Registry.getRegistry(null,null).registerComponent(getHandler().getGlobal(),rgOname,null);
  }
  String endpointName=getName();
  endpoint.setName(endpointName.substring(1,endpointName.length() - 1));
  try {
    endpoint.init();
  }
 catch (  Exception ex) {
    getLog().error(sm.getString("abstractProtocolHandler.initError",getName()),ex);
    throw ex;
  }
}

ID 5253=========================================================================type: 1
Method:org.apache.coyote.AbstractProtocol#init()
Rmethod: org.apache.tomcat.util.net.AbstractEndpoint#init()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void init() throws Exception {
  if (getLog().isInfoEnabled())   getLog().info(sm.getString("abstractProtocolHandler.init",getName()));
  if (oname == null) {
    oname=createObjectName();
    if (oname != null) {
      Registry.getRegistry(null,null).registerComponent(this,oname,null);
    }
  }
  if (this.domain != null) {
    try {
      tpOname=new ObjectName(domain + ":" + "type=ThreadPool,name="+ getName());
      Registry.getRegistry(null,null).registerComponent(endpoint,tpOname,null);
    }
 catch (    Exception e) {
      getLog().error(sm.getString("abstractProtocolHandler.mbeanRegistrationFailed",tpOname,getName()),e);
    }
    rgOname=new ObjectName(domain + ":type=GlobalRequestProcessor,name=" + getName());
    Registry.getRegistry(null,null).registerComponent(getHandler().getGlobal(),rgOname,null);
  }
  String endpointName=getName();
  endpoint.setName(endpointName.substring(1,endpointName.length() - 1));
  try {
    endpoint.init();
  }
 catch (  Exception ex) {
    getLog().error(sm.getString("abstractProtocolHandler.initError",getName()),ex);
    throw ex;
  }
}

ID 5254=========================================================================type: 1
Method:org.apache.coyote.AbstractProtocol#start()
Rmethod: org.apache.tomcat.util.net.AbstractEndpoint#start()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void start() throws Exception {
  if (getLog().isInfoEnabled())   getLog().info(sm.getString("abstractProtocolHandler.start",getName()));
  try {
    endpoint.start();
  }
 catch (  Exception ex) {
    getLog().error(sm.getString("abstractProtocolHandler.startError",getName()),ex);
    throw ex;
  }
}

ID 5255=========================================================================type: 1
Method:org.apache.coyote.AbstractProtocol#stop()
Rmethod: org.apache.tomcat.util.net.AbstractEndpoint#stop()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void stop() throws Exception {
  if (getLog().isInfoEnabled())   getLog().info(sm.getString("abstractProtocolHandler.stop",getName()));
  try {
    endpoint.stop();
  }
 catch (  Exception ex) {
    getLog().error(sm.getString("abstractProtocolHandler.stopError",getName()),ex);
    throw ex;
  }
}

ID 5256=========================================================================type: 1
Method:org.apache.coyote.AbstractProtocol#destroy()
Rmethod: org.apache.tomcat.util.net.AbstractEndpoint#destroy()
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public void destroy(){
  if (getLog().isInfoEnabled()) {
    getLog().info(sm.getString("abstractProtocolHandler.destroy",getName()));
  }
  try {
    endpoint.destroy();
  }
 catch (  Exception e) {
    getLog().error(sm.getString("abstractProtocolHandler.destroyError",getName()),e);
  }
  if (oname != null) {
    Registry.getRegistry(null,null).unregisterComponent(oname);
  }
  if (tpOname != null)   Registry.getRegistry(null,null).unregisterComponent(tpOname);
  if (rgOname != null)   Registry.getRegistry(null,null).unregisterComponent(rgOname);
}

ID 5257=========================================================================type: 1
Method:org.apache.coyote.AbstractConnectionHandler#process(SocketWrapper<S>, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Processor#process(SocketWrapper<S>)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") public SocketState process(SocketWrapper<S> wrapper,SocketStatus status){
  if (wrapper == null) {
    return SocketState.CLOSED;
  }
  S socket=wrapper.getSocket();
  if (socket == null) {
    return SocketState.CLOSED;
  }
  Processor<S> processor=connections.get(socket);
  if (status == SocketStatus.DISCONNECT && processor == null) {
    return SocketState.CLOSED;
  }
  wrapper.setAsync(false);
  ContainerThreadMarker.markAsContainerThread();
  try {
    if (processor == null) {
      processor=recycledProcessors.poll();
    }
    if (processor == null) {
      processor=createProcessor();
    }
    initSsl(wrapper,processor);
    SocketState state=SocketState.CLOSED;
    do {
      if (status == SocketStatus.DISCONNECT && !processor.isComet()) {
      }
 else       if (processor.isAsync() || state == SocketState.ASYNC_END) {
        state=processor.asyncDispatch(status);
        if (state == SocketState.OPEN) {
          getProtocol().endpoint.removeWaitingRequest(wrapper);
          state=processor.process(wrapper);
        }
      }
 else       if (processor.isComet()) {
        state=processor.event(status);
      }
 else       if (processor.getUpgradeInbound() != null) {
        state=processor.upgradeDispatch();
      }
 else       if (processor.isUpgrade()) {
        state=processor.upgradeDispatch(status);
      }
 else {
        state=processor.process(wrapper);
      }
      if (state != SocketState.CLOSED && processor.isAsync()) {
        state=processor.asyncPostProcess();
      }
      if (state == SocketState.UPGRADING) {
        HttpUpgradeHandler httpUpgradeHandler=processor.getHttpUpgradeHandler();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,httpUpgradeHandler);
        wrapper.setUpgraded(true);
        connections.put(socket,processor);
        httpUpgradeHandler.init((WebConnection)processor);
      }
 else       if (state == SocketState.UPGRADING_TOMCAT) {
        org.apache.coyote.http11.upgrade.UpgradeInbound inbound=processor.getUpgradeInbound();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,inbound);
        inbound.onUpgradeComplete();
      }
      if (getLog().isDebugEnabled()) {
        getLog().debug("Socket: [" + wrapper + "], Status in: ["+ status+ "], State out: ["+ state+ "]");
      }
    }
 while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING || state == SocketState.UPGRADING_TOMCAT);
    if (state == SocketState.LONG) {
      connections.put(socket,processor);
      longPoll(wrapper,processor);
    }
 else     if (state == SocketState.OPEN) {
      connections.remove(socket);
      release(wrapper,processor,false,true);
    }
 else     if (state == SocketState.SENDFILE) {
      connections.remove(socket);
      release(wrapper,processor,false,false);
    }
 else     if (state == SocketState.UPGRADED) {
      connections.put(socket,processor);
      if (status != SocketStatus.OPEN_WRITE) {
        longPoll(wrapper,processor);
      }
    }
 else {
      connections.remove(socket);
      if (processor.isUpgrade()) {
        processor.getHttpUpgradeHandler().destroy();
      }
 else       if (processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) {
      }
 else {
        release(wrapper,processor,true,false);
      }
    }
    return state;
  }
 catch (  java.net.SocketException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"),e);
  }
catch (  java.io.IOException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"),e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    getLog().error(sm.getString("abstractConnectionHandler.error"),e);
  }
  connections.remove(socket);
  if (!(processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) && !processor.isUpgrade()) {
    release(wrapper,processor,true,false);
  }
  return SocketState.CLOSED;
}

ID 5258=========================================================================type: 1
Method:org.apache.coyote.AbstractConnectionHandler#process(SocketWrapper<S>, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Processor#event(org.apache.tomcat.util.net.SocketStatus)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") public SocketState process(SocketWrapper<S> wrapper,SocketStatus status){
  if (wrapper == null) {
    return SocketState.CLOSED;
  }
  S socket=wrapper.getSocket();
  if (socket == null) {
    return SocketState.CLOSED;
  }
  Processor<S> processor=connections.get(socket);
  if (status == SocketStatus.DISCONNECT && processor == null) {
    return SocketState.CLOSED;
  }
  wrapper.setAsync(false);
  ContainerThreadMarker.markAsContainerThread();
  try {
    if (processor == null) {
      processor=recycledProcessors.poll();
    }
    if (processor == null) {
      processor=createProcessor();
    }
    initSsl(wrapper,processor);
    SocketState state=SocketState.CLOSED;
    do {
      if (status == SocketStatus.DISCONNECT && !processor.isComet()) {
      }
 else       if (processor.isAsync() || state == SocketState.ASYNC_END) {
        state=processor.asyncDispatch(status);
        if (state == SocketState.OPEN) {
          getProtocol().endpoint.removeWaitingRequest(wrapper);
          state=processor.process(wrapper);
        }
      }
 else       if (processor.isComet()) {
        state=processor.event(status);
      }
 else       if (processor.getUpgradeInbound() != null) {
        state=processor.upgradeDispatch();
      }
 else       if (processor.isUpgrade()) {
        state=processor.upgradeDispatch(status);
      }
 else {
        state=processor.process(wrapper);
      }
      if (state != SocketState.CLOSED && processor.isAsync()) {
        state=processor.asyncPostProcess();
      }
      if (state == SocketState.UPGRADING) {
        HttpUpgradeHandler httpUpgradeHandler=processor.getHttpUpgradeHandler();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,httpUpgradeHandler);
        wrapper.setUpgraded(true);
        connections.put(socket,processor);
        httpUpgradeHandler.init((WebConnection)processor);
      }
 else       if (state == SocketState.UPGRADING_TOMCAT) {
        org.apache.coyote.http11.upgrade.UpgradeInbound inbound=processor.getUpgradeInbound();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,inbound);
        inbound.onUpgradeComplete();
      }
      if (getLog().isDebugEnabled()) {
        getLog().debug("Socket: [" + wrapper + "], Status in: ["+ status+ "], State out: ["+ state+ "]");
      }
    }
 while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING || state == SocketState.UPGRADING_TOMCAT);
    if (state == SocketState.LONG) {
      connections.put(socket,processor);
      longPoll(wrapper,processor);
    }
 else     if (state == SocketState.OPEN) {
      connections.remove(socket);
      release(wrapper,processor,false,true);
    }
 else     if (state == SocketState.SENDFILE) {
      connections.remove(socket);
      release(wrapper,processor,false,false);
    }
 else     if (state == SocketState.UPGRADED) {
      connections.put(socket,processor);
      if (status != SocketStatus.OPEN_WRITE) {
        longPoll(wrapper,processor);
      }
    }
 else {
      connections.remove(socket);
      if (processor.isUpgrade()) {
        processor.getHttpUpgradeHandler().destroy();
      }
 else       if (processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) {
      }
 else {
        release(wrapper,processor,true,false);
      }
    }
    return state;
  }
 catch (  java.net.SocketException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"),e);
  }
catch (  java.io.IOException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"),e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    getLog().error(sm.getString("abstractConnectionHandler.error"),e);
  }
  connections.remove(socket);
  if (!(processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) && !processor.isUpgrade()) {
    release(wrapper,processor,true,false);
  }
  return SocketState.CLOSED;
}

ID 5259=========================================================================type: 1
Method:org.apache.coyote.AbstractConnectionHandler#process(SocketWrapper<S>, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Processor#upgradeDispatch()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") public SocketState process(SocketWrapper<S> wrapper,SocketStatus status){
  if (wrapper == null) {
    return SocketState.CLOSED;
  }
  S socket=wrapper.getSocket();
  if (socket == null) {
    return SocketState.CLOSED;
  }
  Processor<S> processor=connections.get(socket);
  if (status == SocketStatus.DISCONNECT && processor == null) {
    return SocketState.CLOSED;
  }
  wrapper.setAsync(false);
  ContainerThreadMarker.markAsContainerThread();
  try {
    if (processor == null) {
      processor=recycledProcessors.poll();
    }
    if (processor == null) {
      processor=createProcessor();
    }
    initSsl(wrapper,processor);
    SocketState state=SocketState.CLOSED;
    do {
      if (status == SocketStatus.DISCONNECT && !processor.isComet()) {
      }
 else       if (processor.isAsync() || state == SocketState.ASYNC_END) {
        state=processor.asyncDispatch(status);
        if (state == SocketState.OPEN) {
          getProtocol().endpoint.removeWaitingRequest(wrapper);
          state=processor.process(wrapper);
        }
      }
 else       if (processor.isComet()) {
        state=processor.event(status);
      }
 else       if (processor.getUpgradeInbound() != null) {
        state=processor.upgradeDispatch();
      }
 else       if (processor.isUpgrade()) {
        state=processor.upgradeDispatch(status);
      }
 else {
        state=processor.process(wrapper);
      }
      if (state != SocketState.CLOSED && processor.isAsync()) {
        state=processor.asyncPostProcess();
      }
      if (state == SocketState.UPGRADING) {
        HttpUpgradeHandler httpUpgradeHandler=processor.getHttpUpgradeHandler();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,httpUpgradeHandler);
        wrapper.setUpgraded(true);
        connections.put(socket,processor);
        httpUpgradeHandler.init((WebConnection)processor);
      }
 else       if (state == SocketState.UPGRADING_TOMCAT) {
        org.apache.coyote.http11.upgrade.UpgradeInbound inbound=processor.getUpgradeInbound();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,inbound);
        inbound.onUpgradeComplete();
      }
      if (getLog().isDebugEnabled()) {
        getLog().debug("Socket: [" + wrapper + "], Status in: ["+ status+ "], State out: ["+ state+ "]");
      }
    }
 while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING || state == SocketState.UPGRADING_TOMCAT);
    if (state == SocketState.LONG) {
      connections.put(socket,processor);
      longPoll(wrapper,processor);
    }
 else     if (state == SocketState.OPEN) {
      connections.remove(socket);
      release(wrapper,processor,false,true);
    }
 else     if (state == SocketState.SENDFILE) {
      connections.remove(socket);
      release(wrapper,processor,false,false);
    }
 else     if (state == SocketState.UPGRADED) {
      connections.put(socket,processor);
      if (status != SocketStatus.OPEN_WRITE) {
        longPoll(wrapper,processor);
      }
    }
 else {
      connections.remove(socket);
      if (processor.isUpgrade()) {
        processor.getHttpUpgradeHandler().destroy();
      }
 else       if (processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) {
      }
 else {
        release(wrapper,processor,true,false);
      }
    }
    return state;
  }
 catch (  java.net.SocketException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"),e);
  }
catch (  java.io.IOException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"),e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    getLog().error(sm.getString("abstractConnectionHandler.error"),e);
  }
  connections.remove(socket);
  if (!(processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) && !processor.isUpgrade()) {
    release(wrapper,processor,true,false);
  }
  return SocketState.CLOSED;
}

ID 5260=========================================================================type: 1
Method:org.apache.coyote.AbstractConnectionHandler#process(SocketWrapper<S>, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Processor#upgradeDispatch(org.apache.tomcat.util.net.SocketStatus)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") public SocketState process(SocketWrapper<S> wrapper,SocketStatus status){
  if (wrapper == null) {
    return SocketState.CLOSED;
  }
  S socket=wrapper.getSocket();
  if (socket == null) {
    return SocketState.CLOSED;
  }
  Processor<S> processor=connections.get(socket);
  if (status == SocketStatus.DISCONNECT && processor == null) {
    return SocketState.CLOSED;
  }
  wrapper.setAsync(false);
  ContainerThreadMarker.markAsContainerThread();
  try {
    if (processor == null) {
      processor=recycledProcessors.poll();
    }
    if (processor == null) {
      processor=createProcessor();
    }
    initSsl(wrapper,processor);
    SocketState state=SocketState.CLOSED;
    do {
      if (status == SocketStatus.DISCONNECT && !processor.isComet()) {
      }
 else       if (processor.isAsync() || state == SocketState.ASYNC_END) {
        state=processor.asyncDispatch(status);
        if (state == SocketState.OPEN) {
          getProtocol().endpoint.removeWaitingRequest(wrapper);
          state=processor.process(wrapper);
        }
      }
 else       if (processor.isComet()) {
        state=processor.event(status);
      }
 else       if (processor.getUpgradeInbound() != null) {
        state=processor.upgradeDispatch();
      }
 else       if (processor.isUpgrade()) {
        state=processor.upgradeDispatch(status);
      }
 else {
        state=processor.process(wrapper);
      }
      if (state != SocketState.CLOSED && processor.isAsync()) {
        state=processor.asyncPostProcess();
      }
      if (state == SocketState.UPGRADING) {
        HttpUpgradeHandler httpUpgradeHandler=processor.getHttpUpgradeHandler();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,httpUpgradeHandler);
        wrapper.setUpgraded(true);
        connections.put(socket,processor);
        httpUpgradeHandler.init((WebConnection)processor);
      }
 else       if (state == SocketState.UPGRADING_TOMCAT) {
        org.apache.coyote.http11.upgrade.UpgradeInbound inbound=processor.getUpgradeInbound();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,inbound);
        inbound.onUpgradeComplete();
      }
      if (getLog().isDebugEnabled()) {
        getLog().debug("Socket: [" + wrapper + "], Status in: ["+ status+ "], State out: ["+ state+ "]");
      }
    }
 while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING || state == SocketState.UPGRADING_TOMCAT);
    if (state == SocketState.LONG) {
      connections.put(socket,processor);
      longPoll(wrapper,processor);
    }
 else     if (state == SocketState.OPEN) {
      connections.remove(socket);
      release(wrapper,processor,false,true);
    }
 else     if (state == SocketState.SENDFILE) {
      connections.remove(socket);
      release(wrapper,processor,false,false);
    }
 else     if (state == SocketState.UPGRADED) {
      connections.put(socket,processor);
      if (status != SocketStatus.OPEN_WRITE) {
        longPoll(wrapper,processor);
      }
    }
 else {
      connections.remove(socket);
      if (processor.isUpgrade()) {
        processor.getHttpUpgradeHandler().destroy();
      }
 else       if (processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) {
      }
 else {
        release(wrapper,processor,true,false);
      }
    }
    return state;
  }
 catch (  java.net.SocketException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"),e);
  }
catch (  java.io.IOException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"),e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    getLog().error(sm.getString("abstractConnectionHandler.error"),e);
  }
  connections.remove(socket);
  if (!(processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) && !processor.isUpgrade()) {
    release(wrapper,processor,true,false);
  }
  return SocketState.CLOSED;
}

ID 5261=========================================================================type: 1
Method:org.apache.coyote.AbstractConnectionHandler#process(SocketWrapper<S>, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.AbstractConnectionHandler#createUpgradeProcessor(SocketWrapper<S>, org.apache.coyote.http11.upgrade.servlet31.HttpUpgradeHandler)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") public SocketState process(SocketWrapper<S> wrapper,SocketStatus status){
  if (wrapper == null) {
    return SocketState.CLOSED;
  }
  S socket=wrapper.getSocket();
  if (socket == null) {
    return SocketState.CLOSED;
  }
  Processor<S> processor=connections.get(socket);
  if (status == SocketStatus.DISCONNECT && processor == null) {
    return SocketState.CLOSED;
  }
  wrapper.setAsync(false);
  ContainerThreadMarker.markAsContainerThread();
  try {
    if (processor == null) {
      processor=recycledProcessors.poll();
    }
    if (processor == null) {
      processor=createProcessor();
    }
    initSsl(wrapper,processor);
    SocketState state=SocketState.CLOSED;
    do {
      if (status == SocketStatus.DISCONNECT && !processor.isComet()) {
      }
 else       if (processor.isAsync() || state == SocketState.ASYNC_END) {
        state=processor.asyncDispatch(status);
        if (state == SocketState.OPEN) {
          getProtocol().endpoint.removeWaitingRequest(wrapper);
          state=processor.process(wrapper);
        }
      }
 else       if (processor.isComet()) {
        state=processor.event(status);
      }
 else       if (processor.getUpgradeInbound() != null) {
        state=processor.upgradeDispatch();
      }
 else       if (processor.isUpgrade()) {
        state=processor.upgradeDispatch(status);
      }
 else {
        state=processor.process(wrapper);
      }
      if (state != SocketState.CLOSED && processor.isAsync()) {
        state=processor.asyncPostProcess();
      }
      if (state == SocketState.UPGRADING) {
        HttpUpgradeHandler httpUpgradeHandler=processor.getHttpUpgradeHandler();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,httpUpgradeHandler);
        wrapper.setUpgraded(true);
        connections.put(socket,processor);
        httpUpgradeHandler.init((WebConnection)processor);
      }
 else       if (state == SocketState.UPGRADING_TOMCAT) {
        org.apache.coyote.http11.upgrade.UpgradeInbound inbound=processor.getUpgradeInbound();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,inbound);
        inbound.onUpgradeComplete();
      }
      if (getLog().isDebugEnabled()) {
        getLog().debug("Socket: [" + wrapper + "], Status in: ["+ status+ "], State out: ["+ state+ "]");
      }
    }
 while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING || state == SocketState.UPGRADING_TOMCAT);
    if (state == SocketState.LONG) {
      connections.put(socket,processor);
      longPoll(wrapper,processor);
    }
 else     if (state == SocketState.OPEN) {
      connections.remove(socket);
      release(wrapper,processor,false,true);
    }
 else     if (state == SocketState.SENDFILE) {
      connections.remove(socket);
      release(wrapper,processor,false,false);
    }
 else     if (state == SocketState.UPGRADED) {
      connections.put(socket,processor);
      if (status != SocketStatus.OPEN_WRITE) {
        longPoll(wrapper,processor);
      }
    }
 else {
      connections.remove(socket);
      if (processor.isUpgrade()) {
        processor.getHttpUpgradeHandler().destroy();
      }
 else       if (processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) {
      }
 else {
        release(wrapper,processor,true,false);
      }
    }
    return state;
  }
 catch (  java.net.SocketException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"),e);
  }
catch (  java.io.IOException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"),e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    getLog().error(sm.getString("abstractConnectionHandler.error"),e);
  }
  connections.remove(socket);
  if (!(processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) && !processor.isUpgrade()) {
    release(wrapper,processor,true,false);
  }
  return SocketState.CLOSED;
}

ID 5262=========================================================================type: 1
Method:org.apache.coyote.AbstractConnectionHandler#process(SocketWrapper<S>, org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.AbstractConnectionHandler#createUpgradeProcessor(SocketWrapper<S>, org.apache.coyote.http11.upgrade.UpgradeInbound)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") public SocketState process(SocketWrapper<S> wrapper,SocketStatus status){
  if (wrapper == null) {
    return SocketState.CLOSED;
  }
  S socket=wrapper.getSocket();
  if (socket == null) {
    return SocketState.CLOSED;
  }
  Processor<S> processor=connections.get(socket);
  if (status == SocketStatus.DISCONNECT && processor == null) {
    return SocketState.CLOSED;
  }
  wrapper.setAsync(false);
  ContainerThreadMarker.markAsContainerThread();
  try {
    if (processor == null) {
      processor=recycledProcessors.poll();
    }
    if (processor == null) {
      processor=createProcessor();
    }
    initSsl(wrapper,processor);
    SocketState state=SocketState.CLOSED;
    do {
      if (status == SocketStatus.DISCONNECT && !processor.isComet()) {
      }
 else       if (processor.isAsync() || state == SocketState.ASYNC_END) {
        state=processor.asyncDispatch(status);
        if (state == SocketState.OPEN) {
          getProtocol().endpoint.removeWaitingRequest(wrapper);
          state=processor.process(wrapper);
        }
      }
 else       if (processor.isComet()) {
        state=processor.event(status);
      }
 else       if (processor.getUpgradeInbound() != null) {
        state=processor.upgradeDispatch();
      }
 else       if (processor.isUpgrade()) {
        state=processor.upgradeDispatch(status);
      }
 else {
        state=processor.process(wrapper);
      }
      if (state != SocketState.CLOSED && processor.isAsync()) {
        state=processor.asyncPostProcess();
      }
      if (state == SocketState.UPGRADING) {
        HttpUpgradeHandler httpUpgradeHandler=processor.getHttpUpgradeHandler();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,httpUpgradeHandler);
        wrapper.setUpgraded(true);
        connections.put(socket,processor);
        httpUpgradeHandler.init((WebConnection)processor);
      }
 else       if (state == SocketState.UPGRADING_TOMCAT) {
        org.apache.coyote.http11.upgrade.UpgradeInbound inbound=processor.getUpgradeInbound();
        release(wrapper,processor,false,false);
        processor=createUpgradeProcessor(wrapper,inbound);
        inbound.onUpgradeComplete();
      }
      if (getLog().isDebugEnabled()) {
        getLog().debug("Socket: [" + wrapper + "], Status in: ["+ status+ "], State out: ["+ state+ "]");
      }
    }
 while (state == SocketState.ASYNC_END || state == SocketState.UPGRADING || state == SocketState.UPGRADING_TOMCAT);
    if (state == SocketState.LONG) {
      connections.put(socket,processor);
      longPoll(wrapper,processor);
    }
 else     if (state == SocketState.OPEN) {
      connections.remove(socket);
      release(wrapper,processor,false,true);
    }
 else     if (state == SocketState.SENDFILE) {
      connections.remove(socket);
      release(wrapper,processor,false,false);
    }
 else     if (state == SocketState.UPGRADED) {
      connections.put(socket,processor);
      if (status != SocketStatus.OPEN_WRITE) {
        longPoll(wrapper,processor);
      }
    }
 else {
      connections.remove(socket);
      if (processor.isUpgrade()) {
        processor.getHttpUpgradeHandler().destroy();
      }
 else       if (processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) {
      }
 else {
        release(wrapper,processor,true,false);
      }
    }
    return state;
  }
 catch (  java.net.SocketException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.socketexception.debug"),e);
  }
catch (  java.io.IOException e) {
    getLog().debug(sm.getString("abstractConnectionHandler.ioexception.debug"),e);
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    getLog().error(sm.getString("abstractConnectionHandler.error"),e);
  }
  connections.remove(socket);
  if (!(processor instanceof org.apache.coyote.http11.upgrade.UpgradeProcessor) && !processor.isUpgrade()) {
    release(wrapper,processor,true,false);
  }
  return SocketState.CLOSED;
}

ID 5264=========================================================================type: 1
Method:org.apache.coyote.AbstractConnectionHandler#register(AbstractProcessor<S>)
Rmethod: org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
protected void register(AbstractProcessor<S> processor){
  if (getProtocol().getDomain() != null) {
synchronized (this) {
      try {
        long count=registerCount.incrementAndGet();
        RequestInfo rp=processor.getRequest().getRequestProcessor();
        rp.setGlobalProcessor(global);
        ObjectName rpName=new ObjectName(getProtocol().getDomain() + ":type=RequestProcessor,worker=" + getProtocol().getName()+ ",name="+ getProtocol().getProtocolName()+ "Request"+ count);
        if (getLog().isDebugEnabled()) {
          getLog().debug("Register " + rpName);
        }
        Registry.getRegistry(null,null).registerComponent(rp,rpName,null);
        rp.setRpName(rpName);
      }
 catch (      Exception e) {
        getLog().warn("Error registering request");
      }
    }
  }
}

ID 5265=========================================================================type: 1
Method:org.apache.coyote.Response#checkSpecialHeader(java.lang.String, java.lang.String)
Rmethod: java.lang.Long#parseLong(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Set internal fields for special header names.  Called from set/addHeader. Return true if the header is special, no need to set the header.
 */
private boolean checkSpecialHeader(String name,String value){
  if (name.equalsIgnoreCase("Content-Type")) {
    setContentType(value);
    return true;
  }
  if (name.equalsIgnoreCase("Content-Length")) {
    try {
      long cL=Long.parseLong(value);
      setContentLength(cL);
      return true;
    }
 catch (    NumberFormatException ex) {
      return false;
    }
  }
  if (name.equalsIgnoreCase("Content-Language")) {
  }
  return false;
}

ID 5268=========================================================================type: 1
Method:org.apache.coyote.http11.filters.BufferedInputFilter#setRequest(org.apache.coyote.Request)
Rmethod: org.apache.coyote.InputBuffer#doRead(org.apache.tomcat.util.buf.ByteChunk, org.apache.coyote.Request)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Reads the request body and buffers it.
 */
@Override public void setRequest(Request request){
  try {
    while (buffer.doRead(tempRead,request) >= 0) {
      buffered.append(tempRead);
      tempRead.recycle();
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException("Request body too large for buffer");
  }
}

ID 5269=========================================================================type: 1
Method:org.apache.coyote.http11.filters.BufferedInputFilter#setRequest(org.apache.coyote.Request)
Rmethod: org.apache.tomcat.util.buf.ByteChunk#append(org.apache.tomcat.util.buf.ByteChunk)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Reads the request body and buffers it.
 */
@Override public void setRequest(Request request){
  try {
    while (buffer.doRead(tempRead,request) >= 0) {
      buffered.append(tempRead);
      tempRead.recycle();
    }
  }
 catch (  IOException ioe) {
    throw new IllegalStateException("Request body too large for buffer");
  }
}

ID 5300=========================================================================type: 1
Method:org.apache.coyote.http11.filters.GzipOutputFilter#flush()
Rmethod: java.util.zip.DeflaterOutputStream#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Added to allow flushing to happen for the gzip'ed outputstream
 */
public void flush(){
  if (compressionStream != null) {
    try {
      if (log.isDebugEnabled()) {
        log.debug("Flushing the compression stream!");
      }
      compressionStream.flush();
    }
 catch (    IOException e) {
      if (log.isDebugEnabled()) {
        log.debug("Ignored exception while flushing gzip filter",e);
      }
    }
  }
}

ID 5318=========================================================================type: 1
Method:org.apache.coyote.http11.Http11NioProcessor#event(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Adapter#event(org.apache.coyote.Request, org.apache.coyote.Response, org.apache.tomcat.util.net.SocketStatus)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState event(SocketStatus status) throws IOException {
  long soTimeout=endpoint.getSoTimeout();
  RequestInfo rp=request.getRequestProcessor();
  final NioEndpoint.KeyAttachment attach=(NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment();
  try {
    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
    if (!getAdapter().event(request,response,status)) {
      setErrorState(ErrorState.CLOSE_NOW,null);
    }
    if (!getErrorState().isError()) {
      if (attach != null) {
        attach.setComet(comet);
        if (comet) {
          Integer comettimeout=(Integer)request.getAttribute(org.apache.coyote.Constants.COMET_TIMEOUT_ATTR);
          if (comettimeout != null) {
            attach.setTimeout(comettimeout.longValue());
          }
        }
 else {
          if (keepAlive) {
            attach.setTimeout(keepAliveTimeout);
          }
 else {
            attach.setTimeout(soTimeout);
          }
        }
      }
    }
  }
 catch (  InterruptedIOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    response.setStatus(500);
    setErrorState(ErrorState.CLOSE_NOW,t);
    log.error(sm.getString("http11processor.request.process"),t);
    getAdapter().log(request,response,0);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (getErrorState().isError() || status == SocketStatus.STOP) {
    return SocketState.CLOSED;
  }
 else   if (!comet) {
    if (keepAlive) {
      inputBuffer.nextRequest();
      outputBuffer.nextRequest();
      return SocketState.OPEN;
    }
 else {
      return SocketState.CLOSED;
    }
  }
 else {
    return SocketState.LONG;
  }
}

ID 5325=========================================================================type: 1
Method:org.apache.coyote.http11.Http11NioProcessor#actionInternal(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.tomcat.util.net.SecureNioChannel#rehandshake(long)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("incomplete-switch") public void actionInternal(ActionCode actionCode,Object param){
switch (actionCode) {
case REQ_HOST_ADDR_ATTRIBUTE:
{
      if ((remoteAddr == null) && (socketWrapper != null)) {
        InetAddress inetAddr=socketWrapper.getSocket().getIOChannel().socket().getInetAddress();
        if (inetAddr != null) {
          remoteAddr=inetAddr.getHostAddress();
        }
      }
      request.remoteAddr().setString(remoteAddr);
      break;
    }
case REQ_LOCAL_NAME_ATTRIBUTE:
{
    if ((localName == null) && (socketWrapper != null)) {
      InetAddress inetAddr=socketWrapper.getSocket().getIOChannel().socket().getLocalAddress();
      if (inetAddr != null) {
        localName=inetAddr.getHostName();
      }
    }
    request.localName().setString(localName);
    break;
  }
case REQ_HOST_ATTRIBUTE:
{
  if ((remoteHost == null) && (socketWrapper != null)) {
    InetAddress inetAddr=socketWrapper.getSocket().getIOChannel().socket().getInetAddress();
    if (inetAddr != null) {
      remoteHost=inetAddr.getHostName();
    }
    if (remoteHost == null) {
      if (remoteAddr != null) {
        remoteHost=remoteAddr;
      }
 else {
        request.remoteHost().recycle();
      }
    }
  }
  request.remoteHost().setString(remoteHost);
  break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (localAddr == null) {
  localAddr=socketWrapper.getSocket().getIOChannel().socket().getLocalAddress().getHostAddress();
}
request.localAddr().setString(localAddr);
break;
}
case REQ_REMOTEPORT_ATTRIBUTE:
{
if ((remotePort == -1) && (socketWrapper != null)) {
remotePort=socketWrapper.getSocket().getIOChannel().socket().getPort();
}
request.setRemotePort(remotePort);
break;
}
case REQ_LOCALPORT_ATTRIBUTE:
{
if ((localPort == -1) && (socketWrapper != null)) {
localPort=socketWrapper.getSocket().getIOChannel().socket().getLocalPort();
}
request.setLocalPort(localPort);
break;
}
case REQ_SSL_ATTRIBUTE:
{
try {
if (sslSupport != null) {
Object sslO=sslSupport.getCipherSuite();
if (sslO != null) {
request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,sslO);
}
sslO=sslSupport.getPeerCertificateChain(false);
if (sslO != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,sslO);
}
sslO=sslSupport.getKeySize();
if (sslO != null) {
request.setAttribute(SSLSupport.KEY_SIZE_KEY,sslO);
}
sslO=sslSupport.getSessionId();
if (sslO != null) {
request.setAttribute(SSLSupport.SESSION_ID_KEY,sslO);
}
sslO=sslSupport.getProtocol();
if (sslO != null) {
request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY,sslO);
}
request.setAttribute(SSLSupport.SESSION_MGR,sslSupport);
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
break;
}
case REQ_SSL_CERTIFICATE:
{
if (sslSupport != null) {
InputFilter[] inputFilters=inputBuffer.getFilters();
((BufferedInputFilter)inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
SecureNioChannel sslChannel=(SecureNioChannel)socketWrapper.getSocket();
SSLEngine engine=sslChannel.getSslEngine();
if (!engine.getNeedClientAuth()) {
engine.setNeedClientAuth(true);
try {
sslChannel.rehandshake(endpoint.getSoTimeout());
sslSupport=((NioEndpoint)endpoint).getHandler().getSslImplementation().getSSLSupport(engine.getSession());
}
 catch (IOException ioe) {
log.warn(sm.getString("http11processor.socket.sslreneg",ioe));
}
}
try {
Object sslO=sslSupport.getPeerCertificateChain(false);
if (sslO != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,sslO);
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case AVAILABLE:
{
request.setAvailable(inputBuffer.available());
break;
}
case COMET_BEGIN:
{
comet=true;
break;
}
case COMET_END:
{
comet=false;
break;
}
case COMET_CLOSE:
{
if (socketWrapper == null || socketWrapper.getSocket().getAttachment() == null) {
return;
}
NioEndpoint.KeyAttachment attach=(NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment();
attach.setCometOps(NioEndpoint.OP_CALLBACK);
RequestInfo rp=request.getRequestProcessor();
if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) {
socketWrapper.getSocket().getPoller().add(socketWrapper.getSocket());
}
break;
}
case COMET_SETTIMEOUT:
{
if (param == null) {
return;
}
if (socketWrapper == null || socketWrapper.getSocket().getAttachment() == null) {
return;
}
NioEndpoint.KeyAttachment attach=(NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment();
long timeout=((Long)param).longValue();
RequestInfo rp=request.getRequestProcessor();
if (rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE) {
attach.setTimeout(timeout);
}
break;
}
case ASYNC_COMPLETE:
{
if (asyncStateMachine.asyncComplete()) {
((NioEndpoint)endpoint).processSocket(socketWrapper.getSocket(),SocketStatus.OPEN_READ,true);
}
break;
}
case ASYNC_SETTIMEOUT:
{
if (param == null) {
return;
}
if (socketWrapper == null || socketWrapper.getSocket().getAttachment() == null) {
return;
}
NioEndpoint.KeyAttachment attach=(NioEndpoint.KeyAttachment)socketWrapper.getSocket().getAttachment();
long timeout=((Long)param).longValue();
attach.setTimeout(timeout);
break;
}
case ASYNC_DISPATCH:
{
if (asyncStateMachine.asyncDispatch()) {
((NioEndpoint)endpoint).processSocket(socketWrapper.getSocket(),SocketStatus.OPEN_READ,true);
}
break;
}
}
}

ID 5328=========================================================================type: 1
Method:org.apache.coyote.http11.upgrade.AbstractProcessor#upgradeDispatch(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletInputStream#onDataAvailable()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState upgradeDispatch(SocketStatus status) throws IOException {
  if (status == SocketStatus.OPEN_READ) {
    try {
      upgradeServletInputStream.onDataAvailable();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onDataAvailableFail"),ioe);
    }
  }
 else   if (status == SocketStatus.OPEN_WRITE) {
    try {
      upgradeServletOutputStream.onWritePossible();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onWritePossibleFail"),ioe);
    }
  }
 else   if (status == SocketStatus.STOP) {
    try {
      upgradeServletInputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.isCloseFail",ioe));
    }
    try {
      upgradeServletOutputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.osCloseFail",ioe));
    }
    return SocketState.CLOSED;
  }
 else {
    return SocketState.CLOSED;
  }
  if (upgradeServletInputStream.isCloseRequired() || upgradeServletOutputStream.isCloseRequired()) {
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 5329=========================================================================type: 1
Method:org.apache.coyote.http11.upgrade.AbstractProcessor#upgradeDispatch(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletOutputStream#onWritePossible()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState upgradeDispatch(SocketStatus status) throws IOException {
  if (status == SocketStatus.OPEN_READ) {
    try {
      upgradeServletInputStream.onDataAvailable();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onDataAvailableFail"),ioe);
    }
  }
 else   if (status == SocketStatus.OPEN_WRITE) {
    try {
      upgradeServletOutputStream.onWritePossible();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onWritePossibleFail"),ioe);
    }
  }
 else   if (status == SocketStatus.STOP) {
    try {
      upgradeServletInputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.isCloseFail",ioe));
    }
    try {
      upgradeServletOutputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.osCloseFail",ioe));
    }
    return SocketState.CLOSED;
  }
 else {
    return SocketState.CLOSED;
  }
  if (upgradeServletInputStream.isCloseRequired() || upgradeServletOutputStream.isCloseRequired()) {
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 5330=========================================================================type: 1
Method:org.apache.coyote.http11.upgrade.AbstractProcessor#upgradeDispatch(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletInputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState upgradeDispatch(SocketStatus status) throws IOException {
  if (status == SocketStatus.OPEN_READ) {
    try {
      upgradeServletInputStream.onDataAvailable();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onDataAvailableFail"),ioe);
    }
  }
 else   if (status == SocketStatus.OPEN_WRITE) {
    try {
      upgradeServletOutputStream.onWritePossible();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onWritePossibleFail"),ioe);
    }
  }
 else   if (status == SocketStatus.STOP) {
    try {
      upgradeServletInputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.isCloseFail",ioe));
    }
    try {
      upgradeServletOutputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.osCloseFail",ioe));
    }
    return SocketState.CLOSED;
  }
 else {
    return SocketState.CLOSED;
  }
  if (upgradeServletInputStream.isCloseRequired() || upgradeServletOutputStream.isCloseRequired()) {
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 5331=========================================================================type: 1
Method:org.apache.coyote.http11.upgrade.AbstractProcessor#upgradeDispatch(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletOutputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final SocketState upgradeDispatch(SocketStatus status) throws IOException {
  if (status == SocketStatus.OPEN_READ) {
    try {
      upgradeServletInputStream.onDataAvailable();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onDataAvailableFail"),ioe);
    }
  }
 else   if (status == SocketStatus.OPEN_WRITE) {
    try {
      upgradeServletOutputStream.onWritePossible();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.onWritePossibleFail"),ioe);
    }
  }
 else   if (status == SocketStatus.STOP) {
    try {
      upgradeServletInputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.isCloseFail",ioe));
    }
    try {
      upgradeServletOutputStream.close();
    }
 catch (    IOException ioe) {
      getLog().debug(sm.getString("abstractProcessor.osCloseFail",ioe));
    }
    return SocketState.CLOSED;
  }
 else {
    return SocketState.CLOSED;
  }
  if (upgradeServletInputStream.isCloseRequired() || upgradeServletOutputStream.isCloseRequired()) {
    return SocketState.CLOSED;
  }
  return SocketState.UPGRADED;
}

ID 5383=========================================================================type: 1
Method:org.apache.coyote.http11.upgrade.AbstractServletInputStream#isReady()
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletInputStream#doIsReady()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * New Servlet 3.1 method.
 */
public final boolean isReady(){
  if (listener == null) {
    throw new IllegalStateException(sm.getString("upgrade.sis.isReady.ise"));
  }
  if (ready != null) {
    return ready.booleanValue();
  }
  try {
    ready=Boolean.valueOf(doIsReady());
  }
 catch (  IOException e) {
    onError(e);
  }
  return ready.booleanValue();
}

ID 5386=========================================================================type: 1
Method:org.apache.coyote.http11.upgrade.AbstractServletInputStream#read(byte[], int, int)
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletInputStream#doRead(boolean, byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public final int read(byte[] b,int off,int len) throws IOException {
  preReadChecks();
  try {
    return doRead(listener == null,b,off,len);
  }
 catch (  IOException ioe) {
    closeRequired=true;
    throw ioe;
  }
}

ID 5388=========================================================================type: 1
Method:org.apache.coyote.http11.upgrade.AbstractServletInputStream#readInternal()
Rmethod: org.apache.coyote.http11.upgrade.AbstractServletInputStream#doRead(boolean, byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int readInternal() throws IOException {
  byte[] b=new byte[1];
  int result;
  try {
    result=doRead(listener == null,b,0,1);
  }
 catch (  IOException ioe) {
    closeRequired=true;
    throw ioe;
  }
  if (result == 0) {
    return -1;
  }
 else   if (result == -1) {
    return -1;
  }
 else {
    return b[0] & 0xFF;
  }
}

ID 5405=========================================================================type: 1
Method:org.apache.coyote.http11.SocketOutputBuffer#doWrite(org.apache.tomcat.util.buf.ByteChunk, org.apache.coyote.Response)
Rmethod: org.apache.coyote.http11.InternalAprOutputBuffer#flushBuffer()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Write chunk.
 */
@Override public int doWrite(ByteChunk chunk,Response res) throws IOException {
  try {
    int len=chunk.getLength();
    int start=chunk.getStart();
    byte[] b=chunk.getBuffer();
    while (len > 0) {
      int thisTime=len;
      if (bbuf.position() == bbuf.capacity()) {
        flushBuffer();
      }
      if (thisTime > bbuf.capacity() - bbuf.position()) {
        thisTime=bbuf.capacity() - bbuf.position();
      }
      bbuf.put(b,start,thisTime);
      len=len - thisTime;
      start=start + thisTime;
    }
    byteCount+=chunk.getLength();
    return chunk.getLength();
  }
 catch (  IOException ioe) {
    response.action(ActionCode.CLOSE_NOW,ioe);
    throw ioe;
  }
}

ID 5416=========================================================================type: 1
Method:org.apache.coyote.http11.SocketOutputBuffer#doWrite(org.apache.tomcat.util.buf.ByteChunk, org.apache.coyote.Response)
Rmethod: org.apache.coyote.http11.InternalNioOutputBuffer#addToBB(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Write chunk.
 */
@Override public int doWrite(ByteChunk chunk,Response res) throws IOException {
  try {
    int len=chunk.getLength();
    int start=chunk.getStart();
    byte[] b=chunk.getBuffer();
    addToBB(b,start,len);
    byteCount+=chunk.getLength();
    return chunk.getLength();
  }
 catch (  IOException ioe) {
    response.action(ActionCode.CLOSE_NOW,ioe);
    throw ioe;
  }
}

ID 5417=========================================================================type: 1
Method:org.apache.coyote.http11.Http11AprProcessor#event(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Adapter#event(org.apache.coyote.Request, org.apache.coyote.Response, org.apache.tomcat.util.net.SocketStatus)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState event(SocketStatus status) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  try {
    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
    if (!getAdapter().event(request,response,status)) {
      setErrorState(ErrorState.CLOSE_NOW,null);
    }
  }
 catch (  InterruptedIOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    response.setStatus(500);
    setErrorState(ErrorState.CLOSE_NOW,t);
    getAdapter().log(request,response,0);
    log.error(sm.getString("http11processor.request.process"),t);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (getErrorState().isError() || status == SocketStatus.STOP) {
    return SocketState.CLOSED;
  }
 else   if (!comet) {
    inputBuffer.nextRequest();
    outputBuffer.nextRequest();
    return SocketState.OPEN;
  }
 else {
    return SocketState.LONG;
  }
}

ID 5418=========================================================================type: 1
Method:org.apache.coyote.http11.Http11AprProcessor#actionInternal(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.tomcat.jni.Address#get(int, long)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("incomplete-switch") public void actionInternal(ActionCode actionCode,Object param){
  long socketRef=socketWrapper.getSocket().longValue();
switch (actionCode) {
case REQ_HOST_ADDR_ATTRIBUTE:
{
      if (remoteAddr == null && (socketRef != 0)) {
        try {
          long sa=Address.get(Socket.APR_REMOTE,socketRef);
          remoteAddr=Address.getip(sa);
        }
 catch (        Exception e) {
          log.warn(sm.getString("http11processor.socket.info"),e);
        }
      }
      request.remoteAddr().setString(remoteAddr);
      break;
    }
case REQ_LOCAL_NAME_ATTRIBUTE:
{
    if (localName == null && (socketRef != 0)) {
      try {
        long sa=Address.get(Socket.APR_LOCAL,socketRef);
        localName=Address.getnameinfo(sa,0);
      }
 catch (      Exception e) {
        log.warn(sm.getString("http11processor.socket.info"),e);
      }
    }
    request.localName().setString(localName);
    break;
  }
case REQ_HOST_ATTRIBUTE:
{
  if (remoteHost == null && (socketRef != 0)) {
    try {
      long sa=Address.get(Socket.APR_REMOTE,socketRef);
      remoteHost=Address.getnameinfo(sa,0);
      if (remoteHost == null) {
        remoteHost=Address.getip(sa);
      }
    }
 catch (    Exception e) {
      log.warn(sm.getString("http11processor.socket.info"),e);
    }
  }
  request.remoteHost().setString(remoteHost);
  break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (localAddr == null && (socketRef != 0)) {
  try {
    long sa=Address.get(Socket.APR_LOCAL,socketRef);
    localAddr=Address.getip(sa);
  }
 catch (  Exception e) {
    log.warn(sm.getString("http11processor.socket.info"),e);
  }
}
request.localAddr().setString(localAddr);
break;
}
case REQ_REMOTEPORT_ATTRIBUTE:
{
if (remotePort == -1 && (socketRef != 0)) {
try {
  long sa=Address.get(Socket.APR_REMOTE,socketRef);
  Sockaddr addr=Address.getInfo(sa);
  remotePort=addr.port;
}
 catch (Exception e) {
  log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setRemotePort(remotePort);
break;
}
case REQ_LOCALPORT_ATTRIBUTE:
{
if (localPort == -1 && (socketRef != 0)) {
try {
long sa=Address.get(Socket.APR_LOCAL,socketRef);
Sockaddr addr=Address.getInfo(sa);
localPort=addr.port;
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setLocalPort(localPort);
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
try {
Object sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_CIPHER);
if (sslO != null) {
request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,sslO);
}
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
sslO=Integer.valueOf(SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CIPHER_USEKEYSIZE));
request.setAttribute(SSLSupport.KEY_SIZE_KEY,sslO);
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_SESSION_ID);
if (sslO != null) {
request.setAttribute(SSLSupport.SESSION_ID_KEY,sslO);
}
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_PROTOCOL);
if (sslO != null) {
request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY,sslO);
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case REQ_SSL_CERTIFICATE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
InputFilter[] inputFilters=inputBuffer.getFilters();
((BufferedInputFilter)inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
try {
SSLSocket.setVerify(socketRef,SSL.SSL_CVERIFY_REQUIRE,((AprEndpoint)endpoint).getSSLVerifyDepth());
if (SSLSocket.renegotiate(socketRef) == 0) {
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf=CertificateFactory.getInstance("X.509");
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case AVAILABLE:
{
request.setAvailable(inputBuffer.available());
break;
}
case COMET_BEGIN:
{
comet=true;
break;
}
case COMET_END:
{
comet=false;
break;
}
case COMET_CLOSE:
{
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
break;
}
case COMET_SETTIMEOUT:
{
break;
}
case ASYNC_COMPLETE:
{
if (asyncStateMachine.asyncComplete()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
case ASYNC_SETTIMEOUT:
{
if (param == null) {
return;
}
long timeout=((Long)param).longValue();
socketWrapper.setTimeout(timeout);
break;
}
case ASYNC_DISPATCH:
{
if (asyncStateMachine.asyncDispatch()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
}
}

ID 5419=========================================================================type: 1
Method:org.apache.coyote.http11.Http11AprProcessor#actionInternal(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.tomcat.jni.SSLSocket#getInfoS(long, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("incomplete-switch") public void actionInternal(ActionCode actionCode,Object param){
  long socketRef=socketWrapper.getSocket().longValue();
switch (actionCode) {
case REQ_HOST_ADDR_ATTRIBUTE:
{
      if (remoteAddr == null && (socketRef != 0)) {
        try {
          long sa=Address.get(Socket.APR_REMOTE,socketRef);
          remoteAddr=Address.getip(sa);
        }
 catch (        Exception e) {
          log.warn(sm.getString("http11processor.socket.info"),e);
        }
      }
      request.remoteAddr().setString(remoteAddr);
      break;
    }
case REQ_LOCAL_NAME_ATTRIBUTE:
{
    if (localName == null && (socketRef != 0)) {
      try {
        long sa=Address.get(Socket.APR_LOCAL,socketRef);
        localName=Address.getnameinfo(sa,0);
      }
 catch (      Exception e) {
        log.warn(sm.getString("http11processor.socket.info"),e);
      }
    }
    request.localName().setString(localName);
    break;
  }
case REQ_HOST_ATTRIBUTE:
{
  if (remoteHost == null && (socketRef != 0)) {
    try {
      long sa=Address.get(Socket.APR_REMOTE,socketRef);
      remoteHost=Address.getnameinfo(sa,0);
      if (remoteHost == null) {
        remoteHost=Address.getip(sa);
      }
    }
 catch (    Exception e) {
      log.warn(sm.getString("http11processor.socket.info"),e);
    }
  }
  request.remoteHost().setString(remoteHost);
  break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (localAddr == null && (socketRef != 0)) {
  try {
    long sa=Address.get(Socket.APR_LOCAL,socketRef);
    localAddr=Address.getip(sa);
  }
 catch (  Exception e) {
    log.warn(sm.getString("http11processor.socket.info"),e);
  }
}
request.localAddr().setString(localAddr);
break;
}
case REQ_REMOTEPORT_ATTRIBUTE:
{
if (remotePort == -1 && (socketRef != 0)) {
try {
  long sa=Address.get(Socket.APR_REMOTE,socketRef);
  Sockaddr addr=Address.getInfo(sa);
  remotePort=addr.port;
}
 catch (Exception e) {
  log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setRemotePort(remotePort);
break;
}
case REQ_LOCALPORT_ATTRIBUTE:
{
if (localPort == -1 && (socketRef != 0)) {
try {
long sa=Address.get(Socket.APR_LOCAL,socketRef);
Sockaddr addr=Address.getInfo(sa);
localPort=addr.port;
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setLocalPort(localPort);
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
try {
Object sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_CIPHER);
if (sslO != null) {
request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,sslO);
}
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
sslO=Integer.valueOf(SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CIPHER_USEKEYSIZE));
request.setAttribute(SSLSupport.KEY_SIZE_KEY,sslO);
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_SESSION_ID);
if (sslO != null) {
request.setAttribute(SSLSupport.SESSION_ID_KEY,sslO);
}
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_PROTOCOL);
if (sslO != null) {
request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY,sslO);
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case REQ_SSL_CERTIFICATE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
InputFilter[] inputFilters=inputBuffer.getFilters();
((BufferedInputFilter)inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
try {
SSLSocket.setVerify(socketRef,SSL.SSL_CVERIFY_REQUIRE,((AprEndpoint)endpoint).getSSLVerifyDepth());
if (SSLSocket.renegotiate(socketRef) == 0) {
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf=CertificateFactory.getInstance("X.509");
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case AVAILABLE:
{
request.setAvailable(inputBuffer.available());
break;
}
case COMET_BEGIN:
{
comet=true;
break;
}
case COMET_END:
{
comet=false;
break;
}
case COMET_CLOSE:
{
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
break;
}
case COMET_SETTIMEOUT:
{
break;
}
case ASYNC_COMPLETE:
{
if (asyncStateMachine.asyncComplete()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
case ASYNC_SETTIMEOUT:
{
if (param == null) {
return;
}
long timeout=((Long)param).longValue();
socketWrapper.setTimeout(timeout);
break;
}
case ASYNC_DISPATCH:
{
if (asyncStateMachine.asyncDispatch()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
}
}

ID 5420=========================================================================type: 1
Method:org.apache.coyote.http11.Http11AprProcessor#actionInternal(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.tomcat.jni.SSLSocket#getInfoI(long, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("incomplete-switch") public void actionInternal(ActionCode actionCode,Object param){
  long socketRef=socketWrapper.getSocket().longValue();
switch (actionCode) {
case REQ_HOST_ADDR_ATTRIBUTE:
{
      if (remoteAddr == null && (socketRef != 0)) {
        try {
          long sa=Address.get(Socket.APR_REMOTE,socketRef);
          remoteAddr=Address.getip(sa);
        }
 catch (        Exception e) {
          log.warn(sm.getString("http11processor.socket.info"),e);
        }
      }
      request.remoteAddr().setString(remoteAddr);
      break;
    }
case REQ_LOCAL_NAME_ATTRIBUTE:
{
    if (localName == null && (socketRef != 0)) {
      try {
        long sa=Address.get(Socket.APR_LOCAL,socketRef);
        localName=Address.getnameinfo(sa,0);
      }
 catch (      Exception e) {
        log.warn(sm.getString("http11processor.socket.info"),e);
      }
    }
    request.localName().setString(localName);
    break;
  }
case REQ_HOST_ATTRIBUTE:
{
  if (remoteHost == null && (socketRef != 0)) {
    try {
      long sa=Address.get(Socket.APR_REMOTE,socketRef);
      remoteHost=Address.getnameinfo(sa,0);
      if (remoteHost == null) {
        remoteHost=Address.getip(sa);
      }
    }
 catch (    Exception e) {
      log.warn(sm.getString("http11processor.socket.info"),e);
    }
  }
  request.remoteHost().setString(remoteHost);
  break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (localAddr == null && (socketRef != 0)) {
  try {
    long sa=Address.get(Socket.APR_LOCAL,socketRef);
    localAddr=Address.getip(sa);
  }
 catch (  Exception e) {
    log.warn(sm.getString("http11processor.socket.info"),e);
  }
}
request.localAddr().setString(localAddr);
break;
}
case REQ_REMOTEPORT_ATTRIBUTE:
{
if (remotePort == -1 && (socketRef != 0)) {
try {
  long sa=Address.get(Socket.APR_REMOTE,socketRef);
  Sockaddr addr=Address.getInfo(sa);
  remotePort=addr.port;
}
 catch (Exception e) {
  log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setRemotePort(remotePort);
break;
}
case REQ_LOCALPORT_ATTRIBUTE:
{
if (localPort == -1 && (socketRef != 0)) {
try {
long sa=Address.get(Socket.APR_LOCAL,socketRef);
Sockaddr addr=Address.getInfo(sa);
localPort=addr.port;
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setLocalPort(localPort);
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
try {
Object sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_CIPHER);
if (sslO != null) {
request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,sslO);
}
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
sslO=Integer.valueOf(SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CIPHER_USEKEYSIZE));
request.setAttribute(SSLSupport.KEY_SIZE_KEY,sslO);
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_SESSION_ID);
if (sslO != null) {
request.setAttribute(SSLSupport.SESSION_ID_KEY,sslO);
}
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_PROTOCOL);
if (sslO != null) {
request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY,sslO);
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case REQ_SSL_CERTIFICATE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
InputFilter[] inputFilters=inputBuffer.getFilters();
((BufferedInputFilter)inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
try {
SSLSocket.setVerify(socketRef,SSL.SSL_CVERIFY_REQUIRE,((AprEndpoint)endpoint).getSSLVerifyDepth());
if (SSLSocket.renegotiate(socketRef) == 0) {
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf=CertificateFactory.getInstance("X.509");
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case AVAILABLE:
{
request.setAvailable(inputBuffer.available());
break;
}
case COMET_BEGIN:
{
comet=true;
break;
}
case COMET_END:
{
comet=false;
break;
}
case COMET_CLOSE:
{
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
break;
}
case COMET_SETTIMEOUT:
{
break;
}
case ASYNC_COMPLETE:
{
if (asyncStateMachine.asyncComplete()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
case ASYNC_SETTIMEOUT:
{
if (param == null) {
return;
}
long timeout=((Long)param).longValue();
socketWrapper.setTimeout(timeout);
break;
}
case ASYNC_DISPATCH:
{
if (asyncStateMachine.asyncDispatch()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
}
}

ID 5421=========================================================================type: 1
Method:org.apache.coyote.http11.Http11AprProcessor#actionInternal(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.tomcat.jni.SSLSocket#getInfoB(long, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("incomplete-switch") public void actionInternal(ActionCode actionCode,Object param){
  long socketRef=socketWrapper.getSocket().longValue();
switch (actionCode) {
case REQ_HOST_ADDR_ATTRIBUTE:
{
      if (remoteAddr == null && (socketRef != 0)) {
        try {
          long sa=Address.get(Socket.APR_REMOTE,socketRef);
          remoteAddr=Address.getip(sa);
        }
 catch (        Exception e) {
          log.warn(sm.getString("http11processor.socket.info"),e);
        }
      }
      request.remoteAddr().setString(remoteAddr);
      break;
    }
case REQ_LOCAL_NAME_ATTRIBUTE:
{
    if (localName == null && (socketRef != 0)) {
      try {
        long sa=Address.get(Socket.APR_LOCAL,socketRef);
        localName=Address.getnameinfo(sa,0);
      }
 catch (      Exception e) {
        log.warn(sm.getString("http11processor.socket.info"),e);
      }
    }
    request.localName().setString(localName);
    break;
  }
case REQ_HOST_ATTRIBUTE:
{
  if (remoteHost == null && (socketRef != 0)) {
    try {
      long sa=Address.get(Socket.APR_REMOTE,socketRef);
      remoteHost=Address.getnameinfo(sa,0);
      if (remoteHost == null) {
        remoteHost=Address.getip(sa);
      }
    }
 catch (    Exception e) {
      log.warn(sm.getString("http11processor.socket.info"),e);
    }
  }
  request.remoteHost().setString(remoteHost);
  break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (localAddr == null && (socketRef != 0)) {
  try {
    long sa=Address.get(Socket.APR_LOCAL,socketRef);
    localAddr=Address.getip(sa);
  }
 catch (  Exception e) {
    log.warn(sm.getString("http11processor.socket.info"),e);
  }
}
request.localAddr().setString(localAddr);
break;
}
case REQ_REMOTEPORT_ATTRIBUTE:
{
if (remotePort == -1 && (socketRef != 0)) {
try {
  long sa=Address.get(Socket.APR_REMOTE,socketRef);
  Sockaddr addr=Address.getInfo(sa);
  remotePort=addr.port;
}
 catch (Exception e) {
  log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setRemotePort(remotePort);
break;
}
case REQ_LOCALPORT_ATTRIBUTE:
{
if (localPort == -1 && (socketRef != 0)) {
try {
long sa=Address.get(Socket.APR_LOCAL,socketRef);
Sockaddr addr=Address.getInfo(sa);
localPort=addr.port;
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setLocalPort(localPort);
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
try {
Object sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_CIPHER);
if (sslO != null) {
request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,sslO);
}
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
sslO=Integer.valueOf(SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CIPHER_USEKEYSIZE));
request.setAttribute(SSLSupport.KEY_SIZE_KEY,sslO);
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_SESSION_ID);
if (sslO != null) {
request.setAttribute(SSLSupport.SESSION_ID_KEY,sslO);
}
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_PROTOCOL);
if (sslO != null) {
request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY,sslO);
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case REQ_SSL_CERTIFICATE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
InputFilter[] inputFilters=inputBuffer.getFilters();
((BufferedInputFilter)inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
try {
SSLSocket.setVerify(socketRef,SSL.SSL_CVERIFY_REQUIRE,((AprEndpoint)endpoint).getSSLVerifyDepth());
if (SSLSocket.renegotiate(socketRef) == 0) {
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf=CertificateFactory.getInstance("X.509");
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case AVAILABLE:
{
request.setAvailable(inputBuffer.available());
break;
}
case COMET_BEGIN:
{
comet=true;
break;
}
case COMET_END:
{
comet=false;
break;
}
case COMET_CLOSE:
{
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
break;
}
case COMET_SETTIMEOUT:
{
break;
}
case ASYNC_COMPLETE:
{
if (asyncStateMachine.asyncComplete()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
case ASYNC_SETTIMEOUT:
{
if (param == null) {
return;
}
long timeout=((Long)param).longValue();
socketWrapper.setTimeout(timeout);
break;
}
case ASYNC_DISPATCH:
{
if (asyncStateMachine.asyncDispatch()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
}
}

ID 5426=========================================================================type: 1
Method:org.apache.coyote.http11.Http11AprProcessor#actionInternal(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.tomcat.jni.SSLSocket#getInfoB(long, int)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("incomplete-switch") public void actionInternal(ActionCode actionCode,Object param){
  long socketRef=socketWrapper.getSocket().longValue();
switch (actionCode) {
case REQ_HOST_ADDR_ATTRIBUTE:
{
      if (remoteAddr == null && (socketRef != 0)) {
        try {
          long sa=Address.get(Socket.APR_REMOTE,socketRef);
          remoteAddr=Address.getip(sa);
        }
 catch (        Exception e) {
          log.warn(sm.getString("http11processor.socket.info"),e);
        }
      }
      request.remoteAddr().setString(remoteAddr);
      break;
    }
case REQ_LOCAL_NAME_ATTRIBUTE:
{
    if (localName == null && (socketRef != 0)) {
      try {
        long sa=Address.get(Socket.APR_LOCAL,socketRef);
        localName=Address.getnameinfo(sa,0);
      }
 catch (      Exception e) {
        log.warn(sm.getString("http11processor.socket.info"),e);
      }
    }
    request.localName().setString(localName);
    break;
  }
case REQ_HOST_ATTRIBUTE:
{
  if (remoteHost == null && (socketRef != 0)) {
    try {
      long sa=Address.get(Socket.APR_REMOTE,socketRef);
      remoteHost=Address.getnameinfo(sa,0);
      if (remoteHost == null) {
        remoteHost=Address.getip(sa);
      }
    }
 catch (    Exception e) {
      log.warn(sm.getString("http11processor.socket.info"),e);
    }
  }
  request.remoteHost().setString(remoteHost);
  break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (localAddr == null && (socketRef != 0)) {
  try {
    long sa=Address.get(Socket.APR_LOCAL,socketRef);
    localAddr=Address.getip(sa);
  }
 catch (  Exception e) {
    log.warn(sm.getString("http11processor.socket.info"),e);
  }
}
request.localAddr().setString(localAddr);
break;
}
case REQ_REMOTEPORT_ATTRIBUTE:
{
if (remotePort == -1 && (socketRef != 0)) {
try {
  long sa=Address.get(Socket.APR_REMOTE,socketRef);
  Sockaddr addr=Address.getInfo(sa);
  remotePort=addr.port;
}
 catch (Exception e) {
  log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setRemotePort(remotePort);
break;
}
case REQ_LOCALPORT_ATTRIBUTE:
{
if (localPort == -1 && (socketRef != 0)) {
try {
long sa=Address.get(Socket.APR_LOCAL,socketRef);
Sockaddr addr=Address.getInfo(sa);
localPort=addr.port;
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.info"),e);
}
}
request.setLocalPort(localPort);
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
try {
Object sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_CIPHER);
if (sslO != null) {
request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,sslO);
}
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
sslO=Integer.valueOf(SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CIPHER_USEKEYSIZE));
request.setAttribute(SSLSupport.KEY_SIZE_KEY,sslO);
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_SESSION_ID);
if (sslO != null) {
request.setAttribute(SSLSupport.SESSION_ID_KEY,sslO);
}
sslO=SSLSocket.getInfoS(socketRef,SSL.SSL_INFO_PROTOCOL);
if (sslO != null) {
request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY,sslO);
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case REQ_SSL_CERTIFICATE:
{
if (endpoint.isSSLEnabled() && (socketRef != 0)) {
InputFilter[] inputFilters=inputBuffer.getFilters();
((BufferedInputFilter)inputFilters[Constants.BUFFERED_FILTER]).setLimit(maxSavePostSize);
inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
try {
SSLSocket.setVerify(socketRef,SSL.SSL_CVERIFY_REQUIRE,((AprEndpoint)endpoint).getSSLVerifyDepth());
if (SSLSocket.renegotiate(socketRef) == 0) {
int certLength=SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
byte[] clientCert=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT);
X509Certificate[] certs=null;
if (clientCert != null && certLength > -1) {
certs=new X509Certificate[certLength + 1];
CertificateFactory cf=CertificateFactory.getInstance("X.509");
certs[0]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(clientCert));
for (int i=0; i < certLength; i++) {
  byte[] data=SSLSocket.getInfoB(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
  certs[i + 1]=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(data));
}
}
if (certs != null) {
request.setAttribute(SSLSupport.CERTIFICATE_KEY,certs);
}
}
}
 catch (Exception e) {
log.warn(sm.getString("http11processor.socket.ssl"),e);
}
}
break;
}
case AVAILABLE:
{
request.setAvailable(inputBuffer.available());
break;
}
case COMET_BEGIN:
{
comet=true;
break;
}
case COMET_END:
{
comet=false;
break;
}
case COMET_CLOSE:
{
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
break;
}
case COMET_SETTIMEOUT:
{
break;
}
case ASYNC_COMPLETE:
{
if (asyncStateMachine.asyncComplete()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
case ASYNC_SETTIMEOUT:
{
if (param == null) {
return;
}
long timeout=((Long)param).longValue();
socketWrapper.setTimeout(timeout);
break;
}
case ASYNC_DISPATCH:
{
if (asyncStateMachine.asyncDispatch()) {
((AprEndpoint)endpoint).processSocketAsync(this.socketWrapper,SocketStatus.OPEN_READ);
}
break;
}
}
}

ID 5442=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.coyote.http11.AbstractOutputBuffer#endRequest()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("deprecation") public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case CLOSE:
{
      try {
        getOutputBuffer().endRequest();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case COMMIT:
{
    if (response.isCommitted()) {
      return;
    }
    try {
      prepareResponse();
      getOutputBuffer().commit();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case ACK:
{
  if ((response.isCommitted()) || !expectation) {
    return;
  }
  getInputBuffer().setSwallowInput(true);
  try {
    getOutputBuffer().sendAck();
  }
 catch (  IOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
  break;
}
case CLIENT_FLUSH:
{
try {
  getOutputBuffer().flush();
}
 catch (IOException e) {
  setErrorState(ErrorState.CLOSE_NOW,e);
  response.setErrorException(e);
}
break;
}
case IS_ERROR:
{
((AtomicBoolean)param).set(getErrorState().isError());
break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
getInputBuffer().setSwallowInput(false);
break;
}
case RESET:
{
getOutputBuffer().reset();
break;
}
case CUSTOM:
{
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk body=(ByteChunk)param;
InputFilter savedBody=new SavedRequestInputFilter(body);
savedBody.setRequest(request);
@SuppressWarnings("unchecked") AbstractInputBuffer<S> internalBuffer=(AbstractInputBuffer<S>)request.getInputBuffer();
internalBuffer.addActiveFilter(savedBody);
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case UPGRADE_TOMCAT:
{
upgradeInbound=(org.apache.coyote.http11.upgrade.UpgradeInbound)param;
getOutputBuffer().finished=true;
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE:
{
httpUpgradeHandler=(HttpUpgradeHandler)param;
getOutputBuffer().finished=true;
break;
}
case CLOSE_NOW:
{
getOutputBuffer().finished=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
endRequest();
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5443=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.coyote.http11.AbstractOutputBuffer#commit()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("deprecation") public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case CLOSE:
{
      try {
        getOutputBuffer().endRequest();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case COMMIT:
{
    if (response.isCommitted()) {
      return;
    }
    try {
      prepareResponse();
      getOutputBuffer().commit();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case ACK:
{
  if ((response.isCommitted()) || !expectation) {
    return;
  }
  getInputBuffer().setSwallowInput(true);
  try {
    getOutputBuffer().sendAck();
  }
 catch (  IOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
  break;
}
case CLIENT_FLUSH:
{
try {
  getOutputBuffer().flush();
}
 catch (IOException e) {
  setErrorState(ErrorState.CLOSE_NOW,e);
  response.setErrorException(e);
}
break;
}
case IS_ERROR:
{
((AtomicBoolean)param).set(getErrorState().isError());
break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
getInputBuffer().setSwallowInput(false);
break;
}
case RESET:
{
getOutputBuffer().reset();
break;
}
case CUSTOM:
{
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk body=(ByteChunk)param;
InputFilter savedBody=new SavedRequestInputFilter(body);
savedBody.setRequest(request);
@SuppressWarnings("unchecked") AbstractInputBuffer<S> internalBuffer=(AbstractInputBuffer<S>)request.getInputBuffer();
internalBuffer.addActiveFilter(savedBody);
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case UPGRADE_TOMCAT:
{
upgradeInbound=(org.apache.coyote.http11.upgrade.UpgradeInbound)param;
getOutputBuffer().finished=true;
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE:
{
httpUpgradeHandler=(HttpUpgradeHandler)param;
getOutputBuffer().finished=true;
break;
}
case CLOSE_NOW:
{
getOutputBuffer().finished=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
endRequest();
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5444=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.coyote.http11.AbstractOutputBuffer#sendAck()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("deprecation") public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case CLOSE:
{
      try {
        getOutputBuffer().endRequest();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case COMMIT:
{
    if (response.isCommitted()) {
      return;
    }
    try {
      prepareResponse();
      getOutputBuffer().commit();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case ACK:
{
  if ((response.isCommitted()) || !expectation) {
    return;
  }
  getInputBuffer().setSwallowInput(true);
  try {
    getOutputBuffer().sendAck();
  }
 catch (  IOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
  break;
}
case CLIENT_FLUSH:
{
try {
  getOutputBuffer().flush();
}
 catch (IOException e) {
  setErrorState(ErrorState.CLOSE_NOW,e);
  response.setErrorException(e);
}
break;
}
case IS_ERROR:
{
((AtomicBoolean)param).set(getErrorState().isError());
break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
getInputBuffer().setSwallowInput(false);
break;
}
case RESET:
{
getOutputBuffer().reset();
break;
}
case CUSTOM:
{
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk body=(ByteChunk)param;
InputFilter savedBody=new SavedRequestInputFilter(body);
savedBody.setRequest(request);
@SuppressWarnings("unchecked") AbstractInputBuffer<S> internalBuffer=(AbstractInputBuffer<S>)request.getInputBuffer();
internalBuffer.addActiveFilter(savedBody);
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case UPGRADE_TOMCAT:
{
upgradeInbound=(org.apache.coyote.http11.upgrade.UpgradeInbound)param;
getOutputBuffer().finished=true;
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE:
{
httpUpgradeHandler=(HttpUpgradeHandler)param;
getOutputBuffer().finished=true;
break;
}
case CLOSE_NOW:
{
getOutputBuffer().finished=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
endRequest();
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5445=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.coyote.http11.AbstractOutputBuffer#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override @SuppressWarnings("deprecation") public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case CLOSE:
{
      try {
        getOutputBuffer().endRequest();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case COMMIT:
{
    if (response.isCommitted()) {
      return;
    }
    try {
      prepareResponse();
      getOutputBuffer().commit();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case ACK:
{
  if ((response.isCommitted()) || !expectation) {
    return;
  }
  getInputBuffer().setSwallowInput(true);
  try {
    getOutputBuffer().sendAck();
  }
 catch (  IOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
  break;
}
case CLIENT_FLUSH:
{
try {
  getOutputBuffer().flush();
}
 catch (IOException e) {
  setErrorState(ErrorState.CLOSE_NOW,e);
  response.setErrorException(e);
}
break;
}
case IS_ERROR:
{
((AtomicBoolean)param).set(getErrorState().isError());
break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
getInputBuffer().setSwallowInput(false);
break;
}
case RESET:
{
getOutputBuffer().reset();
break;
}
case CUSTOM:
{
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk body=(ByteChunk)param;
InputFilter savedBody=new SavedRequestInputFilter(body);
savedBody.setRequest(request);
@SuppressWarnings("unchecked") AbstractInputBuffer<S> internalBuffer=(AbstractInputBuffer<S>)request.getInputBuffer();
internalBuffer.addActiveFilter(savedBody);
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case UPGRADE_TOMCAT:
{
upgradeInbound=(org.apache.coyote.http11.upgrade.UpgradeInbound)param;
getOutputBuffer().finished=true;
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE:
{
httpUpgradeHandler=(HttpUpgradeHandler)param;
getOutputBuffer().finished=true;
break;
}
case CLOSE_NOW:
{
getOutputBuffer().finished=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
endRequest();
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5448=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#process(SocketWrapper<S>)
Rmethod: org.apache.coyote.http11.AbstractHttp11Processor#setRequestLineReadTimeout()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @param socketWrapper Socket from which the HTTP requests will be readand the HTTP responses will be written.
 * @throws IOException error during an I/O operationgL process B ( Adapterservice;/(ContainerS- invoker eB
 */
@Override public SocketState process(SocketWrapper<S> socketWrapper) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  setSocketWrapper(socketWrapper);
  getInputBuffer().init(socketWrapper,endpoint);
  getOutputBuffer().init(socketWrapper,endpoint);
  keepAlive=true;
  comet=false;
  openSocket=false;
  sendfileInProgress=false;
  readComplete=true;
  if (endpoint.getUsePolling()) {
    keptAlive=false;
  }
 else {
    keptAlive=socketWrapper.isKeptAlive();
  }
  if (disableKeepAlive()) {
    socketWrapper.setKeepAliveLeft(0);
  }
  while (!getErrorState().isError() && keepAlive && !comet&& !isAsync()&& upgradeInbound == null && httpUpgradeHandler == null && !endpoint.isPaused()) {
    try {
      setRequestLineReadTimeout();
      if (!getInputBuffer().parseRequestLine(keptAlive)) {
        if (handleIncompleteRequestLineRead()) {
          break;
        }
      }
      if (endpoint.isPaused()) {
        response.setStatus(503);
        setErrorState(ErrorState.CLOSE_CLEAN,null);
      }
 else {
        keptAlive=true;
        request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
        request.getCookies().setLimit(getMaxCookieCount());
        if (!getInputBuffer().parseHeaders()) {
          openSocket=true;
          readComplete=false;
          break;
        }
        if (!disableUploadTimeout) {
          setSocketTimeout(connectionUploadTimeout);
        }
      }
    }
 catch (    IOException e) {
      if (getLog().isDebugEnabled()) {
        getLog().debug(sm.getString("http11processor.header.parse"),e);
      }
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      UserDataHelper.Mode logMode=userDataHelper.getNextMode();
      if (logMode != null) {
        String message=sm.getString("http11processor.header.parse");
switch (logMode) {
case INFO_THEN_DEBUG:
          message+=sm.getString("http11processor.fallToDebug");
case INFO:
        getLog().info(message,t);
      break;
case DEBUG:
    getLog().debug(message,t);
}
}
response.setStatus(400);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
if (!getErrorState().isError()) {
rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
try {
prepareRequest();
}
 catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
if (getLog().isDebugEnabled()) {
  getLog().debug(sm.getString("http11processor.request.prepare"),t);
}
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
if (maxKeepAliveRequests == 1) {
keepAlive=false;
}
 else if (maxKeepAliveRequests > 0 && socketWrapper.decrementKeepAlive() <= 0) {
keepAlive=false;
}
if (!getErrorState().isError()) {
try {
rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
adapter.service(request,response);
if (keepAlive && !getErrorState().isError() && (response.getErrorException() != null || (!isAsync() && statusDropsConnection(response.getStatus())))) {
  setErrorState(ErrorState.CLOSE_CLEAN,null);
}
setCometTimeouts(socketWrapper);
}
 catch (InterruptedIOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
catch (HeadersTooLargeException e) {
getLog().error(sm.getString("http11processor.request.process"),e);
if (response.isCommitted()) {
  setErrorState(ErrorState.CLOSE_NOW,e);
}
 else {
  response.reset();
  response.setStatus(500);
  setErrorState(ErrorState.CLOSE_CLEAN,e);
  response.setHeader("Connection","close");
}
}
catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
getLog().error(sm.getString("http11processor.request.process"),t);
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
if (!isAsync() && !comet) {
if (getErrorState().isError()) {
getInputBuffer().setSwallowInput(false);
}
 else {
checkExpectationAndResponseStatus();
}
endRequest();
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
if (getErrorState().isError()) {
response.setStatus(500);
}
request.updateCounters();
if (!isAsync() && !comet || getErrorState().isError()) {
if (getErrorState().isIoAllowed()) {
getInputBuffer().nextRequest();
getOutputBuffer().nextRequest();
}
}
if (!disableUploadTimeout) {
if (endpoint.getSoTimeout() > 0) {
setSocketTimeout(endpoint.getSoTimeout());
}
 else {
setSocketTimeout(0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
if (breakKeepAliveLoop(socketWrapper)) {
break;
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
if (getErrorState().isError() || endpoint.isPaused()) {
return SocketState.CLOSED;
}
 else if (isAsync() || comet) {
return SocketState.LONG;
}
 else if (isUpgrade()) {
return SocketState.UPGRADING;
}
 else if (getUpgradeInbound() != null) {
return SocketState.UPGRADING_TOMCAT;
}
 else {
if (sendfileInProgress) {
return SocketState.SENDFILE;
}
 else {
if (openSocket) {
if (readComplete) {
  return SocketState.OPEN;
}
 else {
  return SocketState.LONG;
}
}
 else {
return SocketState.CLOSED;
}
}
}
}

ID 5449=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#process(SocketWrapper<S>)
Rmethod: org.apache.coyote.http11.AbstractInputBuffer#parseRequestLine(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @param socketWrapper Socket from which the HTTP requests will be readand the HTTP responses will be written.
 * @throws IOException error during an I/O operationgL process B ( Adapterservice;/(ContainerS- invoker eB
 */
@Override public SocketState process(SocketWrapper<S> socketWrapper) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  setSocketWrapper(socketWrapper);
  getInputBuffer().init(socketWrapper,endpoint);
  getOutputBuffer().init(socketWrapper,endpoint);
  keepAlive=true;
  comet=false;
  openSocket=false;
  sendfileInProgress=false;
  readComplete=true;
  if (endpoint.getUsePolling()) {
    keptAlive=false;
  }
 else {
    keptAlive=socketWrapper.isKeptAlive();
  }
  if (disableKeepAlive()) {
    socketWrapper.setKeepAliveLeft(0);
  }
  while (!getErrorState().isError() && keepAlive && !comet&& !isAsync()&& upgradeInbound == null && httpUpgradeHandler == null && !endpoint.isPaused()) {
    try {
      setRequestLineReadTimeout();
      if (!getInputBuffer().parseRequestLine(keptAlive)) {
        if (handleIncompleteRequestLineRead()) {
          break;
        }
      }
      if (endpoint.isPaused()) {
        response.setStatus(503);
        setErrorState(ErrorState.CLOSE_CLEAN,null);
      }
 else {
        keptAlive=true;
        request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
        request.getCookies().setLimit(getMaxCookieCount());
        if (!getInputBuffer().parseHeaders()) {
          openSocket=true;
          readComplete=false;
          break;
        }
        if (!disableUploadTimeout) {
          setSocketTimeout(connectionUploadTimeout);
        }
      }
    }
 catch (    IOException e) {
      if (getLog().isDebugEnabled()) {
        getLog().debug(sm.getString("http11processor.header.parse"),e);
      }
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      UserDataHelper.Mode logMode=userDataHelper.getNextMode();
      if (logMode != null) {
        String message=sm.getString("http11processor.header.parse");
switch (logMode) {
case INFO_THEN_DEBUG:
          message+=sm.getString("http11processor.fallToDebug");
case INFO:
        getLog().info(message,t);
      break;
case DEBUG:
    getLog().debug(message,t);
}
}
response.setStatus(400);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
if (!getErrorState().isError()) {
rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
try {
prepareRequest();
}
 catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
if (getLog().isDebugEnabled()) {
  getLog().debug(sm.getString("http11processor.request.prepare"),t);
}
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
if (maxKeepAliveRequests == 1) {
keepAlive=false;
}
 else if (maxKeepAliveRequests > 0 && socketWrapper.decrementKeepAlive() <= 0) {
keepAlive=false;
}
if (!getErrorState().isError()) {
try {
rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
adapter.service(request,response);
if (keepAlive && !getErrorState().isError() && (response.getErrorException() != null || (!isAsync() && statusDropsConnection(response.getStatus())))) {
  setErrorState(ErrorState.CLOSE_CLEAN,null);
}
setCometTimeouts(socketWrapper);
}
 catch (InterruptedIOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
catch (HeadersTooLargeException e) {
getLog().error(sm.getString("http11processor.request.process"),e);
if (response.isCommitted()) {
  setErrorState(ErrorState.CLOSE_NOW,e);
}
 else {
  response.reset();
  response.setStatus(500);
  setErrorState(ErrorState.CLOSE_CLEAN,e);
  response.setHeader("Connection","close");
}
}
catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
getLog().error(sm.getString("http11processor.request.process"),t);
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
if (!isAsync() && !comet) {
if (getErrorState().isError()) {
getInputBuffer().setSwallowInput(false);
}
 else {
checkExpectationAndResponseStatus();
}
endRequest();
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
if (getErrorState().isError()) {
response.setStatus(500);
}
request.updateCounters();
if (!isAsync() && !comet || getErrorState().isError()) {
if (getErrorState().isIoAllowed()) {
getInputBuffer().nextRequest();
getOutputBuffer().nextRequest();
}
}
if (!disableUploadTimeout) {
if (endpoint.getSoTimeout() > 0) {
setSocketTimeout(endpoint.getSoTimeout());
}
 else {
setSocketTimeout(0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
if (breakKeepAliveLoop(socketWrapper)) {
break;
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
if (getErrorState().isError() || endpoint.isPaused()) {
return SocketState.CLOSED;
}
 else if (isAsync() || comet) {
return SocketState.LONG;
}
 else if (isUpgrade()) {
return SocketState.UPGRADING;
}
 else if (getUpgradeInbound() != null) {
return SocketState.UPGRADING_TOMCAT;
}
 else {
if (sendfileInProgress) {
return SocketState.SENDFILE;
}
 else {
if (openSocket) {
if (readComplete) {
  return SocketState.OPEN;
}
 else {
  return SocketState.LONG;
}
}
 else {
return SocketState.CLOSED;
}
}
}
}

ID 5450=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#process(SocketWrapper<S>)
Rmethod: org.apache.coyote.http11.AbstractInputBuffer#parseHeaders()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @param socketWrapper Socket from which the HTTP requests will be readand the HTTP responses will be written.
 * @throws IOException error during an I/O operationgL process B ( Adapterservice;/(ContainerS- invoker eB
 */
@Override public SocketState process(SocketWrapper<S> socketWrapper) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  setSocketWrapper(socketWrapper);
  getInputBuffer().init(socketWrapper,endpoint);
  getOutputBuffer().init(socketWrapper,endpoint);
  keepAlive=true;
  comet=false;
  openSocket=false;
  sendfileInProgress=false;
  readComplete=true;
  if (endpoint.getUsePolling()) {
    keptAlive=false;
  }
 else {
    keptAlive=socketWrapper.isKeptAlive();
  }
  if (disableKeepAlive()) {
    socketWrapper.setKeepAliveLeft(0);
  }
  while (!getErrorState().isError() && keepAlive && !comet&& !isAsync()&& upgradeInbound == null && httpUpgradeHandler == null && !endpoint.isPaused()) {
    try {
      setRequestLineReadTimeout();
      if (!getInputBuffer().parseRequestLine(keptAlive)) {
        if (handleIncompleteRequestLineRead()) {
          break;
        }
      }
      if (endpoint.isPaused()) {
        response.setStatus(503);
        setErrorState(ErrorState.CLOSE_CLEAN,null);
      }
 else {
        keptAlive=true;
        request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
        request.getCookies().setLimit(getMaxCookieCount());
        if (!getInputBuffer().parseHeaders()) {
          openSocket=true;
          readComplete=false;
          break;
        }
        if (!disableUploadTimeout) {
          setSocketTimeout(connectionUploadTimeout);
        }
      }
    }
 catch (    IOException e) {
      if (getLog().isDebugEnabled()) {
        getLog().debug(sm.getString("http11processor.header.parse"),e);
      }
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      UserDataHelper.Mode logMode=userDataHelper.getNextMode();
      if (logMode != null) {
        String message=sm.getString("http11processor.header.parse");
switch (logMode) {
case INFO_THEN_DEBUG:
          message+=sm.getString("http11processor.fallToDebug");
case INFO:
        getLog().info(message,t);
      break;
case DEBUG:
    getLog().debug(message,t);
}
}
response.setStatus(400);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
if (!getErrorState().isError()) {
rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
try {
prepareRequest();
}
 catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
if (getLog().isDebugEnabled()) {
  getLog().debug(sm.getString("http11processor.request.prepare"),t);
}
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
if (maxKeepAliveRequests == 1) {
keepAlive=false;
}
 else if (maxKeepAliveRequests > 0 && socketWrapper.decrementKeepAlive() <= 0) {
keepAlive=false;
}
if (!getErrorState().isError()) {
try {
rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
adapter.service(request,response);
if (keepAlive && !getErrorState().isError() && (response.getErrorException() != null || (!isAsync() && statusDropsConnection(response.getStatus())))) {
  setErrorState(ErrorState.CLOSE_CLEAN,null);
}
setCometTimeouts(socketWrapper);
}
 catch (InterruptedIOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
catch (HeadersTooLargeException e) {
getLog().error(sm.getString("http11processor.request.process"),e);
if (response.isCommitted()) {
  setErrorState(ErrorState.CLOSE_NOW,e);
}
 else {
  response.reset();
  response.setStatus(500);
  setErrorState(ErrorState.CLOSE_CLEAN,e);
  response.setHeader("Connection","close");
}
}
catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
getLog().error(sm.getString("http11processor.request.process"),t);
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
if (!isAsync() && !comet) {
if (getErrorState().isError()) {
getInputBuffer().setSwallowInput(false);
}
 else {
checkExpectationAndResponseStatus();
}
endRequest();
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
if (getErrorState().isError()) {
response.setStatus(500);
}
request.updateCounters();
if (!isAsync() && !comet || getErrorState().isError()) {
if (getErrorState().isIoAllowed()) {
getInputBuffer().nextRequest();
getOutputBuffer().nextRequest();
}
}
if (!disableUploadTimeout) {
if (endpoint.getSoTimeout() > 0) {
setSocketTimeout(endpoint.getSoTimeout());
}
 else {
setSocketTimeout(0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
if (breakKeepAliveLoop(socketWrapper)) {
break;
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
if (getErrorState().isError() || endpoint.isPaused()) {
return SocketState.CLOSED;
}
 else if (isAsync() || comet) {
return SocketState.LONG;
}
 else if (isUpgrade()) {
return SocketState.UPGRADING;
}
 else if (getUpgradeInbound() != null) {
return SocketState.UPGRADING_TOMCAT;
}
 else {
if (sendfileInProgress) {
return SocketState.SENDFILE;
}
 else {
if (openSocket) {
if (readComplete) {
  return SocketState.OPEN;
}
 else {
  return SocketState.LONG;
}
}
 else {
return SocketState.CLOSED;
}
}
}
}

ID 5451=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#process(SocketWrapper<S>)
Rmethod: org.apache.coyote.http11.AbstractHttp11Processor#setSocketTimeout(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @param socketWrapper Socket from which the HTTP requests will be readand the HTTP responses will be written.
 * @throws IOException error during an I/O operationgL process B ( Adapterservice;/(ContainerS- invoker eB
 */
@Override public SocketState process(SocketWrapper<S> socketWrapper) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  setSocketWrapper(socketWrapper);
  getInputBuffer().init(socketWrapper,endpoint);
  getOutputBuffer().init(socketWrapper,endpoint);
  keepAlive=true;
  comet=false;
  openSocket=false;
  sendfileInProgress=false;
  readComplete=true;
  if (endpoint.getUsePolling()) {
    keptAlive=false;
  }
 else {
    keptAlive=socketWrapper.isKeptAlive();
  }
  if (disableKeepAlive()) {
    socketWrapper.setKeepAliveLeft(0);
  }
  while (!getErrorState().isError() && keepAlive && !comet&& !isAsync()&& upgradeInbound == null && httpUpgradeHandler == null && !endpoint.isPaused()) {
    try {
      setRequestLineReadTimeout();
      if (!getInputBuffer().parseRequestLine(keptAlive)) {
        if (handleIncompleteRequestLineRead()) {
          break;
        }
      }
      if (endpoint.isPaused()) {
        response.setStatus(503);
        setErrorState(ErrorState.CLOSE_CLEAN,null);
      }
 else {
        keptAlive=true;
        request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
        request.getCookies().setLimit(getMaxCookieCount());
        if (!getInputBuffer().parseHeaders()) {
          openSocket=true;
          readComplete=false;
          break;
        }
        if (!disableUploadTimeout) {
          setSocketTimeout(connectionUploadTimeout);
        }
      }
    }
 catch (    IOException e) {
      if (getLog().isDebugEnabled()) {
        getLog().debug(sm.getString("http11processor.header.parse"),e);
      }
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      UserDataHelper.Mode logMode=userDataHelper.getNextMode();
      if (logMode != null) {
        String message=sm.getString("http11processor.header.parse");
switch (logMode) {
case INFO_THEN_DEBUG:
          message+=sm.getString("http11processor.fallToDebug");
case INFO:
        getLog().info(message,t);
      break;
case DEBUG:
    getLog().debug(message,t);
}
}
response.setStatus(400);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
if (!getErrorState().isError()) {
rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
try {
prepareRequest();
}
 catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
if (getLog().isDebugEnabled()) {
  getLog().debug(sm.getString("http11processor.request.prepare"),t);
}
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
if (maxKeepAliveRequests == 1) {
keepAlive=false;
}
 else if (maxKeepAliveRequests > 0 && socketWrapper.decrementKeepAlive() <= 0) {
keepAlive=false;
}
if (!getErrorState().isError()) {
try {
rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
adapter.service(request,response);
if (keepAlive && !getErrorState().isError() && (response.getErrorException() != null || (!isAsync() && statusDropsConnection(response.getStatus())))) {
  setErrorState(ErrorState.CLOSE_CLEAN,null);
}
setCometTimeouts(socketWrapper);
}
 catch (InterruptedIOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
catch (HeadersTooLargeException e) {
getLog().error(sm.getString("http11processor.request.process"),e);
if (response.isCommitted()) {
  setErrorState(ErrorState.CLOSE_NOW,e);
}
 else {
  response.reset();
  response.setStatus(500);
  setErrorState(ErrorState.CLOSE_CLEAN,e);
  response.setHeader("Connection","close");
}
}
catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
getLog().error(sm.getString("http11processor.request.process"),t);
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
if (!isAsync() && !comet) {
if (getErrorState().isError()) {
getInputBuffer().setSwallowInput(false);
}
 else {
checkExpectationAndResponseStatus();
}
endRequest();
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
if (getErrorState().isError()) {
response.setStatus(500);
}
request.updateCounters();
if (!isAsync() && !comet || getErrorState().isError()) {
if (getErrorState().isIoAllowed()) {
getInputBuffer().nextRequest();
getOutputBuffer().nextRequest();
}
}
if (!disableUploadTimeout) {
if (endpoint.getSoTimeout() > 0) {
setSocketTimeout(endpoint.getSoTimeout());
}
 else {
setSocketTimeout(0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
if (breakKeepAliveLoop(socketWrapper)) {
break;
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
if (getErrorState().isError() || endpoint.isPaused()) {
return SocketState.CLOSED;
}
 else if (isAsync() || comet) {
return SocketState.LONG;
}
 else if (isUpgrade()) {
return SocketState.UPGRADING;
}
 else if (getUpgradeInbound() != null) {
return SocketState.UPGRADING_TOMCAT;
}
 else {
if (sendfileInProgress) {
return SocketState.SENDFILE;
}
 else {
if (openSocket) {
if (readComplete) {
  return SocketState.OPEN;
}
 else {
  return SocketState.LONG;
}
}
 else {
return SocketState.CLOSED;
}
}
}
}

ID 5452=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#process(SocketWrapper<S>)
Rmethod: org.apache.coyote.Adapter#service(org.apache.coyote.Request, org.apache.coyote.Response)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @param socketWrapper Socket from which the HTTP requests will be readand the HTTP responses will be written.
 * @throws IOException error during an I/O operationgL process B ( Adapterservice;/(ContainerS- invoker eB
 */
@Override public SocketState process(SocketWrapper<S> socketWrapper) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  setSocketWrapper(socketWrapper);
  getInputBuffer().init(socketWrapper,endpoint);
  getOutputBuffer().init(socketWrapper,endpoint);
  keepAlive=true;
  comet=false;
  openSocket=false;
  sendfileInProgress=false;
  readComplete=true;
  if (endpoint.getUsePolling()) {
    keptAlive=false;
  }
 else {
    keptAlive=socketWrapper.isKeptAlive();
  }
  if (disableKeepAlive()) {
    socketWrapper.setKeepAliveLeft(0);
  }
  while (!getErrorState().isError() && keepAlive && !comet&& !isAsync()&& upgradeInbound == null && httpUpgradeHandler == null && !endpoint.isPaused()) {
    try {
      setRequestLineReadTimeout();
      if (!getInputBuffer().parseRequestLine(keptAlive)) {
        if (handleIncompleteRequestLineRead()) {
          break;
        }
      }
      if (endpoint.isPaused()) {
        response.setStatus(503);
        setErrorState(ErrorState.CLOSE_CLEAN,null);
      }
 else {
        keptAlive=true;
        request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());
        request.getCookies().setLimit(getMaxCookieCount());
        if (!getInputBuffer().parseHeaders()) {
          openSocket=true;
          readComplete=false;
          break;
        }
        if (!disableUploadTimeout) {
          setSocketTimeout(connectionUploadTimeout);
        }
      }
    }
 catch (    IOException e) {
      if (getLog().isDebugEnabled()) {
        getLog().debug(sm.getString("http11processor.header.parse"),e);
      }
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      UserDataHelper.Mode logMode=userDataHelper.getNextMode();
      if (logMode != null) {
        String message=sm.getString("http11processor.header.parse");
switch (logMode) {
case INFO_THEN_DEBUG:
          message+=sm.getString("http11processor.fallToDebug");
case INFO:
        getLog().info(message,t);
      break;
case DEBUG:
    getLog().debug(message,t);
}
}
response.setStatus(400);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
if (!getErrorState().isError()) {
rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
try {
prepareRequest();
}
 catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
if (getLog().isDebugEnabled()) {
  getLog().debug(sm.getString("http11processor.request.prepare"),t);
}
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
if (maxKeepAliveRequests == 1) {
keepAlive=false;
}
 else if (maxKeepAliveRequests > 0 && socketWrapper.decrementKeepAlive() <= 0) {
keepAlive=false;
}
if (!getErrorState().isError()) {
try {
rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
adapter.service(request,response);
if (keepAlive && !getErrorState().isError() && (response.getErrorException() != null || (!isAsync() && statusDropsConnection(response.getStatus())))) {
  setErrorState(ErrorState.CLOSE_CLEAN,null);
}
setCometTimeouts(socketWrapper);
}
 catch (InterruptedIOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
catch (HeadersTooLargeException e) {
getLog().error(sm.getString("http11processor.request.process"),e);
if (response.isCommitted()) {
  setErrorState(ErrorState.CLOSE_NOW,e);
}
 else {
  response.reset();
  response.setStatus(500);
  setErrorState(ErrorState.CLOSE_CLEAN,e);
  response.setHeader("Connection","close");
}
}
catch (Throwable t) {
ExceptionUtils.handleThrowable(t);
getLog().error(sm.getString("http11processor.request.process"),t);
response.setStatus(500);
setErrorState(ErrorState.CLOSE_CLEAN,t);
getAdapter().log(request,response,0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
if (!isAsync() && !comet) {
if (getErrorState().isError()) {
getInputBuffer().setSwallowInput(false);
}
 else {
checkExpectationAndResponseStatus();
}
endRequest();
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
if (getErrorState().isError()) {
response.setStatus(500);
}
request.updateCounters();
if (!isAsync() && !comet || getErrorState().isError()) {
if (getErrorState().isIoAllowed()) {
getInputBuffer().nextRequest();
getOutputBuffer().nextRequest();
}
}
if (!disableUploadTimeout) {
if (endpoint.getSoTimeout() > 0) {
setSocketTimeout(endpoint.getSoTimeout());
}
 else {
setSocketTimeout(0);
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
if (breakKeepAliveLoop(socketWrapper)) {
break;
}
}
rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
if (getErrorState().isError() || endpoint.isPaused()) {
return SocketState.CLOSED;
}
 else if (isAsync() || comet) {
return SocketState.LONG;
}
 else if (isUpgrade()) {
return SocketState.UPGRADING;
}
 else if (getUpgradeInbound() != null) {
return SocketState.UPGRADING_TOMCAT;
}
 else {
if (sendfileInProgress) {
return SocketState.SENDFILE;
}
 else {
if (openSocket) {
if (readComplete) {
  return SocketState.OPEN;
}
 else {
  return SocketState.LONG;
}
}
 else {
return SocketState.CLOSED;
}
}
}
}

ID 5455=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#asyncDispatch(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Adapter#asyncDispatch(org.apache.coyote.Request, org.apache.coyote.Response, org.apache.tomcat.util.net.SocketStatus)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public SocketState asyncDispatch(SocketStatus status){
  RequestInfo rp=request.getRequestProcessor();
  try {
    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
    if (!getAdapter().asyncDispatch(request,response,status)) {
      setErrorState(ErrorState.CLOSE_NOW,null);
    }
    resetTimeouts();
  }
 catch (  InterruptedIOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    setErrorState(ErrorState.CLOSE_NOW,t);
    getLog().error(sm.getString("http11processor.request.process"),t);
  }
 finally {
    if (getErrorState().isError()) {
      response.setStatus(500);
      adapter.log(request,response,0);
    }
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (getErrorState().isError()) {
    return SocketState.CLOSED;
  }
 else   if (isAsync()) {
    return SocketState.LONG;
  }
 else {
    if (!keepAlive) {
      return SocketState.CLOSED;
    }
 else {
      endRequest();
      getInputBuffer().nextRequest();
      getOutputBuffer().nextRequest();
      return SocketState.OPEN;
    }
  }
}

ID 5456=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#endRequest()
Rmethod: org.apache.coyote.http11.AbstractInputBuffer#endRequest()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void endRequest(){
  if (getErrorState().isIoAllowed()) {
    try {
      getInputBuffer().endRequest();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      response.setStatus(500);
      setErrorState(ErrorState.CLOSE_NOW,t);
      getLog().error(sm.getString("http11processor.request.finish"),t);
    }
  }
  if (getErrorState().isIoAllowed()) {
    try {
      getOutputBuffer().endRequest();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      setErrorState(ErrorState.CLOSE_NOW,t);
      getLog().error(sm.getString("http11processor.response.finish"),t);
    }
  }
}

ID 5457=========================================================================type: 1
Method:org.apache.coyote.http11.AbstractHttp11Processor#endRequest()
Rmethod: org.apache.coyote.http11.AbstractOutputBuffer#endRequest()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void endRequest(){
  if (getErrorState().isIoAllowed()) {
    try {
      getInputBuffer().endRequest();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      response.setStatus(500);
      setErrorState(ErrorState.CLOSE_NOW,t);
      getLog().error(sm.getString("http11processor.request.finish"),t);
    }
  }
  if (getErrorState().isIoAllowed()) {
    try {
      getOutputBuffer().endRequest();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      setErrorState(ErrorState.CLOSE_NOW,t);
      getLog().error(sm.getString("http11processor.response.finish"),t);
    }
  }
}

ID 5495=========================================================================type: 1
Method:org.apache.coyote.http11.OutputStreamOutputBuffer#doWrite(org.apache.tomcat.util.buf.ByteChunk, org.apache.coyote.Response)
Rmethod: org.apache.tomcat.util.buf.ByteChunk#append(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Write chunk.
 */
@Override public int doWrite(ByteChunk chunk,Response res) throws IOException {
  try {
    int length=chunk.getLength();
    if (useSocketBuffer) {
      socketBuffer.append(chunk.getBuffer(),chunk.getStart(),length);
    }
 else {
      outputStream.write(chunk.getBuffer(),chunk.getStart(),length);
    }
    byteCount+=chunk.getLength();
    return chunk.getLength();
  }
 catch (  IOException ioe) {
    response.action(ActionCode.CLOSE_NOW,ioe);
    throw ioe;
  }
}

ID 5496=========================================================================type: 1
Method:org.apache.coyote.http11.OutputStreamOutputBuffer#doWrite(org.apache.tomcat.util.buf.ByteChunk, org.apache.coyote.Response)
Rmethod: java.io.OutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Write chunk.
 */
@Override public int doWrite(ByteChunk chunk,Response res) throws IOException {
  try {
    int length=chunk.getLength();
    if (useSocketBuffer) {
      socketBuffer.append(chunk.getBuffer(),chunk.getStart(),length);
    }
 else {
      outputStream.write(chunk.getBuffer(),chunk.getStart(),length);
    }
    byteCount+=chunk.getLength();
    return chunk.getLength();
  }
 catch (  IOException ioe) {
    response.action(ActionCode.CLOSE_NOW,ioe);
    throw ioe;
  }
}

ID 5507=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpNioProcessor#process(SocketWrapper<org.apache.tomcat.util.net.NioChannel>)
Rmethod: org.apache.coyote.ajp.AjpNioProcessor#readMessage(org.apache.coyote.ajp.AjpMessage, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<NioChannel> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  long soTimeout=endpoint.getSoTimeout();
  boolean cping=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      int bytesRead=readMessage(requestHeaderMessage,false);
      if (bytesRead == 0) {
        break;
      }
      if (keepAliveTimeout > 0) {
        socket.setTimeout(soTimeout);
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        try {
          output(pongMessageArray,0,pongMessageArray.length);
        }
 catch (        IOException e) {
          setErrorState(ErrorState.CLOSE_NOW,null);
        }
        recycle(false);
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        recycle(true);
        break;
      }
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    if (keepAliveTimeout > 0) {
      socket.setTimeout(keepAliveTimeout);
    }
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (!getErrorState().isError() && !endpoint.isPaused()) {
    if (isAsync()) {
      return SocketState.LONG;
    }
 else {
      return SocketState.OPEN;
    }
  }
 else {
    return SocketState.CLOSED;
  }
}

ID 5508=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpNioProcessor#process(SocketWrapper<org.apache.tomcat.util.net.NioChannel>)
Rmethod: org.apache.coyote.ajp.AjpNioProcessor#output(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<NioChannel> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  long soTimeout=endpoint.getSoTimeout();
  boolean cping=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      int bytesRead=readMessage(requestHeaderMessage,false);
      if (bytesRead == 0) {
        break;
      }
      if (keepAliveTimeout > 0) {
        socket.setTimeout(soTimeout);
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        try {
          output(pongMessageArray,0,pongMessageArray.length);
        }
 catch (        IOException e) {
          setErrorState(ErrorState.CLOSE_NOW,null);
        }
        recycle(false);
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        recycle(true);
        break;
      }
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    if (keepAliveTimeout > 0) {
      socket.setTimeout(keepAliveTimeout);
    }
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (!getErrorState().isError() && !endpoint.isPaused()) {
    if (isAsync()) {
      return SocketState.LONG;
    }
 else {
      return SocketState.OPEN;
    }
  }
 else {
    return SocketState.CLOSED;
  }
}

ID 5509=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpNioProcessor#process(SocketWrapper<org.apache.tomcat.util.net.NioChannel>)
Rmethod: org.apache.coyote.Adapter#service(org.apache.coyote.Request, org.apache.coyote.Response)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<NioChannel> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  long soTimeout=endpoint.getSoTimeout();
  boolean cping=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      int bytesRead=readMessage(requestHeaderMessage,false);
      if (bytesRead == 0) {
        break;
      }
      if (keepAliveTimeout > 0) {
        socket.setTimeout(soTimeout);
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        try {
          output(pongMessageArray,0,pongMessageArray.length);
        }
 catch (        IOException e) {
          setErrorState(ErrorState.CLOSE_NOW,null);
        }
        recycle(false);
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        recycle(true);
        break;
      }
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    if (keepAliveTimeout > 0) {
      socket.setTimeout(keepAliveTimeout);
    }
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (!getErrorState().isError() && !endpoint.isPaused()) {
    if (isAsync()) {
      return SocketState.LONG;
    }
 else {
      return SocketState.OPEN;
    }
  }
 else {
    return SocketState.CLOSED;
  }
}

ID 5521=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpAprProcessor#process(SocketWrapper<java.lang.Long>)
Rmethod: org.apache.coyote.ajp.AjpAprProcessor#readMessage(org.apache.coyote.ajp.AjpMessage, boolean, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<Long> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  long socketRef=socket.getSocket().longValue();
  Socket.setrbb(socketRef,inputBuffer);
  Socket.setsbb(socketRef,outputBuffer);
  boolean cping=false;
  boolean keptAlive=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      if (!readMessage(requestHeaderMessage,true,keptAlive)) {
        break;
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        if (Socket.send(socketRef,pongMessageArray,0,pongMessageArray.length) < 0) {
          setErrorState(ErrorState.CLOSE_NOW,null);
        }
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        break;
      }
      keptAlive=true;
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (!getErrorState().isError() && !endpoint.isPaused()) {
    if (isAsync()) {
      return SocketState.LONG;
    }
 else {
      return SocketState.OPEN;
    }
  }
 else {
    return SocketState.CLOSED;
  }
}

ID 5522=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpAprProcessor#process(SocketWrapper<java.lang.Long>)
Rmethod: org.apache.coyote.Adapter#service(org.apache.coyote.Request, org.apache.coyote.Response)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<Long> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  long socketRef=socket.getSocket().longValue();
  Socket.setrbb(socketRef,inputBuffer);
  Socket.setsbb(socketRef,outputBuffer);
  boolean cping=false;
  boolean keptAlive=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      if (!readMessage(requestHeaderMessage,true,keptAlive)) {
        break;
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        if (Socket.send(socketRef,pongMessageArray,0,pongMessageArray.length) < 0) {
          setErrorState(ErrorState.CLOSE_NOW,null);
        }
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        break;
      }
      keptAlive=true;
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (!getErrorState().isError() && !endpoint.isPaused()) {
    if (isAsync()) {
      return SocketState.LONG;
    }
 else {
      return SocketState.OPEN;
    }
  }
 else {
    return SocketState.CLOSED;
  }
}

ID 5527=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.coyote.ajp.AbstractAjpProcessor#prepareResponse()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case COMMIT:
{
      if (response.isCommitted())       return;
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      try {
        flush(false);
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case CLIENT_FLUSH:
{
    if (!response.isCommitted()) {
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
        return;
      }
    }
    try {
      flush(true);
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case IS_ERROR:
{
  ((AtomicBoolean)param).set(getErrorState().isError());
  break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
break;
}
case CLOSE:
{
try {
finish();
}
 catch (IOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (!certificates.isNull()) {
ByteChunk certData=certificates.getByteChunk();
X509Certificate jsseCerts[]=null;
ByteArrayInputStream bais=new ByteArrayInputStream(certData.getBytes(),certData.getStart(),certData.getLength());
try {
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
while (bais.available() > 0) {
  X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
  if (jsseCerts == null) {
    jsseCerts=new X509Certificate[1];
    jsseCerts[0]=cert;
  }
 else {
    X509Certificate[] temp=new X509Certificate[jsseCerts.length + 1];
    System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
    temp[jsseCerts.length]=cert;
    jsseCerts=temp;
  }
}
}
 catch (java.security.cert.CertificateException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
catch (NoSuchProviderException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
request.setAttribute(SSLSupport.CERTIFICATE_KEY,jsseCerts);
}
break;
}
case REQ_HOST_ATTRIBUTE:
{
if (request.remoteHost().isNull()) {
try {
request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
}
 catch (IOException iex) {
}
}
break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (request.localAddr().isNull()) {
request.localAddr().setString(request.localName().toString());
}
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk bc=(ByteChunk)param;
int length=bc.getLength();
bodyBytes.setBytes(bc.getBytes(),bc.getStart(),length);
request.setContentLength(length);
first=false;
empty=false;
replay=true;
endOfStream=false;
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE_TOMCAT:
{
break;
}
case CLOSE_NOW:
{
swallowResponse=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5528=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.coyote.ajp.AbstractAjpProcessor#flush(boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case COMMIT:
{
      if (response.isCommitted())       return;
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      try {
        flush(false);
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case CLIENT_FLUSH:
{
    if (!response.isCommitted()) {
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
        return;
      }
    }
    try {
      flush(true);
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case IS_ERROR:
{
  ((AtomicBoolean)param).set(getErrorState().isError());
  break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
break;
}
case CLOSE:
{
try {
finish();
}
 catch (IOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (!certificates.isNull()) {
ByteChunk certData=certificates.getByteChunk();
X509Certificate jsseCerts[]=null;
ByteArrayInputStream bais=new ByteArrayInputStream(certData.getBytes(),certData.getStart(),certData.getLength());
try {
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
while (bais.available() > 0) {
  X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
  if (jsseCerts == null) {
    jsseCerts=new X509Certificate[1];
    jsseCerts[0]=cert;
  }
 else {
    X509Certificate[] temp=new X509Certificate[jsseCerts.length + 1];
    System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
    temp[jsseCerts.length]=cert;
    jsseCerts=temp;
  }
}
}
 catch (java.security.cert.CertificateException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
catch (NoSuchProviderException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
request.setAttribute(SSLSupport.CERTIFICATE_KEY,jsseCerts);
}
break;
}
case REQ_HOST_ATTRIBUTE:
{
if (request.remoteHost().isNull()) {
try {
request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
}
 catch (IOException iex) {
}
}
break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (request.localAddr().isNull()) {
request.localAddr().setString(request.localName().toString());
}
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk bc=(ByteChunk)param;
int length=bc.getLength();
bodyBytes.setBytes(bc.getBytes(),bc.getStart(),length);
request.setContentLength(length);
first=false;
empty=false;
replay=true;
endOfStream=false;
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE_TOMCAT:
{
break;
}
case CLOSE_NOW:
{
swallowResponse=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5529=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: org.apache.coyote.ajp.AbstractAjpProcessor#finish()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case COMMIT:
{
      if (response.isCommitted())       return;
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      try {
        flush(false);
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case CLIENT_FLUSH:
{
    if (!response.isCommitted()) {
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
        return;
      }
    }
    try {
      flush(true);
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case IS_ERROR:
{
  ((AtomicBoolean)param).set(getErrorState().isError());
  break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
break;
}
case CLOSE:
{
try {
finish();
}
 catch (IOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (!certificates.isNull()) {
ByteChunk certData=certificates.getByteChunk();
X509Certificate jsseCerts[]=null;
ByteArrayInputStream bais=new ByteArrayInputStream(certData.getBytes(),certData.getStart(),certData.getLength());
try {
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
while (bais.available() > 0) {
  X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
  if (jsseCerts == null) {
    jsseCerts=new X509Certificate[1];
    jsseCerts[0]=cert;
  }
 else {
    X509Certificate[] temp=new X509Certificate[jsseCerts.length + 1];
    System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
    temp[jsseCerts.length]=cert;
    jsseCerts=temp;
  }
}
}
 catch (java.security.cert.CertificateException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
catch (NoSuchProviderException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
request.setAttribute(SSLSupport.CERTIFICATE_KEY,jsseCerts);
}
break;
}
case REQ_HOST_ATTRIBUTE:
{
if (request.remoteHost().isNull()) {
try {
request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
}
 catch (IOException iex) {
}
}
break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (request.localAddr().isNull()) {
request.localAddr().setString(request.localName().toString());
}
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk bc=(ByteChunk)param;
int length=bc.getLength();
bodyBytes.setBytes(bc.getBytes(),bc.getStart(),length);
request.setContentLength(length);
first=false;
empty=false;
replay=true;
endOfStream=false;
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE_TOMCAT:
{
break;
}
case CLOSE_NOW:
{
swallowResponse=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5530=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: java.security.cert.CertificateFactory#getInstance(java.lang.String)
parentException: GeneralSecurityException 
thrown: CertificateException
exception comment: /** 
 * This exception indicates one of a variety of certificate problems. <p><em>Note: The classes in the package  {@code javax.security.cert}exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE). New applications should instead use the standard Java SE certificate classes located in {@code java.security.cert}.</em></p>
 * @author Hemma Prafullchandra
 * @since 1.4
 * @see Certificate
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case COMMIT:
{
      if (response.isCommitted())       return;
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      try {
        flush(false);
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case CLIENT_FLUSH:
{
    if (!response.isCommitted()) {
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
        return;
      }
    }
    try {
      flush(true);
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case IS_ERROR:
{
  ((AtomicBoolean)param).set(getErrorState().isError());
  break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
break;
}
case CLOSE:
{
try {
finish();
}
 catch (IOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (!certificates.isNull()) {
ByteChunk certData=certificates.getByteChunk();
X509Certificate jsseCerts[]=null;
ByteArrayInputStream bais=new ByteArrayInputStream(certData.getBytes(),certData.getStart(),certData.getLength());
try {
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
while (bais.available() > 0) {
  X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
  if (jsseCerts == null) {
    jsseCerts=new X509Certificate[1];
    jsseCerts[0]=cert;
  }
 else {
    X509Certificate[] temp=new X509Certificate[jsseCerts.length + 1];
    System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
    temp[jsseCerts.length]=cert;
    jsseCerts=temp;
  }
}
}
 catch (java.security.cert.CertificateException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
catch (NoSuchProviderException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
request.setAttribute(SSLSupport.CERTIFICATE_KEY,jsseCerts);
}
break;
}
case REQ_HOST_ATTRIBUTE:
{
if (request.remoteHost().isNull()) {
try {
request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
}
 catch (IOException iex) {
}
}
break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (request.localAddr().isNull()) {
request.localAddr().setString(request.localName().toString());
}
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk bc=(ByteChunk)param;
int length=bc.getLength();
bodyBytes.setBytes(bc.getBytes(),bc.getStart(),length);
request.setContentLength(length);
first=false;
empty=false;
replay=true;
endOfStream=false;
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE_TOMCAT:
{
break;
}
case CLOSE_NOW:
{
swallowResponse=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5531=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: java.security.cert.CertificateFactory#getInstance(java.lang.String, java.lang.String)
parentException: GeneralSecurityException 
thrown: CertificateException
exception comment: /** 
 * This exception indicates one of a variety of certificate problems. <p><em>Note: The classes in the package  {@code javax.security.cert}exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE). New applications should instead use the standard Java SE certificate classes located in {@code java.security.cert}.</em></p>
 * @author Hemma Prafullchandra
 * @since 1.4
 * @see Certificate
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case COMMIT:
{
      if (response.isCommitted())       return;
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      try {
        flush(false);
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case CLIENT_FLUSH:
{
    if (!response.isCommitted()) {
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
        return;
      }
    }
    try {
      flush(true);
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case IS_ERROR:
{
  ((AtomicBoolean)param).set(getErrorState().isError());
  break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
break;
}
case CLOSE:
{
try {
finish();
}
 catch (IOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (!certificates.isNull()) {
ByteChunk certData=certificates.getByteChunk();
X509Certificate jsseCerts[]=null;
ByteArrayInputStream bais=new ByteArrayInputStream(certData.getBytes(),certData.getStart(),certData.getLength());
try {
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
while (bais.available() > 0) {
  X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
  if (jsseCerts == null) {
    jsseCerts=new X509Certificate[1];
    jsseCerts[0]=cert;
  }
 else {
    X509Certificate[] temp=new X509Certificate[jsseCerts.length + 1];
    System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
    temp[jsseCerts.length]=cert;
    jsseCerts=temp;
  }
}
}
 catch (java.security.cert.CertificateException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
catch (NoSuchProviderException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
request.setAttribute(SSLSupport.CERTIFICATE_KEY,jsseCerts);
}
break;
}
case REQ_HOST_ATTRIBUTE:
{
if (request.remoteHost().isNull()) {
try {
request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
}
 catch (IOException iex) {
}
}
break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (request.localAddr().isNull()) {
request.localAddr().setString(request.localName().toString());
}
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk bc=(ByteChunk)param;
int length=bc.getLength();
bodyBytes.setBytes(bc.getBytes(),bc.getStart(),length);
request.setContentLength(length);
first=false;
empty=false;
replay=true;
endOfStream=false;
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE_TOMCAT:
{
break;
}
case CLOSE_NOW:
{
swallowResponse=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5532=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: java.security.cert.CertificateFactory#getInstance(java.lang.String, java.lang.String)
parentException: GeneralSecurityException 
thrown: NoSuchProviderException
exception comment: /** 
 * This exception is thrown when a particular security provider is requested but is not available in the environment.
 * @author Benjamin Renaud
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case COMMIT:
{
      if (response.isCommitted())       return;
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      try {
        flush(false);
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case CLIENT_FLUSH:
{
    if (!response.isCommitted()) {
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
        return;
      }
    }
    try {
      flush(true);
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case IS_ERROR:
{
  ((AtomicBoolean)param).set(getErrorState().isError());
  break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
break;
}
case CLOSE:
{
try {
finish();
}
 catch (IOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (!certificates.isNull()) {
ByteChunk certData=certificates.getByteChunk();
X509Certificate jsseCerts[]=null;
ByteArrayInputStream bais=new ByteArrayInputStream(certData.getBytes(),certData.getStart(),certData.getLength());
try {
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
while (bais.available() > 0) {
  X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
  if (jsseCerts == null) {
    jsseCerts=new X509Certificate[1];
    jsseCerts[0]=cert;
  }
 else {
    X509Certificate[] temp=new X509Certificate[jsseCerts.length + 1];
    System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
    temp[jsseCerts.length]=cert;
    jsseCerts=temp;
  }
}
}
 catch (java.security.cert.CertificateException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
catch (NoSuchProviderException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
request.setAttribute(SSLSupport.CERTIFICATE_KEY,jsseCerts);
}
break;
}
case REQ_HOST_ATTRIBUTE:
{
if (request.remoteHost().isNull()) {
try {
request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
}
 catch (IOException iex) {
}
}
break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (request.localAddr().isNull()) {
request.localAddr().setString(request.localName().toString());
}
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk bc=(ByteChunk)param;
int length=bc.getLength();
bodyBytes.setBytes(bc.getBytes(),bc.getStart(),length);
request.setContentLength(length);
first=false;
empty=false;
replay=true;
endOfStream=false;
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE_TOMCAT:
{
break;
}
case CLOSE_NOW:
{
swallowResponse=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5533=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#action(org.apache.coyote.ActionCode, java.lang.Object)
Rmethod: java.security.cert.CertificateFactory#generateCertificate(java.io.InputStream)
parentException: GeneralSecurityException 
thrown: CertificateException
exception comment: /** 
 * This exception indicates one of a variety of certificate problems. <p><em>Note: The classes in the package  {@code javax.security.cert}exist for compatibility with earlier versions of the Java Secure Sockets Extension (JSSE). New applications should instead use the standard Java SE certificate classes located in {@code java.security.cert}.</em></p>
 * @author Hemma Prafullchandra
 * @since 1.4
 * @see Certificate
 */

block: 
/** 
 * Send an action to the connector.
 * @param actionCode Type of the action
 * @param param Action parameter
 */
@Override public final void action(ActionCode actionCode,Object param){
switch (actionCode) {
case COMMIT:
{
      if (response.isCommitted())       return;
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      try {
        flush(false);
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
      break;
    }
case CLIENT_FLUSH:
{
    if (!response.isCommitted()) {
      try {
        prepareResponse();
      }
 catch (      IOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
        return;
      }
    }
    try {
      flush(true);
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
    break;
  }
case IS_ERROR:
{
  ((AtomicBoolean)param).set(getErrorState().isError());
  break;
}
case DISABLE_SWALLOW_INPUT:
{
setErrorState(ErrorState.CLOSE_CLEAN,null);
break;
}
case CLOSE:
{
try {
finish();
}
 catch (IOException e) {
setErrorState(ErrorState.CLOSE_NOW,e);
}
break;
}
case REQ_SSL_ATTRIBUTE:
{
if (!certificates.isNull()) {
ByteChunk certData=certificates.getByteChunk();
X509Certificate jsseCerts[]=null;
ByteArrayInputStream bais=new ByteArrayInputStream(certData.getBytes(),certData.getStart(),certData.getLength());
try {
CertificateFactory cf;
if (clientCertProvider == null) {
  cf=CertificateFactory.getInstance("X.509");
}
 else {
  cf=CertificateFactory.getInstance("X.509",clientCertProvider);
}
while (bais.available() > 0) {
  X509Certificate cert=(X509Certificate)cf.generateCertificate(bais);
  if (jsseCerts == null) {
    jsseCerts=new X509Certificate[1];
    jsseCerts[0]=cert;
  }
 else {
    X509Certificate[] temp=new X509Certificate[jsseCerts.length + 1];
    System.arraycopy(jsseCerts,0,temp,0,jsseCerts.length);
    temp[jsseCerts.length]=cert;
    jsseCerts=temp;
  }
}
}
 catch (java.security.cert.CertificateException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
catch (NoSuchProviderException e) {
getLog().error(sm.getString("ajpprocessor.certs.fail"),e);
return;
}
request.setAttribute(SSLSupport.CERTIFICATE_KEY,jsseCerts);
}
break;
}
case REQ_HOST_ATTRIBUTE:
{
if (request.remoteHost().isNull()) {
try {
request.remoteHost().setString(InetAddress.getByName(request.remoteAddr().toString()).getHostName());
}
 catch (IOException iex) {
}
}
break;
}
case REQ_LOCAL_ADDR_ATTRIBUTE:
{
if (request.localAddr().isNull()) {
request.localAddr().setString(request.localName().toString());
}
break;
}
case REQ_SET_BODY_REPLAY:
{
ByteChunk bc=(ByteChunk)param;
int length=bc.getLength();
bodyBytes.setBytes(bc.getBytes(),bc.getStart(),length);
request.setContentLength(length);
first=false;
empty=false;
replay=true;
endOfStream=false;
break;
}
case ASYNC_START:
{
asyncStateMachine.asyncStart((AsyncContextCallback)param);
getSocketWrapper().access();
break;
}
case ASYNC_DISPATCHED:
{
asyncStateMachine.asyncDispatched();
break;
}
case ASYNC_TIMEOUT:
{
AtomicBoolean result=(AtomicBoolean)param;
result.set(asyncStateMachine.asyncTimeout());
break;
}
case ASYNC_RUN:
{
asyncStateMachine.asyncRun((Runnable)param);
break;
}
case ASYNC_ERROR:
{
asyncStateMachine.asyncError();
break;
}
case ASYNC_IS_STARTED:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncStarted());
break;
}
case ASYNC_IS_COMPLETING:
{
((AtomicBoolean)param).set(asyncStateMachine.isCompleting());
break;
}
case ASYNC_IS_DISPATCHING:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncDispatching());
break;
}
case ASYNC_IS_ASYNC:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsync());
break;
}
case ASYNC_IS_TIMINGOUT:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncTimingOut());
break;
}
case ASYNC_IS_ERROR:
{
((AtomicBoolean)param).set(asyncStateMachine.isAsyncError());
break;
}
case ASYNC_POST_PROCESS:
{
asyncStateMachine.asyncPostProcess();
break;
}
case UPGRADE_TOMCAT:
{
break;
}
case CLOSE_NOW:
{
swallowResponse=true;
if (param instanceof Throwable) {
setErrorState(ErrorState.CLOSE_NOW,(Throwable)param);
}
 else {
setErrorState(ErrorState.CLOSE_NOW,null);
}
break;
}
case END_REQUEST:
{
break;
}
default :
{
actionInternal(actionCode,param);
break;
}
}
}

ID 5535=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#asyncDispatch(org.apache.tomcat.util.net.SocketStatus)
Rmethod: org.apache.coyote.Adapter#asyncDispatch(org.apache.coyote.Request, org.apache.coyote.Response, org.apache.tomcat.util.net.SocketStatus)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
@Override public SocketState asyncDispatch(SocketStatus status){
  RequestInfo rp=request.getRequestProcessor();
  try {
    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
    if (!getAdapter().asyncDispatch(request,response,status)) {
      setErrorState(ErrorState.CLOSE_NOW,null);
    }
    resetTimeouts();
  }
 catch (  InterruptedIOException e) {
    setErrorState(ErrorState.CLOSE_NOW,e);
  }
catch (  Throwable t) {
    ExceptionUtils.handleThrowable(t);
    setErrorState(ErrorState.CLOSE_NOW,t);
    getLog().error(sm.getString("http11processor.request.process"),t);
  }
 finally {
    if (getErrorState().isError()) {
      response.setStatus(500);
      adapter.log(request,response,0);
    }
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (isAsync()) {
    if (getErrorState().isError()) {
      request.updateCounters();
      return SocketState.CLOSED;
    }
 else {
      return SocketState.LONG;
    }
  }
 else {
    request.updateCounters();
    if (getErrorState().isError()) {
      return SocketState.CLOSED;
    }
 else {
      recycle(false);
      return SocketState.OPEN;
    }
  }
}

ID 5539=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#parseHost(org.apache.tomcat.util.buf.MessageBytes)
Rmethod: org.apache.tomcat.util.buf.MessageBytes#duplicate(org.apache.tomcat.util.buf.MessageBytes)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Parse host.
 */
protected void parseHost(MessageBytes valueMB){
  if (valueMB == null || valueMB.isNull()) {
    request.setServerPort(request.getLocalPort());
    try {
      request.serverName().duplicate(request.localName());
    }
 catch (    IOException e) {
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,e);
    }
    return;
  }
  ByteChunk valueBC=valueMB.getByteChunk();
  byte[] valueB=valueBC.getBytes();
  int valueL=valueBC.getLength();
  int valueS=valueBC.getStart();
  int colonPos=-1;
  if (hostNameC.length < valueL) {
    hostNameC=new char[valueL];
  }
  boolean ipv6=(valueB[valueS] == '[');
  boolean bracketClosed=false;
  for (int i=0; i < valueL; i++) {
    char b=(char)valueB[i + valueS];
    hostNameC[i]=b;
    if (b == ']') {
      bracketClosed=true;
    }
 else     if (b == ':') {
      if (!ipv6 || bracketClosed) {
        colonPos=i;
        break;
      }
    }
  }
  if (colonPos < 0) {
    if (request.scheme().equalsIgnoreCase("https")) {
      request.setServerPort(443);
    }
 else {
      request.setServerPort(80);
    }
    request.serverName().setChars(hostNameC,0,valueL);
  }
 else {
    request.serverName().setChars(hostNameC,0,colonPos);
    int port=0;
    int mult=1;
    for (int i=valueL - 1; i > colonPos; i--) {
      int charValue=HexUtils.getDec(valueB[i + valueS]);
      if (charValue == -1) {
        response.setStatus(400);
        setErrorState(ErrorState.CLOSE_CLEAN,null);
        break;
      }
      port=port + (charValue * mult);
      mult=10 * mult;
    }
    request.setServerPort(port);
  }
}

ID 5542=========================================================================type: 1
Method:org.apache.coyote.ajp.AbstractAjpProcessor#finish()
Rmethod: org.apache.coyote.ajp.AbstractAjpProcessor#prepareResponse()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Finish AJP response.
 */
protected void finish() throws IOException {
  if (!response.isCommitted()) {
    try {
      prepareResponse();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      return;
    }
  }
  if (finished)   return;
  finished=true;
  if (first && request.getContentLengthLong() > 0) {
    receive();
  }
  if (getErrorState().isError()) {
    output(endAndCloseMessageArray,0,endAndCloseMessageArray.length);
  }
 else {
    output(endMessageArray,0,endMessageArray.length);
  }
}

ID 5547=========================================================================type: 1
Method:org.apache.coyote.ajp.SocketOutputBuffer#doWrite(org.apache.tomcat.util.buf.ByteChunk, org.apache.coyote.Response)
Rmethod: org.apache.coyote.ajp.AbstractAjpProcessor#prepareResponse()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Write chunk.
 */
@Override public int doWrite(ByteChunk chunk,Response res) throws IOException {
  if (!response.isCommitted()) {
    try {
      prepareResponse();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
  }
  if (!swallowResponse) {
    try {
      int len=chunk.getLength();
      int chunkSize=Constants.MAX_SEND_SIZE + packetSize - Constants.MAX_PACKET_SIZE;
      int off=0;
      while (len > 0) {
        int thisTime=len;
        if (thisTime > chunkSize) {
          thisTime=chunkSize;
        }
        len-=thisTime;
        responseMessage.reset();
        responseMessage.appendByte(Constants.JK_AJP13_SEND_BODY_CHUNK);
        responseMessage.appendBytes(chunk.getBytes(),chunk.getOffset() + off,thisTime);
        responseMessage.end();
        output(responseMessage.getBuffer(),0,responseMessage.getLen());
        off+=thisTime;
      }
      bytesWritten+=chunk.getLength();
    }
 catch (    IOException ioe) {
      response.action(ActionCode.CLOSE_NOW,ioe);
      throw ioe;
    }
  }
  return chunk.getLength();
}

ID 5548=========================================================================type: 1
Method:org.apache.coyote.ajp.SocketOutputBuffer#doWrite(org.apache.tomcat.util.buf.ByteChunk, org.apache.coyote.Response)
Rmethod: org.apache.coyote.ajp.AbstractAjpProcessor#output(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Write chunk.
 */
@Override public int doWrite(ByteChunk chunk,Response res) throws IOException {
  if (!response.isCommitted()) {
    try {
      prepareResponse();
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
    }
  }
  if (!swallowResponse) {
    try {
      int len=chunk.getLength();
      int chunkSize=Constants.MAX_SEND_SIZE + packetSize - Constants.MAX_PACKET_SIZE;
      int off=0;
      while (len > 0) {
        int thisTime=len;
        if (thisTime > chunkSize) {
          thisTime=chunkSize;
        }
        len-=thisTime;
        responseMessage.reset();
        responseMessage.appendByte(Constants.JK_AJP13_SEND_BODY_CHUNK);
        responseMessage.appendBytes(chunk.getBytes(),chunk.getOffset() + off,thisTime);
        responseMessage.end();
        output(responseMessage.getBuffer(),0,responseMessage.getLen());
        off+=thisTime;
      }
      bytesWritten+=chunk.getLength();
    }
 catch (    IOException ioe) {
      response.action(ActionCode.CLOSE_NOW,ioe);
      throw ioe;
    }
  }
  return chunk.getLength();
}

ID 5552=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpProcessor#process(SocketWrapper<java.net.Socket>)
Rmethod: java.net.Socket#setSoTimeout(int)
parentException: IOException 
thrown: SocketException
exception comment: /** 
 * Thrown to indicate that there is an error creating or accessing a Socket.
 * @author  Jonathan Payne
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<Socket> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  input=socket.getSocket().getInputStream();
  output=socket.getSocket().getOutputStream();
  int soTimeout=-1;
  if (keepAliveTimeout > 0) {
    soTimeout=socket.getSocket().getSoTimeout();
  }
  boolean cping=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(keepAliveTimeout);
      }
      if (!readMessage(requestHeaderMessage)) {
        break;
      }
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(soTimeout);
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        try {
          output.write(pongMessageArray);
        }
 catch (        IOException e) {
          setErrorState(ErrorState.CLOSE_NOW,e);
        }
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        break;
      }
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (isAsync() && !getErrorState().isError() && !endpoint.isPaused()) {
    return SocketState.LONG;
  }
 else {
    input=null;
    output=null;
    return SocketState.CLOSED;
  }
}

ID 5553=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpProcessor#process(SocketWrapper<java.net.Socket>)
Rmethod: org.apache.coyote.ajp.AjpProcessor#readMessage(org.apache.coyote.ajp.AjpMessage)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<Socket> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  input=socket.getSocket().getInputStream();
  output=socket.getSocket().getOutputStream();
  int soTimeout=-1;
  if (keepAliveTimeout > 0) {
    soTimeout=socket.getSocket().getSoTimeout();
  }
  boolean cping=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(keepAliveTimeout);
      }
      if (!readMessage(requestHeaderMessage)) {
        break;
      }
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(soTimeout);
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        try {
          output.write(pongMessageArray);
        }
 catch (        IOException e) {
          setErrorState(ErrorState.CLOSE_NOW,e);
        }
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        break;
      }
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (isAsync() && !getErrorState().isError() && !endpoint.isPaused()) {
    return SocketState.LONG;
  }
 else {
    input=null;
    output=null;
    return SocketState.CLOSED;
  }
}

ID 5554=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpProcessor#process(SocketWrapper<java.net.Socket>)
Rmethod: java.io.OutputStream#write(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<Socket> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  input=socket.getSocket().getInputStream();
  output=socket.getSocket().getOutputStream();
  int soTimeout=-1;
  if (keepAliveTimeout > 0) {
    soTimeout=socket.getSocket().getSoTimeout();
  }
  boolean cping=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(keepAliveTimeout);
      }
      if (!readMessage(requestHeaderMessage)) {
        break;
      }
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(soTimeout);
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        try {
          output.write(pongMessageArray);
        }
 catch (        IOException e) {
          setErrorState(ErrorState.CLOSE_NOW,e);
        }
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        break;
      }
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (isAsync() && !getErrorState().isError() && !endpoint.isPaused()) {
    return SocketState.LONG;
  }
 else {
    input=null;
    output=null;
    return SocketState.CLOSED;
  }
}

ID 5555=========================================================================type: 1
Method:org.apache.coyote.ajp.AjpProcessor#process(SocketWrapper<java.net.Socket>)
Rmethod: org.apache.coyote.Adapter#service(org.apache.coyote.Request, org.apache.coyote.Response)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Process pipelined HTTP requests using the specified input and output streams.
 * @throws IOException error during an I/O operation
 */
@Override public SocketState process(SocketWrapper<Socket> socket) throws IOException {
  RequestInfo rp=request.getRequestProcessor();
  rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
  this.socketWrapper=socket;
  input=socket.getSocket().getInputStream();
  output=socket.getSocket().getOutputStream();
  int soTimeout=-1;
  if (keepAliveTimeout > 0) {
    soTimeout=socket.getSocket().getSoTimeout();
  }
  boolean cping=false;
  while (!getErrorState().isError() && !endpoint.isPaused()) {
    try {
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(keepAliveTimeout);
      }
      if (!readMessage(requestHeaderMessage)) {
        break;
      }
      if (keepAliveTimeout > 0) {
        socket.getSocket().setSoTimeout(soTimeout);
      }
      int type=requestHeaderMessage.getByte();
      if (type == Constants.JK_AJP13_CPING_REQUEST) {
        if (endpoint.isPaused()) {
          recycle(true);
          break;
        }
        cping=true;
        try {
          output.write(pongMessageArray);
        }
 catch (        IOException e) {
          setErrorState(ErrorState.CLOSE_NOW,e);
        }
        continue;
      }
 else       if (type != Constants.JK_AJP13_FORWARD_REQUEST) {
        if (log.isDebugEnabled()) {
          log.debug("Unexpected message: " + type);
        }
        setErrorState(ErrorState.CLOSE_NOW,null);
        break;
      }
      request.setStartTime(System.currentTimeMillis());
    }
 catch (    IOException e) {
      setErrorState(ErrorState.CLOSE_NOW,e);
      break;
    }
catch (    Throwable t) {
      ExceptionUtils.handleThrowable(t);
      log.debug(sm.getString("ajpprocessor.header.error"),t);
      response.setStatus(400);
      setErrorState(ErrorState.CLOSE_CLEAN,t);
      getAdapter().log(request,response,0);
    }
    if (!getErrorState().isError()) {
      rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
      try {
        prepareRequest();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.debug(sm.getString("ajpprocessor.request.prepare"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (!getErrorState().isError() && !cping && endpoint.isPaused()) {
      response.setStatus(503);
      setErrorState(ErrorState.CLOSE_CLEAN,null);
      getAdapter().log(request,response,0);
    }
    cping=false;
    if (!getErrorState().isError()) {
      try {
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        adapter.service(request,response);
      }
 catch (      InterruptedIOException e) {
        setErrorState(ErrorState.CLOSE_NOW,e);
      }
catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString("ajpprocessor.request.process"),t);
        response.setStatus(500);
        setErrorState(ErrorState.CLOSE_CLEAN,t);
        getAdapter().log(request,response,0);
      }
    }
    if (isAsync() && !getErrorState().isError()) {
      break;
    }
    if (!finished && getErrorState().isIoAllowed()) {
      try {
        finish();
      }
 catch (      Throwable t) {
        ExceptionUtils.handleThrowable(t);
        setErrorState(ErrorState.CLOSE_NOW,t);
      }
    }
    if (getErrorState().isError()) {
      response.setStatus(500);
    }
    request.updateCounters();
    rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
    recycle(false);
  }
  rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
  if (isAsync() && !getErrorState().isError() && !endpoint.isPaused()) {
    return SocketState.LONG;
  }
 else {
    input=null;
    output=null;
    return SocketState.CLOSED;
  }
}

ID 5567=========================================================================type: 1
Method:org.apache.el.util.ReflectionUtil#isCoercibleFrom(java.lang.Object, Class<?>)
Rmethod: org.apache.el.lang.ELSupport#coerceToType(java.lang.Object, Class<?>)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
private static boolean isCoercibleFrom(Object src,Class<?> target){
  try {
    ELSupport.coerceToType(src,target);
  }
 catch (  ELException e) {
    return false;
  }
  return true;
}

ID 5597=========================================================================type: 1
Method:org.apache.el.ValueExpressionImpl#isLiteralText()
Rmethod: org.apache.el.ValueExpressionImpl#getNode()
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public boolean isLiteralText(){
  try {
    return this.getNode() instanceof AstLiteralExpression;
  }
 catch (  ELException ele) {
    return false;
  }
}

ID 5666=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa1_0(long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa1_0(long active0){
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_0(0,active0);
    return 1;
  }
switch (curChar) {
case 123:
    if ((active0 & 0x4L) != 0L)     return jjStopAtPos(1,2);
 else     if ((active0 & 0x8L) != 0L)     return jjStopAtPos(1,3);
  break;
default :
break;
}
return jjStartNfa_0(0,active0);
}

ID 5667=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveNfa_0(int, int)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveNfa_0(int startState,int curPos){
  int startsAt=0;
  jjnewStateCnt=8;
  int i=1;
  jjstateSet[0]=startState;
  int kind=0x7fffffff;
  for (; ; ) {
    if (++jjround == 0x7fffffff)     ReInitRounds();
    if (curChar < 64) {
      long l=1L << curChar;
      do {
switch (jjstateSet[--i]) {
case 7:
          if ((0xffffffe7ffffffffL & l) != 0L) {
            if (kind > 1)             kind=1;
            jjCheckNAddStates(0,4);
          }
 else           if ((0x1800000000L & l) != 0L) {
            if (kind > 1)             kind=1;
            jjCheckNAdd(5);
          }
        if ((0xffffffe7ffffffffL & l) != 0L)         jjCheckNAddTwoStates(0,1);
      break;
case 0:
    if ((0xffffffe7ffffffffL & l) != 0L)     jjCheckNAddTwoStates(0,1);
  break;
case 2:
if ((0xffffffe7ffffffffL & l) == 0L) break;
if (kind > 1) kind=1;
jjCheckNAddStates(0,4);
break;
case 3:
if ((0xffffffe7ffffffffL & l) != 0L) jjCheckNAddTwoStates(3,4);
break;
case 4:
if ((0x1800000000L & l) != 0L) jjCheckNAdd(5);
break;
case 5:
if ((0xffffffe7ffffffffL & l) == 0L) break;
if (kind > 1) kind=1;
jjCheckNAddStates(5,8);
break;
case 6:
if ((0x1800000000L & l) == 0L) break;
if (kind > 1) kind=1;
jjCheckNAddStates(9,13);
break;
default :
break;
}
}
 while (i != startsAt);
}
 else if (curChar < 128) {
long l=1L << (curChar & 077);
do {
switch (jjstateSet[--i]) {
case 7:
if (kind > 1) kind=1;
jjCheckNAddStates(0,4);
if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddTwoStates(0,1);
 else if (curChar == 92) {
if (kind > 1) kind=1;
jjCheckNAddStates(14,17);
}
break;
case 0:
if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddTwoStates(0,1);
break;
case 1:
if (curChar != 92) break;
if (kind > 1) kind=1;
jjCheckNAddStates(14,17);
break;
case 2:
if (kind > 1) kind=1;
jjCheckNAddStates(0,4);
break;
case 3:
jjCheckNAddTwoStates(3,4);
break;
case 5:
if ((0xf7ffffffefffffffL & l) == 0L) break;
if (kind > 1) kind=1;
jjCheckNAddStates(5,8);
break;
default :
break;
}
}
 while (i != startsAt);
}
 else {
int hiByte=(int)(curChar >> 8);
int i1=hiByte >> 6;
long l1=1L << (hiByte & 077);
int i2=(curChar & 0xff) >> 6;
long l2=1L << (curChar & 077);
do {
switch (jjstateSet[--i]) {
case 7:
if (jjCanMove_0(hiByte,i1,i2,l1,l2)) jjCheckNAddTwoStates(0,1);
if (jjCanMove_0(hiByte,i1,i2,l1,l2)) {
if (kind > 1) kind=1;
jjCheckNAddStates(0,4);
}
break;
case 0:
if (jjCanMove_0(hiByte,i1,i2,l1,l2)) jjCheckNAddTwoStates(0,1);
break;
case 2:
if (!jjCanMove_0(hiByte,i1,i2,l1,l2)) break;
if (kind > 1) kind=1;
jjCheckNAddStates(0,4);
break;
case 3:
if (jjCanMove_0(hiByte,i1,i2,l1,l2)) jjCheckNAddTwoStates(3,4);
break;
case 5:
if (!jjCanMove_0(hiByte,i1,i2,l1,l2)) break;
if (kind > 1) kind=1;
jjCheckNAddStates(5,8);
break;
default :
break;
}
}
 while (i != startsAt);
}
if (kind != 0x7fffffff) {
jjmatchedKind=kind;
jjmatchedPos=curPos;
kind=0x7fffffff;
}
++curPos;
if ((i=jjnewStateCnt) == (startsAt=8 - (jjnewStateCnt=startsAt))) return curPos;
try {
curChar=input_stream.readChar();
}
 catch (java.io.IOException e) {
return curPos;
}
}
}

ID 5668=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa1_1(long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa1_1(long active0){
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(0,active0);
    return 1;
  }
switch (curChar) {
case 38:
    if ((active0 & 0x2000000000L) != 0L)     return jjStopAtPos(1,37);
  break;
case 61:
if ((active0 & 0x8000000L) != 0L) return jjStopAtPos(1,27);
 else if ((active0 & 0x20000000L) != 0L) return jjStopAtPos(1,29);
 else if ((active0 & 0x80000000L) != 0L) return jjStopAtPos(1,31);
 else if ((active0 & 0x200000000L) != 0L) return jjStopAtPos(1,33);
break;
case 97:
return jjMoveStringLiteralDfa2_1(active0,0x2000L);
case 101:
if ((active0 & 0x10000000L) != 0L) return jjStartNfaWithStates_1(1,28,30);
 else if ((active0 & 0x40000000L) != 0L) return jjStartNfaWithStates_1(1,30,30);
 else if ((active0 & 0x400000000L) != 0L) return jjStartNfaWithStates_1(1,34,30);
break;
case 105:
return jjMoveStringLiteralDfa2_1(active0,0x1000000000000L);
case 109:
return jjMoveStringLiteralDfa2_1(active0,0x20000000000L);
case 110:
return jjMoveStringLiteralDfa2_1(active0,0x44000000000L);
case 111:
return jjMoveStringLiteralDfa2_1(active0,0x4001000000000L);
case 113:
if ((active0 & 0x100000000L) != 0L) return jjStartNfaWithStates_1(1,32,30);
break;
case 114:
if ((active0 & 0x10000000000L) != 0L) return jjStartNfaWithStates_1(1,40,30);
return jjMoveStringLiteralDfa2_1(active0,0x1000L);
case 116:
if ((active0 & 0x1000000L) != 0L) return jjStartNfaWithStates_1(1,24,30);
 else if ((active0 & 0x4000000L) != 0L) return jjStartNfaWithStates_1(1,26,30);
break;
case 117:
return jjMoveStringLiteralDfa2_1(active0,0x4000L);
case 124:
if ((active0 & 0x8000000000L) != 0L) return jjStopAtPos(1,39);
break;
default :
break;
}
return jjStartNfa_1(0,active0);
}

ID 5669=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa2_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa2_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(0,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(1,active0);
    return 2;
  }
switch (curChar) {
case 100:
    if ((active0 & 0x4000000000L) != 0L)     return jjStartNfaWithStates_1(2,38,30);
 else     if ((active0 & 0x4000000000000L) != 0L)     return jjStartNfaWithStates_1(2,50,30);
  break;
case 108:
return jjMoveStringLiteralDfa3_1(active0,0x6000L);
case 112:
return jjMoveStringLiteralDfa3_1(active0,0x20000000000L);
case 115:
return jjMoveStringLiteralDfa3_1(active0,0x40000000000L);
case 116:
if ((active0 & 0x1000000000L) != 0L) return jjStartNfaWithStates_1(2,36,30);
break;
case 117:
return jjMoveStringLiteralDfa3_1(active0,0x1000L);
case 118:
if ((active0 & 0x1000000000000L) != 0L) return jjStartNfaWithStates_1(2,48,30);
break;
default :
break;
}
return jjStartNfa_1(1,active0);
}

ID 5670=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa3_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa3_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(1,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(2,active0);
    return 3;
  }
switch (curChar) {
case 101:
    if ((active0 & 0x1000L) != 0L)     return jjStartNfaWithStates_1(3,12,30);
  break;
case 108:
if ((active0 & 0x4000L) != 0L) return jjStartNfaWithStates_1(3,14,30);
break;
case 115:
return jjMoveStringLiteralDfa4_1(active0,0x2000L);
case 116:
return jjMoveStringLiteralDfa4_1(active0,0x60000000000L);
default :
break;
}
return jjStartNfa_1(2,active0);
}

ID 5671=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa4_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa4_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(2,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(3,active0);
    return 4;
  }
switch (curChar) {
case 97:
    return jjMoveStringLiteralDfa5_1(active0,0x40000000000L);
case 101:
  if ((active0 & 0x2000L) != 0L)   return jjStartNfaWithStates_1(4,13,30);
break;
case 121:
if ((active0 & 0x20000000000L) != 0L) return jjStartNfaWithStates_1(4,41,30);
break;
default :
break;
}
return jjStartNfa_1(3,active0);
}

ID 5672=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa5_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa5_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(3,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(4,active0);
    return 5;
  }
switch (curChar) {
case 110:
    return jjMoveStringLiteralDfa6_1(active0,0x40000000000L);
default :
  break;
}
return jjStartNfa_1(4,active0);
}

ID 5673=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa6_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa6_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(4,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(5,active0);
    return 6;
  }
switch (curChar) {
case 99:
    return jjMoveStringLiteralDfa7_1(active0,0x40000000000L);
default :
  break;
}
return jjStartNfa_1(5,active0);
}

ID 5674=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa7_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa7_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(5,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(6,active0);
    return 7;
  }
switch (curChar) {
case 101:
    return jjMoveStringLiteralDfa8_1(active0,0x40000000000L);
default :
  break;
}
return jjStartNfa_1(6,active0);
}

ID 5675=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa8_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa8_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(6,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(7,active0);
    return 8;
  }
switch (curChar) {
case 111:
    return jjMoveStringLiteralDfa9_1(active0,0x40000000000L);
default :
  break;
}
return jjStartNfa_1(7,active0);
}

ID 5676=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveStringLiteralDfa9_1(long, long)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveStringLiteralDfa9_1(long old0,long active0){
  if (((active0&=old0)) == 0L)   return jjStartNfa_1(7,old0);
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    jjStopStringLiteralDfa_1(8,active0);
    return 9;
  }
switch (curChar) {
case 102:
    if ((active0 & 0x40000000000L) != 0L)     return jjStartNfaWithStates_1(9,42,30);
  break;
default :
break;
}
return jjStartNfa_1(8,active0);
}

ID 5677=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjStartNfaWithStates_1(int, int, int)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjStartNfaWithStates_1(int pos,int kind,int state){
  jjmatchedKind=kind;
  jjmatchedPos=pos;
  try {
    curChar=input_stream.readChar();
  }
 catch (  java.io.IOException e) {
    return pos + 1;
  }
  return jjMoveNfa_1(state,pos + 1);
}

ID 5678=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#jjMoveNfa_1(int, int)
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private int jjMoveNfa_1(int startState,int curPos){
  int startsAt=0;
  jjnewStateCnt=30;
  int i=1;
  jjstateSet[0]=startState;
  int kind=0x7fffffff;
  for (; ; ) {
    if (++jjround == 0x7fffffff)     ReInitRounds();
    if (curChar < 64) {
      long l=1L << curChar;
      do {
switch (jjstateSet[--i]) {
case 0:
          if ((0x3ff000000000000L & l) != 0L) {
            if (kind > 8)             kind=8;
            jjCheckNAddStates(18,22);
          }
 else           if ((0x1800000000L & l) != 0L) {
            if (kind > 51)             kind=51;
            jjCheckNAddTwoStates(28,29);
          }
 else           if (curChar == 39)           jjCheckNAddStates(23,25);
 else           if (curChar == 34)           jjCheckNAddStates(26,28);
 else           if (curChar == 46)           jjCheckNAdd(1);
        break;
case 30:
      if ((0x3ff001000000000L & l) != 0L) {
        if (kind > 52)         kind=52;
        jjCheckNAdd(29);
      }
    if ((0x3ff001000000000L & l) != 0L) {
      if (kind > 51)       kind=51;
      jjCheckNAdd(28);
    }
  break;
case 1:
if ((0x3ff000000000000L & l) == 0L) break;
if (kind > 9) kind=9;
jjCheckNAddTwoStates(1,2);
break;
case 3:
if ((0x280000000000L & l) != 0L) jjCheckNAdd(4);
break;
case 4:
if ((0x3ff000000000000L & l) == 0L) break;
if (kind > 9) kind=9;
jjCheckNAdd(4);
break;
case 5:
if (curChar == 34) jjCheckNAddStates(26,28);
break;
case 6:
if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26,28);
break;
case 8:
if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26,28);
break;
case 9:
if (curChar == 34 && kind > 11) kind=11;
break;
case 10:
if (curChar == 39) jjCheckNAddStates(23,25);
break;
case 11:
if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23,25);
break;
case 13:
if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23,25);
break;
case 14:
if (curChar == 39 && kind > 11) kind=11;
break;
case 15:
if ((0x3ff000000000000L & l) == 0L) break;
if (kind > 8) kind=8;
jjCheckNAddStates(18,22);
break;
case 16:
if ((0x3ff000000000000L & l) == 0L) break;
if (kind > 8) kind=8;
jjCheckNAdd(16);
break;
case 17:
if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17,18);
break;
case 18:
if (curChar != 46) break;
if (kind > 9) kind=9;
jjCheckNAddTwoStates(19,20);
break;
case 19:
if ((0x3ff000000000000L & l) == 0L) break;
if (kind > 9) kind=9;
jjCheckNAddTwoStates(19,20);
break;
case 21:
if ((0x280000000000L & l) != 0L) jjCheckNAdd(22);
break;
case 22:
if ((0x3ff000000000000L & l) == 0L) break;
if (kind > 9) kind=9;
jjCheckNAdd(22);
break;
case 23:
if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23,24);
break;
case 25:
if ((0x280000000000L & l) != 0L) jjCheckNAdd(26);
break;
case 26:
if ((0x3ff000000000000L & l) == 0L) break;
if (kind > 9) kind=9;
jjCheckNAdd(26);
break;
case 27:
if ((0x1800000000L & l) == 0L) break;
if (kind > 51) kind=51;
jjCheckNAddTwoStates(28,29);
break;
case 28:
if ((0x3ff001000000000L & l) == 0L) break;
if (kind > 51) kind=51;
jjCheckNAdd(28);
break;
case 29:
if ((0x3ff001000000000L & l) == 0L) break;
if (kind > 52) kind=52;
jjCheckNAdd(29);
break;
default :
break;
}
}
 while (i != startsAt);
}
 else if (curChar < 128) {
long l=1L << (curChar & 077);
do {
switch (jjstateSet[--i]) {
case 0:
if ((0x7fffffe87fffffeL & l) == 0L) break;
if (kind > 51) kind=51;
jjCheckNAddTwoStates(28,29);
break;
case 30:
if ((0x7fffffe87fffffeL & l) != 0L) {
if (kind > 52) kind=52;
jjCheckNAdd(29);
}
if ((0x7fffffe87fffffeL & l) != 0L) {
if (kind > 51) kind=51;
jjCheckNAdd(28);
}
break;
case 2:
if ((0x2000000020L & l) != 0L) jjAddStates(29,30);
break;
case 6:
if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26,28);
break;
case 7:
if (curChar == 92) jjstateSet[jjnewStateCnt++]=8;
break;
case 8:
if (curChar == 92) jjCheckNAddStates(26,28);
break;
case 11:
if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23,25);
break;
case 12:
if (curChar == 92) jjstateSet[jjnewStateCnt++]=13;
break;
case 13:
if (curChar == 92) jjCheckNAddStates(23,25);
break;
case 20:
if ((0x2000000020L & l) != 0L) jjAddStates(31,32);
break;
case 24:
if ((0x2000000020L & l) != 0L) jjAddStates(33,34);
break;
case 28:
if ((0x7fffffe87fffffeL & l) == 0L) break;
if (kind > 51) kind=51;
jjCheckNAdd(28);
break;
case 29:
if ((0x7fffffe87fffffeL & l) == 0L) break;
if (kind > 52) kind=52;
jjCheckNAdd(29);
break;
default :
break;
}
}
 while (i != startsAt);
}
 else {
int hiByte=(int)(curChar >> 8);
int i1=hiByte >> 6;
long l1=1L << (hiByte & 077);
int i2=(curChar & 0xff) >> 6;
long l2=1L << (curChar & 077);
do {
switch (jjstateSet[--i]) {
case 0:
if (!jjCanMove_1(hiByte,i1,i2,l1,l2)) break;
if (kind > 51) kind=51;
jjCheckNAddTwoStates(28,29);
break;
case 30:
if (jjCanMove_1(hiByte,i1,i2,l1,l2)) {
if (kind > 51) kind=51;
jjCheckNAdd(28);
}
if (jjCanMove_1(hiByte,i1,i2,l1,l2)) {
if (kind > 52) kind=52;
jjCheckNAdd(29);
}
break;
case 6:
if (jjCanMove_0(hiByte,i1,i2,l1,l2)) jjAddStates(26,28);
break;
case 11:
if (jjCanMove_0(hiByte,i1,i2,l1,l2)) jjAddStates(23,25);
break;
case 28:
if (!jjCanMove_1(hiByte,i1,i2,l1,l2)) break;
if (kind > 51) kind=51;
jjCheckNAdd(28);
break;
case 29:
if (!jjCanMove_1(hiByte,i1,i2,l1,l2)) break;
if (kind > 52) kind=52;
jjCheckNAdd(29);
break;
default :
break;
}
}
 while (i != startsAt);
}
if (kind != 0x7fffffff) {
jjmatchedKind=kind;
jjmatchedPos=curPos;
kind=0x7fffffff;
}
++curPos;
if ((i=jjnewStateCnt) == (startsAt=30 - (jjnewStateCnt=startsAt))) return curPos;
try {
curChar=input_stream.readChar();
}
 catch (java.io.IOException e) {
return curPos;
}
}
}

ID 5679=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#getNextToken()
Rmethod: org.apache.el.parser.SimpleCharStream#BeginToken()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Get the next Token. 
 */
public Token getNextToken(){
  Token matchedToken;
  int curPos=0;
  EOFLoop:   for (; ; ) {
    try {
      curChar=input_stream.BeginToken();
    }
 catch (    java.io.IOException e) {
      jjmatchedKind=0;
      matchedToken=jjFillToken();
      return matchedToken;
    }
switch (curLexState) {
case 0:
      jjmatchedKind=0x7fffffff;
    jjmatchedPos=0;
  curPos=jjMoveStringLiteralDfa0_0();
break;
case 1:
try {
input_stream.backup(0);
while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L) curChar=input_stream.BeginToken();
}
 catch (java.io.IOException e1) {
continue EOFLoop;
}
jjmatchedKind=0x7fffffff;
jjmatchedPos=0;
curPos=jjMoveStringLiteralDfa0_1();
if (jjmatchedPos == 0 && jjmatchedKind > 56) {
jjmatchedKind=56;
}
break;
}
if (jjmatchedKind != 0x7fffffff) {
if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1);
if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
matchedToken=jjFillToken();
if (jjnewLexState[jjmatchedKind] != -1) curLexState=jjnewLexState[jjmatchedKind];
return matchedToken;
}
 else {
if (jjnewLexState[jjmatchedKind] != -1) curLexState=jjnewLexState[jjmatchedKind];
continue EOFLoop;
}
}
int error_line=input_stream.getEndLine();
int error_column=input_stream.getEndColumn();
String error_after=null;
boolean EOFSeen=false;
try {
input_stream.readChar();
input_stream.backup(1);
}
 catch (java.io.IOException e1) {
EOFSeen=true;
error_after=curPos <= 1 ? "" : input_stream.GetImage();
if (curChar == '\n' || curChar == '\r') {
error_line++;
error_column=0;
}
 else error_column++;
}
if (!EOFSeen) {
input_stream.backup(1);
error_after=curPos <= 1 ? "" : input_stream.GetImage();
}
throw new TokenMgrError(EOFSeen,curLexState,error_line,error_column,error_after,curChar,TokenMgrError.LEXICAL_ERROR);
}
}

ID 5680=========================================================================type: 1
Method:org.apache.el.parser.ELParserTokenManager#getNextToken()
Rmethod: org.apache.el.parser.SimpleCharStream#readChar()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Get the next Token. 
 */
public Token getNextToken(){
  Token matchedToken;
  int curPos=0;
  EOFLoop:   for (; ; ) {
    try {
      curChar=input_stream.BeginToken();
    }
 catch (    java.io.IOException e) {
      jjmatchedKind=0;
      matchedToken=jjFillToken();
      return matchedToken;
    }
switch (curLexState) {
case 0:
      jjmatchedKind=0x7fffffff;
    jjmatchedPos=0;
  curPos=jjMoveStringLiteralDfa0_0();
break;
case 1:
try {
input_stream.backup(0);
while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L) curChar=input_stream.BeginToken();
}
 catch (java.io.IOException e1) {
continue EOFLoop;
}
jjmatchedKind=0x7fffffff;
jjmatchedPos=0;
curPos=jjMoveStringLiteralDfa0_1();
if (jjmatchedPos == 0 && jjmatchedKind > 56) {
jjmatchedKind=56;
}
break;
}
if (jjmatchedKind != 0x7fffffff) {
if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1);
if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
matchedToken=jjFillToken();
if (jjnewLexState[jjmatchedKind] != -1) curLexState=jjnewLexState[jjmatchedKind];
return matchedToken;
}
 else {
if (jjnewLexState[jjmatchedKind] != -1) curLexState=jjnewLexState[jjmatchedKind];
continue EOFLoop;
}
}
int error_line=input_stream.getEndLine();
int error_column=input_stream.getEndColumn();
String error_after=null;
boolean EOFSeen=false;
try {
input_stream.readChar();
input_stream.backup(1);
}
 catch (java.io.IOException e1) {
EOFSeen=true;
error_after=curPos <= 1 ? "" : input_stream.GetImage();
if (curChar == '\n' || curChar == '\r') {
error_line++;
error_column=0;
}
 else error_column++;
}
if (!EOFSeen) {
input_stream.backup(1);
error_after=curPos <= 1 ? "" : input_stream.GetImage();
}
throw new TokenMgrError(EOFSeen,curLexState,error_line,error_column,error_after,curChar,TokenMgrError.LEXICAL_ERROR);
}
}

ID 5683=========================================================================type: 1
Method:org.apache.el.parser.AstFunction#getValue(org.apache.el.lang.EvaluationContext)
Rmethod: org.apache.el.parser.Node#getValue(org.apache.el.lang.EvaluationContext)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public Object getValue(EvaluationContext ctx) throws ELException {
  FunctionMapper fnMapper=ctx.getFunctionMapper();
  if (fnMapper == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.null"));
  }
  Method m=fnMapper.resolveFunction(this.prefix,this.localName);
  if (m == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.method",this.getOutputName()));
  }
  Class<?>[] paramTypes=m.getParameterTypes();
  Object[] params=null;
  Object result=null;
  int numParams=this.jjtGetNumChildren();
  if (numParams > 0) {
    params=new Object[numParams];
    try {
      for (int i=0; i < numParams; i++) {
        params[i]=this.children[i].getValue(ctx);
        params[i]=coerceToType(params[i],paramTypes[i]);
      }
    }
 catch (    ELException ele) {
      throw new ELException(MessageFactory.get("error.function",this.getOutputName()),ele);
    }
  }
  try {
    result=m.invoke(null,params);
  }
 catch (  IllegalAccessException iae) {
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),iae);
  }
catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),cause);
  }
  return result;
}

ID 5684=========================================================================type: 1
Method:org.apache.el.parser.AstFunction#getValue(org.apache.el.lang.EvaluationContext)
Rmethod: org.apache.el.lang.ELSupport#coerceToType(java.lang.Object, Class<?>)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public Object getValue(EvaluationContext ctx) throws ELException {
  FunctionMapper fnMapper=ctx.getFunctionMapper();
  if (fnMapper == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.null"));
  }
  Method m=fnMapper.resolveFunction(this.prefix,this.localName);
  if (m == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.method",this.getOutputName()));
  }
  Class<?>[] paramTypes=m.getParameterTypes();
  Object[] params=null;
  Object result=null;
  int numParams=this.jjtGetNumChildren();
  if (numParams > 0) {
    params=new Object[numParams];
    try {
      for (int i=0; i < numParams; i++) {
        params[i]=this.children[i].getValue(ctx);
        params[i]=coerceToType(params[i],paramTypes[i]);
      }
    }
 catch (    ELException ele) {
      throw new ELException(MessageFactory.get("error.function",this.getOutputName()),ele);
    }
  }
  try {
    result=m.invoke(null,params);
  }
 catch (  IllegalAccessException iae) {
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),iae);
  }
catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),cause);
  }
  return result;
}

ID 5685=========================================================================type: 1
Method:org.apache.el.parser.AstFunction#getValue(org.apache.el.lang.EvaluationContext)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public Object getValue(EvaluationContext ctx) throws ELException {
  FunctionMapper fnMapper=ctx.getFunctionMapper();
  if (fnMapper == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.null"));
  }
  Method m=fnMapper.resolveFunction(this.prefix,this.localName);
  if (m == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.method",this.getOutputName()));
  }
  Class<?>[] paramTypes=m.getParameterTypes();
  Object[] params=null;
  Object result=null;
  int numParams=this.jjtGetNumChildren();
  if (numParams > 0) {
    params=new Object[numParams];
    try {
      for (int i=0; i < numParams; i++) {
        params[i]=this.children[i].getValue(ctx);
        params[i]=coerceToType(params[i],paramTypes[i]);
      }
    }
 catch (    ELException ele) {
      throw new ELException(MessageFactory.get("error.function",this.getOutputName()),ele);
    }
  }
  try {
    result=m.invoke(null,params);
  }
 catch (  IllegalAccessException iae) {
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),iae);
  }
catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),cause);
  }
  return result;
}

ID 5687=========================================================================type: 1
Method:org.apache.el.parser.AstFunction#getValue(org.apache.el.lang.EvaluationContext)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public Object getValue(EvaluationContext ctx) throws ELException {
  FunctionMapper fnMapper=ctx.getFunctionMapper();
  if (fnMapper == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.null"));
  }
  Method m=fnMapper.resolveFunction(this.prefix,this.localName);
  if (m == null) {
    throw new ELException(MessageFactory.get("error.fnMapper.method",this.getOutputName()));
  }
  Class<?>[] paramTypes=m.getParameterTypes();
  Object[] params=null;
  Object result=null;
  int numParams=this.jjtGetNumChildren();
  if (numParams > 0) {
    params=new Object[numParams];
    try {
      for (int i=0; i < numParams; i++) {
        params[i]=this.children[i].getValue(ctx);
        params[i]=coerceToType(params[i],paramTypes[i]);
      }
    }
 catch (    ELException ele) {
      throw new ELException(MessageFactory.get("error.function",this.getOutputName()),ele);
    }
  }
  try {
    result=m.invoke(null,params);
  }
 catch (  IllegalAccessException iae) {
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),iae);
  }
catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(MessageFactory.get("error.function",this.getOutputName()),cause);
  }
  return result;
}

ID 5696=========================================================================type: 1
Method:org.apache.el.parser.ELParser#parse(java.lang.String)
Rmethod: org.apache.el.parser.ELParser#CompositeExpression()
parentException: 
thrown: ParseException
exception comment: /** 
 * Signals that an error has been reached unexpectedly while parsing.
 * @see java.lang.Exception
 * @see java.text.Format
 * @see java.text.FieldPosition
 * @author      Mark Davis
 */

block: 
public static Node parse(String ref) throws ELException {
  try {
    return (new ELParser(new StringReader(ref))).CompositeExpression();
  }
 catch (  ParseException pe) {
    throw new ELException(pe.getMessage());
  }
}

ID 5768=========================================================================type: 1
Method:org.apache.el.parser.ELParser#ELParser(java.io.InputStream, java.lang.String)
Rmethod: org.apache.el.parser.SimpleCharStream#SimpleCharStream(java.io.InputStream, java.lang.String, int, int)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Constructor with InputStream and supplied encoding 
 */
public ELParser(java.io.InputStream stream,String encoding){
  try {
    jj_input_stream=new SimpleCharStream(stream,encoding,1,1);
  }
 catch (  java.io.UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
  token_source=new ELParserTokenManager(jj_input_stream);
  token=new Token();
  jj_ntk=-1;
  jj_gen=0;
  for (int i=0; i < 36; i++)   jj_la1[i]=-1;
  for (int i=0; i < jj_2_rtns.length; i++)   jj_2_rtns[i]=new JJCalls();
}

ID 5769=========================================================================type: 1
Method:org.apache.el.parser.ELParser#ReInit(java.io.InputStream, java.lang.String)
Rmethod: org.apache.el.parser.SimpleCharStream#ReInit(java.io.InputStream, java.lang.String, int, int)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Reinitialise. 
 */
public void ReInit(java.io.InputStream stream,String encoding){
  try {
    jj_input_stream.ReInit(stream,encoding,1,1);
  }
 catch (  java.io.UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
  token_source.ReInit(jj_input_stream);
  token=new Token();
  jj_ntk=-1;
  jjtree.reset();
  jj_gen=0;
  for (int i=0; i < 36; i++)   jj_la1[i]=-1;
  for (int i=0; i < jj_2_rtns.length; i++)   jj_2_rtns[i]=new JJCalls();
}

ID 5802=========================================================================type: 1
Method:org.apache.el.parser.AstValue#invoke(org.apache.el.lang.EvaluationContext, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public Object invoke(EvaluationContext ctx,@SuppressWarnings("rawtypes") Class[] paramTypes,Object[] paramValues) throws ELException {
  Target t=getTarget(ctx);
  Method m=null;
  Object[] values=null;
  Class<?>[] types=null;
  if (isParametersProvided()) {
    values=((AstMethodParameters)this.jjtGetChild(this.jjtGetNumChildren() - 1)).getParameters(ctx);
    types=getTypesFromValues(values);
  }
 else {
    values=paramValues;
    types=paramTypes;
  }
  m=ReflectionUtil.getMethod(t.base,t.property,types,values);
  values=convertArgs(values,m);
  Object result=null;
  try {
    result=m.invoke(t.base,values);
  }
 catch (  IllegalAccessException iae) {
    throw new ELException(iae);
  }
catch (  IllegalArgumentException iae) {
    throw new ELException(iae);
  }
catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(cause);
  }
  return result;
}

ID 5803=========================================================================type: 1
Method:org.apache.el.parser.AstValue#invoke(org.apache.el.lang.EvaluationContext, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
@Override public Object invoke(EvaluationContext ctx,@SuppressWarnings("rawtypes") Class[] paramTypes,Object[] paramValues) throws ELException {
  Target t=getTarget(ctx);
  Method m=null;
  Object[] values=null;
  Class<?>[] types=null;
  if (isParametersProvided()) {
    values=((AstMethodParameters)this.jjtGetChild(this.jjtGetNumChildren() - 1)).getParameters(ctx);
    types=getTypesFromValues(values);
  }
 else {
    values=paramValues;
    types=paramTypes;
  }
  m=ReflectionUtil.getMethod(t.base,t.property,types,values);
  values=convertArgs(values,m);
  Object result=null;
  try {
    result=m.invoke(t.base,values);
  }
 catch (  IllegalAccessException iae) {
    throw new ELException(iae);
  }
catch (  IllegalArgumentException iae) {
    throw new ELException(iae);
  }
catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(cause);
  }
  return result;
}

ID 5804=========================================================================type: 1
Method:org.apache.el.parser.AstValue#invoke(org.apache.el.lang.EvaluationContext, Class#RAW[], java.lang.Object[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public Object invoke(EvaluationContext ctx,@SuppressWarnings("rawtypes") Class[] paramTypes,Object[] paramValues) throws ELException {
  Target t=getTarget(ctx);
  Method m=null;
  Object[] values=null;
  Class<?>[] types=null;
  if (isParametersProvided()) {
    values=((AstMethodParameters)this.jjtGetChild(this.jjtGetNumChildren() - 1)).getParameters(ctx);
    types=getTypesFromValues(values);
  }
 else {
    values=paramValues;
    types=paramTypes;
  }
  m=ReflectionUtil.getMethod(t.base,t.property,types,values);
  values=convertArgs(values,m);
  Object result=null;
  try {
    result=m.invoke(t.base,values);
  }
 catch (  IllegalAccessException iae) {
    throw new ELException(iae);
  }
catch (  IllegalArgumentException iae) {
    throw new ELException(iae);
  }
catch (  InvocationTargetException ite) {
    Throwable cause=ite.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(cause);
  }
  return result;
}

ID 5810=========================================================================type: 1
Method:org.apache.el.parser.SimpleCharStream#FillBuff()
Rmethod: java.io.Reader#read(char[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void FillBuff() throws java.io.IOException {
  if (maxNextCharInd == available) {
    if (available == bufsize) {
      if (tokenBegin > 2048) {
        bufpos=maxNextCharInd=0;
        available=tokenBegin;
      }
 else       if (tokenBegin < 0)       bufpos=maxNextCharInd=0;
 else       ExpandBuff(false);
    }
 else     if (available > tokenBegin)     available=bufsize;
 else     if ((tokenBegin - available) < 2048)     ExpandBuff(true);
 else     available=tokenBegin;
  }
  int i;
  try {
    if ((i=inputStream.read(buffer,maxNextCharInd,available - maxNextCharInd)) == -1) {
      inputStream.close();
      throw new java.io.IOException();
    }
 else     maxNextCharInd+=i;
    return;
  }
 catch (  java.io.IOException e) {
    --bufpos;
    backup(0);
    if (tokenBegin == -1)     tokenBegin=bufpos;
    throw e;
  }
}

ID 5811=========================================================================type: 1
Method:org.apache.el.parser.SimpleCharStream#FillBuff()
Rmethod: java.io.Reader#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void FillBuff() throws java.io.IOException {
  if (maxNextCharInd == available) {
    if (available == bufsize) {
      if (tokenBegin > 2048) {
        bufpos=maxNextCharInd=0;
        available=tokenBegin;
      }
 else       if (tokenBegin < 0)       bufpos=maxNextCharInd=0;
 else       ExpandBuff(false);
    }
 else     if (available > tokenBegin)     available=bufsize;
 else     if ((tokenBegin - available) < 2048)     ExpandBuff(true);
 else     available=tokenBegin;
  }
  int i;
  try {
    if ((i=inputStream.read(buffer,maxNextCharInd,available - maxNextCharInd)) == -1) {
      inputStream.close();
      throw new java.io.IOException();
    }
 else     maxNextCharInd+=i;
    return;
  }
 catch (  java.io.IOException e) {
    --bufpos;
    backup(0);
    if (tokenBegin == -1)     tokenBegin=bufpos;
    throw e;
  }
}

ID 5831=========================================================================type: 1
Method:org.apache.el.lang.ExpressionBuilder#prepare(org.apache.el.parser.Node)
Rmethod: org.apache.el.parser.Node#accept(org.apache.el.parser.NodeVisitor)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
private void prepare(Node node) throws ELException {
  try {
    node.accept(this);
  }
 catch (  Exception e) {
    if (e instanceof ELException) {
      throw (ELException)e;
    }
 else {
      throw (new ELException(e));
    }
  }
  if (this.fnMapper instanceof FunctionMapperFactory) {
    this.fnMapper=((FunctionMapperFactory)this.fnMapper).create();
  }
  if (this.varMapper instanceof VariableMapperFactory) {
    this.varMapper=((VariableMapperFactory)this.varMapper).create();
  }
}

ID 5854=========================================================================type: 1
Method:org.apache.el.lang.ELSupport#coerceToNumber(java.lang.String, Class<?>)
Rmethod: java.lang.Long#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
protected static final Number coerceToNumber(final String val,final Class<?> type) throws ELException {
  if (Long.TYPE == type || Long.class.equals(type)) {
    try {
      return Long.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Integer.TYPE == type || Integer.class.equals(type)) {
    try {
      return Integer.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Double.TYPE == type || Double.class.equals(type)) {
    try {
      return Double.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigInteger.class.equals(type)) {
    try {
      return new BigInteger(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigDecimal.class.equals(type)) {
    try {
      return new BigDecimal(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Byte.TYPE == type || Byte.class.equals(type)) {
    try {
      return Byte.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Short.TYPE == type || Short.class.equals(type)) {
    try {
      return Short.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Float.TYPE == type || Float.class.equals(type)) {
    try {
      return Float.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
}

ID 5855=========================================================================type: 1
Method:org.apache.el.lang.ELSupport#coerceToNumber(java.lang.String, Class<?>)
Rmethod: java.lang.Integer#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
protected static final Number coerceToNumber(final String val,final Class<?> type) throws ELException {
  if (Long.TYPE == type || Long.class.equals(type)) {
    try {
      return Long.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Integer.TYPE == type || Integer.class.equals(type)) {
    try {
      return Integer.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Double.TYPE == type || Double.class.equals(type)) {
    try {
      return Double.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigInteger.class.equals(type)) {
    try {
      return new BigInteger(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigDecimal.class.equals(type)) {
    try {
      return new BigDecimal(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Byte.TYPE == type || Byte.class.equals(type)) {
    try {
      return Byte.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Short.TYPE == type || Short.class.equals(type)) {
    try {
      return Short.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Float.TYPE == type || Float.class.equals(type)) {
    try {
      return Float.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
}

ID 5856=========================================================================type: 1
Method:org.apache.el.lang.ELSupport#coerceToNumber(java.lang.String, Class<?>)
Rmethod: java.lang.Double#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
protected static final Number coerceToNumber(final String val,final Class<?> type) throws ELException {
  if (Long.TYPE == type || Long.class.equals(type)) {
    try {
      return Long.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Integer.TYPE == type || Integer.class.equals(type)) {
    try {
      return Integer.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Double.TYPE == type || Double.class.equals(type)) {
    try {
      return Double.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigInteger.class.equals(type)) {
    try {
      return new BigInteger(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigDecimal.class.equals(type)) {
    try {
      return new BigDecimal(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Byte.TYPE == type || Byte.class.equals(type)) {
    try {
      return Byte.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Short.TYPE == type || Short.class.equals(type)) {
    try {
      return Short.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Float.TYPE == type || Float.class.equals(type)) {
    try {
      return Float.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
}

ID 5857=========================================================================type: 1
Method:org.apache.el.lang.ELSupport#coerceToNumber(java.lang.String, Class<?>)
Rmethod: java.lang.Byte#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
protected static final Number coerceToNumber(final String val,final Class<?> type) throws ELException {
  if (Long.TYPE == type || Long.class.equals(type)) {
    try {
      return Long.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Integer.TYPE == type || Integer.class.equals(type)) {
    try {
      return Integer.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Double.TYPE == type || Double.class.equals(type)) {
    try {
      return Double.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigInteger.class.equals(type)) {
    try {
      return new BigInteger(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigDecimal.class.equals(type)) {
    try {
      return new BigDecimal(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Byte.TYPE == type || Byte.class.equals(type)) {
    try {
      return Byte.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Short.TYPE == type || Short.class.equals(type)) {
    try {
      return Short.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Float.TYPE == type || Float.class.equals(type)) {
    try {
      return Float.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
}

ID 5858=========================================================================type: 1
Method:org.apache.el.lang.ELSupport#coerceToNumber(java.lang.String, Class<?>)
Rmethod: java.lang.Short#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
protected static final Number coerceToNumber(final String val,final Class<?> type) throws ELException {
  if (Long.TYPE == type || Long.class.equals(type)) {
    try {
      return Long.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Integer.TYPE == type || Integer.class.equals(type)) {
    try {
      return Integer.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Double.TYPE == type || Double.class.equals(type)) {
    try {
      return Double.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigInteger.class.equals(type)) {
    try {
      return new BigInteger(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigDecimal.class.equals(type)) {
    try {
      return new BigDecimal(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Byte.TYPE == type || Byte.class.equals(type)) {
    try {
      return Byte.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Short.TYPE == type || Short.class.equals(type)) {
    try {
      return Short.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Float.TYPE == type || Float.class.equals(type)) {
    try {
      return Float.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
}

ID 5859=========================================================================type: 1
Method:org.apache.el.lang.ELSupport#coerceToNumber(java.lang.String, Class<?>)
Rmethod: java.lang.Float#valueOf(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
protected static final Number coerceToNumber(final String val,final Class<?> type) throws ELException {
  if (Long.TYPE == type || Long.class.equals(type)) {
    try {
      return Long.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Integer.TYPE == type || Integer.class.equals(type)) {
    try {
      return Integer.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Double.TYPE == type || Double.class.equals(type)) {
    try {
      return Double.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigInteger.class.equals(type)) {
    try {
      return new BigInteger(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (BigDecimal.class.equals(type)) {
    try {
      return new BigDecimal(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Byte.TYPE == type || Byte.class.equals(type)) {
    try {
      return Byte.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Short.TYPE == type || Short.class.equals(type)) {
    try {
      return Short.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  if (Float.TYPE == type || Float.class.equals(type)) {
    try {
      return Float.valueOf(val);
    }
 catch (    NumberFormatException nfe) {
      throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
    }
  }
  throw new ELException(MessageFactory.get("error.convert",val,String.class,type));
}

ID 5863=========================================================================type: 1
Method:org.apache.el.lang.ELSupport#coerceToType(java.lang.Object, Class<?>)
Rmethod: java.beans.PropertyEditor#setAsText(java.lang.String)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public static final Object coerceToType(final Object obj,final Class<?> type) throws ELException {
  if (type == null || Object.class.equals(type) || (obj != null && type.isAssignableFrom(obj.getClass()))) {
    return obj;
  }
  if (String.class.equals(type)) {
    return coerceToString(obj);
  }
  if (ELArithmetic.isNumberType(type)) {
    return coerceToNumber(obj,type);
  }
  if (Character.class.equals(type) || Character.TYPE == type) {
    return coerceToCharacter(obj);
  }
  if (Boolean.class.equals(type) || Boolean.TYPE == type) {
    return coerceToBoolean(obj);
  }
  if (type.isEnum()) {
    return coerceToEnum(obj,type);
  }
  if (obj == null)   return null;
  if (obj instanceof String) {
    PropertyEditor editor=PropertyEditorManager.findEditor(type);
    if (editor == null) {
      if ("".equals(obj)) {
        return null;
      }
      throw new ELException(MessageFactory.get("error.convert",obj,obj.getClass(),type));
    }
 else {
      try {
        editor.setAsText((String)obj);
        return editor.getValue();
      }
 catch (      RuntimeException e) {
        if ("".equals(obj)) {
          return null;
        }
        throw new ELException(MessageFactory.get("error.convert",obj,obj.getClass(),type),e);
      }
    }
  }
  throw new ELException(MessageFactory.get("error.convert",obj,obj.getClass(),type));
}

ID 5922=========================================================================type: 1
Method:org.apache.naming.NamingContext#lookup(javax.naming.Name, boolean)
Rmethod: javax.naming.spi.NamingManager#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
/** 
 * Retrieves the named object.
 * @param name the name of the object to look up
 * @param resolveLinks If true, the links will be resolved
 * @return the object bound to name
 * @exception NamingException if a naming exception is encountered
 */
protected Object lookup(Name name,boolean resolveLinks) throws NamingException {
  while ((!name.isEmpty()) && (name.get(0).length() == 0))   name=name.getSuffix(1);
  if (name.isEmpty()) {
    return new NamingContext(env,this.name,bindings);
  }
  NamingEntry entry=bindings.get(name.get(0));
  if (entry == null) {
    throw new NameNotFoundException(sm.getString("namingContext.nameNotBound",name,name.get(0)));
  }
  if (name.size() > 1) {
    if (entry.type != NamingEntry.CONTEXT) {
      throw new NamingException(sm.getString("namingContext.contextExpected"));
    }
    return ((Context)entry.value).lookup(name.getSuffix(1));
  }
 else {
    if ((resolveLinks) && (entry.type == NamingEntry.LINK_REF)) {
      String link=((LinkRef)entry.value).getLinkName();
      if (link.startsWith(".")) {
        return lookup(link.substring(1));
      }
 else {
        return (new InitialContext(env)).lookup(link);
      }
    }
 else     if (entry.type == NamingEntry.REFERENCE) {
      try {
        Object obj=NamingManager.getObjectInstance(entry.value,name,this,env);
        if (entry.value instanceof ResourceRef) {
          boolean singleton=Boolean.parseBoolean((String)((ResourceRef)entry.value).get("singleton").getContent());
          if (singleton) {
            entry.type=NamingEntry.ENTRY;
            entry.value=obj;
          }
        }
        return obj;
      }
 catch (      NamingException e) {
        throw e;
      }
catch (      Exception e) {
        log.warn(sm.getString("namingContext.failResolvingReference"),e);
        throw new NamingException(e.getMessage());
      }
    }
 else {
      return entry.value;
    }
  }
}

ID 6034=========================================================================type: 1
Method:org.apache.naming.resources.ProxyDirContext#lookupCache(java.lang.String)
Rmethod: org.apache.naming.resources.ProxyDirContext#parseName(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Retrieves the named object as a cache entry, without any exception.
 * @param name the name of the object to look up
 * @return the cache entry bound to name
 */
public CacheEntry lookupCache(String name){
  CacheEntry entry=cacheLookup(name);
  if (entry == null) {
    entry=new CacheEntry();
    entry.name=name;
    try {
      Object object=dirContext.lookup(parseName(name));
      if (object instanceof InputStream) {
        entry.resource=new Resource((InputStream)object);
      }
 else       if (object instanceof DirContext) {
        entry.context=(DirContext)object;
      }
 else       if (object instanceof Resource) {
        entry.resource=(Resource)object;
      }
 else {
        entry.resource=new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset())));
      }
      Attributes attributes=dirContext.getAttributes(parseName(name));
      if (!(attributes instanceof ResourceAttributes)) {
        attributes=new ResourceAttributes(attributes);
      }
      entry.attributes=(ResourceAttributes)attributes;
    }
 catch (    NamingException e) {
      entry.exists=false;
    }
  }
  return entry;
}

ID 6035=========================================================================type: 1
Method:org.apache.naming.resources.ProxyDirContext#lookupCache(java.lang.String)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Retrieves the named object as a cache entry, without any exception.
 * @param name the name of the object to look up
 * @return the cache entry bound to name
 */
public CacheEntry lookupCache(String name){
  CacheEntry entry=cacheLookup(name);
  if (entry == null) {
    entry=new CacheEntry();
    entry.name=name;
    try {
      Object object=dirContext.lookup(parseName(name));
      if (object instanceof InputStream) {
        entry.resource=new Resource((InputStream)object);
      }
 else       if (object instanceof DirContext) {
        entry.context=(DirContext)object;
      }
 else       if (object instanceof Resource) {
        entry.resource=(Resource)object;
      }
 else {
        entry.resource=new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset())));
      }
      Attributes attributes=dirContext.getAttributes(parseName(name));
      if (!(attributes instanceof ResourceAttributes)) {
        attributes=new ResourceAttributes(attributes);
      }
      entry.attributes=(ResourceAttributes)attributes;
    }
 catch (    NamingException e) {
      entry.exists=false;
    }
  }
  return entry;
}

ID 6036=========================================================================type: 1
Method:org.apache.naming.resources.ProxyDirContext#lookupCache(java.lang.String)
Rmethod: javax.naming.directory.DirContext#getAttributes(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Retrieves the named object as a cache entry, without any exception.
 * @param name the name of the object to look up
 * @return the cache entry bound to name
 */
public CacheEntry lookupCache(String name){
  CacheEntry entry=cacheLookup(name);
  if (entry == null) {
    entry=new CacheEntry();
    entry.name=name;
    try {
      Object object=dirContext.lookup(parseName(name));
      if (object instanceof InputStream) {
        entry.resource=new Resource((InputStream)object);
      }
 else       if (object instanceof DirContext) {
        entry.context=(DirContext)object;
      }
 else       if (object instanceof Resource) {
        entry.resource=(Resource)object;
      }
 else {
        entry.resource=new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset())));
      }
      Attributes attributes=dirContext.getAttributes(parseName(name));
      if (!(attributes instanceof ResourceAttributes)) {
        attributes=new ResourceAttributes(attributes);
      }
      entry.attributes=(ResourceAttributes)attributes;
    }
 catch (    NamingException e) {
      entry.exists=false;
    }
  }
  return entry;
}

ID 6037=========================================================================type: 1
Method:org.apache.naming.resources.ProxyDirContext#revalidate(org.apache.naming.resources.CacheEntry)
Rmethod: javax.naming.directory.DirContext#getAttributes(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Revalidate entry.
 */
protected boolean revalidate(CacheEntry entry){
  if (!entry.exists)   return false;
  if (entry.attributes == null)   return false;
  long lastModified=entry.attributes.getLastModified();
  long contentLength=entry.attributes.getContentLength();
  if (lastModified <= 0)   return false;
  try {
    Attributes tempAttributes=dirContext.getAttributes(entry.name);
    ResourceAttributes attributes=null;
    if (!(tempAttributes instanceof ResourceAttributes)) {
      attributes=new ResourceAttributes(tempAttributes);
    }
 else {
      attributes=(ResourceAttributes)tempAttributes;
    }
    long lastModified2=attributes.getLastModified();
    long contentLength2=attributes.getContentLength();
    return (lastModified == lastModified2) && (contentLength == contentLength2);
  }
 catch (  NamingException e) {
    return false;
  }
}

ID 6038=========================================================================type: 1
Method:org.apache.naming.resources.ProxyDirContext#cacheLoad(org.apache.naming.resources.CacheEntry)
Rmethod: javax.naming.directory.DirContext#getAttributes(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Load entry into cache.
 */
protected void cacheLoad(CacheEntry entry){
  final String name=entry.name;
  boolean exists=true;
  if (entry.attributes == null) {
    try {
      Attributes attributes=dirContext.getAttributes(name);
      if (!(attributes instanceof ResourceAttributes)) {
        entry.attributes=new ResourceAttributes(attributes);
      }
 else {
        entry.attributes=(ResourceAttributes)attributes;
      }
    }
 catch (    NamingException e) {
      exists=false;
    }
  }
  if ((exists) && (entry.resource == null) && (entry.context == null)) {
    try {
      Object object=dirContext.lookup(name);
      if (object instanceof InputStream) {
        entry.resource=new Resource((InputStream)object);
      }
 else       if (object instanceof DirContext) {
        entry.context=(DirContext)object;
      }
 else       if (object instanceof Resource) {
        entry.resource=(Resource)object;
      }
 else {
        entry.resource=new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset())));
      }
    }
 catch (    NamingException e) {
      exists=false;
    }
  }
  if ((exists) && (entry.resource != null) && (entry.resource.getContent() == null)&& (entry.attributes.getContentLength() >= 0)&& (entry.attributes.getContentLength() < (cacheObjectMaxSize * 1024))) {
    int length=(int)entry.attributes.getContentLength();
    entry.size+=(entry.attributes.getContentLength() / 1024);
    InputStream is=null;
    try {
      is=entry.resource.streamContent();
      int pos=0;
      byte[] b=new byte[length];
      while (pos < length) {
        int n=is.read(b,pos,length - pos);
        if (n < 0)         break;
        pos=pos + n;
      }
      entry.resource.setContent(b);
    }
 catch (    IOException e) {
    }
 finally {
      try {
        if (is != null)         is.close();
      }
 catch (      IOException e) {
      }
    }
  }
  entry.exists=exists;
  entry.timestamp=System.currentTimeMillis() + cacheTTL;
synchronized (cache) {
    if ((cache.lookup(name) == null) && cache.allocate(entry.size)) {
      cache.load(entry);
    }
  }
}

ID 6039=========================================================================type: 1
Method:org.apache.naming.resources.ProxyDirContext#cacheLoad(org.apache.naming.resources.CacheEntry)
Rmethod: javax.naming.Context#lookup(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * Load entry into cache.
 */
protected void cacheLoad(CacheEntry entry){
  final String name=entry.name;
  boolean exists=true;
  if (entry.attributes == null) {
    try {
      Attributes attributes=dirContext.getAttributes(name);
      if (!(attributes instanceof ResourceAttributes)) {
        entry.attributes=new ResourceAttributes(attributes);
      }
 else {
        entry.attributes=(ResourceAttributes)attributes;
      }
    }
 catch (    NamingException e) {
      exists=false;
    }
  }
  if ((exists) && (entry.resource == null) && (entry.context == null)) {
    try {
      Object object=dirContext.lookup(name);
      if (object instanceof InputStream) {
        entry.resource=new Resource((InputStream)object);
      }
 else       if (object instanceof DirContext) {
        entry.context=(DirContext)object;
      }
 else       if (object instanceof Resource) {
        entry.resource=(Resource)object;
      }
 else {
        entry.resource=new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset())));
      }
    }
 catch (    NamingException e) {
      exists=false;
    }
  }
  if ((exists) && (entry.resource != null) && (entry.resource.getContent() == null)&& (entry.attributes.getContentLength() >= 0)&& (entry.attributes.getContentLength() < (cacheObjectMaxSize * 1024))) {
    int length=(int)entry.attributes.getContentLength();
    entry.size+=(entry.attributes.getContentLength() / 1024);
    InputStream is=null;
    try {
      is=entry.resource.streamContent();
      int pos=0;
      byte[] b=new byte[length];
      while (pos < length) {
        int n=is.read(b,pos,length - pos);
        if (n < 0)         break;
        pos=pos + n;
      }
      entry.resource.setContent(b);
    }
 catch (    IOException e) {
    }
 finally {
      try {
        if (is != null)         is.close();
      }
 catch (      IOException e) {
      }
    }
  }
  entry.exists=exists;
  entry.timestamp=System.currentTimeMillis() + cacheTTL;
synchronized (cache) {
    if ((cache.lookup(name) == null) && cache.allocate(entry.size)) {
      cache.load(entry);
    }
  }
}

ID 6045=========================================================================type: 1
Method:org.apache.naming.resources.WARDirContext#release()
Rmethod: java.util.zip.ZipFile#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Release any resources allocated for this directory context.
 */
@Override public void release(){
  entries=null;
  if (base != null) {
    try {
      base.close();
    }
 catch (    IOException e) {
      log.warn("Exception closing WAR File " + base.getName(),e);
    }
  }
  base=null;
  super.release();
}

ID 6046=========================================================================type: 1
Method:org.apache.naming.resources.WARDirContext#doLookup(java.lang.String)
Rmethod: org.apache.naming.resources.WARDirContext#getEscapedJndiName(java.lang.String)
parentException: NamingException 
thrown: InvalidNameException
exception comment: /** 
 * This exception indicates that the name being specified does not conform to the naming syntax of a naming system. This exception is thrown by any of the methods that does name parsing (such as those in Context, DirContext, CompositeName and CompoundName). <p> Synchronization and serialization issues that apply to NamingException apply directly here.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @see Context
 * @see javax.naming.directory.DirContext
 * @see CompositeName
 * @see CompoundName
 * @see NameParser
 * @since 1.3
 */

block: 
/** 
 * Retrieves the named object.
 * @param strName the name of the object to look up
 * @return the object bound to name
 */
@Override protected Object doLookup(String strName){
  Name name;
  try {
    name=getEscapedJndiName(strName);
  }
 catch (  InvalidNameException e) {
    log.info(sm.getString("resources.invalidName",strName),e);
    return null;
  }
  if (name.isEmpty())   return this;
  Entry entry=treeLookup(name);
  if (entry == null)   return null;
  ZipEntry zipEntry=entry.getEntry();
  if (zipEntry.isDirectory())   return new WARDirContext(base,entry);
 else   return new WARResource(entry.getEntry());
}

ID 6073=========================================================================type: 1
Method:org.apache.naming.resources.DirContextURLConnection#list()
Rmethod: javax.naming.Context#list(java.lang.String)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
/** 
 * List children of this collection. The names given are relative to this URI's path. The full uri of the children is then : path + "/" + name.
 */
public Enumeration<String> list() throws IOException {
  if (!connected) {
    connect();
  }
  if ((resource == null) && (collection == null)) {
    throw new FileNotFoundException(getURL() == null ? "null" : getURL().toString());
  }
  Vector<String> result=new Vector<String>();
  if (collection != null) {
    try {
      NamingEnumeration<NameClassPair> enumeration=collection.list("/");
      UEncoder urlEncoder=new UEncoder(UEncoder.SafeCharsSet.WITH_SLASH);
      while (enumeration.hasMoreElements()) {
        NameClassPair ncp=enumeration.nextElement();
        String s=ncp.getName();
        result.addElement(urlEncoder.encodeURL(s,0,s.length()).toString());
      }
    }
 catch (    NamingException e) {
      throw new FileNotFoundException(getURL() == null ? "null" : getURL().toString());
    }
  }
  return result.elements();
}

ID 6080=========================================================================type: 1
Method:org.apache.naming.resources.FileDirContext#rebind(java.lang.String, java.lang.Object, javax.naming.directory.Attributes)
Rmethod: java.io.FileOutputStream#FileOutputStream(java.io.File)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Binds a name to an object, along with associated attributes, overwriting any existing binding. If attrs is null and obj is a DirContext, the attributes from obj are used. If attrs is null and obj is not a DirContext, any existing attributes associated with the object already bound in the directory remain unchanged. If attrs is non-null, any existing attributes associated with the object already bound in the directory are removed and attrs is associated with the named object. If obj is a DirContext and attrs is non-null, the attributes of obj are ignored.
 * @param name the name to bind; may not be empty
 * @param obj the object to bind; possibly null
 * @param attrs the attributes to associate with the binding
 * @exception javax.naming.directory.InvalidAttributesException if some"mandatory" attributes of the binding are not supplied
 * @exception NamingException if a naming exception is encountered
 */
@Override public void rebind(String name,Object obj,Attributes attrs) throws NamingException {
  File file=new File(base,name);
  InputStream is=null;
  if (obj instanceof Resource) {
    try {
      is=((Resource)obj).streamContent();
    }
 catch (    IOException e) {
    }
  }
 else   if (obj instanceof InputStream) {
    is=(InputStream)obj;
  }
 else   if (obj instanceof DirContext) {
    if (file.exists()) {
      if (!file.delete())       throw new NamingException(sm.getString("resources.bindFailed",name));
    }
    if (!file.mkdir())     throw new NamingException(sm.getString("resources.bindFailed",name));
  }
  if (is == null)   throw new NamingException(sm.getString("resources.bindFailed",name));
  FileOutputStream os=null;
  byte buffer[]=new byte[BUFFER_SIZE];
  int len=-1;
  try {
    os=new FileOutputStream(file);
    while (true) {
      len=is.read(buffer);
      if (len == -1)       break;
      os.write(buffer,0,len);
    }
  }
 catch (  IOException e) {
    NamingException ne=new NamingException(sm.getString("resources.bindFailed",e));
    ne.initCause(e);
    throw ne;
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
      }
    }
    try {
      is.close();
    }
 catch (    IOException e) {
    }
  }
}

ID 6081=========================================================================type: 1
Method:org.apache.naming.resources.FileDirContext#rebind(java.lang.String, java.lang.Object, javax.naming.directory.Attributes)
Rmethod: java.io.InputStream#read(byte[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Binds a name to an object, along with associated attributes, overwriting any existing binding. If attrs is null and obj is a DirContext, the attributes from obj are used. If attrs is null and obj is not a DirContext, any existing attributes associated with the object already bound in the directory remain unchanged. If attrs is non-null, any existing attributes associated with the object already bound in the directory are removed and attrs is associated with the named object. If obj is a DirContext and attrs is non-null, the attributes of obj are ignored.
 * @param name the name to bind; may not be empty
 * @param obj the object to bind; possibly null
 * @param attrs the attributes to associate with the binding
 * @exception javax.naming.directory.InvalidAttributesException if some"mandatory" attributes of the binding are not supplied
 * @exception NamingException if a naming exception is encountered
 */
@Override public void rebind(String name,Object obj,Attributes attrs) throws NamingException {
  File file=new File(base,name);
  InputStream is=null;
  if (obj instanceof Resource) {
    try {
      is=((Resource)obj).streamContent();
    }
 catch (    IOException e) {
    }
  }
 else   if (obj instanceof InputStream) {
    is=(InputStream)obj;
  }
 else   if (obj instanceof DirContext) {
    if (file.exists()) {
      if (!file.delete())       throw new NamingException(sm.getString("resources.bindFailed",name));
    }
    if (!file.mkdir())     throw new NamingException(sm.getString("resources.bindFailed",name));
  }
  if (is == null)   throw new NamingException(sm.getString("resources.bindFailed",name));
  FileOutputStream os=null;
  byte buffer[]=new byte[BUFFER_SIZE];
  int len=-1;
  try {
    os=new FileOutputStream(file);
    while (true) {
      len=is.read(buffer);
      if (len == -1)       break;
      os.write(buffer,0,len);
    }
  }
 catch (  IOException e) {
    NamingException ne=new NamingException(sm.getString("resources.bindFailed",e));
    ne.initCause(e);
    throw ne;
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
      }
    }
    try {
      is.close();
    }
 catch (    IOException e) {
    }
  }
}

ID 6082=========================================================================type: 1
Method:org.apache.naming.resources.FileDirContext#rebind(java.lang.String, java.lang.Object, javax.naming.directory.Attributes)
Rmethod: java.io.FileOutputStream#write(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Binds a name to an object, along with associated attributes, overwriting any existing binding. If attrs is null and obj is a DirContext, the attributes from obj are used. If attrs is null and obj is not a DirContext, any existing attributes associated with the object already bound in the directory remain unchanged. If attrs is non-null, any existing attributes associated with the object already bound in the directory are removed and attrs is associated with the named object. If obj is a DirContext and attrs is non-null, the attributes of obj are ignored.
 * @param name the name to bind; may not be empty
 * @param obj the object to bind; possibly null
 * @param attrs the attributes to associate with the binding
 * @exception javax.naming.directory.InvalidAttributesException if some"mandatory" attributes of the binding are not supplied
 * @exception NamingException if a naming exception is encountered
 */
@Override public void rebind(String name,Object obj,Attributes attrs) throws NamingException {
  File file=new File(base,name);
  InputStream is=null;
  if (obj instanceof Resource) {
    try {
      is=((Resource)obj).streamContent();
    }
 catch (    IOException e) {
    }
  }
 else   if (obj instanceof InputStream) {
    is=(InputStream)obj;
  }
 else   if (obj instanceof DirContext) {
    if (file.exists()) {
      if (!file.delete())       throw new NamingException(sm.getString("resources.bindFailed",name));
    }
    if (!file.mkdir())     throw new NamingException(sm.getString("resources.bindFailed",name));
  }
  if (is == null)   throw new NamingException(sm.getString("resources.bindFailed",name));
  FileOutputStream os=null;
  byte buffer[]=new byte[BUFFER_SIZE];
  int len=-1;
  try {
    os=new FileOutputStream(file);
    while (true) {
      len=is.read(buffer);
      if (len == -1)       break;
      os.write(buffer,0,len);
    }
  }
 catch (  IOException e) {
    NamingException ne=new NamingException(sm.getString("resources.bindFailed",e));
    ne.initCause(e);
    throw ne;
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
      }
    }
    try {
      is.close();
    }
 catch (    IOException e) {
    }
  }
}

ID 6103=========================================================================type: 1
Method:org.apache.naming.resources.BaseDirContext#addResourcesJar(java.net.URL)
Rmethod: java.net.URL#openConnection()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Add a resources JAR. The contents of /META-INF/resources/ will be used if a requested resource can not be found in the main context.
 */
public void addResourcesJar(URL url){
  try {
    JarURLConnection conn=(JarURLConnection)url.openConnection();
    JarFile jarFile=conn.getJarFile();
    ZipEntry entry=jarFile.getEntry("/");
    WARDirContext warDirContext=new WARDirContext(jarFile,new WARDirContext.Entry("/",entry));
    warDirContext.loadEntries();
    altDirContexts.add(warDirContext);
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("resources.addResourcesJarFail",url),ioe);
  }
}

ID 6104=========================================================================type: 1
Method:org.apache.naming.resources.BaseDirContext#addResourcesJar(java.net.URL)
Rmethod: java.net.JarURLConnection#getJarFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Add a resources JAR. The contents of /META-INF/resources/ will be used if a requested resource can not be found in the main context.
 */
public void addResourcesJar(URL url){
  try {
    JarURLConnection conn=(JarURLConnection)url.openConnection();
    JarFile jarFile=conn.getJarFile();
    ZipEntry entry=jarFile.getEntry("/");
    WARDirContext warDirContext=new WARDirContext(jarFile,new WARDirContext.Entry("/",entry));
    warDirContext.loadEntries();
    altDirContexts.add(warDirContext);
  }
 catch (  IOException ioe) {
    log.warn(sm.getString("resources.addResourcesJarFail",url),ioe);
  }
}

ID 6146=========================================================================type: 1
Method:org.apache.naming.NamingContextBindingsEnumeration#nextElement()
Rmethod: org.apache.naming.NamingContextBindingsEnumeration#nextElementInternal()
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
@Override public Binding nextElement(){
  try {
    return nextElementInternal();
  }
 catch (  NamingException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}

ID 6147=========================================================================type: 1
Method:org.apache.naming.NamingContextBindingsEnumeration#nextElementInternal()
Rmethod: javax.naming.CompositeName#CompositeName(java.lang.String)
parentException: NamingException 
thrown: InvalidNameException
exception comment: /** 
 * This exception indicates that the name being specified does not conform to the naming syntax of a naming system. This exception is thrown by any of the methods that does name parsing (such as those in Context, DirContext, CompositeName and CompoundName). <p> Synchronization and serialization issues that apply to NamingException apply directly here.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @see Context
 * @see javax.naming.directory.DirContext
 * @see CompositeName
 * @see CompoundName
 * @see NameParser
 * @since 1.3
 */

block: 
private Binding nextElementInternal() throws NamingException {
  NamingEntry entry=iterator.next();
  Object value;
  if (entry.type == NamingEntry.REFERENCE || entry.type == NamingEntry.LINK_REF) {
    try {
      value=ctx.lookup(new CompositeName(entry.name));
    }
 catch (    NamingException e) {
      throw e;
    }
catch (    Exception e) {
      NamingException ne=new NamingException(e.getMessage());
      ne.initCause(e);
      throw ne;
    }
  }
 else {
    value=entry.value;
  }
  return new Binding(entry.name,value.getClass().getName(),value,true);
}

ID 6148=========================================================================type: 1
Method:org.apache.naming.NamingContextBindingsEnumeration#nextElementInternal()
Rmethod: javax.naming.Context#lookup(javax.naming.Name)
parentException: 
thrown: NamingException
exception comment: /** 
 * This is the superclass of all exceptions thrown by operations in the Context and DirContext interfaces. The nature of the failure is described by the name of the subclass. This exception captures the information pinpointing where the operation failed, such as where resolution last proceeded to. <ul> <li> Resolved Name. Portion of name that has been resolved. <li> Resolved Object. Object to which resolution of name proceeded. <li> Remaining Name. Portion of name that has not been resolved. <li> Explanation. Detail explaining why name resolution failed. <li> Root Exception. The exception that caused this naming exception to be thrown. </ul> null is an acceptable value for any of these fields. When null, it means that no such information has been recorded for that field. <p> A NamingException instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single NamingException instance should lock the object. <p> This exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The <i>root exception</i> (or <i>root cause</i>) is the same object as the <i>cause</i> returned by the  {@link Throwable#getCause()} method.
 * @author Rosanna Lee
 * @author Scott Seligman
 * @since 1.3
 */

block: 
private Binding nextElementInternal() throws NamingException {
  NamingEntry entry=iterator.next();
  Object value;
  if (entry.type == NamingEntry.REFERENCE || entry.type == NamingEntry.LINK_REF) {
    try {
      value=ctx.lookup(new CompositeName(entry.name));
    }
 catch (    NamingException e) {
      throw e;
    }
catch (    Exception e) {
      NamingException ne=new NamingException(e.getMessage());
      ne.initCause(e);
      throw ne;
    }
  }
 else {
    value=entry.value;
  }
  return new Binding(entry.name,value.getClass().getName(),value,true);
}

ID 6235=========================================================================type: 1
Method:org.apache.naming.factory.webservices.ServiceRefFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Crete a new serviceref instance.
 * @param obj The reference object describing the webservice
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof ServiceRef) {
    Reference ref=(Reference)obj;
    ClassLoader tcl=Thread.currentThread().getContextClassLoader();
    if (tcl == null)     tcl=this.getClass().getClassLoader();
    ServiceFactory factory=ServiceFactory.newInstance();
    javax.xml.rpc.Service service=null;
    RefAddr tmp=ref.get(ServiceRef.SERVICE_INTERFACE);
    String serviceInterface=null;
    if (tmp != null)     serviceInterface=(String)tmp.getContent();
    tmp=ref.get(ServiceRef.WSDL);
    String wsdlRefAddr=null;
    if (tmp != null)     wsdlRefAddr=(String)tmp.getContent();
    Hashtable<String,QName> portComponentRef=new Hashtable<String,QName>();
    QName serviceQname=null;
    tmp=ref.get(ServiceRef.SERVICE_LOCAL_PART);
    if (tmp != null) {
      String serviceLocalPart=(String)tmp.getContent();
      tmp=ref.get(ServiceRef.SERVICE_NAMESPACE);
      if (tmp == null) {
        serviceQname=new QName(serviceLocalPart);
      }
 else {
        String serviceNamespace=(String)tmp.getContent();
        serviceQname=new QName(serviceNamespace,serviceLocalPart);
      }
    }
    Class<?> serviceInterfaceClass=null;
    if (serviceInterface == null) {
      if (serviceQname == null) {
        throw new NamingException("Could not create service-ref instance");
      }
      try {
        if (wsdlRefAddr == null) {
          service=factory.createService(serviceQname);
        }
 else {
          service=factory.createService(new URL(wsdlRefAddr),serviceQname);
        }
      }
 catch (      Exception e) {
        NamingException ex=new NamingException("Could not create service");
        ex.initCause(e);
        throw ex;
      }
    }
 else {
      try {
        serviceInterfaceClass=tcl.loadClass(serviceInterface);
      }
 catch (      ClassNotFoundException e) {
        NamingException ex=new NamingException("Could not load service Interface");
        ex.initCause(e);
        throw ex;
      }
      if (serviceInterfaceClass == null) {
        throw new NamingException("Could not load service Interface");
      }
      try {
        if (wsdlRefAddr == null) {
          if (!Service.class.isAssignableFrom(serviceInterfaceClass)) {
            throw new NamingException("service Interface should extend javax.xml.rpc.Service");
          }
          service=factory.loadService(serviceInterfaceClass);
        }
 else {
          service=factory.loadService(new URL(wsdlRefAddr),serviceInterfaceClass,new Properties());
        }
      }
 catch (      Exception e) {
        NamingException ex=new NamingException("Could not create service");
        ex.initCause(e);
        throw ex;
      }
    }
    if (service == null) {
      throw new NamingException("Cannot create service object");
    }
    serviceQname=service.getServiceName();
    serviceInterfaceClass=service.getClass();
    if (wsdlRefAddr != null) {
      try {
        WSDLFactory wsdlfactory=WSDLFactory.newInstance();
        WSDLReader reader=wsdlfactory.newWSDLReader();
        reader.setFeature("javax.wsdl.importDocuments",true);
        Definition def=reader.readWSDL((new URL(wsdlRefAddr)).toExternalForm());
        javax.wsdl.Service wsdlservice=def.getService(serviceQname);
        @SuppressWarnings("unchecked") Map<String,?> ports=wsdlservice.getPorts();
        Method m=serviceInterfaceClass.getMethod("setEndpointAddress",new Class[]{java.lang.String.class,java.lang.String.class});
        for (Iterator<String> i=ports.keySet().iterator(); i.hasNext(); ) {
          String portName=i.next();
          Port port=wsdlservice.getPort(portName);
          String endpoint=getSOAPLocation(port);
          m.invoke(service,new Object[]{port.getName(),endpoint});
          portComponentRef.put(endpoint,new QName(port.getName()));
        }
      }
 catch (      Exception e) {
        if (e instanceof InvocationTargetException) {
          Throwable cause=e.getCause();
          if (cause instanceof ThreadDeath) {
            throw (ThreadDeath)cause;
          }
          if (cause instanceof VirtualMachineError) {
            throw (VirtualMachineError)cause;
          }
        }
        NamingException ex=new NamingException("Error while reading Wsdl File");
        ex.initCause(e);
        throw ex;
      }
    }
    ServiceProxy proxy=new ServiceProxy(service);
    for (int i=0; i < ref.size(); i++)     if (ServiceRef.SERVICEENDPOINTINTERFACE.equals(ref.get(i).getType())) {
      String serviceendpoint="";
      String portlink="";
      serviceendpoint=(String)ref.get(i).getContent();
      if (ServiceRef.PORTCOMPONENTLINK.equals(ref.get(i + 1).getType())) {
        i++;
        portlink=(String)ref.get(i).getContent();
      }
      portComponentRef.put(serviceendpoint,new QName(portlink));
    }
    proxy.setPortComponentRef(portComponentRef);
    Class<?>[] interfaces=null;
    Class<?>[] serviceInterfaces=serviceInterfaceClass.getInterfaces();
    interfaces=new Class[serviceInterfaces.length + 1];
    for (int i=0; i < serviceInterfaces.length; i++) {
      interfaces[i]=serviceInterfaces[i];
    }
    interfaces[interfaces.length - 1]=javax.xml.rpc.Service.class;
    Object proxyInstance=null;
    try {
      proxyInstance=Proxy.newProxyInstance(tcl,interfaces,proxy);
    }
 catch (    IllegalArgumentException e) {
      proxyInstance=Proxy.newProxyInstance(tcl,serviceInterfaces,proxy);
    }
    if (((ServiceRef)ref).getHandlersSize() > 0) {
      HandlerRegistry handlerRegistry=service.getHandlerRegistry();
      ArrayList<String> soaproles=new ArrayList<String>();
      while (((ServiceRef)ref).getHandlersSize() > 0) {
        HandlerRef handlerRef=((ServiceRef)ref).getHandler();
        HandlerInfo handlerInfo=new HandlerInfo();
        tmp=handlerRef.get(HandlerRef.HANDLER_CLASS);
        if ((tmp == null) || (tmp.getContent() == null))         break;
        Class<?> handlerClass=null;
        try {
          handlerClass=tcl.loadClass((String)tmp.getContent());
        }
 catch (        ClassNotFoundException e) {
          break;
        }
        ArrayList<QName> headers=new ArrayList<QName>();
        Hashtable<String,String> config=new Hashtable<String,String>();
        ArrayList<String> portNames=new ArrayList<String>();
        for (int i=0; i < handlerRef.size(); i++)         if (HandlerRef.HANDLER_LOCALPART.equals(handlerRef.get(i).getType())) {
          String localpart="";
          String namespace="";
          localpart=(String)handlerRef.get(i).getContent();
          if (HandlerRef.HANDLER_NAMESPACE.equals(handlerRef.get(i + 1).getType())) {
            i++;
            namespace=(String)handlerRef.get(i).getContent();
          }
          QName header=new QName(namespace,localpart);
          headers.add(header);
        }
 else         if (HandlerRef.HANDLER_PARAMNAME.equals(handlerRef.get(i).getType())) {
          String paramName="";
          String paramValue="";
          paramName=(String)handlerRef.get(i).getContent();
          if (HandlerRef.HANDLER_PARAMVALUE.equals(handlerRef.get(i + 1).getType())) {
            i++;
            paramValue=(String)handlerRef.get(i).getContent();
          }
          config.put(paramName,paramValue);
        }
 else         if (HandlerRef.HANDLER_SOAPROLE.equals(handlerRef.get(i).getType())) {
          String soaprole="";
          soaprole=(String)handlerRef.get(i).getContent();
          soaproles.add(soaprole);
        }
 else         if (HandlerRef.HANDLER_PORTNAME.equals(handlerRef.get(i).getType())) {
          String portName="";
          portName=(String)handlerRef.get(i).getContent();
          portNames.add(portName);
        }
        handlerInfo.setHandlerClass(handlerClass);
        handlerInfo.setHeaders(headers.toArray(new QName[headers.size()]));
        handlerInfo.setHandlerConfig(config);
        if (!portNames.isEmpty()) {
          Iterator<String> iter=portNames.iterator();
          while (iter.hasNext())           initHandlerChain(new QName(iter.next()),handlerRegistry,handlerInfo,soaproles);
        }
 else {
          Enumeration<QName> e=portComponentRef.elements();
          while (e.hasMoreElements())           initHandlerChain(e.nextElement(),handlerRegistry,handlerInfo,soaproles);
        }
      }
    }
    return proxyInstance;
  }
  return null;
}

ID 6242=========================================================================type: 1
Method:org.apache.naming.factory.webservices.ServiceRefFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.reflect.Proxy#newProxyInstance(java.lang.ClassLoader, Class<?>[], java.lang.reflect.InvocationHandler)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Crete a new serviceref instance.
 * @param obj The reference object describing the webservice
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof ServiceRef) {
    Reference ref=(Reference)obj;
    ClassLoader tcl=Thread.currentThread().getContextClassLoader();
    if (tcl == null)     tcl=this.getClass().getClassLoader();
    ServiceFactory factory=ServiceFactory.newInstance();
    javax.xml.rpc.Service service=null;
    RefAddr tmp=ref.get(ServiceRef.SERVICE_INTERFACE);
    String serviceInterface=null;
    if (tmp != null)     serviceInterface=(String)tmp.getContent();
    tmp=ref.get(ServiceRef.WSDL);
    String wsdlRefAddr=null;
    if (tmp != null)     wsdlRefAddr=(String)tmp.getContent();
    Hashtable<String,QName> portComponentRef=new Hashtable<String,QName>();
    QName serviceQname=null;
    tmp=ref.get(ServiceRef.SERVICE_LOCAL_PART);
    if (tmp != null) {
      String serviceLocalPart=(String)tmp.getContent();
      tmp=ref.get(ServiceRef.SERVICE_NAMESPACE);
      if (tmp == null) {
        serviceQname=new QName(serviceLocalPart);
      }
 else {
        String serviceNamespace=(String)tmp.getContent();
        serviceQname=new QName(serviceNamespace,serviceLocalPart);
      }
    }
    Class<?> serviceInterfaceClass=null;
    if (serviceInterface == null) {
      if (serviceQname == null) {
        throw new NamingException("Could not create service-ref instance");
      }
      try {
        if (wsdlRefAddr == null) {
          service=factory.createService(serviceQname);
        }
 else {
          service=factory.createService(new URL(wsdlRefAddr),serviceQname);
        }
      }
 catch (      Exception e) {
        NamingException ex=new NamingException("Could not create service");
        ex.initCause(e);
        throw ex;
      }
    }
 else {
      try {
        serviceInterfaceClass=tcl.loadClass(serviceInterface);
      }
 catch (      ClassNotFoundException e) {
        NamingException ex=new NamingException("Could not load service Interface");
        ex.initCause(e);
        throw ex;
      }
      if (serviceInterfaceClass == null) {
        throw new NamingException("Could not load service Interface");
      }
      try {
        if (wsdlRefAddr == null) {
          if (!Service.class.isAssignableFrom(serviceInterfaceClass)) {
            throw new NamingException("service Interface should extend javax.xml.rpc.Service");
          }
          service=factory.loadService(serviceInterfaceClass);
        }
 else {
          service=factory.loadService(new URL(wsdlRefAddr),serviceInterfaceClass,new Properties());
        }
      }
 catch (      Exception e) {
        NamingException ex=new NamingException("Could not create service");
        ex.initCause(e);
        throw ex;
      }
    }
    if (service == null) {
      throw new NamingException("Cannot create service object");
    }
    serviceQname=service.getServiceName();
    serviceInterfaceClass=service.getClass();
    if (wsdlRefAddr != null) {
      try {
        WSDLFactory wsdlfactory=WSDLFactory.newInstance();
        WSDLReader reader=wsdlfactory.newWSDLReader();
        reader.setFeature("javax.wsdl.importDocuments",true);
        Definition def=reader.readWSDL((new URL(wsdlRefAddr)).toExternalForm());
        javax.wsdl.Service wsdlservice=def.getService(serviceQname);
        @SuppressWarnings("unchecked") Map<String,?> ports=wsdlservice.getPorts();
        Method m=serviceInterfaceClass.getMethod("setEndpointAddress",new Class[]{java.lang.String.class,java.lang.String.class});
        for (Iterator<String> i=ports.keySet().iterator(); i.hasNext(); ) {
          String portName=i.next();
          Port port=wsdlservice.getPort(portName);
          String endpoint=getSOAPLocation(port);
          m.invoke(service,new Object[]{port.getName(),endpoint});
          portComponentRef.put(endpoint,new QName(port.getName()));
        }
      }
 catch (      Exception e) {
        if (e instanceof InvocationTargetException) {
          Throwable cause=e.getCause();
          if (cause instanceof ThreadDeath) {
            throw (ThreadDeath)cause;
          }
          if (cause instanceof VirtualMachineError) {
            throw (VirtualMachineError)cause;
          }
        }
        NamingException ex=new NamingException("Error while reading Wsdl File");
        ex.initCause(e);
        throw ex;
      }
    }
    ServiceProxy proxy=new ServiceProxy(service);
    for (int i=0; i < ref.size(); i++)     if (ServiceRef.SERVICEENDPOINTINTERFACE.equals(ref.get(i).getType())) {
      String serviceendpoint="";
      String portlink="";
      serviceendpoint=(String)ref.get(i).getContent();
      if (ServiceRef.PORTCOMPONENTLINK.equals(ref.get(i + 1).getType())) {
        i++;
        portlink=(String)ref.get(i).getContent();
      }
      portComponentRef.put(serviceendpoint,new QName(portlink));
    }
    proxy.setPortComponentRef(portComponentRef);
    Class<?>[] interfaces=null;
    Class<?>[] serviceInterfaces=serviceInterfaceClass.getInterfaces();
    interfaces=new Class[serviceInterfaces.length + 1];
    for (int i=0; i < serviceInterfaces.length; i++) {
      interfaces[i]=serviceInterfaces[i];
    }
    interfaces[interfaces.length - 1]=javax.xml.rpc.Service.class;
    Object proxyInstance=null;
    try {
      proxyInstance=Proxy.newProxyInstance(tcl,interfaces,proxy);
    }
 catch (    IllegalArgumentException e) {
      proxyInstance=Proxy.newProxyInstance(tcl,serviceInterfaces,proxy);
    }
    if (((ServiceRef)ref).getHandlersSize() > 0) {
      HandlerRegistry handlerRegistry=service.getHandlerRegistry();
      ArrayList<String> soaproles=new ArrayList<String>();
      while (((ServiceRef)ref).getHandlersSize() > 0) {
        HandlerRef handlerRef=((ServiceRef)ref).getHandler();
        HandlerInfo handlerInfo=new HandlerInfo();
        tmp=handlerRef.get(HandlerRef.HANDLER_CLASS);
        if ((tmp == null) || (tmp.getContent() == null))         break;
        Class<?> handlerClass=null;
        try {
          handlerClass=tcl.loadClass((String)tmp.getContent());
        }
 catch (        ClassNotFoundException e) {
          break;
        }
        ArrayList<QName> headers=new ArrayList<QName>();
        Hashtable<String,String> config=new Hashtable<String,String>();
        ArrayList<String> portNames=new ArrayList<String>();
        for (int i=0; i < handlerRef.size(); i++)         if (HandlerRef.HANDLER_LOCALPART.equals(handlerRef.get(i).getType())) {
          String localpart="";
          String namespace="";
          localpart=(String)handlerRef.get(i).getContent();
          if (HandlerRef.HANDLER_NAMESPACE.equals(handlerRef.get(i + 1).getType())) {
            i++;
            namespace=(String)handlerRef.get(i).getContent();
          }
          QName header=new QName(namespace,localpart);
          headers.add(header);
        }
 else         if (HandlerRef.HANDLER_PARAMNAME.equals(handlerRef.get(i).getType())) {
          String paramName="";
          String paramValue="";
          paramName=(String)handlerRef.get(i).getContent();
          if (HandlerRef.HANDLER_PARAMVALUE.equals(handlerRef.get(i + 1).getType())) {
            i++;
            paramValue=(String)handlerRef.get(i).getContent();
          }
          config.put(paramName,paramValue);
        }
 else         if (HandlerRef.HANDLER_SOAPROLE.equals(handlerRef.get(i).getType())) {
          String soaprole="";
          soaprole=(String)handlerRef.get(i).getContent();
          soaproles.add(soaprole);
        }
 else         if (HandlerRef.HANDLER_PORTNAME.equals(handlerRef.get(i).getType())) {
          String portName="";
          portName=(String)handlerRef.get(i).getContent();
          portNames.add(portName);
        }
        handlerInfo.setHandlerClass(handlerClass);
        handlerInfo.setHeaders(headers.toArray(new QName[headers.size()]));
        handlerInfo.setHandlerConfig(config);
        if (!portNames.isEmpty()) {
          Iterator<String> iter=portNames.iterator();
          while (iter.hasNext())           initHandlerChain(new QName(iter.next()),handlerRegistry,handlerInfo,soaproles);
        }
 else {
          Enumeration<QName> e=portComponentRef.elements();
          while (e.hasMoreElements())           initHandlerChain(e.nextElement(),handlerRegistry,handlerInfo,soaproles);
        }
      }
    }
    return proxyInstance;
  }
  return null;
}

ID 6243=========================================================================type: 1
Method:org.apache.naming.factory.webservices.ServiceRefFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Crete a new serviceref instance.
 * @param obj The reference object describing the webservice
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof ServiceRef) {
    Reference ref=(Reference)obj;
    ClassLoader tcl=Thread.currentThread().getContextClassLoader();
    if (tcl == null)     tcl=this.getClass().getClassLoader();
    ServiceFactory factory=ServiceFactory.newInstance();
    javax.xml.rpc.Service service=null;
    RefAddr tmp=ref.get(ServiceRef.SERVICE_INTERFACE);
    String serviceInterface=null;
    if (tmp != null)     serviceInterface=(String)tmp.getContent();
    tmp=ref.get(ServiceRef.WSDL);
    String wsdlRefAddr=null;
    if (tmp != null)     wsdlRefAddr=(String)tmp.getContent();
    Hashtable<String,QName> portComponentRef=new Hashtable<String,QName>();
    QName serviceQname=null;
    tmp=ref.get(ServiceRef.SERVICE_LOCAL_PART);
    if (tmp != null) {
      String serviceLocalPart=(String)tmp.getContent();
      tmp=ref.get(ServiceRef.SERVICE_NAMESPACE);
      if (tmp == null) {
        serviceQname=new QName(serviceLocalPart);
      }
 else {
        String serviceNamespace=(String)tmp.getContent();
        serviceQname=new QName(serviceNamespace,serviceLocalPart);
      }
    }
    Class<?> serviceInterfaceClass=null;
    if (serviceInterface == null) {
      if (serviceQname == null) {
        throw new NamingException("Could not create service-ref instance");
      }
      try {
        if (wsdlRefAddr == null) {
          service=factory.createService(serviceQname);
        }
 else {
          service=factory.createService(new URL(wsdlRefAddr),serviceQname);
        }
      }
 catch (      Exception e) {
        NamingException ex=new NamingException("Could not create service");
        ex.initCause(e);
        throw ex;
      }
    }
 else {
      try {
        serviceInterfaceClass=tcl.loadClass(serviceInterface);
      }
 catch (      ClassNotFoundException e) {
        NamingException ex=new NamingException("Could not load service Interface");
        ex.initCause(e);
        throw ex;
      }
      if (serviceInterfaceClass == null) {
        throw new NamingException("Could not load service Interface");
      }
      try {
        if (wsdlRefAddr == null) {
          if (!Service.class.isAssignableFrom(serviceInterfaceClass)) {
            throw new NamingException("service Interface should extend javax.xml.rpc.Service");
          }
          service=factory.loadService(serviceInterfaceClass);
        }
 else {
          service=factory.loadService(new URL(wsdlRefAddr),serviceInterfaceClass,new Properties());
        }
      }
 catch (      Exception e) {
        NamingException ex=new NamingException("Could not create service");
        ex.initCause(e);
        throw ex;
      }
    }
    if (service == null) {
      throw new NamingException("Cannot create service object");
    }
    serviceQname=service.getServiceName();
    serviceInterfaceClass=service.getClass();
    if (wsdlRefAddr != null) {
      try {
        WSDLFactory wsdlfactory=WSDLFactory.newInstance();
        WSDLReader reader=wsdlfactory.newWSDLReader();
        reader.setFeature("javax.wsdl.importDocuments",true);
        Definition def=reader.readWSDL((new URL(wsdlRefAddr)).toExternalForm());
        javax.wsdl.Service wsdlservice=def.getService(serviceQname);
        @SuppressWarnings("unchecked") Map<String,?> ports=wsdlservice.getPorts();
        Method m=serviceInterfaceClass.getMethod("setEndpointAddress",new Class[]{java.lang.String.class,java.lang.String.class});
        for (Iterator<String> i=ports.keySet().iterator(); i.hasNext(); ) {
          String portName=i.next();
          Port port=wsdlservice.getPort(portName);
          String endpoint=getSOAPLocation(port);
          m.invoke(service,new Object[]{port.getName(),endpoint});
          portComponentRef.put(endpoint,new QName(port.getName()));
        }
      }
 catch (      Exception e) {
        if (e instanceof InvocationTargetException) {
          Throwable cause=e.getCause();
          if (cause instanceof ThreadDeath) {
            throw (ThreadDeath)cause;
          }
          if (cause instanceof VirtualMachineError) {
            throw (VirtualMachineError)cause;
          }
        }
        NamingException ex=new NamingException("Error while reading Wsdl File");
        ex.initCause(e);
        throw ex;
      }
    }
    ServiceProxy proxy=new ServiceProxy(service);
    for (int i=0; i < ref.size(); i++)     if (ServiceRef.SERVICEENDPOINTINTERFACE.equals(ref.get(i).getType())) {
      String serviceendpoint="";
      String portlink="";
      serviceendpoint=(String)ref.get(i).getContent();
      if (ServiceRef.PORTCOMPONENTLINK.equals(ref.get(i + 1).getType())) {
        i++;
        portlink=(String)ref.get(i).getContent();
      }
      portComponentRef.put(serviceendpoint,new QName(portlink));
    }
    proxy.setPortComponentRef(portComponentRef);
    Class<?>[] interfaces=null;
    Class<?>[] serviceInterfaces=serviceInterfaceClass.getInterfaces();
    interfaces=new Class[serviceInterfaces.length + 1];
    for (int i=0; i < serviceInterfaces.length; i++) {
      interfaces[i]=serviceInterfaces[i];
    }
    interfaces[interfaces.length - 1]=javax.xml.rpc.Service.class;
    Object proxyInstance=null;
    try {
      proxyInstance=Proxy.newProxyInstance(tcl,interfaces,proxy);
    }
 catch (    IllegalArgumentException e) {
      proxyInstance=Proxy.newProxyInstance(tcl,serviceInterfaces,proxy);
    }
    if (((ServiceRef)ref).getHandlersSize() > 0) {
      HandlerRegistry handlerRegistry=service.getHandlerRegistry();
      ArrayList<String> soaproles=new ArrayList<String>();
      while (((ServiceRef)ref).getHandlersSize() > 0) {
        HandlerRef handlerRef=((ServiceRef)ref).getHandler();
        HandlerInfo handlerInfo=new HandlerInfo();
        tmp=handlerRef.get(HandlerRef.HANDLER_CLASS);
        if ((tmp == null) || (tmp.getContent() == null))         break;
        Class<?> handlerClass=null;
        try {
          handlerClass=tcl.loadClass((String)tmp.getContent());
        }
 catch (        ClassNotFoundException e) {
          break;
        }
        ArrayList<QName> headers=new ArrayList<QName>();
        Hashtable<String,String> config=new Hashtable<String,String>();
        ArrayList<String> portNames=new ArrayList<String>();
        for (int i=0; i < handlerRef.size(); i++)         if (HandlerRef.HANDLER_LOCALPART.equals(handlerRef.get(i).getType())) {
          String localpart="";
          String namespace="";
          localpart=(String)handlerRef.get(i).getContent();
          if (HandlerRef.HANDLER_NAMESPACE.equals(handlerRef.get(i + 1).getType())) {
            i++;
            namespace=(String)handlerRef.get(i).getContent();
          }
          QName header=new QName(namespace,localpart);
          headers.add(header);
        }
 else         if (HandlerRef.HANDLER_PARAMNAME.equals(handlerRef.get(i).getType())) {
          String paramName="";
          String paramValue="";
          paramName=(String)handlerRef.get(i).getContent();
          if (HandlerRef.HANDLER_PARAMVALUE.equals(handlerRef.get(i + 1).getType())) {
            i++;
            paramValue=(String)handlerRef.get(i).getContent();
          }
          config.put(paramName,paramValue);
        }
 else         if (HandlerRef.HANDLER_SOAPROLE.equals(handlerRef.get(i).getType())) {
          String soaprole="";
          soaprole=(String)handlerRef.get(i).getContent();
          soaproles.add(soaprole);
        }
 else         if (HandlerRef.HANDLER_PORTNAME.equals(handlerRef.get(i).getType())) {
          String portName="";
          portName=(String)handlerRef.get(i).getContent();
          portNames.add(portName);
        }
        handlerInfo.setHandlerClass(handlerClass);
        handlerInfo.setHeaders(headers.toArray(new QName[headers.size()]));
        handlerInfo.setHandlerConfig(config);
        if (!portNames.isEmpty()) {
          Iterator<String> iter=portNames.iterator();
          while (iter.hasNext())           initHandlerChain(new QName(iter.next()),handlerRegistry,handlerInfo,soaproles);
        }
 else {
          Enumeration<QName> e=portComponentRef.elements();
          while (e.hasMoreElements())           initHandlerChain(e.nextElement(),handlerRegistry,handlerInfo,soaproles);
        }
      }
    }
    return proxyInstance;
  }
  return null;
}

ID 6250=========================================================================type: 1
Method:org.apache.naming.factory.webservices.ServiceProxy#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * @see InvocationHandler#invoke(Object,Method,Object[])
 */
@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  if (portQNameClass.equals(method)) {
    return getProxyPortQNameClass(args);
  }
  if (portClass.equals(method)) {
    return getProxyPortClass(args);
  }
  try {
    return method.invoke(service,args);
  }
 catch (  InvocationTargetException ite) {
    throw ite.getTargetException();
  }
}

ID 6255=========================================================================type: 1
Method:org.apache.naming.factory.DataSourceLinkFactory#wrapDataSource(java.lang.Object, java.lang.String, java.lang.String)
Rmethod: org.apache.naming.factory.DataSourceHandler#DataSourceHandler(javax.sql.DataSource, java.lang.String, java.lang.String)
parentException: Throwable Object 
thrown: Exception
exception comment: /** 
 * The class  {@code Exception} and its subclasses are a form of{@code Throwable} that indicates conditions that a reasonableapplication might want to catch. <p>The class  {@code Exception} and any subclasses that are not alsosubclasses of  {@link RuntimeException} are <em>checkedexceptions</em>.  Checked exceptions need to be declared in a method or constructor's  {@code throws} clause if they can be thrownby the execution of the method or constructor and propagate outside the method or constructor boundary.
 * @author  Frank Yellin
 * @see java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */

block: 
protected Object wrapDataSource(Object datasource,String username,String password) throws NamingException {
  try {
    Class<?> proxyClass=Proxy.getProxyClass(datasource.getClass().getClassLoader(),datasource.getClass().getInterfaces());
    Constructor<?> proxyConstructor=proxyClass.getConstructor(new Class[]{InvocationHandler.class});
    DataSourceHandler handler=new DataSourceHandler((DataSource)datasource,username,password);
    return proxyConstructor.newInstance(handler);
  }
 catch (  Exception x) {
    if (x instanceof InvocationTargetException) {
      Throwable cause=x.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      if (cause instanceof Exception) {
        x=(Exception)cause;
      }
    }
    if (x instanceof NamingException)     throw (NamingException)x;
 else {
      NamingException nx=new NamingException(x.getMessage());
      nx.initCause(x);
      throw nx;
    }
  }
}

ID 6266=========================================================================type: 1
Method:org.apache.naming.factory.TransactionFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new User transaction instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof TransactionRef) {
    Reference ref=(Reference)obj;
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Throwable t) {
          if (t instanceof NamingException)           throw (NamingException)t;
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(t);
          throw ex;
        }
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6267=========================================================================type: 1
Method:org.apache.naming.factory.TransactionFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new User transaction instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof TransactionRef) {
    Reference ref=(Reference)obj;
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Throwable t) {
          if (t instanceof NamingException)           throw (NamingException)t;
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(t);
          throw ex;
        }
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6271=========================================================================type: 1
Method:org.apache.naming.factory.ResourceEnvFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Resource env instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof ResourceEnvRef) {
    Reference ref=(Reference)obj;
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Throwable t) {
          if (t instanceof NamingException)           throw (NamingException)t;
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(t);
          throw ex;
        }
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6272=========================================================================type: 1
Method:org.apache.naming.factory.ResourceEnvFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Resource env instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof ResourceEnvRef) {
    Reference ref=(Reference)obj;
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Throwable t) {
          if (t instanceof NamingException)           throw (NamingException)t;
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(t);
          throw ex;
        }
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6277=========================================================================type: 1
Method:org.apache.naming.factory.ResourceLinkFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#forName(java.lang.String, boolean, java.lang.ClassLoader)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new DataSource instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (!(obj instanceof ResourceLinkRef)) {
    return null;
  }
  Reference ref=(Reference)obj;
  String globalName=null;
  RefAddr refAddr=ref.get(ResourceLinkRef.GLOBALNAME);
  if (refAddr != null) {
    globalName=refAddr.getContent().toString();
    if (!validateGlobalResourceAccess(globalName)) {
      return null;
    }
    Object result=null;
    result=globalContext.lookup(globalName);
    String expectedClassName=ref.getClassName();
    if (expectedClassName == null) {
      throw new IllegalArgumentException(sm.getString("resourceLinkFactory.nullType",name,globalName));
    }
    try {
      Class<?> expectedClazz=Class.forName(expectedClassName,true,Thread.currentThread().getContextClassLoader());
      if (!expectedClazz.isAssignableFrom(result.getClass())) {
        throw new IllegalArgumentException(sm.getString("resourceLinkFactory.wrongType",name,globalName,expectedClassName,result.getClass().getName()));
      }
    }
 catch (    ClassNotFoundException e) {
      throw new IllegalArgumentException(sm.getString("resourceLinkFactory.unknownType",name,globalName,expectedClassName),e);
    }
    return result;
  }
  return null;
}

ID 6280=========================================================================type: 1
Method:org.apache.naming.factory.EjbFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new EJB instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof EjbRef) {
    Reference ref=(Reference)obj;
    RefAddr linkRefAddr=ref.get(EjbRef.LINK);
    if (linkRefAddr != null) {
      String ejbLink=linkRefAddr.getContent().toString();
      Object beanObj=(new InitialContext()).lookup(ejbLink);
      return beanObj;
    }
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Throwable t) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(t);
          throw ex;
        }
      }
    }
 else {
      String javaxEjbFactoryClassName=System.getProperty("javax.ejb.Factory",Constants.OPENEJB_EJB_FACTORY);
      try {
        factory=(ObjectFactory)Class.forName(javaxEjbFactoryClassName).newInstance();
      }
 catch (      Throwable t) {
        if (t instanceof NamingException)         throw (NamingException)t;
        NamingException ex=new NamingException("Could not create resource factory instance");
        ex.initCause(t);
        throw ex;
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6281=========================================================================type: 1
Method:org.apache.naming.factory.EjbFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new EJB instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof EjbRef) {
    Reference ref=(Reference)obj;
    RefAddr linkRefAddr=ref.get(EjbRef.LINK);
    if (linkRefAddr != null) {
      String ejbLink=linkRefAddr.getContent().toString();
      Object beanObj=(new InitialContext()).lookup(ejbLink);
      return beanObj;
    }
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Throwable t) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(t);
          throw ex;
        }
      }
    }
 else {
      String javaxEjbFactoryClassName=System.getProperty("javax.ejb.Factory",Constants.OPENEJB_EJB_FACTORY);
      try {
        factory=(ObjectFactory)Class.forName(javaxEjbFactoryClassName).newInstance();
      }
 catch (      Throwable t) {
        if (t instanceof NamingException)         throw (NamingException)t;
        NamingException ex=new NamingException("Could not create resource factory instance");
        ex.initCause(t);
        throw ex;
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6287=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6288=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.beans.Introspector#getBeanInfo(Class<?>)
parentException: 
thrown: IntrospectionException
exception comment: /** 
 * An exception occurred during the introspection of an MBean.
 * @since 1.5
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6289=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6290=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6291=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6292=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6293=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6294=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6295=========================================================================type: 1
Method:org.apache.naming.factory.BeanFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Create a new Bean instance.
 * @param obj The reference object describing the Bean
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws NamingException {
  if (obj instanceof ResourceRef) {
    try {
      Reference ref=(Reference)obj;
      String beanClassName=ref.getClassName();
      Class<?> beanClass=null;
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      if (tcl != null) {
        try {
          beanClass=tcl.loadClass(beanClassName);
        }
 catch (        ClassNotFoundException e) {
        }
      }
 else {
        try {
          beanClass=Class.forName(beanClassName);
        }
 catch (        ClassNotFoundException e) {
          e.printStackTrace();
        }
      }
      if (beanClass == null) {
        throw new NamingException("Class not found: " + beanClassName);
      }
      BeanInfo bi=Introspector.getBeanInfo(beanClass);
      PropertyDescriptor[] pda=bi.getPropertyDescriptors();
      Object bean=beanClass.newInstance();
      RefAddr ra=ref.get("forceString");
      Map<String,Method> forced=new HashMap<String,Method>();
      String value;
      if (ra != null) {
        value=(String)ra.getContent();
        Class<?> paramTypes[]=new Class[1];
        paramTypes[0]=String.class;
        String setterName;
        int index;
        for (        String param : value.split(",")) {
          param=param.trim();
          index=param.indexOf('=');
          if (index >= 0) {
            setterName=param.substring(index + 1).trim();
            param=param.substring(0,index).trim();
          }
 else {
            setterName="set" + param.substring(0,1).toUpperCase(Locale.ENGLISH) + param.substring(1);
          }
          try {
            forced.put(param,beanClass.getMethod(setterName,paramTypes));
          }
 catch (          NoSuchMethodException ex) {
            throw new NamingException("Forced String setter " + setterName + " not found for property "+ param);
          }
catch (          SecurityException ex) {
            throw new NamingException("Forced String setter " + setterName + " not allowed for property "+ param);
          }
        }
      }
      Enumeration<RefAddr> e=ref.getAll();
      while (e.hasMoreElements()) {
        ra=e.nextElement();
        String propName=ra.getType();
        if (propName.equals(Constants.FACTORY) || propName.equals("scope") || propName.equals("auth")|| propName.equals("forceString")|| propName.equals("singleton")) {
          continue;
        }
        value=(String)ra.getContent();
        Object[] valueArray=new Object[1];
        Method method=forced.get(propName);
        if (method != null) {
          valueArray[0]=value;
          try {
            method.invoke(bean,valueArray);
          }
 catch (          IllegalAccessException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalAccessException for property "+ propName);
          }
catch (          IllegalArgumentException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw IllegalArgumentException for property "+ propName);
          }
catch (          InvocationTargetException ex) {
            throw new NamingException("Forced String setter " + method.getName() + " threw InvocationTargetException for property "+ propName);
          }
          continue;
        }
        int i=0;
        for (i=0; i < pda.length; i++) {
          if (pda[i].getName().equals(propName)) {
            Class<?> propType=pda[i].getPropertyType();
            if (propType.equals(String.class)) {
              valueArray[0]=value;
            }
 else             if (propType.equals(Character.class) || propType.equals(char.class)) {
              valueArray[0]=Character.valueOf(value.charAt(0));
            }
 else             if (propType.equals(Byte.class) || propType.equals(byte.class)) {
              valueArray[0]=Byte.valueOf(value);
            }
 else             if (propType.equals(Short.class) || propType.equals(short.class)) {
              valueArray[0]=Short.valueOf(value);
            }
 else             if (propType.equals(Integer.class) || propType.equals(int.class)) {
              valueArray[0]=Integer.valueOf(value);
            }
 else             if (propType.equals(Long.class) || propType.equals(long.class)) {
              valueArray[0]=Long.valueOf(value);
            }
 else             if (propType.equals(Float.class) || propType.equals(float.class)) {
              valueArray[0]=Float.valueOf(value);
            }
 else             if (propType.equals(Double.class) || propType.equals(double.class)) {
              valueArray[0]=Double.valueOf(value);
            }
 else             if (propType.equals(Boolean.class) || propType.equals(boolean.class)) {
              valueArray[0]=Boolean.valueOf(value);
            }
 else {
              throw new NamingException("String conversion for property " + propName + " of type '"+ propType.getName()+ "' not available");
            }
            Method setProp=pda[i].getWriteMethod();
            if (setProp != null) {
              setProp.invoke(bean,valueArray);
            }
 else {
              throw new NamingException("Write not allowed for property: " + propName);
            }
            break;
          }
        }
        if (i == pda.length) {
          throw new NamingException("No set method found for property: " + propName);
        }
      }
      return bean;
    }
 catch (    java.beans.IntrospectionException ie) {
      NamingException ne=new NamingException(ie.getMessage());
      ne.setRootCause(ie);
      throw ne;
    }
catch (    java.lang.IllegalAccessException iae) {
      NamingException ne=new NamingException(iae.getMessage());
      ne.setRootCause(iae);
      throw ne;
    }
catch (    java.lang.InstantiationException ie2) {
      NamingException ne=new NamingException(ie2.getMessage());
      ne.setRootCause(ie2);
      throw ne;
    }
catch (    java.lang.reflect.InvocationTargetException ite) {
      Throwable cause=ite.getCause();
      if (cause instanceof ThreadDeath) {
        throw (ThreadDeath)cause;
      }
      if (cause instanceof VirtualMachineError) {
        throw (VirtualMachineError)cause;
      }
      NamingException ne=new NamingException(ite.getMessage());
      ne.setRootCause(ite);
      throw ne;
    }
  }
 else {
    return null;
  }
}

ID 6303=========================================================================type: 1
Method:org.apache.naming.factory.ResourceFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Crete a new DataSource instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof ResourceRef) {
    Reference ref=(Reference)obj;
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Exception e) {
          if (e instanceof NamingException)           throw (NamingException)e;
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(e);
          throw ex;
        }
      }
    }
 else {
      if (ref.getClassName().equals("javax.sql.DataSource")) {
        String javaxSqlDataSourceFactoryClassName=System.getProperty("javax.sql.DataSource.Factory",Constants.DBCP_DATASOURCE_FACTORY);
        try {
          factory=(ObjectFactory)Class.forName(javaxSqlDataSourceFactoryClassName).newInstance();
        }
 catch (        Exception e) {
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(e);
          throw ex;
        }
      }
 else       if (ref.getClassName().equals("javax.mail.Session")) {
        String javaxMailSessionFactoryClassName=System.getProperty("javax.mail.Session.Factory","org.apache.naming.factory.MailSessionFactory");
        try {
          factory=(ObjectFactory)Class.forName(javaxMailSessionFactoryClassName).newInstance();
        }
 catch (        Throwable t) {
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(t);
          throw ex;
        }
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6304=========================================================================type: 1
Method:org.apache.naming.factory.ResourceFactory#getObjectInstance(java.lang.Object, javax.naming.Name, javax.naming.Context, Hashtable<?,?>)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
/** 
 * Crete a new DataSource instance.
 * @param obj The reference object describing the DataSource
 */
@Override public Object getObjectInstance(Object obj,Name name,Context nameCtx,Hashtable<?,?> environment) throws Exception {
  if (obj instanceof ResourceRef) {
    Reference ref=(Reference)obj;
    ObjectFactory factory=null;
    RefAddr factoryRefAddr=ref.get(Constants.FACTORY);
    if (factoryRefAddr != null) {
      String factoryClassName=factoryRefAddr.getContent().toString();
      ClassLoader tcl=Thread.currentThread().getContextClassLoader();
      Class<?> factoryClass=null;
      if (tcl != null) {
        try {
          factoryClass=tcl.loadClass(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
 else {
        try {
          factoryClass=Class.forName(factoryClassName);
        }
 catch (        ClassNotFoundException e) {
          NamingException ex=new NamingException("Could not load resource factory class");
          ex.initCause(e);
          throw ex;
        }
      }
      if (factoryClass != null) {
        try {
          factory=(ObjectFactory)factoryClass.newInstance();
        }
 catch (        Exception e) {
          if (e instanceof NamingException)           throw (NamingException)e;
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(e);
          throw ex;
        }
      }
    }
 else {
      if (ref.getClassName().equals("javax.sql.DataSource")) {
        String javaxSqlDataSourceFactoryClassName=System.getProperty("javax.sql.DataSource.Factory",Constants.DBCP_DATASOURCE_FACTORY);
        try {
          factory=(ObjectFactory)Class.forName(javaxSqlDataSourceFactoryClassName).newInstance();
        }
 catch (        Exception e) {
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(e);
          throw ex;
        }
      }
 else       if (ref.getClassName().equals("javax.mail.Session")) {
        String javaxMailSessionFactoryClassName=System.getProperty("javax.mail.Session.Factory","org.apache.naming.factory.MailSessionFactory");
        try {
          factory=(ObjectFactory)Class.forName(javaxMailSessionFactoryClassName).newInstance();
        }
 catch (        Throwable t) {
          NamingException ex=new NamingException("Could not create resource factory instance");
          ex.initCause(t);
          throw ex;
        }
      }
    }
    if (factory != null) {
      return factory.getObjectInstance(obj,name,nameCtx,environment);
    }
 else {
      throw new NamingException("Cannot create resource instance");
    }
  }
  return null;
}

ID 6322=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServlet#init(javax.servlet.ServletConfig)
Rmethod: javax.servlet.ServletContext#getResource(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
@Override public void init(ServletConfig config) throws ServletException {
  super.init(config);
  this.config=config;
  this.context=config.getServletContext();
  String engineOptionsName=config.getInitParameter("engineOptionsClass");
  if (Constants.IS_SECURITY_ENABLED && engineOptionsName != null) {
    log.info(Localizer.getMessage("jsp.info.ignoreSetting","engineOptionsClass",engineOptionsName));
    engineOptionsName=null;
  }
  if (engineOptionsName != null) {
    try {
      ClassLoader loader=Thread.currentThread().getContextClassLoader();
      Class<?> engineOptionsClass=loader.loadClass(engineOptionsName);
      Class<?>[] ctorSig={ServletConfig.class,ServletContext.class};
      Constructor<?> ctor=engineOptionsClass.getConstructor(ctorSig);
      Object[] args={config,context};
      options=(Options)ctor.newInstance(args);
    }
 catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      log.warn("Failed to load engineOptionsClass",e);
      options=new EmbeddedServletOptions(config,context);
    }
  }
 else {
    options=new EmbeddedServletOptions(config,context);
  }
  rctxt=new JspRuntimeContext(context,options);
  if (config.getInitParameter("jspFile") != null) {
    jspFile=config.getInitParameter("jspFile");
    try {
      if (null == context.getResource(jspFile)) {
        throw new ServletException("missing jspFile: [" + jspFile + "]");
      }
    }
 catch (    MalformedURLException e) {
      throw new ServletException("Can not locate jsp file",e);
    }
    try {
      if (SecurityUtil.isPackageProtectionEnabled()) {
        AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){
          @Override public Object run() throws IOException, ServletException {
            serviceJspFile(null,null,jspFile,true);
            return null;
          }
        }
);
      }
 else {
        serviceJspFile(null,null,jspFile,true);
      }
    }
 catch (    IOException e) {
      throw new ServletException("Could not precompile jsp: " + jspFile,e);
    }
catch (    PrivilegedActionException e) {
      Throwable t=e.getCause();
      if (t instanceof ServletException)       throw (ServletException)t;
      throw new ServletException("Could not precompile jsp: " + jspFile,e);
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(Localizer.getMessage("jsp.message.scratch.dir.is",options.getScratchDir().toString()));
    log.debug(Localizer.getMessage("jsp.message.dont.modify.servlets"));
  }
}

ID 6325=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServlet#init(javax.servlet.ServletConfig)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public void init(ServletConfig config) throws ServletException {
  super.init(config);
  this.config=config;
  this.context=config.getServletContext();
  String engineOptionsName=config.getInitParameter("engineOptionsClass");
  if (Constants.IS_SECURITY_ENABLED && engineOptionsName != null) {
    log.info(Localizer.getMessage("jsp.info.ignoreSetting","engineOptionsClass",engineOptionsName));
    engineOptionsName=null;
  }
  if (engineOptionsName != null) {
    try {
      ClassLoader loader=Thread.currentThread().getContextClassLoader();
      Class<?> engineOptionsClass=loader.loadClass(engineOptionsName);
      Class<?>[] ctorSig={ServletConfig.class,ServletContext.class};
      Constructor<?> ctor=engineOptionsClass.getConstructor(ctorSig);
      Object[] args={config,context};
      options=(Options)ctor.newInstance(args);
    }
 catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      log.warn("Failed to load engineOptionsClass",e);
      options=new EmbeddedServletOptions(config,context);
    }
  }
 else {
    options=new EmbeddedServletOptions(config,context);
  }
  rctxt=new JspRuntimeContext(context,options);
  if (config.getInitParameter("jspFile") != null) {
    jspFile=config.getInitParameter("jspFile");
    try {
      if (null == context.getResource(jspFile)) {
        throw new ServletException("missing jspFile: [" + jspFile + "]");
      }
    }
 catch (    MalformedURLException e) {
      throw new ServletException("Can not locate jsp file",e);
    }
    try {
      if (SecurityUtil.isPackageProtectionEnabled()) {
        AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){
          @Override public Object run() throws IOException, ServletException {
            serviceJspFile(null,null,jspFile,true);
            return null;
          }
        }
);
      }
 else {
        serviceJspFile(null,null,jspFile,true);
      }
    }
 catch (    IOException e) {
      throw new ServletException("Could not precompile jsp: " + jspFile,e);
    }
catch (    PrivilegedActionException e) {
      Throwable t=e.getCause();
      if (t instanceof ServletException)       throw (ServletException)t;
      throw new ServletException("Could not precompile jsp: " + jspFile,e);
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(Localizer.getMessage("jsp.message.scratch.dir.is",options.getScratchDir().toString()));
    log.debug(Localizer.getMessage("jsp.message.dont.modify.servlets"));
  }
}

ID 6326=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServlet#init(javax.servlet.ServletConfig)
Rmethod: org.apache.jasper.servlet.JspServlet#serviceJspFile(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void init(ServletConfig config) throws ServletException {
  super.init(config);
  this.config=config;
  this.context=config.getServletContext();
  String engineOptionsName=config.getInitParameter("engineOptionsClass");
  if (Constants.IS_SECURITY_ENABLED && engineOptionsName != null) {
    log.info(Localizer.getMessage("jsp.info.ignoreSetting","engineOptionsClass",engineOptionsName));
    engineOptionsName=null;
  }
  if (engineOptionsName != null) {
    try {
      ClassLoader loader=Thread.currentThread().getContextClassLoader();
      Class<?> engineOptionsClass=loader.loadClass(engineOptionsName);
      Class<?>[] ctorSig={ServletConfig.class,ServletContext.class};
      Constructor<?> ctor=engineOptionsClass.getConstructor(ctorSig);
      Object[] args={config,context};
      options=(Options)ctor.newInstance(args);
    }
 catch (    Throwable e) {
      e=ExceptionUtils.unwrapInvocationTargetException(e);
      ExceptionUtils.handleThrowable(e);
      log.warn("Failed to load engineOptionsClass",e);
      options=new EmbeddedServletOptions(config,context);
    }
  }
 else {
    options=new EmbeddedServletOptions(config,context);
  }
  rctxt=new JspRuntimeContext(context,options);
  if (config.getInitParameter("jspFile") != null) {
    jspFile=config.getInitParameter("jspFile");
    try {
      if (null == context.getResource(jspFile)) {
        throw new ServletException("missing jspFile: [" + jspFile + "]");
      }
    }
 catch (    MalformedURLException e) {
      throw new ServletException("Can not locate jsp file",e);
    }
    try {
      if (SecurityUtil.isPackageProtectionEnabled()) {
        AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){
          @Override public Object run() throws IOException, ServletException {
            serviceJspFile(null,null,jspFile,true);
            return null;
          }
        }
);
      }
 else {
        serviceJspFile(null,null,jspFile,true);
      }
    }
 catch (    IOException e) {
      throw new ServletException("Could not precompile jsp: " + jspFile,e);
    }
catch (    PrivilegedActionException e) {
      Throwable t=e.getCause();
      if (t instanceof ServletException)       throw (ServletException)t;
      throw new ServletException("Could not precompile jsp: " + jspFile,e);
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(Localizer.getMessage("jsp.message.scratch.dir.is",options.getScratchDir().toString()));
    log.debug(Localizer.getMessage("jsp.message.dont.modify.servlets"));
  }
}

ID 6329=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServlet#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.jasper.servlet.JspServlet#preCompile(javax.servlet.http.HttpServletRequest)
parentException: 
thrown: ServletException
exception comment: null
block: 
@SuppressWarnings("deprecation") @Override public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  String jspUri=jspFile;
  if (jspUri == null) {
    String jspFile=(String)request.getAttribute(Constants.JSP_FILE);
    if (jspFile != null) {
      jspUri=jspFile;
      request.removeAttribute(Constants.JSP_FILE);
    }
  }
  if (jspUri == null) {
    jspUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
    if (jspUri != null) {
      String pathInfo=(String)request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);
      if (pathInfo != null) {
        jspUri+=pathInfo;
      }
    }
 else {
      jspUri=request.getServletPath();
      String pathInfo=request.getPathInfo();
      if (pathInfo != null) {
        jspUri+=pathInfo;
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug("JspEngine --> " + jspUri);
    log.debug("\t     ServletPath: " + request.getServletPath());
    log.debug("\t        PathInfo: " + request.getPathInfo());
    log.debug("\t        RealPath: " + context.getRealPath(jspUri));
    log.debug("\t      RequestURI: " + request.getRequestURI());
    log.debug("\t     QueryString: " + request.getQueryString());
  }
  try {
    boolean precompile=preCompile(request);
    serviceJspFile(request,response,jspUri,precompile);
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  IOException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(e);
  }
}

ID 6330=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServlet#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.jasper.servlet.JspServlet#serviceJspFile(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, boolean)
parentException: 
thrown: ServletException
exception comment: null
block: 
@SuppressWarnings("deprecation") @Override public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  String jspUri=jspFile;
  if (jspUri == null) {
    String jspFile=(String)request.getAttribute(Constants.JSP_FILE);
    if (jspFile != null) {
      jspUri=jspFile;
      request.removeAttribute(Constants.JSP_FILE);
    }
  }
  if (jspUri == null) {
    jspUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
    if (jspUri != null) {
      String pathInfo=(String)request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);
      if (pathInfo != null) {
        jspUri+=pathInfo;
      }
    }
 else {
      jspUri=request.getServletPath();
      String pathInfo=request.getPathInfo();
      if (pathInfo != null) {
        jspUri+=pathInfo;
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug("JspEngine --> " + jspUri);
    log.debug("\t     ServletPath: " + request.getServletPath());
    log.debug("\t        PathInfo: " + request.getPathInfo());
    log.debug("\t        RealPath: " + context.getRealPath(jspUri));
    log.debug("\t      RequestURI: " + request.getRequestURI());
    log.debug("\t     QueryString: " + request.getQueryString());
  }
  try {
    boolean precompile=preCompile(request);
    serviceJspFile(request,response,jspUri,precompile);
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  IOException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(e);
  }
}

ID 6331=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServlet#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: org.apache.jasper.servlet.JspServlet#serviceJspFile(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, boolean)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@SuppressWarnings("deprecation") @Override public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  String jspUri=jspFile;
  if (jspUri == null) {
    String jspFile=(String)request.getAttribute(Constants.JSP_FILE);
    if (jspFile != null) {
      jspUri=jspFile;
      request.removeAttribute(Constants.JSP_FILE);
    }
  }
  if (jspUri == null) {
    jspUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
    if (jspUri != null) {
      String pathInfo=(String)request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);
      if (pathInfo != null) {
        jspUri+=pathInfo;
      }
    }
 else {
      jspUri=request.getServletPath();
      String pathInfo=request.getPathInfo();
      if (pathInfo != null) {
        jspUri+=pathInfo;
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug("JspEngine --> " + jspUri);
    log.debug("\t     ServletPath: " + request.getServletPath());
    log.debug("\t        PathInfo: " + request.getPathInfo());
    log.debug("\t        RealPath: " + context.getRealPath(jspUri));
    log.debug("\t      RequestURI: " + request.getRequestURI());
    log.debug("\t     QueryString: " + request.getQueryString());
  }
  try {
    boolean precompile=preCompile(request);
    serviceJspFile(request,response,jspUri,precompile);
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  ServletException e) {
    throw e;
  }
catch (  IOException e) {
    throw e;
  }
catch (  Throwable e) {
    ExceptionUtils.handleThrowable(e);
    throw new ServletException(e);
  }
}

ID 6337=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServlet#serviceJspFile(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.String, boolean)
Rmethod: org.apache.jasper.servlet.JspServletWrapper#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
private void serviceJspFile(HttpServletRequest request,HttpServletResponse response,String jspUri,boolean precompile) throws ServletException, IOException {
  JspServletWrapper wrapper=rctxt.getWrapper(jspUri);
  if (wrapper == null) {
synchronized (this) {
      wrapper=rctxt.getWrapper(jspUri);
      if (wrapper == null) {
        if (null == context.getResource(jspUri)) {
          handleMissingResource(request,response,jspUri);
          return;
        }
        wrapper=new JspServletWrapper(config,options,jspUri,rctxt);
        rctxt.addWrapper(jspUri,wrapper);
      }
    }
  }
  try {
    wrapper.service(request,response,precompile);
  }
 catch (  FileNotFoundException fnfe) {
    handleMissingResource(request,response,jspUri);
  }
}

ID 6346=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServletWrapper#loadTagFile()
Rmethod: org.apache.jasper.JspCompilationContext#compile()
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Compile (if needed) and load a tag file
 */
public Class<?> loadTagFile() throws JasperException {
  try {
    if (ctxt.isRemoved()) {
      throw new FileNotFoundException(jspUri);
    }
    if (options.getDevelopment() || firstTime) {
synchronized (this) {
        firstTime=false;
        ctxt.compile();
      }
    }
 else {
      if (compileException != null) {
        throw compileException;
      }
    }
    if (reload) {
      tagHandlerClass=ctxt.load();
      reload=false;
    }
  }
 catch (  FileNotFoundException ex) {
    throw new JasperException(ex);
  }
  return tagHandlerClass;
}

ID 6353=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServletWrapper#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: javax.servlet.http.HttpServletResponse#sendError(int, java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void service(HttpServletRequest request,HttpServletResponse response,boolean precompile) throws ServletException, IOException, FileNotFoundException {
  Servlet servlet;
  try {
    if (ctxt.isRemoved()) {
      throw new FileNotFoundException(jspUri);
    }
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      if (available > System.currentTimeMillis()) {
        response.setDateHeader("Retry-After",available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,Localizer.getMessage("jsp.error.unavailable"));
        return;
      }
      available=0;
    }
    if (options.getDevelopment() || firstTime) {
synchronized (this) {
        firstTime=false;
        ctxt.compile();
      }
    }
 else {
      if (compileException != null) {
        throw compileException;
      }
    }
    servlet=getServlet();
    if (precompile) {
      return;
    }
  }
 catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  FileNotFoundException fnfe) {
    throw fnfe;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
  try {
    if (unloadAllowed) {
synchronized (this) {
        if (unloadByCount) {
          if (unloadHandle == null) {
            unloadHandle=ctxt.getRuntimeContext().push(this);
          }
 else           if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            ctxt.getRuntimeContext().makeYoungest(unloadHandle);
            lastUsageTime=System.currentTimeMillis();
          }
        }
 else {
          if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            lastUsageTime=System.currentTimeMillis();
          }
        }
      }
    }
    if (servlet instanceof SingleThreadModel) {
synchronized (this) {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
  }
 catch (  UnavailableException ex) {
    String includeRequestUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);
    if (includeRequestUri != null) {
      throw ex;
    }
    int unavailableSeconds=ex.getUnavailableSeconds();
    if (unavailableSeconds <= 0) {
      unavailableSeconds=60;
    }
    available=System.currentTimeMillis() + (unavailableSeconds * 1000L);
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,ex.getMessage());
  }
catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw new IOException(handleJspException(ex).getMessage(),ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
}

ID 6354=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServletWrapper#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: org.apache.jasper.JspCompilationContext#compile()
parentException: ServletException 
thrown: JasperException
exception comment: null
block: 
public void service(HttpServletRequest request,HttpServletResponse response,boolean precompile) throws ServletException, IOException, FileNotFoundException {
  Servlet servlet;
  try {
    if (ctxt.isRemoved()) {
      throw new FileNotFoundException(jspUri);
    }
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      if (available > System.currentTimeMillis()) {
        response.setDateHeader("Retry-After",available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,Localizer.getMessage("jsp.error.unavailable"));
        return;
      }
      available=0;
    }
    if (options.getDevelopment() || firstTime) {
synchronized (this) {
        firstTime=false;
        ctxt.compile();
      }
    }
 else {
      if (compileException != null) {
        throw compileException;
      }
    }
    servlet=getServlet();
    if (precompile) {
      return;
    }
  }
 catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  FileNotFoundException fnfe) {
    throw fnfe;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
  try {
    if (unloadAllowed) {
synchronized (this) {
        if (unloadByCount) {
          if (unloadHandle == null) {
            unloadHandle=ctxt.getRuntimeContext().push(this);
          }
 else           if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            ctxt.getRuntimeContext().makeYoungest(unloadHandle);
            lastUsageTime=System.currentTimeMillis();
          }
        }
 else {
          if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            lastUsageTime=System.currentTimeMillis();
          }
        }
      }
    }
    if (servlet instanceof SingleThreadModel) {
synchronized (this) {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
  }
 catch (  UnavailableException ex) {
    String includeRequestUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);
    if (includeRequestUri != null) {
      throw ex;
    }
    int unavailableSeconds=ex.getUnavailableSeconds();
    if (unavailableSeconds <= 0) {
      unavailableSeconds=60;
    }
    available=System.currentTimeMillis() + (unavailableSeconds * 1000L);
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,ex.getMessage());
  }
catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw new IOException(handleJspException(ex).getMessage(),ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
}

ID 6355=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServletWrapper#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: org.apache.jasper.JspCompilationContext#compile()
parentException: IOException 
thrown: FileNotFoundException
exception comment: /** 
 * Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the  {@link FileInputStream},  {@link FileOutputStream}, and  {@link RandomAccessFile} constructors when a filewith the specified pathname does not exist.  It will also be thrown by these constructors if the file does exist but for some reason is inaccessible, for example when an attempt is made to open a read-only file for writing.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public void service(HttpServletRequest request,HttpServletResponse response,boolean precompile) throws ServletException, IOException, FileNotFoundException {
  Servlet servlet;
  try {
    if (ctxt.isRemoved()) {
      throw new FileNotFoundException(jspUri);
    }
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      if (available > System.currentTimeMillis()) {
        response.setDateHeader("Retry-After",available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,Localizer.getMessage("jsp.error.unavailable"));
        return;
      }
      available=0;
    }
    if (options.getDevelopment() || firstTime) {
synchronized (this) {
        firstTime=false;
        ctxt.compile();
      }
    }
 else {
      if (compileException != null) {
        throw compileException;
      }
    }
    servlet=getServlet();
    if (precompile) {
      return;
    }
  }
 catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  FileNotFoundException fnfe) {
    throw fnfe;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
  try {
    if (unloadAllowed) {
synchronized (this) {
        if (unloadByCount) {
          if (unloadHandle == null) {
            unloadHandle=ctxt.getRuntimeContext().push(this);
          }
 else           if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            ctxt.getRuntimeContext().makeYoungest(unloadHandle);
            lastUsageTime=System.currentTimeMillis();
          }
        }
 else {
          if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            lastUsageTime=System.currentTimeMillis();
          }
        }
      }
    }
    if (servlet instanceof SingleThreadModel) {
synchronized (this) {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
  }
 catch (  UnavailableException ex) {
    String includeRequestUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);
    if (includeRequestUri != null) {
      throw ex;
    }
    int unavailableSeconds=ex.getUnavailableSeconds();
    if (unavailableSeconds <= 0) {
      unavailableSeconds=60;
    }
    available=System.currentTimeMillis() + (unavailableSeconds * 1000L);
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,ex.getMessage());
  }
catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw new IOException(handleJspException(ex).getMessage(),ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
}

ID 6356=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServletWrapper#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: org.apache.jasper.servlet.JspServletWrapper#getServlet()
parentException: 
thrown: ServletException
exception comment: null
block: 
public void service(HttpServletRequest request,HttpServletResponse response,boolean precompile) throws ServletException, IOException, FileNotFoundException {
  Servlet servlet;
  try {
    if (ctxt.isRemoved()) {
      throw new FileNotFoundException(jspUri);
    }
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      if (available > System.currentTimeMillis()) {
        response.setDateHeader("Retry-After",available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,Localizer.getMessage("jsp.error.unavailable"));
        return;
      }
      available=0;
    }
    if (options.getDevelopment() || firstTime) {
synchronized (this) {
        firstTime=false;
        ctxt.compile();
      }
    }
 else {
      if (compileException != null) {
        throw compileException;
      }
    }
    servlet=getServlet();
    if (precompile) {
      return;
    }
  }
 catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  FileNotFoundException fnfe) {
    throw fnfe;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
  try {
    if (unloadAllowed) {
synchronized (this) {
        if (unloadByCount) {
          if (unloadHandle == null) {
            unloadHandle=ctxt.getRuntimeContext().push(this);
          }
 else           if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            ctxt.getRuntimeContext().makeYoungest(unloadHandle);
            lastUsageTime=System.currentTimeMillis();
          }
        }
 else {
          if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            lastUsageTime=System.currentTimeMillis();
          }
        }
      }
    }
    if (servlet instanceof SingleThreadModel) {
synchronized (this) {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
  }
 catch (  UnavailableException ex) {
    String includeRequestUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);
    if (includeRequestUri != null) {
      throw ex;
    }
    int unavailableSeconds=ex.getUnavailableSeconds();
    if (unavailableSeconds <= 0) {
      unavailableSeconds=60;
    }
    available=System.currentTimeMillis() + (unavailableSeconds * 1000L);
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,ex.getMessage());
  }
catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw new IOException(handleJspException(ex).getMessage(),ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
}

ID 6357=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServletWrapper#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: javax.servlet.Servlet#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: ServletException
exception comment: null
block: 
public void service(HttpServletRequest request,HttpServletResponse response,boolean precompile) throws ServletException, IOException, FileNotFoundException {
  Servlet servlet;
  try {
    if (ctxt.isRemoved()) {
      throw new FileNotFoundException(jspUri);
    }
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      if (available > System.currentTimeMillis()) {
        response.setDateHeader("Retry-After",available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,Localizer.getMessage("jsp.error.unavailable"));
        return;
      }
      available=0;
    }
    if (options.getDevelopment() || firstTime) {
synchronized (this) {
        firstTime=false;
        ctxt.compile();
      }
    }
 else {
      if (compileException != null) {
        throw compileException;
      }
    }
    servlet=getServlet();
    if (precompile) {
      return;
    }
  }
 catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  FileNotFoundException fnfe) {
    throw fnfe;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
  try {
    if (unloadAllowed) {
synchronized (this) {
        if (unloadByCount) {
          if (unloadHandle == null) {
            unloadHandle=ctxt.getRuntimeContext().push(this);
          }
 else           if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            ctxt.getRuntimeContext().makeYoungest(unloadHandle);
            lastUsageTime=System.currentTimeMillis();
          }
        }
 else {
          if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            lastUsageTime=System.currentTimeMillis();
          }
        }
      }
    }
    if (servlet instanceof SingleThreadModel) {
synchronized (this) {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
  }
 catch (  UnavailableException ex) {
    String includeRequestUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);
    if (includeRequestUri != null) {
      throw ex;
    }
    int unavailableSeconds=ex.getUnavailableSeconds();
    if (unavailableSeconds <= 0) {
      unavailableSeconds=60;
    }
    available=System.currentTimeMillis() + (unavailableSeconds * 1000L);
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,ex.getMessage());
  }
catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw new IOException(handleJspException(ex).getMessage(),ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
}

ID 6358=========================================================================type: 1
Method:org.apache.jasper.servlet.JspServletWrapper#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, boolean)
Rmethod: javax.servlet.Servlet#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void service(HttpServletRequest request,HttpServletResponse response,boolean precompile) throws ServletException, IOException, FileNotFoundException {
  Servlet servlet;
  try {
    if (ctxt.isRemoved()) {
      throw new FileNotFoundException(jspUri);
    }
    if ((available > 0L) && (available < Long.MAX_VALUE)) {
      if (available > System.currentTimeMillis()) {
        response.setDateHeader("Retry-After",available);
        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,Localizer.getMessage("jsp.error.unavailable"));
        return;
      }
      available=0;
    }
    if (options.getDevelopment() || firstTime) {
synchronized (this) {
        firstTime=false;
        ctxt.compile();
      }
    }
 else {
      if (compileException != null) {
        throw compileException;
      }
    }
    servlet=getServlet();
    if (precompile) {
      return;
    }
  }
 catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  FileNotFoundException fnfe) {
    throw fnfe;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
  try {
    if (unloadAllowed) {
synchronized (this) {
        if (unloadByCount) {
          if (unloadHandle == null) {
            unloadHandle=ctxt.getRuntimeContext().push(this);
          }
 else           if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            ctxt.getRuntimeContext().makeYoungest(unloadHandle);
            lastUsageTime=System.currentTimeMillis();
          }
        }
 else {
          if (lastUsageTime < ctxt.getRuntimeContext().getLastJspQueueUpdate()) {
            lastUsageTime=System.currentTimeMillis();
          }
        }
      }
    }
    if (servlet instanceof SingleThreadModel) {
synchronized (this) {
        servlet.service(request,response);
      }
    }
 else {
      servlet.service(request,response);
    }
  }
 catch (  UnavailableException ex) {
    String includeRequestUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);
    if (includeRequestUri != null) {
      throw ex;
    }
    int unavailableSeconds=ex.getUnavailableSeconds();
    if (unavailableSeconds <= 0) {
      unavailableSeconds=60;
    }
    available=System.currentTimeMillis() + (unavailableSeconds * 1000L);
    response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,ex.getMessage());
  }
catch (  ServletException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  IOException ex) {
    if (options.getDevelopment()) {
      throw new IOException(handleJspException(ex).getMessage(),ex);
    }
    throw ex;
  }
catch (  IllegalStateException ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw ex;
  }
catch (  Exception ex) {
    if (options.getDevelopment()) {
      throw handleJspException(ex);
    }
    throw new JasperException(ex);
  }
}

ID 6369=========================================================================type: 1
Method:org.apache.jasper.security.SecurityClassLoad#securityClassLoad(java.lang.ClassLoader)
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
public static void securityClassLoad(ClassLoader loader){
  if (System.getSecurityManager() == null) {
    return;
  }
  final String basePackage="org.apache.jasper.";
  try {
    loader.loadClass(basePackage + "runtime.JspFactoryImpl$PrivilegedGetPageContext");
    loader.loadClass(basePackage + "runtime.JspFactoryImpl$PrivilegedReleasePageContext");
    loader.loadClass(basePackage + "runtime.JspRuntimeLibrary");
    loader.loadClass(basePackage + "runtime.ServletResponseWrapperInclude");
    loader.loadClass(basePackage + "runtime.TagHandlerPool");
    loader.loadClass(basePackage + "runtime.JspFragmentHelper");
    loader.loadClass(basePackage + "runtime.ProtectedFunctionMapper");
    loader.loadClass(basePackage + "runtime.PageContextImpl");
    loader.loadClass(basePackage + "runtime.PageContextImpl$1");
    loader.loadClass(basePackage + "runtime.PageContextImpl$2");
    loader.loadClass(basePackage + "runtime.PageContextImpl$3");
    loader.loadClass(basePackage + "runtime.PageContextImpl$4");
    loader.loadClass(basePackage + "runtime.PageContextImpl$5");
    loader.loadClass(basePackage + "runtime.PageContextImpl$6");
    loader.loadClass(basePackage + "runtime.PageContextImpl$7");
    loader.loadClass(basePackage + "runtime.PageContextImpl$8");
    loader.loadClass(basePackage + "runtime.PageContextImpl$9");
    loader.loadClass(basePackage + "runtime.PageContextImpl$10");
    loader.loadClass(basePackage + "runtime.PageContextImpl$11");
    loader.loadClass(basePackage + "runtime.PageContextImpl$12");
    loader.loadClass(basePackage + "runtime.JspContextWrapper");
    SecurityUtil.isPackageProtectionEnabled();
    loader.loadClass(basePackage + "servlet.JspServletWrapper");
    loader.loadClass(basePackage + "runtime.JspWriterImpl$1");
  }
 catch (  ClassNotFoundException ex) {
    log.error("SecurityClassLoad",ex);
  }
}

ID 6376=========================================================================type: 1
Method:org.apache.jasper.el.ELResolverImpl#getValue(javax.el.ELContext, java.lang.Object, java.lang.Object)
Rmethod: javax.servlet.jsp.el.VariableResolver#resolveVariable(java.lang.String)
parentException: 
thrown: ELException
exception comment: null
block: 
@Override public Object getValue(ELContext context,Object base,Object property) throws NullPointerException, PropertyNotFoundException, ELException {
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null) {
    context.setPropertyResolved(true);
    if (property != null) {
      try {
        return this.variableResolver.resolveVariable(property.toString());
      }
 catch (      javax.servlet.jsp.el.ELException e) {
        throw new ELException(e.getMessage(),e.getCause());
      }
    }
  }
  if (!context.isPropertyResolved()) {
    return elResolver.getValue(context,base,property);
  }
  return null;
}

ID 6380=========================================================================type: 1
Method:org.apache.jasper.el.ELResolverImpl#getType(javax.el.ELContext, java.lang.Object, java.lang.Object)
Rmethod: javax.servlet.jsp.el.VariableResolver#resolveVariable(java.lang.String)
parentException: 
thrown: ELException
exception comment: null
block: 
@Override public Class<?> getType(ELContext context,Object base,Object property) throws NullPointerException, PropertyNotFoundException, ELException {
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null) {
    context.setPropertyResolved(true);
    if (property != null) {
      try {
        Object obj=this.variableResolver.resolveVariable(property.toString());
        return (obj != null) ? obj.getClass() : null;
      }
 catch (      javax.servlet.jsp.el.ELException e) {
        throw new ELException(e.getMessage(),e.getCause());
      }
    }
  }
  if (!context.isPropertyResolved()) {
    return elResolver.getType(context,base,property);
  }
  return null;
}

ID 6393=========================================================================type: 1
Method:org.apache.jasper.el.JspMethodExpression#getMethodInfo(javax.el.ELContext)
Rmethod: javax.el.MethodExpression#getMethodInfo(javax.el.ELContext)
parentException: ELException RuntimeException 
thrown: PropertyNotFoundException
exception comment: null
block: 
@Override public MethodInfo getMethodInfo(ELContext context) throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException {
  try {
    return this.target.getMethodInfo(context);
  }
 catch (  MethodNotFoundException e) {
    if (e instanceof JspMethodNotFoundException)     throw e;
    throw new JspMethodNotFoundException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6394=========================================================================type: 1
Method:org.apache.jasper.el.JspMethodExpression#getMethodInfo(javax.el.ELContext)
Rmethod: javax.el.MethodExpression#getMethodInfo(javax.el.ELContext)
parentException: ELException RuntimeException 
thrown: MethodNotFoundException
exception comment: null
block: 
@Override public MethodInfo getMethodInfo(ELContext context) throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException {
  try {
    return this.target.getMethodInfo(context);
  }
 catch (  MethodNotFoundException e) {
    if (e instanceof JspMethodNotFoundException)     throw e;
    throw new JspMethodNotFoundException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6395=========================================================================type: 1
Method:org.apache.jasper.el.JspMethodExpression#getMethodInfo(javax.el.ELContext)
Rmethod: javax.el.MethodExpression#getMethodInfo(javax.el.ELContext)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public MethodInfo getMethodInfo(ELContext context) throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException {
  try {
    return this.target.getMethodInfo(context);
  }
 catch (  MethodNotFoundException e) {
    if (e instanceof JspMethodNotFoundException)     throw e;
    throw new JspMethodNotFoundException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6397=========================================================================type: 1
Method:org.apache.jasper.el.JspMethodExpression#invoke(javax.el.ELContext, java.lang.Object[])
Rmethod: javax.el.MethodExpression#invoke(javax.el.ELContext, java.lang.Object[])
parentException: ELException RuntimeException 
thrown: PropertyNotFoundException
exception comment: null
block: 
@Override public Object invoke(ELContext context,Object[] params) throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException {
  try {
    return this.target.invoke(context,params);
  }
 catch (  MethodNotFoundException e) {
    if (e instanceof JspMethodNotFoundException)     throw e;
    throw new JspMethodNotFoundException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6398=========================================================================type: 1
Method:org.apache.jasper.el.JspMethodExpression#invoke(javax.el.ELContext, java.lang.Object[])
Rmethod: javax.el.MethodExpression#invoke(javax.el.ELContext, java.lang.Object[])
parentException: ELException RuntimeException 
thrown: MethodNotFoundException
exception comment: null
block: 
@Override public Object invoke(ELContext context,Object[] params) throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException {
  try {
    return this.target.invoke(context,params);
  }
 catch (  MethodNotFoundException e) {
    if (e instanceof JspMethodNotFoundException)     throw e;
    throw new JspMethodNotFoundException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6399=========================================================================type: 1
Method:org.apache.jasper.el.JspMethodExpression#invoke(javax.el.ELContext, java.lang.Object[])
Rmethod: javax.el.MethodExpression#invoke(javax.el.ELContext, java.lang.Object[])
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public Object invoke(ELContext context,Object[] params) throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException {
  try {
    return this.target.invoke(context,params);
  }
 catch (  MethodNotFoundException e) {
    if (e instanceof JspMethodNotFoundException)     throw e;
    throw new JspMethodNotFoundException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6406=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#getType(javax.el.ELContext)
Rmethod: javax.el.ValueExpression#getType(javax.el.ELContext)
parentException: ELException RuntimeException 
thrown: PropertyNotFoundException
exception comment: null
block: 
@Override public Class<?> getType(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException {
  try {
    return this.target.getType(context);
  }
 catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6407=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#getType(javax.el.ELContext)
Rmethod: javax.el.ValueExpression#getType(javax.el.ELContext)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public Class<?> getType(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException {
  try {
    return this.target.getType(context);
  }
 catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6409=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#isReadOnly(javax.el.ELContext)
Rmethod: javax.el.ValueExpression#isReadOnly(javax.el.ELContext)
parentException: ELException RuntimeException 
thrown: PropertyNotFoundException
exception comment: null
block: 
@Override public boolean isReadOnly(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException {
  try {
    return this.target.isReadOnly(context);
  }
 catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6410=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#isReadOnly(javax.el.ELContext)
Rmethod: javax.el.ValueExpression#isReadOnly(javax.el.ELContext)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public boolean isReadOnly(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException {
  try {
    return this.target.isReadOnly(context);
  }
 catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6412=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#setValue(javax.el.ELContext, java.lang.Object)
Rmethod: javax.el.ValueExpression#setValue(javax.el.ELContext, java.lang.Object)
parentException: ELException RuntimeException 
thrown: PropertyNotFoundException
exception comment: null
block: 
@Override public void setValue(ELContext context,Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException {
  try {
    this.target.setValue(context,value);
  }
 catch (  PropertyNotWritableException e) {
    if (e instanceof JspPropertyNotWritableException)     throw e;
    throw new JspPropertyNotWritableException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6413=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#setValue(javax.el.ELContext, java.lang.Object)
Rmethod: javax.el.ValueExpression#setValue(javax.el.ELContext, java.lang.Object)
parentException: ELException RuntimeException 
thrown: PropertyNotWritableException
exception comment: null
block: 
@Override public void setValue(ELContext context,Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException {
  try {
    this.target.setValue(context,value);
  }
 catch (  PropertyNotWritableException e) {
    if (e instanceof JspPropertyNotWritableException)     throw e;
    throw new JspPropertyNotWritableException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6414=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#setValue(javax.el.ELContext, java.lang.Object)
Rmethod: javax.el.ValueExpression#setValue(javax.el.ELContext, java.lang.Object)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public void setValue(ELContext context,Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException {
  try {
    this.target.setValue(context,value);
  }
 catch (  PropertyNotWritableException e) {
    if (e instanceof JspPropertyNotWritableException)     throw e;
    throw new JspPropertyNotWritableException(this.mark,e);
  }
catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6416=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#getValue(javax.el.ELContext)
Rmethod: javax.el.ValueExpression#getValue(javax.el.ELContext)
parentException: ELException RuntimeException 
thrown: PropertyNotFoundException
exception comment: null
block: 
@Override public Object getValue(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException {
  try {
    return this.target.getValue(context);
  }
 catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6417=========================================================================type: 1
Method:org.apache.jasper.el.JspValueExpression#getValue(javax.el.ELContext)
Rmethod: javax.el.ValueExpression#getValue(javax.el.ELContext)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public Object getValue(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException {
  try {
    return this.target.getValue(context);
  }
 catch (  PropertyNotFoundException e) {
    if (e instanceof JspPropertyNotFoundException)     throw e;
    throw new JspPropertyNotFoundException(this.mark,e);
  }
catch (  ELException e) {
    if (e instanceof JspELException)     throw e;
    throw new JspELException(this.mark,e);
  }
}

ID 6425=========================================================================type: 1
Method:org.apache.jasper.el.ExpressionEvaluatorImpl#parseExpression(java.lang.String, Class#RAW, javax.servlet.jsp.el.FunctionMapper)
Rmethod: javax.el.ExpressionFactory#createValueExpression(javax.el.ELContext, java.lang.String, Class<?>)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
@Override public Expression parseExpression(String expression,@SuppressWarnings("rawtypes") Class expectedType,FunctionMapper fMapper) throws ELException {
  try {
    ELContextImpl ctx=new ELContextImpl(ELContextImpl.getDefaultResolver());
    if (fMapper != null) {
      ctx.setFunctionMapper(new FunctionMapperImpl(fMapper));
    }
    ValueExpression ve=this.factory.createValueExpression(ctx,expression,expectedType);
    return new ExpressionImpl(ve);
  }
 catch (  javax.el.ELException e) {
    throw new ELParseException(e.getMessage());
  }
}

ID 6428=========================================================================type: 1
Method:org.apache.jasper.JspC#main(java.lang.String[])
Rmethod: org.apache.jasper.JspC#setArgs(java.lang.String[])
parentException: ServletException 
thrown: JasperException
exception comment: null
block: 
public static void main(String arg[]){
  if (arg.length == 0) {
    System.out.println(Localizer.getMessage("jspc.usage"));
  }
 else {
    JspC jspc=new JspC();
    try {
      jspc.setArgs(arg);
      if (jspc.helpNeeded) {
        System.out.println(Localizer.getMessage("jspc.usage"));
      }
 else {
        jspc.execute();
      }
    }
 catch (    JasperException je) {
      System.err.println(je);
      if (jspc.dieLevel != NO_DIE_LEVEL) {
        System.exit(jspc.dieLevel);
      }
    }
catch (    BuildException je) {
      System.err.println(je);
      if (jspc.dieLevel != NO_DIE_LEVEL) {
        System.exit(jspc.dieLevel);
      }
    }
  }
}

ID 6429=========================================================================type: 1
Method:org.apache.jasper.JspC#setArgs(java.lang.String[])
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Apply command-line arguments.
 * @param arg The arguments
 */
public void setArgs(String[] arg) throws JasperException {
  args=arg;
  String tok;
  dieLevel=NO_DIE_LEVEL;
  while ((tok=nextArg()) != null) {
    if (tok.equals(SWITCH_VERBOSE)) {
      verbose=true;
      showSuccess=true;
      listErrors=true;
    }
 else     if (tok.equals(SWITCH_OUTPUT_DIR)) {
      tok=nextArg();
      setOutputDir(tok);
    }
 else     if (tok.equals(SWITCH_PACKAGE_NAME)) {
      targetPackage=nextArg();
    }
 else     if (tok.equals(SWITCH_COMPILE)) {
      compile=true;
    }
 else     if (tok.equals(SWITCH_CLASS_NAME)) {
      targetClassName=nextArg();
    }
 else     if (tok.equals(SWITCH_URI_BASE)) {
      uriBase=nextArg();
    }
 else     if (tok.equals(SWITCH_URI_ROOT)) {
      setUriroot(nextArg());
    }
 else     if (tok.equals(SWITCH_FILE_WEBAPP)) {
      setUriroot(nextArg());
    }
 else     if (tok.equals(SHOW_SUCCESS)) {
      showSuccess=true;
    }
 else     if (tok.equals(LIST_ERRORS)) {
      listErrors=true;
    }
 else     if (tok.equals(SWITCH_WEBAPP_INC)) {
      webxmlFile=nextArg();
      if (webxmlFile != null) {
        webxmlLevel=INC_WEBXML;
      }
    }
 else     if (tok.equals(SWITCH_WEBAPP_XML)) {
      webxmlFile=nextArg();
      if (webxmlFile != null) {
        webxmlLevel=ALL_WEBXML;
      }
    }
 else     if (tok.equals(SWITCH_WEBAPP_XML_ENCODING)) {
      setWebXmlEncoding(nextArg());
    }
 else     if (tok.equals(SWITCH_ADD_WEBAPP_XML_MAPPINGS)) {
      setAddWebXmlMappings(true);
    }
 else     if (tok.equals(SWITCH_MAPPED)) {
      mappedFile=true;
    }
 else     if (tok.equals(SWITCH_XPOWERED_BY)) {
      xpoweredBy=true;
    }
 else     if (tok.equals(SWITCH_TRIM_SPACES)) {
      setTrimSpaces(true);
    }
 else     if (tok.equals(SWITCH_CACHE)) {
      tok=nextArg();
      if ("false".equals(tok)) {
        caching=false;
      }
 else {
        caching=true;
      }
    }
 else     if (tok.equals(SWITCH_CLASSPATH)) {
      setClassPath(nextArg());
    }
 else     if (tok.startsWith(SWITCH_DIE)) {
      try {
        dieLevel=Integer.parseInt(tok.substring(SWITCH_DIE.length()));
      }
 catch (      NumberFormatException nfe) {
        dieLevel=DEFAULT_DIE_LEVEL;
      }
    }
 else     if (tok.equals(SWITCH_HELP)) {
      helpNeeded=true;
    }
 else     if (tok.equals(SWITCH_POOLING)) {
      tok=nextArg();
      if ("false".equals(tok)) {
        poolingEnabled=false;
      }
 else {
        poolingEnabled=true;
      }
    }
 else     if (tok.equals(SWITCH_ENCODING)) {
      setJavaEncoding(nextArg());
    }
 else     if (tok.equals(SWITCH_SOURCE)) {
      setCompilerSourceVM(nextArg());
    }
 else     if (tok.equals(SWITCH_TARGET)) {
      setCompilerTargetVM(nextArg());
    }
 else     if (tok.equals(SWITCH_SMAP)) {
      smapSuppressed=false;
    }
 else     if (tok.equals(SWITCH_DUMP_SMAP)) {
      smapDumped=true;
    }
 else     if (tok.equals(SWITCH_VALIDATE_TLD)) {
      setValidateTld(true);
    }
 else     if (tok.equals(SWITCH_VALIDATE_XML)) {
      setValidateXml(true);
    }
 else     if (tok.equals(SWITCH_BLOCK_EXTERNAL)) {
      setBlockExternal(true);
    }
 else     if (tok.equals(SWITCH_NO_BLOCK_EXTERNAL)) {
      setBlockExternal(false);
    }
 else     if (tok.equals(SWITCH_QUOTE_ATTRIBUTE_EL)) {
      setQuoteAttributeEL(true);
    }
 else     if (tok.equals(SWITCH_NO_QUOTE_ATTRIBUTE_EL)) {
      setQuoteAttributeEL(false);
    }
 else {
      if (tok.startsWith("-")) {
        throw new JasperException("Unrecognized option: " + tok + ".  Use -help for help.");
      }
      if (!fullstop) {
        argPos--;
      }
      break;
    }
  }
  while (true) {
    String file=nextFile();
    if (file == null) {
      break;
    }
    pages.add(file);
  }
}

ID 6447=========================================================================type: 1
Method:org.apache.jasper.JspC#execute()
Rmethod: org.apache.jasper.JspC#initClassLoader()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Executes the compilation.
 */
@Override public void execute(){
  if (log.isDebugEnabled()) {
    log.debug("execute() starting for " + pages.size() + " pages.");
  }
  try {
    if (uriRoot == null) {
      if (pages.size() == 0) {
        throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget"));
      }
      String firstJsp=pages.get(0);
      File firstJspF=new File(firstJsp);
      if (!firstJspF.exists()) {
        throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist",firstJsp));
      }
      locateUriRoot(firstJspF);
    }
    if (uriRoot == null) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot"));
    }
    File uriRootF=new File(uriRoot);
    if (!uriRootF.isDirectory()) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));
    }
    if (loader == null) {
      loader=initClassLoader();
    }
    if (context == null) {
      initServletContext(loader);
    }
    if (pages.size() == 0) {
      scanFiles(uriRootF);
    }
    initWebXml();
    Iterator<String> iter=pages.iterator();
    while (iter.hasNext()) {
      String nextjsp=iter.next();
      File fjsp=new File(nextjsp);
      if (!fjsp.isAbsolute()) {
        fjsp=new File(uriRootF,nextjsp);
      }
      if (!fjsp.exists()) {
        if (log.isWarnEnabled()) {
          log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist",fjsp.toString()));
        }
        continue;
      }
      String s=fjsp.getAbsolutePath();
      if (s.startsWith(uriRoot)) {
        nextjsp=s.substring(uriRoot.length());
      }
      if (nextjsp.startsWith("." + File.separatorChar)) {
        nextjsp=nextjsp.substring(2);
      }
      processFile(nextjsp);
    }
    completeWebXml();
    if (addWebXmlMappings) {
      mergeIntoWebXml();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(ioe);
  }
catch (  JasperException je) {
    Throwable rootCause=je;
    while (rootCause instanceof JasperException && ((JasperException)rootCause).getRootCause() != null) {
      rootCause=((JasperException)rootCause).getRootCause();
    }
    if (rootCause != je) {
      rootCause.printStackTrace();
    }
    throw new BuildException(je);
  }
 finally {
    if (loader != null) {
      LogFactory.release(loader);
    }
  }
}

ID 6448=========================================================================type: 1
Method:org.apache.jasper.JspC#execute()
Rmethod: org.apache.jasper.JspC#initServletContext(java.lang.ClassLoader)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Executes the compilation.
 */
@Override public void execute(){
  if (log.isDebugEnabled()) {
    log.debug("execute() starting for " + pages.size() + " pages.");
  }
  try {
    if (uriRoot == null) {
      if (pages.size() == 0) {
        throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget"));
      }
      String firstJsp=pages.get(0);
      File firstJspF=new File(firstJsp);
      if (!firstJspF.exists()) {
        throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist",firstJsp));
      }
      locateUriRoot(firstJspF);
    }
    if (uriRoot == null) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot"));
    }
    File uriRootF=new File(uriRoot);
    if (!uriRootF.isDirectory()) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));
    }
    if (loader == null) {
      loader=initClassLoader();
    }
    if (context == null) {
      initServletContext(loader);
    }
    if (pages.size() == 0) {
      scanFiles(uriRootF);
    }
    initWebXml();
    Iterator<String> iter=pages.iterator();
    while (iter.hasNext()) {
      String nextjsp=iter.next();
      File fjsp=new File(nextjsp);
      if (!fjsp.isAbsolute()) {
        fjsp=new File(uriRootF,nextjsp);
      }
      if (!fjsp.exists()) {
        if (log.isWarnEnabled()) {
          log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist",fjsp.toString()));
        }
        continue;
      }
      String s=fjsp.getAbsolutePath();
      if (s.startsWith(uriRoot)) {
        nextjsp=s.substring(uriRoot.length());
      }
      if (nextjsp.startsWith("." + File.separatorChar)) {
        nextjsp=nextjsp.substring(2);
      }
      processFile(nextjsp);
    }
    completeWebXml();
    if (addWebXmlMappings) {
      mergeIntoWebXml();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(ioe);
  }
catch (  JasperException je) {
    Throwable rootCause=je;
    while (rootCause instanceof JasperException && ((JasperException)rootCause).getRootCause() != null) {
      rootCause=((JasperException)rootCause).getRootCause();
    }
    if (rootCause != je) {
      rootCause.printStackTrace();
    }
    throw new BuildException(je);
  }
 finally {
    if (loader != null) {
      LogFactory.release(loader);
    }
  }
}

ID 6449=========================================================================type: 1
Method:org.apache.jasper.JspC#execute()
Rmethod: org.apache.jasper.JspC#initServletContext(java.lang.ClassLoader)
parentException: ServletException 
thrown: JasperException
exception comment: null
block: 
/** 
 * Executes the compilation.
 */
@Override public void execute(){
  if (log.isDebugEnabled()) {
    log.debug("execute() starting for " + pages.size() + " pages.");
  }
  try {
    if (uriRoot == null) {
      if (pages.size() == 0) {
        throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget"));
      }
      String firstJsp=pages.get(0);
      File firstJspF=new File(firstJsp);
      if (!firstJspF.exists()) {
        throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist",firstJsp));
      }
      locateUriRoot(firstJspF);
    }
    if (uriRoot == null) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot"));
    }
    File uriRootF=new File(uriRoot);
    if (!uriRootF.isDirectory()) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));
    }
    if (loader == null) {
      loader=initClassLoader();
    }
    if (context == null) {
      initServletContext(loader);
    }
    if (pages.size() == 0) {
      scanFiles(uriRootF);
    }
    initWebXml();
    Iterator<String> iter=pages.iterator();
    while (iter.hasNext()) {
      String nextjsp=iter.next();
      File fjsp=new File(nextjsp);
      if (!fjsp.isAbsolute()) {
        fjsp=new File(uriRootF,nextjsp);
      }
      if (!fjsp.exists()) {
        if (log.isWarnEnabled()) {
          log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist",fjsp.toString()));
        }
        continue;
      }
      String s=fjsp.getAbsolutePath();
      if (s.startsWith(uriRoot)) {
        nextjsp=s.substring(uriRoot.length());
      }
      if (nextjsp.startsWith("." + File.separatorChar)) {
        nextjsp=nextjsp.substring(2);
      }
      processFile(nextjsp);
    }
    completeWebXml();
    if (addWebXmlMappings) {
      mergeIntoWebXml();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(ioe);
  }
catch (  JasperException je) {
    Throwable rootCause=je;
    while (rootCause instanceof JasperException && ((JasperException)rootCause).getRootCause() != null) {
      rootCause=((JasperException)rootCause).getRootCause();
    }
    if (rootCause != je) {
      rootCause.printStackTrace();
    }
    throw new BuildException(je);
  }
 finally {
    if (loader != null) {
      LogFactory.release(loader);
    }
  }
}

ID 6450=========================================================================type: 1
Method:org.apache.jasper.JspC#execute()
Rmethod: org.apache.jasper.JspC#scanFiles(java.io.File)
parentException: ServletException 
thrown: JasperException
exception comment: null
block: 
/** 
 * Executes the compilation.
 */
@Override public void execute(){
  if (log.isDebugEnabled()) {
    log.debug("execute() starting for " + pages.size() + " pages.");
  }
  try {
    if (uriRoot == null) {
      if (pages.size() == 0) {
        throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget"));
      }
      String firstJsp=pages.get(0);
      File firstJspF=new File(firstJsp);
      if (!firstJspF.exists()) {
        throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist",firstJsp));
      }
      locateUriRoot(firstJspF);
    }
    if (uriRoot == null) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot"));
    }
    File uriRootF=new File(uriRoot);
    if (!uriRootF.isDirectory()) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));
    }
    if (loader == null) {
      loader=initClassLoader();
    }
    if (context == null) {
      initServletContext(loader);
    }
    if (pages.size() == 0) {
      scanFiles(uriRootF);
    }
    initWebXml();
    Iterator<String> iter=pages.iterator();
    while (iter.hasNext()) {
      String nextjsp=iter.next();
      File fjsp=new File(nextjsp);
      if (!fjsp.isAbsolute()) {
        fjsp=new File(uriRootF,nextjsp);
      }
      if (!fjsp.exists()) {
        if (log.isWarnEnabled()) {
          log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist",fjsp.toString()));
        }
        continue;
      }
      String s=fjsp.getAbsolutePath();
      if (s.startsWith(uriRoot)) {
        nextjsp=s.substring(uriRoot.length());
      }
      if (nextjsp.startsWith("." + File.separatorChar)) {
        nextjsp=nextjsp.substring(2);
      }
      processFile(nextjsp);
    }
    completeWebXml();
    if (addWebXmlMappings) {
      mergeIntoWebXml();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(ioe);
  }
catch (  JasperException je) {
    Throwable rootCause=je;
    while (rootCause instanceof JasperException && ((JasperException)rootCause).getRootCause() != null) {
      rootCause=((JasperException)rootCause).getRootCause();
    }
    if (rootCause != je) {
      rootCause.printStackTrace();
    }
    throw new BuildException(je);
  }
 finally {
    if (loader != null) {
      LogFactory.release(loader);
    }
  }
}

ID 6451=========================================================================type: 1
Method:org.apache.jasper.JspC#execute()
Rmethod: org.apache.jasper.JspC#processFile(java.lang.String)
parentException: ServletException 
thrown: JasperException
exception comment: null
block: 
/** 
 * Executes the compilation.
 */
@Override public void execute(){
  if (log.isDebugEnabled()) {
    log.debug("execute() starting for " + pages.size() + " pages.");
  }
  try {
    if (uriRoot == null) {
      if (pages.size() == 0) {
        throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget"));
      }
      String firstJsp=pages.get(0);
      File firstJspF=new File(firstJsp);
      if (!firstJspF.exists()) {
        throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist",firstJsp));
      }
      locateUriRoot(firstJspF);
    }
    if (uriRoot == null) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot"));
    }
    File uriRootF=new File(uriRoot);
    if (!uriRootF.isDirectory()) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));
    }
    if (loader == null) {
      loader=initClassLoader();
    }
    if (context == null) {
      initServletContext(loader);
    }
    if (pages.size() == 0) {
      scanFiles(uriRootF);
    }
    initWebXml();
    Iterator<String> iter=pages.iterator();
    while (iter.hasNext()) {
      String nextjsp=iter.next();
      File fjsp=new File(nextjsp);
      if (!fjsp.isAbsolute()) {
        fjsp=new File(uriRootF,nextjsp);
      }
      if (!fjsp.exists()) {
        if (log.isWarnEnabled()) {
          log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist",fjsp.toString()));
        }
        continue;
      }
      String s=fjsp.getAbsolutePath();
      if (s.startsWith(uriRoot)) {
        nextjsp=s.substring(uriRoot.length());
      }
      if (nextjsp.startsWith("." + File.separatorChar)) {
        nextjsp=nextjsp.substring(2);
      }
      processFile(nextjsp);
    }
    completeWebXml();
    if (addWebXmlMappings) {
      mergeIntoWebXml();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(ioe);
  }
catch (  JasperException je) {
    Throwable rootCause=je;
    while (rootCause instanceof JasperException && ((JasperException)rootCause).getRootCause() != null) {
      rootCause=((JasperException)rootCause).getRootCause();
    }
    if (rootCause != je) {
      rootCause.printStackTrace();
    }
    throw new BuildException(je);
  }
 finally {
    if (loader != null) {
      LogFactory.release(loader);
    }
  }
}

ID 6452=========================================================================type: 1
Method:org.apache.jasper.JspC#execute()
Rmethod: org.apache.jasper.JspC#mergeIntoWebXml()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Executes the compilation.
 */
@Override public void execute(){
  if (log.isDebugEnabled()) {
    log.debug("execute() starting for " + pages.size() + " pages.");
  }
  try {
    if (uriRoot == null) {
      if (pages.size() == 0) {
        throw new JasperException(Localizer.getMessage("jsp.error.jspc.missingTarget"));
      }
      String firstJsp=pages.get(0);
      File firstJspF=new File(firstJsp);
      if (!firstJspF.exists()) {
        throw new JasperException(Localizer.getMessage("jspc.error.fileDoesNotExist",firstJsp));
      }
      locateUriRoot(firstJspF);
    }
    if (uriRoot == null) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.no_uriroot"));
    }
    File uriRootF=new File(uriRoot);
    if (!uriRootF.isDirectory()) {
      throw new JasperException(Localizer.getMessage("jsp.error.jspc.uriroot_not_dir"));
    }
    if (loader == null) {
      loader=initClassLoader();
    }
    if (context == null) {
      initServletContext(loader);
    }
    if (pages.size() == 0) {
      scanFiles(uriRootF);
    }
    initWebXml();
    Iterator<String> iter=pages.iterator();
    while (iter.hasNext()) {
      String nextjsp=iter.next();
      File fjsp=new File(nextjsp);
      if (!fjsp.isAbsolute()) {
        fjsp=new File(uriRootF,nextjsp);
      }
      if (!fjsp.exists()) {
        if (log.isWarnEnabled()) {
          log.warn(Localizer.getMessage("jspc.error.fileDoesNotExist",fjsp.toString()));
        }
        continue;
      }
      String s=fjsp.getAbsolutePath();
      if (s.startsWith(uriRoot)) {
        nextjsp=s.substring(uriRoot.length());
      }
      if (nextjsp.startsWith("." + File.separatorChar)) {
        nextjsp=nextjsp.substring(2);
      }
      processFile(nextjsp);
    }
    completeWebXml();
    if (addWebXmlMappings) {
      mergeIntoWebXml();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(ioe);
  }
catch (  JasperException je) {
    Throwable rootCause=je;
    while (rootCause instanceof JasperException && ((JasperException)rootCause).getRootCause() != null) {
      rootCause=((JasperException)rootCause).getRootCause();
    }
    if (rootCause != je) {
      rootCause.printStackTrace();
    }
    throw new BuildException(je);
  }
 finally {
    if (loader != null) {
      LogFactory.release(loader);
    }
  }
}

ID 6453=========================================================================type: 1
Method:org.apache.jasper.JspC#initWebXml()
Rmethod: org.apache.jasper.JspC#openWebxmlWriter(java.io.File)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void initWebXml(){
  try {
    if (webxmlLevel >= INC_WEBXML) {
      mapout=openWebxmlWriter(new File(webxmlFile));
      servletout=new CharArrayWriter();
      mappingout=new CharArrayWriter();
    }
 else {
      mapout=null;
      servletout=null;
      mappingout=null;
    }
    if (webxmlLevel >= ALL_WEBXML) {
      mapout.write(Localizer.getMessage("jspc.webxml.header"));
      mapout.flush();
    }
 else     if ((webxmlLevel >= INC_WEBXML) && !addWebXmlMappings) {
      mapout.write(Localizer.getMessage("jspc.webinc.header"));
      mapout.flush();
    }
  }
 catch (  IOException ioe) {
    mapout=null;
    servletout=null;
    mappingout=null;
  }
}

ID 6454=========================================================================type: 1
Method:org.apache.jasper.JspC#initWebXml()
Rmethod: java.io.Writer#write(char[])
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void initWebXml(){
  try {
    if (webxmlLevel >= INC_WEBXML) {
      mapout=openWebxmlWriter(new File(webxmlFile));
      servletout=new CharArrayWriter();
      mappingout=new CharArrayWriter();
    }
 else {
      mapout=null;
      servletout=null;
      mappingout=null;
    }
    if (webxmlLevel >= ALL_WEBXML) {
      mapout.write(Localizer.getMessage("jspc.webxml.header"));
      mapout.flush();
    }
 else     if ((webxmlLevel >= INC_WEBXML) && !addWebXmlMappings) {
      mapout.write(Localizer.getMessage("jspc.webinc.header"));
      mapout.flush();
    }
  }
 catch (  IOException ioe) {
    mapout=null;
    servletout=null;
    mappingout=null;
  }
}

ID 6455=========================================================================type: 1
Method:org.apache.jasper.JspC#initWebXml()
Rmethod: java.io.Writer#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
protected void initWebXml(){
  try {
    if (webxmlLevel >= INC_WEBXML) {
      mapout=openWebxmlWriter(new File(webxmlFile));
      servletout=new CharArrayWriter();
      mappingout=new CharArrayWriter();
    }
 else {
      mapout=null;
      servletout=null;
      mappingout=null;
    }
    if (webxmlLevel >= ALL_WEBXML) {
      mapout.write(Localizer.getMessage("jspc.webxml.header"));
      mapout.flush();
    }
 else     if ((webxmlLevel >= INC_WEBXML) && !addWebXmlMappings) {
      mapout.write(Localizer.getMessage("jspc.webinc.header"));
      mapout.flush();
    }
  }
 catch (  IOException ioe) {
    mapout=null;
    servletout=null;
    mappingout=null;
  }
}

ID 6462=========================================================================type: 1
Method:org.apache.jasper.JspC#initClassLoader()
Rmethod: java.net.URI#toURL()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Initializes the classloader as/if needed for the given compilation context.
 * @throws IOException If an error occurs
 */
protected ClassLoader initClassLoader() throws IOException {
  classPath=getClassPath();
  ClassLoader jspcLoader=getClass().getClassLoader();
  if (jspcLoader instanceof AntClassLoader) {
    classPath+=File.pathSeparator + ((AntClassLoader)jspcLoader).getClasspath();
  }
  ArrayList<URL> urls=new ArrayList<URL>();
  StringTokenizer tokenizer=new StringTokenizer(classPath,File.pathSeparator);
  while (tokenizer.hasMoreTokens()) {
    String path=tokenizer.nextToken();
    try {
      File libFile=new File(path);
      urls.add(libFile.toURI().toURL());
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
  }
  File webappBase=new File(uriRoot);
  if (webappBase.exists()) {
    File classes=new File(webappBase,"/WEB-INF/classes");
    try {
      if (classes.exists()) {
        classPath=classPath + File.pathSeparator + classes.getCanonicalPath();
        urls.add(classes.getCanonicalFile().toURI().toURL());
      }
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
    File lib=new File(webappBase,"/WEB-INF/lib");
    if (lib.exists() && lib.isDirectory()) {
      String[] libs=lib.list();
      if (libs != null) {
        for (int i=0; i < libs.length; i++) {
          if (libs[i].length() < 5)           continue;
          String ext=libs[i].substring(libs[i].length() - 4);
          if (!".jar".equalsIgnoreCase(ext)) {
            if (".tld".equalsIgnoreCase(ext)) {
              log.warn("TLD files should not be placed in " + "/WEB-INF/lib");
            }
            continue;
          }
          try {
            File libFile=new File(lib,libs[i]);
            classPath=classPath + File.pathSeparator + libFile.getAbsolutePath();
            urls.add(libFile.getAbsoluteFile().toURI().toURL());
          }
 catch (          IOException ioe) {
            throw new RuntimeException(ioe.toString());
          }
        }
      }
    }
  }
  URL urlsA[]=new URL[urls.size()];
  urls.toArray(urlsA);
  loader=new URLClassLoader(urlsA,this.getClass().getClassLoader());
  return loader;
}

ID 6463=========================================================================type: 1
Method:org.apache.jasper.JspC#initClassLoader()
Rmethod: java.io.File#getCanonicalPath()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Initializes the classloader as/if needed for the given compilation context.
 * @throws IOException If an error occurs
 */
protected ClassLoader initClassLoader() throws IOException {
  classPath=getClassPath();
  ClassLoader jspcLoader=getClass().getClassLoader();
  if (jspcLoader instanceof AntClassLoader) {
    classPath+=File.pathSeparator + ((AntClassLoader)jspcLoader).getClasspath();
  }
  ArrayList<URL> urls=new ArrayList<URL>();
  StringTokenizer tokenizer=new StringTokenizer(classPath,File.pathSeparator);
  while (tokenizer.hasMoreTokens()) {
    String path=tokenizer.nextToken();
    try {
      File libFile=new File(path);
      urls.add(libFile.toURI().toURL());
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
  }
  File webappBase=new File(uriRoot);
  if (webappBase.exists()) {
    File classes=new File(webappBase,"/WEB-INF/classes");
    try {
      if (classes.exists()) {
        classPath=classPath + File.pathSeparator + classes.getCanonicalPath();
        urls.add(classes.getCanonicalFile().toURI().toURL());
      }
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
    File lib=new File(webappBase,"/WEB-INF/lib");
    if (lib.exists() && lib.isDirectory()) {
      String[] libs=lib.list();
      if (libs != null) {
        for (int i=0; i < libs.length; i++) {
          if (libs[i].length() < 5)           continue;
          String ext=libs[i].substring(libs[i].length() - 4);
          if (!".jar".equalsIgnoreCase(ext)) {
            if (".tld".equalsIgnoreCase(ext)) {
              log.warn("TLD files should not be placed in " + "/WEB-INF/lib");
            }
            continue;
          }
          try {
            File libFile=new File(lib,libs[i]);
            classPath=classPath + File.pathSeparator + libFile.getAbsolutePath();
            urls.add(libFile.getAbsoluteFile().toURI().toURL());
          }
 catch (          IOException ioe) {
            throw new RuntimeException(ioe.toString());
          }
        }
      }
    }
  }
  URL urlsA[]=new URL[urls.size()];
  urls.toArray(urlsA);
  loader=new URLClassLoader(urlsA,this.getClass().getClassLoader());
  return loader;
}

ID 6464=========================================================================type: 1
Method:org.apache.jasper.JspC#initClassLoader()
Rmethod: java.io.File#getCanonicalFile()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Initializes the classloader as/if needed for the given compilation context.
 * @throws IOException If an error occurs
 */
protected ClassLoader initClassLoader() throws IOException {
  classPath=getClassPath();
  ClassLoader jspcLoader=getClass().getClassLoader();
  if (jspcLoader instanceof AntClassLoader) {
    classPath+=File.pathSeparator + ((AntClassLoader)jspcLoader).getClasspath();
  }
  ArrayList<URL> urls=new ArrayList<URL>();
  StringTokenizer tokenizer=new StringTokenizer(classPath,File.pathSeparator);
  while (tokenizer.hasMoreTokens()) {
    String path=tokenizer.nextToken();
    try {
      File libFile=new File(path);
      urls.add(libFile.toURI().toURL());
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
  }
  File webappBase=new File(uriRoot);
  if (webappBase.exists()) {
    File classes=new File(webappBase,"/WEB-INF/classes");
    try {
      if (classes.exists()) {
        classPath=classPath + File.pathSeparator + classes.getCanonicalPath();
        urls.add(classes.getCanonicalFile().toURI().toURL());
      }
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
    File lib=new File(webappBase,"/WEB-INF/lib");
    if (lib.exists() && lib.isDirectory()) {
      String[] libs=lib.list();
      if (libs != null) {
        for (int i=0; i < libs.length; i++) {
          if (libs[i].length() < 5)           continue;
          String ext=libs[i].substring(libs[i].length() - 4);
          if (!".jar".equalsIgnoreCase(ext)) {
            if (".tld".equalsIgnoreCase(ext)) {
              log.warn("TLD files should not be placed in " + "/WEB-INF/lib");
            }
            continue;
          }
          try {
            File libFile=new File(lib,libs[i]);
            classPath=classPath + File.pathSeparator + libFile.getAbsolutePath();
            urls.add(libFile.getAbsoluteFile().toURI().toURL());
          }
 catch (          IOException ioe) {
            throw new RuntimeException(ioe.toString());
          }
        }
      }
    }
  }
  URL urlsA[]=new URL[urls.size()];
  urls.toArray(urlsA);
  loader=new URLClassLoader(urlsA,this.getClass().getClassLoader());
  return loader;
}

ID 6465=========================================================================type: 1
Method:org.apache.jasper.JspC#initClassLoader()
Rmethod: java.net.URI#toURL()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * Initializes the classloader as/if needed for the given compilation context.
 * @throws IOException If an error occurs
 */
protected ClassLoader initClassLoader() throws IOException {
  classPath=getClassPath();
  ClassLoader jspcLoader=getClass().getClassLoader();
  if (jspcLoader instanceof AntClassLoader) {
    classPath+=File.pathSeparator + ((AntClassLoader)jspcLoader).getClasspath();
  }
  ArrayList<URL> urls=new ArrayList<URL>();
  StringTokenizer tokenizer=new StringTokenizer(classPath,File.pathSeparator);
  while (tokenizer.hasMoreTokens()) {
    String path=tokenizer.nextToken();
    try {
      File libFile=new File(path);
      urls.add(libFile.toURI().toURL());
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
  }
  File webappBase=new File(uriRoot);
  if (webappBase.exists()) {
    File classes=new File(webappBase,"/WEB-INF/classes");
    try {
      if (classes.exists()) {
        classPath=classPath + File.pathSeparator + classes.getCanonicalPath();
        urls.add(classes.getCanonicalFile().toURI().toURL());
      }
    }
 catch (    IOException ioe) {
      throw new RuntimeException(ioe.toString());
    }
    File lib=new File(webappBase,"/WEB-INF/lib");
    if (lib.exists() && lib.isDirectory()) {
      String[] libs=lib.list();
      if (libs != null) {
        for (int i=0; i < libs.length; i++) {
          if (libs[i].length() < 5)           continue;
          String ext=libs[i].substring(libs[i].length() - 4);
          if (!".jar".equalsIgnoreCase(ext)) {
            if (".tld".equalsIgnoreCase(ext)) {
              log.warn("TLD files should not be placed in " + "/WEB-INF/lib");
            }
            continue;
          }
          try {
            File libFile=new File(lib,libs[i]);
            classPath=classPath + File.pathSeparator + libFile.getAbsolutePath();
            urls.add(libFile.getAbsoluteFile().toURI().toURL());
          }
 catch (          IOException ioe) {
            throw new RuntimeException(ioe.toString());
          }
        }
      }
    }
  }
  URL urlsA[]=new URL[urls.size()];
  urls.toArray(urlsA);
  loader=new URLClassLoader(urlsA,this.getClass().getClassLoader());
  return loader;
}

ID 6469=========================================================================type: 1
Method:org.apache.jasper.JspC#openWebxmlReader(java.io.File)
Rmethod: java.io.InputStreamReader#InputStreamReader(java.io.InputStream, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
private Reader openWebxmlReader(File file) throws IOException {
  FileInputStream fis=new FileInputStream(file);
  try {
    return webxmlEncoding != null ? new InputStreamReader(fis,webxmlEncoding) : new InputStreamReader(fis);
  }
 catch (  IOException ex) {
    fis.close();
    throw ex;
  }
}

ID 6470=========================================================================type: 1
Method:org.apache.jasper.JspC#openWebxmlReader(java.io.File)
Rmethod: java.io.FileInputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private Reader openWebxmlReader(File file) throws IOException {
  FileInputStream fis=new FileInputStream(file);
  try {
    return webxmlEncoding != null ? new InputStreamReader(fis,webxmlEncoding) : new InputStreamReader(fis);
  }
 catch (  IOException ex) {
    fis.close();
    throw ex;
  }
}

ID 6472=========================================================================type: 1
Method:org.apache.jasper.JspC#openWebxmlWriter(java.io.File)
Rmethod: java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
private Writer openWebxmlWriter(File file) throws IOException {
  FileOutputStream fos=new FileOutputStream(file);
  try {
    return webxmlEncoding != null ? new OutputStreamWriter(fos,webxmlEncoding) : new OutputStreamWriter(fos);
  }
 catch (  IOException ex) {
    fos.close();
    throw ex;
  }
}

ID 6473=========================================================================type: 1
Method:org.apache.jasper.JspC#openWebxmlWriter(java.io.File)
Rmethod: java.io.FileOutputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private Writer openWebxmlWriter(File file) throws IOException {
  FileOutputStream fos=new FileOutputStream(file);
  try {
    return webxmlEncoding != null ? new OutputStreamWriter(fos,webxmlEncoding) : new OutputStreamWriter(fos);
  }
 catch (  IOException ex) {
    fos.close();
    throw ex;
  }
}

ID 6492=========================================================================type: 1
Method:org.apache.jasper.runtime.PageContextImpl#release()
Rmethod: org.apache.jasper.runtime.JspWriterImpl#flushBuffer()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void release(){
  out=baseOut;
  try {
    if (isIncluded) {
      ((JspWriterImpl)out).flushBuffer();
    }
 else {
      ((JspWriterImpl)out).flushBuffer();
    }
  }
 catch (  IOException ex) {
    IllegalStateException ise=new IllegalStateException(Localizer.getMessage("jsp.error.flush"),ex);
    throw ise;
  }
 finally {
    servlet=null;
    config=null;
    context=null;
    applicationContext=null;
    elContext=null;
    errorPageURL=null;
    request=null;
    response=null;
    depth=-1;
    baseOut.recycle();
    session=null;
    attributes.clear();
    for (    BodyContentImpl body : outs) {
      body.recycle();
    }
  }
}

ID 6497=========================================================================type: 1
Method:org.apache.jasper.runtime.PageContextImpl#include(java.lang.String, boolean)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public void include(final String relativeUrlPath,final boolean flush) throws ServletException, IOException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      AccessController.doPrivileged(new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          doInclude(relativeUrlPath,flush);
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException e) {
      Exception ex=e.getException();
      if (ex instanceof IOException) {
        throw (IOException)ex;
      }
 else {
        throw (ServletException)ex;
      }
    }
  }
 else {
    doInclude(relativeUrlPath,flush);
  }
}

ID 6504=========================================================================type: 1
Method:org.apache.jasper.runtime.PageContextImpl#forward(java.lang.String)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public void forward(final String relativeUrlPath) throws ServletException, IOException {
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      AccessController.doPrivileged(new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          doForward(relativeUrlPath);
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException e) {
      Exception ex=e.getException();
      if (ex instanceof IOException) {
        throw (IOException)ex;
      }
 else {
        throw (ServletException)ex;
      }
    }
  }
 else {
    doForward(relativeUrlPath);
  }
}

ID 6507=========================================================================type: 1
Method:org.apache.jasper.runtime.PageContextImpl#doForward(java.lang.String)
Rmethod: javax.servlet.jsp.JspWriter#clear()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void doForward(String relativeUrlPath) throws ServletException, IOException {
  try {
    out.clear();
    baseOut.clear();
  }
 catch (  IOException ex) {
    IllegalStateException ise=new IllegalStateException(Localizer.getMessage("jsp.error.attempt_to_clear_flushed_buffer"));
    ise.initCause(ex);
    throw ise;
  }
  while (response instanceof ServletResponseWrapperInclude) {
    response=((ServletResponseWrapperInclude)response).getResponse();
  }
  final String path=getAbsolutePathRelativeToContext(relativeUrlPath);
  String includeUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
  if (includeUri != null)   request.removeAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
  try {
    context.getRequestDispatcher(path).forward(request,response);
  }
  finally {
    if (includeUri != null)     request.setAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH,includeUri);
  }
}

ID 6508=========================================================================type: 1
Method:org.apache.jasper.runtime.PageContextImpl#doForward(java.lang.String)
Rmethod: org.apache.jasper.runtime.JspWriterImpl#clear()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private void doForward(String relativeUrlPath) throws ServletException, IOException {
  try {
    out.clear();
    baseOut.clear();
  }
 catch (  IOException ex) {
    IllegalStateException ise=new IllegalStateException(Localizer.getMessage("jsp.error.attempt_to_clear_flushed_buffer"));
    ise.initCause(ex);
    throw ise;
  }
  while (response instanceof ServletResponseWrapperInclude) {
    response=((ServletResponseWrapperInclude)response).getResponse();
  }
  final String path=getAbsolutePathRelativeToContext(relativeUrlPath);
  String includeUri=(String)request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
  if (includeUri != null)   request.removeAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);
  try {
    context.getRequestDispatcher(path).forward(request,response);
  }
  finally {
    if (includeUri != null)     request.setAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH,includeUri);
  }
}

ID 6515=========================================================================type: 1
Method:org.apache.jasper.runtime.PageContextImpl#handlePageException(java.lang.Throwable)
Rmethod: java.security.AccessController#doPrivileged(PrivilegedExceptionAction<T>)
parentException: 
thrown: PrivilegedActionException
exception comment: /** 
 * This exception is thrown by {@code doPrivileged(PrivilegedExceptionAction)} and{@code doPrivileged(PrivilegedExceptionAction,AccessControlContext context)} to indicatethat the action being performed threw a checked exception.  The exception thrown by the action can be obtained by calling the {@code getException} method.  In effect, an{@code PrivilegedActionException} is a "wrapper"for an exception thrown by a privileged action. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "exception thrown by the privileged computation" that is provided at construction time and accessed via the  {@link #getException()} method is now known as the<i>cause</i>, and may be accessed via the  {@link Throwable#getCause()}method, as well as the aforementioned "legacy method."
 * @see PrivilegedExceptionAction
 * @see AccessController#doPrivileged(PrivilegedExceptionAction)
 * @see AccessController#doPrivileged(PrivilegedExceptionAction,AccessControlContext)
 */

block: 
@Override public void handlePageException(final Throwable t) throws IOException, ServletException {
  if (t == null)   throw new NullPointerException("null Throwable");
  if (SecurityUtil.isPackageProtectionEnabled()) {
    try {
      AccessController.doPrivileged(new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          doHandlePageException(t);
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException e) {
      Exception ex=e.getException();
      if (ex instanceof IOException) {
        throw (IOException)ex;
      }
 else {
        throw (ServletException)ex;
      }
    }
  }
 else {
    doHandlePageException(t);
  }
}

ID 6609=========================================================================type: 1
Method:org.apache.jasper.runtime.JspRuntimeLibrary#getValueFromPropertyEditorManager(Class<?>, java.lang.String, java.lang.String)
Rmethod: java.beans.PropertyEditor#setAsText(java.lang.String)
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
public static Object getValueFromPropertyEditorManager(Class<?> attrClass,String attrName,String attrValue) throws JasperException {
  try {
    PropertyEditor propEditor=PropertyEditorManager.findEditor(attrClass);
    if (propEditor != null) {
      propEditor.setAsText(attrValue);
      return propEditor.getValue();
    }
 else {
      throw new IllegalArgumentException(Localizer.getMessage("jsp.error.beans.propertyeditor.notregistered"));
    }
  }
 catch (  IllegalArgumentException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.beans.property.conversion",attrValue,attrClass.getName(),attrName,ex.getMessage()));
  }
}

ID 6613=========================================================================type: 1
Method:org.apache.jasper.runtime.JspRuntimeLibrary#URLEncode(java.lang.String, java.lang.String)
Rmethod: java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * URL encodes a string, based on the supplied character encoding. This performs the same function as java.next.URLEncode.encode in J2SDK1.4, and should be removed if the only platform supported is 1.4 or higher.
 * @param s The String to be URL encoded.
 * @param enc The character encoding 
 * @return The URL encoded String
 */
public static String URLEncode(String s,String enc){
  if (s == null) {
    return "null";
  }
  if (enc == null) {
    enc="ISO-8859-1";
  }
  StringBuilder out=new StringBuilder(s.length());
  ByteArrayOutputStream buf=new ByteArrayOutputStream();
  OutputStreamWriter writer=null;
  try {
    writer=new OutputStreamWriter(buf,enc);
  }
 catch (  java.io.UnsupportedEncodingException ex) {
    writer=new OutputStreamWriter(buf);
  }
  for (int i=0; i < s.length(); i++) {
    int c=s.charAt(i);
    if (c == ' ') {
      out.append('+');
    }
 else     if (isSafeChar(c)) {
      out.append((char)c);
    }
 else {
      try {
        writer.write(c);
        writer.flush();
      }
 catch (      IOException e) {
        buf.reset();
        continue;
      }
      byte[] ba=buf.toByteArray();
      for (int j=0; j < ba.length; j++) {
        out.append('%');
        out.append(Character.forDigit((ba[j] >> 4) & 0xf,16));
        out.append(Character.forDigit(ba[j] & 0xf,16));
      }
      buf.reset();
    }
  }
  return out.toString();
}

ID 6614=========================================================================type: 1
Method:org.apache.jasper.runtime.JspRuntimeLibrary#URLEncode(java.lang.String, java.lang.String)
Rmethod: java.io.OutputStreamWriter#write(int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * URL encodes a string, based on the supplied character encoding. This performs the same function as java.next.URLEncode.encode in J2SDK1.4, and should be removed if the only platform supported is 1.4 or higher.
 * @param s The String to be URL encoded.
 * @param enc The character encoding 
 * @return The URL encoded String
 */
public static String URLEncode(String s,String enc){
  if (s == null) {
    return "null";
  }
  if (enc == null) {
    enc="ISO-8859-1";
  }
  StringBuilder out=new StringBuilder(s.length());
  ByteArrayOutputStream buf=new ByteArrayOutputStream();
  OutputStreamWriter writer=null;
  try {
    writer=new OutputStreamWriter(buf,enc);
  }
 catch (  java.io.UnsupportedEncodingException ex) {
    writer=new OutputStreamWriter(buf);
  }
  for (int i=0; i < s.length(); i++) {
    int c=s.charAt(i);
    if (c == ' ') {
      out.append('+');
    }
 else     if (isSafeChar(c)) {
      out.append((char)c);
    }
 else {
      try {
        writer.write(c);
        writer.flush();
      }
 catch (      IOException e) {
        buf.reset();
        continue;
      }
      byte[] ba=buf.toByteArray();
      for (int j=0; j < ba.length; j++) {
        out.append('%');
        out.append(Character.forDigit((ba[j] >> 4) & 0xf,16));
        out.append(Character.forDigit(ba[j] & 0xf,16));
      }
      buf.reset();
    }
  }
  return out.toString();
}

ID 6615=========================================================================type: 1
Method:org.apache.jasper.runtime.JspRuntimeLibrary#URLEncode(java.lang.String, java.lang.String)
Rmethod: java.io.OutputStreamWriter#flush()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * URL encodes a string, based on the supplied character encoding. This performs the same function as java.next.URLEncode.encode in J2SDK1.4, and should be removed if the only platform supported is 1.4 or higher.
 * @param s The String to be URL encoded.
 * @param enc The character encoding 
 * @return The URL encoded String
 */
public static String URLEncode(String s,String enc){
  if (s == null) {
    return "null";
  }
  if (enc == null) {
    enc="ISO-8859-1";
  }
  StringBuilder out=new StringBuilder(s.length());
  ByteArrayOutputStream buf=new ByteArrayOutputStream();
  OutputStreamWriter writer=null;
  try {
    writer=new OutputStreamWriter(buf,enc);
  }
 catch (  java.io.UnsupportedEncodingException ex) {
    writer=new OutputStreamWriter(buf);
  }
  for (int i=0; i < s.length(); i++) {
    int c=s.charAt(i);
    if (c == ' ') {
      out.append('+');
    }
 else     if (isSafeChar(c)) {
      out.append((char)c);
    }
 else {
      try {
        writer.write(c);
        writer.flush();
      }
 catch (      IOException e) {
        buf.reset();
        continue;
      }
      byte[] ba=buf.toByteArray();
      for (int j=0; j < ba.length; j++) {
        out.append('%');
        out.append(Character.forDigit((ba[j] >> 4) & 0xf,16));
        out.append(Character.forDigit(ba[j] & 0xf,16));
      }
      buf.reset();
    }
  }
  return out.toString();
}

ID 6676=========================================================================type: 1
Method:org.apache.jasper.runtime.ProtectedFunctionMapper#mapFunction(java.lang.String, Class<?>, java.lang.String, Class<?>[])
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
/** 
 * Stores a mapping from the given EL function prefix and name to the given Java method.
 * @param fnQName The EL function qualified name (including prefix)
 * @param c The class containing the Java method
 * @param methodName The name of the Java method
 * @param args The arguments of the Java method
 * @throws RuntimeException if no method with the given signature could be found.
 */
public void mapFunction(String fnQName,final Class<?> c,final String methodName,final Class<?>[] args){
  java.lang.reflect.Method method;
  try {
    method=c.getMethod(methodName,args);
  }
 catch (  NoSuchMethodException e) {
    throw new RuntimeException("Invalid function mapping - no such method: " + e.getMessage());
  }
  this.fnmap.put(fnQName,method);
}

ID 6678=========================================================================type: 1
Method:org.apache.jasper.runtime.ProtectedFunctionMapper#getMapForFunction(java.lang.String, Class<?>, java.lang.String, Class<?>[])
Rmethod: java.lang.Class#getMethod(java.lang.String, Class<?>[])
parentException: ReflectiveOperationException 
thrown: NoSuchMethodException
exception comment: /** 
 * Thrown when a particular method cannot be found.
 * @author     unascribed
 * @since      JDK1.0
 */

block: 
/** 
 * Creates an instance for this class, and stores the Method for the given EL function prefix and name. This method is used for the case when there is only one function in the EL expression.
 * @param fnQName The EL function qualified name (including prefix)
 * @param c The class containing the Java method
 * @param methodName The name of the Java method
 * @param args The arguments of the Java method
 * @throws RuntimeException if no method with the given signature could be found.
 */
public static ProtectedFunctionMapper getMapForFunction(String fnQName,final Class<?> c,final String methodName,final Class<?>[] args){
  java.lang.reflect.Method method;
  ProtectedFunctionMapper funcMapper=new ProtectedFunctionMapper();
  try {
    method=c.getMethod(methodName,args);
  }
 catch (  NoSuchMethodException e) {
    throw new RuntimeException("Invalid function mapping - no such method: " + e.getMessage());
  }
  funcMapper.theMethod=method;
  return funcMapper;
}

ID 6750=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#createCompiler(java.lang.String)
Rmethod: java.lang.Class#forName(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
protected Compiler createCompiler(String className){
  Compiler compiler=null;
  try {
    compiler=(Compiler)Class.forName(className).newInstance();
  }
 catch (  InstantiationException e) {
    log.warn(Localizer.getMessage("jsp.error.compiler"),e);
  }
catch (  IllegalAccessException e) {
    log.warn(Localizer.getMessage("jsp.error.compiler"),e);
  }
catch (  NoClassDefFoundError e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.compiler"),e);
    }
  }
catch (  ClassNotFoundException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.compiler"),e);
    }
  }
  return compiler;
}

ID 6751=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#createCompiler(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
protected Compiler createCompiler(String className){
  Compiler compiler=null;
  try {
    compiler=(Compiler)Class.forName(className).newInstance();
  }
 catch (  InstantiationException e) {
    log.warn(Localizer.getMessage("jsp.error.compiler"),e);
  }
catch (  IllegalAccessException e) {
    log.warn(Localizer.getMessage("jsp.error.compiler"),e);
  }
catch (  NoClassDefFoundError e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.compiler"),e);
    }
  }
catch (  ClassNotFoundException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.compiler"),e);
    }
  }
  return compiler;
}

ID 6752=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#createCompiler(java.lang.String)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
protected Compiler createCompiler(String className){
  Compiler compiler=null;
  try {
    compiler=(Compiler)Class.forName(className).newInstance();
  }
 catch (  InstantiationException e) {
    log.warn(Localizer.getMessage("jsp.error.compiler"),e);
  }
catch (  IllegalAccessException e) {
    log.warn(Localizer.getMessage("jsp.error.compiler"),e);
  }
catch (  NoClassDefFoundError e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.compiler"),e);
    }
  }
catch (  ClassNotFoundException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.compiler"),e);
    }
  }
  return compiler;
}

ID 6755=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getJspLastModified()
Rmethod: org.apache.jasper.JspCompilationContext#getResource(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
/** 
 * @deprecated Will be removed in Tomcat 8.0.x. Use{@link #getLastModified(String)} instead.
 */
@Deprecated public long getJspLastModified(){
  long result=-1;
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(getJspFile());
    if (jspUrl == null) {
      incrementRemoved();
      return result;
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return result;
}

ID 6756=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getJspLastModified()
Rmethod: java.net.URL#openConnection()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @deprecated Will be removed in Tomcat 8.0.x. Use{@link #getLastModified(String)} instead.
 */
@Deprecated public long getJspLastModified(){
  long result=-1;
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(getJspFile());
    if (jspUrl == null) {
      incrementRemoved();
      return result;
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return result;
}

ID 6757=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getJspLastModified()
Rmethod: java.net.JarURLConnection#getJarEntry()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @deprecated Will be removed in Tomcat 8.0.x. Use{@link #getLastModified(String)} instead.
 */
@Deprecated public long getJspLastModified(){
  long result=-1;
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(getJspFile());
    if (jspUrl == null) {
      incrementRemoved();
      return result;
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return result;
}

ID 6758=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getJspLastModified()
Rmethod: java.net.URLConnection#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @deprecated Will be removed in Tomcat 8.0.x. Use{@link #getLastModified(String)} instead.
 */
@Deprecated public long getJspLastModified(){
  long result=-1;
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(getJspFile());
    if (jspUrl == null) {
      incrementRemoved();
      return result;
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return result;
}

ID 6759=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getJspLastModified()
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * @deprecated Will be removed in Tomcat 8.0.x. Use{@link #getLastModified(String)} instead.
 */
@Deprecated public long getJspLastModified(){
  long result=-1;
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(getJspFile());
    if (jspUrl == null) {
      incrementRemoved();
      return result;
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return result;
}

ID 6760=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getLastModified(java.lang.String)
Rmethod: java.net.URI#URI(java.lang.String)
parentException: 
thrown: URISyntaxException
exception comment: /** 
 * Checked exception thrown to indicate that a string could not be parsed as a URI reference.
 * @author Mark Reinhold
 * @see URI
 * @since 1.4
 */

block: 
public Long getLastModified(String resource){
  long result=-1;
  if (resource.startsWith("file:/")) {
    File f;
    try {
      f=new File(new URI(resource));
    }
 catch (    URISyntaxException e) {
      return Long.valueOf(-1);
    }
    return Long.valueOf(f.lastModified());
  }
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(resource);
    if (jspUrl == null) {
      incrementRemoved();
      return Long.valueOf(result);
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return Long.valueOf(result);
}

ID 6761=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getLastModified(java.lang.String)
Rmethod: org.apache.jasper.JspCompilationContext#getResource(java.lang.String)
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
public Long getLastModified(String resource){
  long result=-1;
  if (resource.startsWith("file:/")) {
    File f;
    try {
      f=new File(new URI(resource));
    }
 catch (    URISyntaxException e) {
      return Long.valueOf(-1);
    }
    return Long.valueOf(f.lastModified());
  }
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(resource);
    if (jspUrl == null) {
      incrementRemoved();
      return Long.valueOf(result);
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return Long.valueOf(result);
}

ID 6762=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getLastModified(java.lang.String)
Rmethod: java.net.URL#openConnection()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public Long getLastModified(String resource){
  long result=-1;
  if (resource.startsWith("file:/")) {
    File f;
    try {
      f=new File(new URI(resource));
    }
 catch (    URISyntaxException e) {
      return Long.valueOf(-1);
    }
    return Long.valueOf(f.lastModified());
  }
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(resource);
    if (jspUrl == null) {
      incrementRemoved();
      return Long.valueOf(result);
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return Long.valueOf(result);
}

ID 6763=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getLastModified(java.lang.String)
Rmethod: java.net.JarURLConnection#getJarEntry()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public Long getLastModified(String resource){
  long result=-1;
  if (resource.startsWith("file:/")) {
    File f;
    try {
      f=new File(new URI(resource));
    }
 catch (    URISyntaxException e) {
      return Long.valueOf(-1);
    }
    return Long.valueOf(f.lastModified());
  }
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(resource);
    if (jspUrl == null) {
      incrementRemoved();
      return Long.valueOf(result);
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return Long.valueOf(result);
}

ID 6764=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getLastModified(java.lang.String)
Rmethod: java.net.URLConnection#getInputStream()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public Long getLastModified(String resource){
  long result=-1;
  if (resource.startsWith("file:/")) {
    File f;
    try {
      f=new File(new URI(resource));
    }
 catch (    URISyntaxException e) {
      return Long.valueOf(-1);
    }
    return Long.valueOf(f.lastModified());
  }
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(resource);
    if (jspUrl == null) {
      incrementRemoved();
      return Long.valueOf(result);
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return Long.valueOf(result);
}

ID 6765=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#getLastModified(java.lang.String)
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public Long getLastModified(String resource){
  long result=-1;
  if (resource.startsWith("file:/")) {
    File f;
    try {
      f=new File(new URI(resource));
    }
 catch (    URISyntaxException e) {
      return Long.valueOf(-1);
    }
    return Long.valueOf(f.lastModified());
  }
  URLConnection uc=null;
  try {
    URL jspUrl=getResource(resource);
    if (jspUrl == null) {
      incrementRemoved();
      return Long.valueOf(result);
    }
    uc=jspUrl.openConnection();
    if (uc instanceof JarURLConnection) {
      result=((JarURLConnection)uc).getJarEntry().getTime();
    }
 else {
      result=uc.getLastModified();
    }
  }
 catch (  IOException e) {
    if (log.isDebugEnabled()) {
      log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
    }
    result=-1;
  }
 finally {
    if (uc != null) {
      try {
        uc.getInputStream().close();
      }
 catch (      IOException e) {
        if (log.isDebugEnabled()) {
          log.debug(Localizer.getMessage("jsp.error.lastModified",getJspFile()),e);
        }
        result=-1;
      }
    }
  }
  return Long.valueOf(result);
}

ID 6766=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#load()
Rmethod: java.lang.ClassLoader#loadClass(java.lang.String)
parentException: ReflectiveOperationException 
thrown: ClassNotFoundException
exception comment: /** 
 * Thrown when an application tries to load in a class through its string name using: <ul> <li>The <code>forName</code> method in class <code>Class</code>. <li>The <code>findSystemClass</code> method in class <code>ClassLoader</code> . <li>The <code>loadClass</code> method in class <code>ClassLoader</code>. </ul> <p> but no definition for the class with the specified name could be found. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "optional exception that was raised while loading the class" that may be provided at construction time and accessed via the  {@link #getException()} method isnow known as the <i>cause</i>, and may be accessed via the  {@link Throwable#getCause()} method, as well as the aforementioned "legacy method."
 * @author  unascribed
 * @see java.lang.Class#forName(java.lang.String)
 * @see java.lang.ClassLoader#findSystemClass(java.lang.String)
 * @see java.lang.ClassLoader#loadClass(java.lang.String,boolean)
 * @since   JDK1.0
 */

block: 
public Class<?> load() throws JasperException {
  try {
    getJspLoader();
    String name=getFQCN();
    servletClass=jspLoader.loadClass(name);
  }
 catch (  ClassNotFoundException cex) {
    throw new JasperException(Localizer.getMessage("jsp.error.unable.load"),cex);
  }
catch (  Exception ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.unable.compile"),ex);
  }
  removed=0;
  return servletClass;
}

ID 6767=========================================================================type: 1
Method:org.apache.jasper.JspCompilationContext#createOutputDir()
Rmethod: java.net.URI#toURL()
parentException: IOException 
thrown: MalformedURLException
exception comment: /** 
 * Thrown to indicate that a malformed URL has occurred. Either no legal protocol could be found in a specification string or the string could not be parsed.
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */

block: 
protected void createOutputDir(){
  String path=null;
  if (isTagFile()) {
    String tagName=tagInfo.getTagClassName();
    path=tagName.replace('.',File.separatorChar);
    path=path.substring(0,path.lastIndexOf(File.separatorChar));
  }
 else {
    path=getServletPackageName().replace('.',File.separatorChar);
  }
  try {
    File base=options.getScratchDir();
    baseUrl=base.toURI().toURL();
    outputDir=base.getAbsolutePath() + File.separator + path+ File.separator;
    if (!makeOutputDir()) {
      throw new IllegalStateException(Localizer.getMessage("jsp.error.outputfolder"));
    }
  }
 catch (  MalformedURLException e) {
    throw new IllegalStateException(Localizer.getMessage("jsp.error.outputfolder"),e);
  }
}

ID 6780=========================================================================type: 1
Method:org.apache.jasper.xmlparser.ParserUtils#parseXMLDocument(java.lang.String, org.xml.sax.InputSource)
Rmethod: javax.xml.parsers.DocumentBuilderFactory#setFeature(java.lang.String, boolean)
parentException: 
thrown: ParserConfigurationException
exception comment: /** 
 * Indicates a serious configuration error.
 * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
 */

block: 
/** 
 * Parse the specified XML document, and return a <code>TreeNode</code> that corresponds to the root node of the document tree.
 * @param location Location (eg URI) of the XML document being parsed
 * @param is Input source containing the deployment descriptor
 * @exception JasperException if an input/output error occurs
 * @exception JasperException if a parsing error occurs
 */
public TreeNode parseXMLDocument(String location,InputSource is) throws JasperException {
  Document document=null;
  ClassLoader original;
  if (Constants.IS_SECURITY_ENABLED) {
    PrivilegedGetTccl pa=new PrivilegedGetTccl();
    original=AccessController.doPrivileged(pa);
  }
 else {
    original=Thread.currentThread().getContextClassLoader();
  }
  try {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(ParserUtils.class.getClassLoader());
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(ParserUtils.class.getClassLoader());
    }
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    factory.setNamespaceAware(true);
    factory.setValidating(validating);
    if (validating) {
      factory.setFeature("http://xml.org/sax/features/validation",true);
      factory.setFeature("http://apache.org/xml/features/validation/schema",true);
    }
    DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setEntityResolver(entityResolverInstance);
    XmlErrorHandler handler=new XmlErrorHandler();
    builder.setErrorHandler(handler);
    document=builder.parse(is);
    if (!handler.getErrors().isEmpty()) {
      throw handler.getErrors().iterator().next();
    }
  }
 catch (  ParserConfigurationException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),ex);
  }
catch (  SAXParseException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml.line",location,Integer.toString(ex.getLineNumber()),Integer.toString(ex.getColumnNumber())),ex);
  }
catch (  SAXException sx) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),sx);
  }
catch (  IOException io) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),io);
  }
 finally {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(original);
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(original);
    }
  }
  return (convert(null,document.getDocumentElement()));
}

ID 6781=========================================================================type: 1
Method:org.apache.jasper.xmlparser.ParserUtils#parseXMLDocument(java.lang.String, org.xml.sax.InputSource)
Rmethod: javax.xml.parsers.DocumentBuilderFactory#newDocumentBuilder()
parentException: 
thrown: ParserConfigurationException
exception comment: /** 
 * Indicates a serious configuration error.
 * @author <a href="mailto:Jeff.Suttor@Sun.com">Jeff Suttor</a>
 */

block: 
/** 
 * Parse the specified XML document, and return a <code>TreeNode</code> that corresponds to the root node of the document tree.
 * @param location Location (eg URI) of the XML document being parsed
 * @param is Input source containing the deployment descriptor
 * @exception JasperException if an input/output error occurs
 * @exception JasperException if a parsing error occurs
 */
public TreeNode parseXMLDocument(String location,InputSource is) throws JasperException {
  Document document=null;
  ClassLoader original;
  if (Constants.IS_SECURITY_ENABLED) {
    PrivilegedGetTccl pa=new PrivilegedGetTccl();
    original=AccessController.doPrivileged(pa);
  }
 else {
    original=Thread.currentThread().getContextClassLoader();
  }
  try {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(ParserUtils.class.getClassLoader());
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(ParserUtils.class.getClassLoader());
    }
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    factory.setNamespaceAware(true);
    factory.setValidating(validating);
    if (validating) {
      factory.setFeature("http://xml.org/sax/features/validation",true);
      factory.setFeature("http://apache.org/xml/features/validation/schema",true);
    }
    DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setEntityResolver(entityResolverInstance);
    XmlErrorHandler handler=new XmlErrorHandler();
    builder.setErrorHandler(handler);
    document=builder.parse(is);
    if (!handler.getErrors().isEmpty()) {
      throw handler.getErrors().iterator().next();
    }
  }
 catch (  ParserConfigurationException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),ex);
  }
catch (  SAXParseException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml.line",location,Integer.toString(ex.getLineNumber()),Integer.toString(ex.getColumnNumber())),ex);
  }
catch (  SAXException sx) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),sx);
  }
catch (  IOException io) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),io);
  }
 finally {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(original);
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(original);
    }
  }
  return (convert(null,document.getDocumentElement()));
}

ID 6782=========================================================================type: 1
Method:org.apache.jasper.xmlparser.ParserUtils#parseXMLDocument(java.lang.String, org.xml.sax.InputSource)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(org.xml.sax.InputSource)
parentException: 
thrown: SAXException
exception comment: /** 
 * Encapsulate a general SAX error or warning. <blockquote> <em>This module, both source code and documentation, is in the Public Domain, and comes with <strong>NO WARRANTY</strong>.</em> See <a href='http://www.saxproject.org'>http://www.saxproject.org</a> for further information. </blockquote> <p>This class can contain basic error or warning information from either the XML parser or the application: a parser writer or application writer can subclass it to provide additional functionality.  SAX handlers may throw this exception or any exception subclassed from it.</p> <p>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</p> <p>If the parser or application needs to include information about a specific location in an XML document, it should use the {@link org.xml.sax.SAXParseException SAXParseException} subclass.</p>
 * @since SAX 1.0
 * @author David Megginson
 * @version 2.0.1 (sax2r2)
 * @see org.xml.sax.SAXParseException
 */

block: 
/** 
 * Parse the specified XML document, and return a <code>TreeNode</code> that corresponds to the root node of the document tree.
 * @param location Location (eg URI) of the XML document being parsed
 * @param is Input source containing the deployment descriptor
 * @exception JasperException if an input/output error occurs
 * @exception JasperException if a parsing error occurs
 */
public TreeNode parseXMLDocument(String location,InputSource is) throws JasperException {
  Document document=null;
  ClassLoader original;
  if (Constants.IS_SECURITY_ENABLED) {
    PrivilegedGetTccl pa=new PrivilegedGetTccl();
    original=AccessController.doPrivileged(pa);
  }
 else {
    original=Thread.currentThread().getContextClassLoader();
  }
  try {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(ParserUtils.class.getClassLoader());
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(ParserUtils.class.getClassLoader());
    }
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    factory.setNamespaceAware(true);
    factory.setValidating(validating);
    if (validating) {
      factory.setFeature("http://xml.org/sax/features/validation",true);
      factory.setFeature("http://apache.org/xml/features/validation/schema",true);
    }
    DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setEntityResolver(entityResolverInstance);
    XmlErrorHandler handler=new XmlErrorHandler();
    builder.setErrorHandler(handler);
    document=builder.parse(is);
    if (!handler.getErrors().isEmpty()) {
      throw handler.getErrors().iterator().next();
    }
  }
 catch (  ParserConfigurationException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),ex);
  }
catch (  SAXParseException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml.line",location,Integer.toString(ex.getLineNumber()),Integer.toString(ex.getColumnNumber())),ex);
  }
catch (  SAXException sx) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),sx);
  }
catch (  IOException io) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),io);
  }
 finally {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(original);
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(original);
    }
  }
  return (convert(null,document.getDocumentElement()));
}

ID 6783=========================================================================type: 1
Method:org.apache.jasper.xmlparser.ParserUtils#parseXMLDocument(java.lang.String, org.xml.sax.InputSource)
Rmethod: javax.xml.parsers.DocumentBuilder#parse(org.xml.sax.InputSource)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Parse the specified XML document, and return a <code>TreeNode</code> that corresponds to the root node of the document tree.
 * @param location Location (eg URI) of the XML document being parsed
 * @param is Input source containing the deployment descriptor
 * @exception JasperException if an input/output error occurs
 * @exception JasperException if a parsing error occurs
 */
public TreeNode parseXMLDocument(String location,InputSource is) throws JasperException {
  Document document=null;
  ClassLoader original;
  if (Constants.IS_SECURITY_ENABLED) {
    PrivilegedGetTccl pa=new PrivilegedGetTccl();
    original=AccessController.doPrivileged(pa);
  }
 else {
    original=Thread.currentThread().getContextClassLoader();
  }
  try {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(ParserUtils.class.getClassLoader());
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(ParserUtils.class.getClassLoader());
    }
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    factory.setNamespaceAware(true);
    factory.setValidating(validating);
    if (validating) {
      factory.setFeature("http://xml.org/sax/features/validation",true);
      factory.setFeature("http://apache.org/xml/features/validation/schema",true);
    }
    DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setEntityResolver(entityResolverInstance);
    XmlErrorHandler handler=new XmlErrorHandler();
    builder.setErrorHandler(handler);
    document=builder.parse(is);
    if (!handler.getErrors().isEmpty()) {
      throw handler.getErrors().iterator().next();
    }
  }
 catch (  ParserConfigurationException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),ex);
  }
catch (  SAXParseException ex) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml.line",location,Integer.toString(ex.getLineNumber()),Integer.toString(ex.getColumnNumber())),ex);
  }
catch (  SAXException sx) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),sx);
  }
catch (  IOException io) {
    throw new JasperException(Localizer.getMessage("jsp.error.parse.xml",location),io);
  }
 finally {
    if (Constants.IS_SECURITY_ENABLED) {
      PrivilegedSetTccl pa=new PrivilegedSetTccl(original);
      AccessController.doPrivileged(pa);
    }
 else {
      Thread.currentThread().setContextClassLoader(original);
    }
  }
  return (convert(null,document.getDocumentElement()));
}

ID 6870=========================================================================type: 1
Method:org.apache.jasper.EmbeddedServletOptions#EmbeddedServletOptions(javax.servlet.ServletConfig, javax.servlet.ServletContext)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
/** 
 * Create an EmbeddedServletOptions object using data available from ServletConfig and ServletContext. 
 */
public EmbeddedServletOptions(ServletConfig config,ServletContext context){
  Enumeration<String> enumeration=config.getInitParameterNames();
  while (enumeration.hasMoreElements()) {
    String k=enumeration.nextElement();
    String v=config.getInitParameter(k);
    setProperty(k,v);
  }
  String keepgen=config.getInitParameter("keepgenerated");
  if (keepgen != null) {
    if (keepgen.equalsIgnoreCase("true")) {
      this.keepGenerated=true;
    }
 else     if (keepgen.equalsIgnoreCase("false")) {
      this.keepGenerated=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.keepgen"));
      }
    }
  }
  String trimsp=config.getInitParameter("trimSpaces");
  if (trimsp != null) {
    if (trimsp.equalsIgnoreCase("true")) {
      trimSpaces=true;
    }
 else     if (trimsp.equalsIgnoreCase("false")) {
      trimSpaces=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.trimspaces"));
      }
    }
  }
  this.isPoolingEnabled=true;
  String poolingEnabledParam=config.getInitParameter("enablePooling");
  if (poolingEnabledParam != null && !poolingEnabledParam.equalsIgnoreCase("true")) {
    if (poolingEnabledParam.equalsIgnoreCase("false")) {
      this.isPoolingEnabled=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.enablePooling"));
      }
    }
  }
  String mapFile=config.getInitParameter("mappedfile");
  if (mapFile != null) {
    if (mapFile.equalsIgnoreCase("true")) {
      this.mappedFile=true;
    }
 else     if (mapFile.equalsIgnoreCase("false")) {
      this.mappedFile=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.mappedFile"));
      }
    }
  }
  String debugInfo=config.getInitParameter("classdebuginfo");
  if (debugInfo != null) {
    if (debugInfo.equalsIgnoreCase("true")) {
      this.classDebugInfo=true;
    }
 else     if (debugInfo.equalsIgnoreCase("false")) {
      this.classDebugInfo=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.classDebugInfo"));
      }
    }
  }
  String checkInterval=config.getInitParameter("checkInterval");
  if (checkInterval != null) {
    try {
      this.checkInterval=Integer.parseInt(checkInterval);
    }
 catch (    NumberFormatException ex) {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.checkInterval"));
      }
    }
  }
  String modificationTestInterval=config.getInitParameter("modificationTestInterval");
  if (modificationTestInterval != null) {
    try {
      this.modificationTestInterval=Integer.parseInt(modificationTestInterval);
    }
 catch (    NumberFormatException ex) {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.modificationTestInterval"));
      }
    }
  }
  String recompileOnFail=config.getInitParameter("recompileOnFail");
  if (recompileOnFail != null) {
    if (recompileOnFail.equalsIgnoreCase("true")) {
      this.recompileOnFail=true;
    }
 else     if (recompileOnFail.equalsIgnoreCase("false")) {
      this.recompileOnFail=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.recompileOnFail"));
      }
    }
  }
  String development=config.getInitParameter("development");
  if (development != null) {
    if (development.equalsIgnoreCase("true")) {
      this.development=true;
    }
 else     if (development.equalsIgnoreCase("false")) {
      this.development=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.development"));
      }
    }
  }
  String suppressSmap=config.getInitParameter("suppressSmap");
  if (suppressSmap != null) {
    if (suppressSmap.equalsIgnoreCase("true")) {
      isSmapSuppressed=true;
    }
 else     if (suppressSmap.equalsIgnoreCase("false")) {
      isSmapSuppressed=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.suppressSmap"));
      }
    }
  }
  String dumpSmap=config.getInitParameter("dumpSmap");
  if (dumpSmap != null) {
    if (dumpSmap.equalsIgnoreCase("true")) {
      isSmapDumped=true;
    }
 else     if (dumpSmap.equalsIgnoreCase("false")) {
      isSmapDumped=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.dumpSmap"));
      }
    }
  }
  String genCharArray=config.getInitParameter("genStringAsCharArray");
  if (genCharArray != null) {
    if (genCharArray.equalsIgnoreCase("true")) {
      genStringAsCharArray=true;
    }
 else     if (genCharArray.equalsIgnoreCase("false")) {
      genStringAsCharArray=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.genchararray"));
      }
    }
  }
  String errBeanClass=config.getInitParameter("errorOnUseBeanInvalidClassAttribute");
  if (errBeanClass != null) {
    if (errBeanClass.equalsIgnoreCase("true")) {
      errorOnUseBeanInvalidClassAttribute=true;
    }
 else     if (errBeanClass.equalsIgnoreCase("false")) {
      errorOnUseBeanInvalidClassAttribute=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.errBean"));
      }
    }
  }
  String ieClassId=config.getInitParameter("ieClassId");
  if (ieClassId != null)   this.ieClassId=ieClassId;
  String classpath=config.getInitParameter("classpath");
  if (classpath != null)   this.classpath=classpath;
  String dir=config.getInitParameter("scratchdir");
  if (dir != null && Constants.IS_SECURITY_ENABLED) {
    log.info(Localizer.getMessage("jsp.info.ignoreSetting","scratchdir",dir));
    dir=null;
  }
  if (dir != null) {
    scratchDir=new File(dir);
  }
 else {
    scratchDir=(File)context.getAttribute(ServletContext.TEMPDIR);
    if (scratchDir == null) {
      dir=System.getProperty("java.io.tmpdir");
      if (dir != null)       scratchDir=new File(dir);
    }
  }
  if (this.scratchDir == null) {
    log.fatal(Localizer.getMessage("jsp.error.no.scratch.dir"));
    return;
  }
  if (!(scratchDir.exists() && scratchDir.canRead() && scratchDir.canWrite()&& scratchDir.isDirectory()))   log.fatal(Localizer.getMessage("jsp.error.bad.scratch.dir",scratchDir.getAbsolutePath()));
  this.compiler=config.getInitParameter("compiler");
  String compilerTargetVM=config.getInitParameter("compilerTargetVM");
  if (compilerTargetVM != null) {
    this.compilerTargetVM=compilerTargetVM;
  }
  String compilerSourceVM=config.getInitParameter("compilerSourceVM");
  if (compilerSourceVM != null) {
    this.compilerSourceVM=compilerSourceVM;
  }
  String javaEncoding=config.getInitParameter("javaEncoding");
  if (javaEncoding != null) {
    this.javaEncoding=javaEncoding;
  }
  String compilerClassName=config.getInitParameter("compilerClassName");
  if (compilerClassName != null) {
    this.compilerClassName=compilerClassName;
  }
  String fork=config.getInitParameter("fork");
  if (fork != null) {
    if (fork.equalsIgnoreCase("true")) {
      this.fork=true;
    }
 else     if (fork.equalsIgnoreCase("false")) {
      this.fork=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.fork"));
      }
    }
  }
  String xpoweredBy=config.getInitParameter("xpoweredBy");
  if (xpoweredBy != null) {
    if (xpoweredBy.equalsIgnoreCase("true")) {
      this.xpoweredBy=true;
    }
 else     if (xpoweredBy.equalsIgnoreCase("false")) {
      this.xpoweredBy=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.xpoweredBy"));
      }
    }
  }
  String displaySourceFragment=config.getInitParameter("displaySourceFragment");
  if (displaySourceFragment != null) {
    if (displaySourceFragment.equalsIgnoreCase("true")) {
      this.displaySourceFragment=true;
    }
 else     if (displaySourceFragment.equalsIgnoreCase("false")) {
      this.displaySourceFragment=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.displaySourceFragment"));
      }
    }
  }
  String maxLoadedJsps=config.getInitParameter("maxLoadedJsps");
  if (maxLoadedJsps != null) {
    try {
      this.maxLoadedJsps=Integer.parseInt(maxLoadedJsps);
    }
 catch (    NumberFormatException ex) {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.maxLoadedJsps","" + this.maxLoadedJsps));
      }
    }
  }
  String jspIdleTimeout=config.getInitParameter("jspIdleTimeout");
  if (jspIdleTimeout != null) {
    try {
      this.jspIdleTimeout=Integer.parseInt(jspIdleTimeout);
    }
 catch (    NumberFormatException ex) {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.jspIdleTimeout","" + this.jspIdleTimeout));
      }
    }
  }
  String quoteAttributeEL=config.getInitParameter("quoteAttributeEL");
  if (quoteAttributeEL != null) {
    if (quoteAttributeEL.equalsIgnoreCase("true")) {
      this.quoteAttributeEL=true;
    }
 else     if (quoteAttributeEL.equalsIgnoreCase("false")) {
      this.quoteAttributeEL=false;
    }
 else {
      if (log.isWarnEnabled()) {
        log.warn(Localizer.getMessage("jsp.warning.quoteAttributeEL"));
      }
    }
  }
  tldLocationsCache=TldLocationsCache.getInstance(context);
  jspConfig=new JspConfig(context);
  tagPluginManager=new TagPluginManager(context);
}

ID 6878=========================================================================type: 1
Method:async.Async1#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override protected void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  final AsyncContext actx=req.startAsync();
  actx.setTimeout(30 * 1000);
  Runnable run=new Runnable(){
    @Override public void run(){
      try {
        String path="/jsp/async/async1.jsp";
        Thread.currentThread().setName("Async1-Thread");
        log.info("Putting AsyncThread to sleep");
        Thread.sleep(2 * 1000);
        log.info("Dispatching to " + path);
        actx.dispatch(path);
      }
 catch (      InterruptedException x) {
        log.error("Async1",x);
      }
catch (      IllegalStateException x) {
        log.error("Async1",x);
      }
    }
  }
;
  Thread t=new Thread(run);
  t.start();
}

ID 6879=========================================================================type: 1
Method:async#run()
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  try {
    String path="/jsp/async/async1.jsp";
    Thread.currentThread().setName("Async1-Thread");
    log.info("Putting AsyncThread to sleep");
    Thread.sleep(2 * 1000);
    log.info("Dispatching to " + path);
    actx.dispatch(path);
  }
 catch (  InterruptedException x) {
    log.error("Async1",x);
  }
catch (  IllegalStateException x) {
    log.error("Async1",x);
  }
}

ID 6881=========================================================================type: 1
Method:async.AsyncStockServlet#writeStock(javax.servlet.AsyncContext, async.Stockticker.Stock)
Rmethod: javax.servlet.ServletResponse#getWriter()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void writeStock(AsyncContext actx,Stock stock){
  HttpServletResponse response=(HttpServletResponse)actx.getResponse();
  try {
    PrintWriter writer=response.getWriter();
    writer.write("STOCK#");
    writer.write(stock.getSymbol());
    writer.write("#");
    writer.write(stock.getValueAsString());
    writer.write("#");
    writer.write(stock.getLastChangeAsString());
    writer.write("#");
    writer.write(String.valueOf(stock.getCnt()));
    writer.write("\n");
    writer.flush();
    response.flushBuffer();
  }
 catch (  IOException x) {
    try {
      actx.complete();
    }
 catch (    Exception ignore) {
    }
  }
}

ID 6882=========================================================================type: 1
Method:async.AsyncStockServlet#writeStock(javax.servlet.AsyncContext, async.Stockticker.Stock)
Rmethod: javax.servlet.ServletResponse#flushBuffer()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
public void writeStock(AsyncContext actx,Stock stock){
  HttpServletResponse response=(HttpServletResponse)actx.getResponse();
  try {
    PrintWriter writer=response.getWriter();
    writer.write("STOCK#");
    writer.write(stock.getSymbol());
    writer.write("#");
    writer.write(stock.getValueAsString());
    writer.write("#");
    writer.write(stock.getLastChangeAsString());
    writer.write("#");
    writer.write(String.valueOf(stock.getCnt()));
    writer.write("\n");
    writer.flush();
    response.flushBuffer();
  }
 catch (  IOException x) {
    try {
      actx.complete();
    }
 catch (    Exception ignore) {
    }
  }
}

ID 6885=========================================================================type: 1
Method:async.Async0#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override protected void service(final HttpServletRequest req,final HttpServletResponse resp) throws ServletException, IOException {
  if (Boolean.TRUE.equals(req.getAttribute("dispatch"))) {
    log.info("Received dispatch, completing on the worker thread.");
    log.info("After complete called started:" + req.isAsyncStarted());
    resp.getWriter().write("Async dispatch worked:+" + System.currentTimeMillis() + "\n");
  }
 else {
    resp.setContentType("text/plain");
    final AsyncContext actx=req.startAsync();
    actx.setTimeout(Long.MAX_VALUE);
    Runnable run=new Runnable(){
      @Override public void run(){
        try {
          req.setAttribute("dispatch",Boolean.TRUE);
          Thread.currentThread().setName("Async0-Thread");
          log.info("Putting AsyncThread to sleep");
          Thread.sleep(2 * 1000);
          log.info("Dispatching");
          actx.dispatch();
        }
 catch (        InterruptedException x) {
          log.error("Async1",x);
        }
catch (        IllegalStateException x) {
          log.error("Async1",x);
        }
      }
    }
;
    Thread t=new Thread(run);
    t.start();
  }
}

ID 6886=========================================================================type: 1
Method:async#run()
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  try {
    req.setAttribute("dispatch",Boolean.TRUE);
    Thread.currentThread().setName("Async0-Thread");
    log.info("Putting AsyncThread to sleep");
    Thread.sleep(2 * 1000);
    log.info("Dispatching");
    actx.dispatch();
  }
 catch (  InterruptedException x) {
    log.error("Async1",x);
  }
catch (  IllegalStateException x) {
    log.error("Async1",x);
  }
}

ID 6887=========================================================================type: 1
Method:async.Async2#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override protected void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  final AsyncContext actx=req.startAsync();
  actx.setTimeout(30 * 1000);
  Runnable run=new Runnable(){
    @Override public void run(){
      try {
        Thread.currentThread().setName("Async2-Thread");
        log.info("Putting AsyncThread to sleep");
        Thread.sleep(2 * 1000);
        log.info("Writing data.");
        actx.getResponse().getWriter().write("Output from background thread. Time:" + System.currentTimeMillis() + "\n");
        actx.complete();
      }
 catch (      InterruptedException x) {
        log.error("Async2",x);
      }
catch (      IllegalStateException x) {
        log.error("Async2",x);
      }
catch (      IOException x) {
        log.error("Async2",x);
      }
    }
  }
;
  Thread t=new Thread(run);
  t.start();
}

ID 6888=========================================================================type: 1
Method:async.Async2#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
Rmethod: javax.servlet.ServletResponse#getWriter()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override protected void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  final AsyncContext actx=req.startAsync();
  actx.setTimeout(30 * 1000);
  Runnable run=new Runnable(){
    @Override public void run(){
      try {
        Thread.currentThread().setName("Async2-Thread");
        log.info("Putting AsyncThread to sleep");
        Thread.sleep(2 * 1000);
        log.info("Writing data.");
        actx.getResponse().getWriter().write("Output from background thread. Time:" + System.currentTimeMillis() + "\n");
        actx.complete();
      }
 catch (      InterruptedException x) {
        log.error("Async2",x);
      }
catch (      IllegalStateException x) {
        log.error("Async2",x);
      }
catch (      IOException x) {
        log.error("Async2",x);
      }
    }
  }
;
  Thread t=new Thread(run);
  t.start();
}

ID 6889=========================================================================type: 1
Method:async#run()
Rmethod: java.lang.Thread#sleep(long)
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  try {
    Thread.currentThread().setName("Async2-Thread");
    log.info("Putting AsyncThread to sleep");
    Thread.sleep(2 * 1000);
    log.info("Writing data.");
    actx.getResponse().getWriter().write("Output from background thread. Time:" + System.currentTimeMillis() + "\n");
    actx.complete();
  }
 catch (  InterruptedException x) {
    log.error("Async2",x);
  }
catch (  IllegalStateException x) {
    log.error("Async2",x);
  }
catch (  IOException x) {
    log.error("Async2",x);
  }
}

ID 6890=========================================================================type: 1
Method:async#run()
Rmethod: javax.servlet.ServletResponse#getWriter()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public void run(){
  try {
    Thread.currentThread().setName("Async2-Thread");
    log.info("Putting AsyncThread to sleep");
    Thread.sleep(2 * 1000);
    log.info("Writing data.");
    actx.getResponse().getWriter().write("Output from background thread. Time:" + System.currentTimeMillis() + "\n");
    actx.complete();
  }
 catch (  InterruptedException x) {
    log.error("Async2",x);
  }
catch (  IllegalStateException x) {
    log.error("Async2",x);
  }
catch (  IOException x) {
    log.error("Async2",x);
  }
}

ID 6891=========================================================================type: 1
Method:async.Stockticker#stop()
Rmethod: java.lang.Thread#join()
parentException: 
thrown: InterruptedException
exception comment: /** 
 * Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.  The following code can be used to achieve this effect: <pre> if (Thread.interrupted())  // Clears interrupted status! throw new InterruptedException(); </pre>
 * @author  Frank Yellin
 * @see java.lang.Object#wait()
 * @see java.lang.Object#wait(long)
 * @see java.lang.Object#wait(long,int)
 * @see java.lang.Thread#sleep(long)
 * @see java.lang.Thread#interrupt()
 * @see java.lang.Thread#interrupted()
 * @since   JDK1.0
 */

block: 
public synchronized void stop(){
  run=false;
  try {
    ticker.join();
  }
 catch (  InterruptedException x) {
    Thread.interrupted();
  }
  ticker=null;
}

ID 6893=========================================================================type: 1
Method:num.NumberGuessBean#setGuess(java.lang.String)
Rmethod: java.lang.Integer#parseInt(java.lang.String)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
public void setGuess(String guess){
  numGuesses++;
  int g;
  try {
    g=Integer.parseInt(guess);
  }
 catch (  NumberFormatException e) {
    g=-1;
  }
  if (g == answer) {
    success=true;
  }
 else   if (g == -1) {
    hint="a number next time";
  }
 else   if (g < answer) {
    hint="higher";
  }
 else   if (g > answer) {
    hint="lower";
  }
}

ID 6951=========================================================================type: 1
Method:javax.servlet.http.HttpUtils#parsePostData(int, javax.servlet.ServletInputStream)
Rmethod: java.io.InputStream#read(byte[], int, int)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Parses data from an HTML form that the client sends to  the server using the HTTP POST method and the  <i>application/x-www-form-urlencoded</i> MIME type. <p>The data sent by the POST method contains key-value pairs. A key can appear more than once in the POST data with different values. However, the key appears only once in  the hashtable, with its value being an array of strings containing the multiple values sent by the POST method. <p>The keys and values in the hashtable are stored in their decoded form, so any + characters are converted to spaces, and characters sent in hexadecimal notation (like <i>%xx</i>) are converted to ASCII characters.
 * @param len        an integer specifying the length,in characters, of the  <code>ServletInputStream</code> object that is also passed to this method
 * @param in        the <code>ServletInputStream</code>object that contains the data sent from the client
 * @return                a <code>HashTable</code> object builtfrom the parsed key-value pairs
 * @exception IllegalArgumentException        if the datasent by the POST method is invalid
 */
public static Hashtable<String,String[]> parsePostData(int len,ServletInputStream in){
  if (len <= 0)   return new Hashtable<String,String[]>();
  if (in == null) {
    throw new IllegalArgumentException();
  }
  byte[] postedBytes=new byte[len];
  try {
    int offset=0;
    do {
      int inputLen=in.read(postedBytes,offset,len - offset);
      if (inputLen <= 0) {
        String msg=lStrings.getString("err.io.short_read");
        throw new IllegalArgumentException(msg);
      }
      offset+=inputLen;
    }
 while ((len - offset) > 0);
  }
 catch (  IOException e) {
    throw new IllegalArgumentException(e.getMessage(),e);
  }
  try {
    String postedBody=new String(postedBytes,0,len,"8859_1");
    return parseQueryString(postedBody);
  }
 catch (  java.io.UnsupportedEncodingException e) {
    throw new IllegalArgumentException(e.getMessage(),e);
  }
}

ID 6952=========================================================================type: 1
Method:javax.servlet.http.HttpUtils#parsePostData(int, javax.servlet.ServletInputStream)
Rmethod: java.lang.String#String(byte[], int, int, java.lang.String)
parentException: IOException 
thrown: UnsupportedEncodingException
exception comment: /** 
 * The Character Encoding is not supported.
 * @author  Asmus Freytag
 * @since   JDK1.1
 */

block: 
/** 
 * Parses data from an HTML form that the client sends to  the server using the HTTP POST method and the  <i>application/x-www-form-urlencoded</i> MIME type. <p>The data sent by the POST method contains key-value pairs. A key can appear more than once in the POST data with different values. However, the key appears only once in  the hashtable, with its value being an array of strings containing the multiple values sent by the POST method. <p>The keys and values in the hashtable are stored in their decoded form, so any + characters are converted to spaces, and characters sent in hexadecimal notation (like <i>%xx</i>) are converted to ASCII characters.
 * @param len        an integer specifying the length,in characters, of the  <code>ServletInputStream</code> object that is also passed to this method
 * @param in        the <code>ServletInputStream</code>object that contains the data sent from the client
 * @return                a <code>HashTable</code> object builtfrom the parsed key-value pairs
 * @exception IllegalArgumentException        if the datasent by the POST method is invalid
 */
public static Hashtable<String,String[]> parsePostData(int len,ServletInputStream in){
  if (len <= 0)   return new Hashtable<String,String[]>();
  if (in == null) {
    throw new IllegalArgumentException();
  }
  byte[] postedBytes=new byte[len];
  try {
    int offset=0;
    do {
      int inputLen=in.read(postedBytes,offset,len - offset);
      if (inputLen <= 0) {
        String msg=lStrings.getString("err.io.short_read");
        throw new IllegalArgumentException(msg);
      }
      offset+=inputLen;
    }
 while ((len - offset) > 0);
  }
 catch (  IOException e) {
    throw new IllegalArgumentException(e.getMessage(),e);
  }
  try {
    String postedBody=new String(postedBytes,0,len,"8859_1");
    return parseQueryString(postedBody);
  }
 catch (  java.io.UnsupportedEncodingException e) {
    throw new IllegalArgumentException(e.getMessage(),e);
  }
}

ID 6953=========================================================================type: 1
Method:javax.servlet.http.HttpUtils#parseName(java.lang.String, java.lang.StringBuilder)
Rmethod: java.lang.Integer#parseInt(java.lang.String, int)
parentException: IllegalArgumentException RuntimeException 
thrown: NumberFormatException
exception comment: /** 
 * Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format.
 * @author  unascribed
 * @see java.lang.Integer#parseInt(String)
 * @since   JDK1.0
 */

block: 
private static String parseName(String s,StringBuilder sb){
  sb.setLength(0);
  for (int i=0; i < s.length(); i++) {
    char c=s.charAt(i);
switch (c) {
case '+':
      sb.append(' ');
    break;
case '%':
  try {
    sb.append((char)Integer.parseInt(s.substring(i + 1,i + 3),16));
    i+=2;
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException();
  }
catch (  StringIndexOutOfBoundsException e) {
    String rest=s.substring(i);
    sb.append(rest);
    if (rest.length() == 2)     i++;
  }
break;
default :
sb.append(c);
break;
}
}
return sb.toString();
}

ID 6954=========================================================================type: 1
Method:javax.servlet.jsp.tagext.BodyContent#clearBody()
Rmethod: javax.servlet.jsp.JspWriter#clear()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Clear the body without throwing any exceptions.
 */
public void clearBody(){
  try {
    this.clear();
  }
 catch (  IOException ex) {
    throw new Error("internal error!;");
  }
}

ID 6981=========================================================================type: 1
Method:javax.el.ExpressionFactory#newInstance(java.util.Properties)
Rmethod: java.lang.Class#getConstructor(Class<?>[])
parentException: RuntimeException 
thrown: SecurityException
exception comment: /** 
 * Thrown by the security manager to indicate a security violation.
 * @author  unascribed
 * @see java.lang.SecurityManager
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new  {@link ExpressionFactory} passing in the provided{@link Properties}. Search order is the same as  {@link #newInstance()}.
 * @param properties the properties to be passed to the new instance (may be null)
 * @return the new ExpressionFactory
 */
public static ExpressionFactory newInstance(Properties properties){
  ExpressionFactory result=null;
  ClassLoader tccl=Thread.currentThread().getContextClassLoader();
  CacheValue cacheValue;
  Class<?> clazz;
  if (tccl == null) {
    cacheValue=nullTcclFactory;
  }
 else {
    CacheKey key=new CacheKey(tccl);
    cacheValue=factoryCache.get(key);
    if (cacheValue == null) {
      CacheValue newCacheValue=new CacheValue();
      cacheValue=factoryCache.putIfAbsent(key,newCacheValue);
      if (cacheValue == null) {
        cacheValue=newCacheValue;
      }
    }
  }
  final Lock readLock=cacheValue.getLock().readLock();
  readLock.lock();
  try {
    clazz=cacheValue.getFactoryClass();
  }
  finally {
    readLock.unlock();
  }
  if (clazz == null) {
    String className=null;
    try {
      final Lock writeLock=cacheValue.getLock().writeLock();
      writeLock.lock();
      try {
        className=cacheValue.getFactoryClassName();
        if (className == null) {
          className=discoverClassName(tccl);
          cacheValue.setFactoryClassName(className);
        }
        if (tccl == null) {
          clazz=Class.forName(className);
        }
 else {
          clazz=tccl.loadClass(className);
        }
        cacheValue.setFactoryClass(clazz);
      }
  finally {
        writeLock.unlock();
      }
    }
 catch (    ClassNotFoundException e) {
      throw new ELException("Unable to find ExpressionFactory of type: " + className,e);
    }
  }
  try {
    Constructor<?> constructor=null;
    if (properties != null) {
      try {
        constructor=clazz.getConstructor(Properties.class);
      }
 catch (      SecurityException se) {
        throw new ELException(se);
      }
catch (      NoSuchMethodException nsme) {
      }
    }
    if (constructor == null) {
      result=(ExpressionFactory)clazz.newInstance();
    }
 else {
      result=(ExpressionFactory)constructor.newInstance(properties);
    }
  }
 catch (  InstantiationException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalAccessException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalArgumentException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
  return result;
}

ID 6982=========================================================================type: 1
Method:javax.el.ExpressionFactory#newInstance(java.util.Properties)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new  {@link ExpressionFactory} passing in the provided{@link Properties}. Search order is the same as  {@link #newInstance()}.
 * @param properties the properties to be passed to the new instance (may be null)
 * @return the new ExpressionFactory
 */
public static ExpressionFactory newInstance(Properties properties){
  ExpressionFactory result=null;
  ClassLoader tccl=Thread.currentThread().getContextClassLoader();
  CacheValue cacheValue;
  Class<?> clazz;
  if (tccl == null) {
    cacheValue=nullTcclFactory;
  }
 else {
    CacheKey key=new CacheKey(tccl);
    cacheValue=factoryCache.get(key);
    if (cacheValue == null) {
      CacheValue newCacheValue=new CacheValue();
      cacheValue=factoryCache.putIfAbsent(key,newCacheValue);
      if (cacheValue == null) {
        cacheValue=newCacheValue;
      }
    }
  }
  final Lock readLock=cacheValue.getLock().readLock();
  readLock.lock();
  try {
    clazz=cacheValue.getFactoryClass();
  }
  finally {
    readLock.unlock();
  }
  if (clazz == null) {
    String className=null;
    try {
      final Lock writeLock=cacheValue.getLock().writeLock();
      writeLock.lock();
      try {
        className=cacheValue.getFactoryClassName();
        if (className == null) {
          className=discoverClassName(tccl);
          cacheValue.setFactoryClassName(className);
        }
        if (tccl == null) {
          clazz=Class.forName(className);
        }
 else {
          clazz=tccl.loadClass(className);
        }
        cacheValue.setFactoryClass(clazz);
      }
  finally {
        writeLock.unlock();
      }
    }
 catch (    ClassNotFoundException e) {
      throw new ELException("Unable to find ExpressionFactory of type: " + className,e);
    }
  }
  try {
    Constructor<?> constructor=null;
    if (properties != null) {
      try {
        constructor=clazz.getConstructor(Properties.class);
      }
 catch (      SecurityException se) {
        throw new ELException(se);
      }
catch (      NoSuchMethodException nsme) {
      }
    }
    if (constructor == null) {
      result=(ExpressionFactory)clazz.newInstance();
    }
 else {
      result=(ExpressionFactory)constructor.newInstance(properties);
    }
  }
 catch (  InstantiationException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalAccessException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalArgumentException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
  return result;
}

ID 6983=========================================================================type: 1
Method:javax.el.ExpressionFactory#newInstance(java.util.Properties)
Rmethod: java.lang.Class#newInstance()
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new  {@link ExpressionFactory} passing in the provided{@link Properties}. Search order is the same as  {@link #newInstance()}.
 * @param properties the properties to be passed to the new instance (may be null)
 * @return the new ExpressionFactory
 */
public static ExpressionFactory newInstance(Properties properties){
  ExpressionFactory result=null;
  ClassLoader tccl=Thread.currentThread().getContextClassLoader();
  CacheValue cacheValue;
  Class<?> clazz;
  if (tccl == null) {
    cacheValue=nullTcclFactory;
  }
 else {
    CacheKey key=new CacheKey(tccl);
    cacheValue=factoryCache.get(key);
    if (cacheValue == null) {
      CacheValue newCacheValue=new CacheValue();
      cacheValue=factoryCache.putIfAbsent(key,newCacheValue);
      if (cacheValue == null) {
        cacheValue=newCacheValue;
      }
    }
  }
  final Lock readLock=cacheValue.getLock().readLock();
  readLock.lock();
  try {
    clazz=cacheValue.getFactoryClass();
  }
  finally {
    readLock.unlock();
  }
  if (clazz == null) {
    String className=null;
    try {
      final Lock writeLock=cacheValue.getLock().writeLock();
      writeLock.lock();
      try {
        className=cacheValue.getFactoryClassName();
        if (className == null) {
          className=discoverClassName(tccl);
          cacheValue.setFactoryClassName(className);
        }
        if (tccl == null) {
          clazz=Class.forName(className);
        }
 else {
          clazz=tccl.loadClass(className);
        }
        cacheValue.setFactoryClass(clazz);
      }
  finally {
        writeLock.unlock();
      }
    }
 catch (    ClassNotFoundException e) {
      throw new ELException("Unable to find ExpressionFactory of type: " + className,e);
    }
  }
  try {
    Constructor<?> constructor=null;
    if (properties != null) {
      try {
        constructor=clazz.getConstructor(Properties.class);
      }
 catch (      SecurityException se) {
        throw new ELException(se);
      }
catch (      NoSuchMethodException nsme) {
      }
    }
    if (constructor == null) {
      result=(ExpressionFactory)clazz.newInstance();
    }
 else {
      result=(ExpressionFactory)constructor.newInstance(properties);
    }
  }
 catch (  InstantiationException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalAccessException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalArgumentException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
  return result;
}

ID 6984=========================================================================type: 1
Method:javax.el.ExpressionFactory#newInstance(java.util.Properties)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InstantiationException
exception comment: /** 
 * Thrown when an application tries to create an instance of a class using the  {@code newInstance} method in class{@code Class}, but the specified class object cannot be instantiated.  The instantiation can fail for a variety of reasons including but not limited to: <ul> <li> the class object represents an abstract class, an interface, an array class, a primitive type, or  {@code void}<li> the class has no nullary constructor </ul>
 * @author  unascribed
 * @see java.lang.Class#newInstance()
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new  {@link ExpressionFactory} passing in the provided{@link Properties}. Search order is the same as  {@link #newInstance()}.
 * @param properties the properties to be passed to the new instance (may be null)
 * @return the new ExpressionFactory
 */
public static ExpressionFactory newInstance(Properties properties){
  ExpressionFactory result=null;
  ClassLoader tccl=Thread.currentThread().getContextClassLoader();
  CacheValue cacheValue;
  Class<?> clazz;
  if (tccl == null) {
    cacheValue=nullTcclFactory;
  }
 else {
    CacheKey key=new CacheKey(tccl);
    cacheValue=factoryCache.get(key);
    if (cacheValue == null) {
      CacheValue newCacheValue=new CacheValue();
      cacheValue=factoryCache.putIfAbsent(key,newCacheValue);
      if (cacheValue == null) {
        cacheValue=newCacheValue;
      }
    }
  }
  final Lock readLock=cacheValue.getLock().readLock();
  readLock.lock();
  try {
    clazz=cacheValue.getFactoryClass();
  }
  finally {
    readLock.unlock();
  }
  if (clazz == null) {
    String className=null;
    try {
      final Lock writeLock=cacheValue.getLock().writeLock();
      writeLock.lock();
      try {
        className=cacheValue.getFactoryClassName();
        if (className == null) {
          className=discoverClassName(tccl);
          cacheValue.setFactoryClassName(className);
        }
        if (tccl == null) {
          clazz=Class.forName(className);
        }
 else {
          clazz=tccl.loadClass(className);
        }
        cacheValue.setFactoryClass(clazz);
      }
  finally {
        writeLock.unlock();
      }
    }
 catch (    ClassNotFoundException e) {
      throw new ELException("Unable to find ExpressionFactory of type: " + className,e);
    }
  }
  try {
    Constructor<?> constructor=null;
    if (properties != null) {
      try {
        constructor=clazz.getConstructor(Properties.class);
      }
 catch (      SecurityException se) {
        throw new ELException(se);
      }
catch (      NoSuchMethodException nsme) {
      }
    }
    if (constructor == null) {
      result=(ExpressionFactory)clazz.newInstance();
    }
 else {
      result=(ExpressionFactory)constructor.newInstance(properties);
    }
  }
 catch (  InstantiationException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalAccessException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalArgumentException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
  return result;
}

ID 6985=========================================================================type: 1
Method:javax.el.ExpressionFactory#newInstance(java.util.Properties)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new  {@link ExpressionFactory} passing in the provided{@link Properties}. Search order is the same as  {@link #newInstance()}.
 * @param properties the properties to be passed to the new instance (may be null)
 * @return the new ExpressionFactory
 */
public static ExpressionFactory newInstance(Properties properties){
  ExpressionFactory result=null;
  ClassLoader tccl=Thread.currentThread().getContextClassLoader();
  CacheValue cacheValue;
  Class<?> clazz;
  if (tccl == null) {
    cacheValue=nullTcclFactory;
  }
 else {
    CacheKey key=new CacheKey(tccl);
    cacheValue=factoryCache.get(key);
    if (cacheValue == null) {
      CacheValue newCacheValue=new CacheValue();
      cacheValue=factoryCache.putIfAbsent(key,newCacheValue);
      if (cacheValue == null) {
        cacheValue=newCacheValue;
      }
    }
  }
  final Lock readLock=cacheValue.getLock().readLock();
  readLock.lock();
  try {
    clazz=cacheValue.getFactoryClass();
  }
  finally {
    readLock.unlock();
  }
  if (clazz == null) {
    String className=null;
    try {
      final Lock writeLock=cacheValue.getLock().writeLock();
      writeLock.lock();
      try {
        className=cacheValue.getFactoryClassName();
        if (className == null) {
          className=discoverClassName(tccl);
          cacheValue.setFactoryClassName(className);
        }
        if (tccl == null) {
          clazz=Class.forName(className);
        }
 else {
          clazz=tccl.loadClass(className);
        }
        cacheValue.setFactoryClass(clazz);
      }
  finally {
        writeLock.unlock();
      }
    }
 catch (    ClassNotFoundException e) {
      throw new ELException("Unable to find ExpressionFactory of type: " + className,e);
    }
  }
  try {
    Constructor<?> constructor=null;
    if (properties != null) {
      try {
        constructor=clazz.getConstructor(Properties.class);
      }
 catch (      SecurityException se) {
        throw new ELException(se);
      }
catch (      NoSuchMethodException nsme) {
      }
    }
    if (constructor == null) {
      result=(ExpressionFactory)clazz.newInstance();
    }
 else {
      result=(ExpressionFactory)constructor.newInstance(properties);
    }
  }
 catch (  InstantiationException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalAccessException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalArgumentException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
  return result;
}

ID 6986=========================================================================type: 1
Method:javax.el.ExpressionFactory#newInstance(java.util.Properties)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * Create a new  {@link ExpressionFactory} passing in the provided{@link Properties}. Search order is the same as  {@link #newInstance()}.
 * @param properties the properties to be passed to the new instance (may be null)
 * @return the new ExpressionFactory
 */
public static ExpressionFactory newInstance(Properties properties){
  ExpressionFactory result=null;
  ClassLoader tccl=Thread.currentThread().getContextClassLoader();
  CacheValue cacheValue;
  Class<?> clazz;
  if (tccl == null) {
    cacheValue=nullTcclFactory;
  }
 else {
    CacheKey key=new CacheKey(tccl);
    cacheValue=factoryCache.get(key);
    if (cacheValue == null) {
      CacheValue newCacheValue=new CacheValue();
      cacheValue=factoryCache.putIfAbsent(key,newCacheValue);
      if (cacheValue == null) {
        cacheValue=newCacheValue;
      }
    }
  }
  final Lock readLock=cacheValue.getLock().readLock();
  readLock.lock();
  try {
    clazz=cacheValue.getFactoryClass();
  }
  finally {
    readLock.unlock();
  }
  if (clazz == null) {
    String className=null;
    try {
      final Lock writeLock=cacheValue.getLock().writeLock();
      writeLock.lock();
      try {
        className=cacheValue.getFactoryClassName();
        if (className == null) {
          className=discoverClassName(tccl);
          cacheValue.setFactoryClassName(className);
        }
        if (tccl == null) {
          clazz=Class.forName(className);
        }
 else {
          clazz=tccl.loadClass(className);
        }
        cacheValue.setFactoryClass(clazz);
      }
  finally {
        writeLock.unlock();
      }
    }
 catch (    ClassNotFoundException e) {
      throw new ELException("Unable to find ExpressionFactory of type: " + className,e);
    }
  }
  try {
    Constructor<?> constructor=null;
    if (properties != null) {
      try {
        constructor=clazz.getConstructor(Properties.class);
      }
 catch (      SecurityException se) {
        throw new ELException(se);
      }
catch (      NoSuchMethodException nsme) {
      }
    }
    if (constructor == null) {
      result=(ExpressionFactory)clazz.newInstance();
    }
 else {
      result=(ExpressionFactory)constructor.newInstance(properties);
    }
  }
 catch (  InstantiationException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalAccessException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalArgumentException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
  return result;
}

ID 6987=========================================================================type: 1
Method:javax.el.ExpressionFactory#newInstance(java.util.Properties)
Rmethod: java.lang.reflect.Constructor#newInstance(java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * Create a new  {@link ExpressionFactory} passing in the provided{@link Properties}. Search order is the same as  {@link #newInstance()}.
 * @param properties the properties to be passed to the new instance (may be null)
 * @return the new ExpressionFactory
 */
public static ExpressionFactory newInstance(Properties properties){
  ExpressionFactory result=null;
  ClassLoader tccl=Thread.currentThread().getContextClassLoader();
  CacheValue cacheValue;
  Class<?> clazz;
  if (tccl == null) {
    cacheValue=nullTcclFactory;
  }
 else {
    CacheKey key=new CacheKey(tccl);
    cacheValue=factoryCache.get(key);
    if (cacheValue == null) {
      CacheValue newCacheValue=new CacheValue();
      cacheValue=factoryCache.putIfAbsent(key,newCacheValue);
      if (cacheValue == null) {
        cacheValue=newCacheValue;
      }
    }
  }
  final Lock readLock=cacheValue.getLock().readLock();
  readLock.lock();
  try {
    clazz=cacheValue.getFactoryClass();
  }
  finally {
    readLock.unlock();
  }
  if (clazz == null) {
    String className=null;
    try {
      final Lock writeLock=cacheValue.getLock().writeLock();
      writeLock.lock();
      try {
        className=cacheValue.getFactoryClassName();
        if (className == null) {
          className=discoverClassName(tccl);
          cacheValue.setFactoryClassName(className);
        }
        if (tccl == null) {
          clazz=Class.forName(className);
        }
 else {
          clazz=tccl.loadClass(className);
        }
        cacheValue.setFactoryClass(clazz);
      }
  finally {
        writeLock.unlock();
      }
    }
 catch (    ClassNotFoundException e) {
      throw new ELException("Unable to find ExpressionFactory of type: " + className,e);
    }
  }
  try {
    Constructor<?> constructor=null;
    if (properties != null) {
      try {
        constructor=clazz.getConstructor(Properties.class);
      }
 catch (      SecurityException se) {
        throw new ELException(se);
      }
catch (      NoSuchMethodException nsme) {
      }
    }
    if (constructor == null) {
      result=(ExpressionFactory)clazz.newInstance();
    }
 else {
      result=(ExpressionFactory)constructor.newInstance(properties);
    }
  }
 catch (  InstantiationException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalAccessException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  IllegalArgumentException e) {
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException("Unable to create ExpressionFactory of type: " + clazz.getName(),e);
  }
  return result;
}

ID 6989=========================================================================type: 1
Method:javax.el.ExpressionFactory#getClassNameServices(java.lang.ClassLoader)
Rmethod: java.io.BufferedReader#readLine()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private static String getClassNameServices(ClassLoader tccl){
  InputStream is=null;
  if (tccl == null) {
    is=ClassLoader.getSystemResourceAsStream(SERVICE_RESOURCE_NAME);
  }
 else {
    is=tccl.getResourceAsStream(SERVICE_RESOURCE_NAME);
  }
  if (is != null) {
    String line=null;
    BufferedReader br=null;
    InputStreamReader isr=null;
    try {
      isr=new InputStreamReader(is,"UTF-8");
      br=new BufferedReader(isr);
      line=br.readLine();
      if (line != null && line.trim().length() > 0) {
        return line.trim();
      }
    }
 catch (    UnsupportedEncodingException e) {
    }
catch (    IOException e) {
      throw new ELException("Failed to read " + SERVICE_RESOURCE_NAME,e);
    }
 finally {
      try {
        if (br != null) {
          br.close();
        }
      }
 catch (      IOException ioe) {
      }
      try {
        if (isr != null) {
          isr.close();
        }
      }
 catch (      IOException ioe) {
      }
      try {
        is.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
  return null;
}

ID 6994=========================================================================type: 1
Method:javax.el.ExpressionFactory#getClassNameJreDir()
Rmethod: java.util.Properties#load(java.io.InputStream)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
private static String getClassNameJreDir(){
  File file=new File(PROPERTY_FILE);
  if (file.canRead()) {
    InputStream is=null;
    try {
      is=new FileInputStream(file);
      Properties props=new Properties();
      props.load(is);
      String value=props.getProperty(PROPERTY_NAME);
      if (value != null && value.trim().length() > 0) {
        return value.trim();
      }
    }
 catch (    FileNotFoundException e) {
    }
catch (    IOException e) {
      throw new ELException("Failed to read " + PROPERTY_FILE,e);
    }
 finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  return null;
}

ID 7003=========================================================================type: 1
Method:javax.el.Util#isCoercibleFrom(java.lang.Object, Class<?>)
Rmethod: javax.el.ExpressionFactory#coerceToType(java.lang.Object, Class<?>)
parentException: RuntimeException 
thrown: ELException
exception comment: null
block: 
private static boolean isCoercibleFrom(Object src,Class<?> target){
  try {
    getExpressionFactory().coerceToType(src,target);
  }
 catch (  ELException e) {
    return false;
  }
  return true;
}

ID 7011=========================================================================type: 1
Method:javax.el.BeanELResolver#getValue(javax.el.ELContext, java.lang.Object, java.lang.Object)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public Object getValue(ELContext context,Object base,Object property) throws NullPointerException, PropertyNotFoundException, ELException {
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null || property == null) {
    return null;
  }
  context.setPropertyResolved(true);
  Method m=this.property(context,base,property).read(context);
  try {
    return m.invoke(base,(Object[])null);
  }
 catch (  IllegalAccessException e) {
    throw new ELException(e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(Util.message(context,"propertyReadError",base.getClass().getName(),property.toString()),cause);
  }
catch (  Exception e) {
    throw new ELException(e);
  }
}

ID 7013=========================================================================type: 1
Method:javax.el.BeanELResolver#getValue(javax.el.ELContext, java.lang.Object, java.lang.Object)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public Object getValue(ELContext context,Object base,Object property) throws NullPointerException, PropertyNotFoundException, ELException {
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null || property == null) {
    return null;
  }
  context.setPropertyResolved(true);
  Method m=this.property(context,base,property).read(context);
  try {
    return m.invoke(base,(Object[])null);
  }
 catch (  IllegalAccessException e) {
    throw new ELException(e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(Util.message(context,"propertyReadError",base.getClass().getName(),property.toString()),cause);
  }
catch (  Exception e) {
    throw new ELException(e);
  }
}

ID 7014=========================================================================type: 1
Method:javax.el.BeanELResolver#setValue(javax.el.ELContext, java.lang.Object, java.lang.Object, java.lang.Object)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
@Override public void setValue(ELContext context,Object base,Object property,Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException {
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null || property == null) {
    return;
  }
  context.setPropertyResolved(true);
  if (this.readOnly) {
    throw new PropertyNotWritableException(Util.message(context,"resolverNotWriteable",base.getClass().getName()));
  }
  Method m=this.property(context,base,property).write(context);
  try {
    m.invoke(base,value);
  }
 catch (  IllegalAccessException e) {
    throw new ELException(e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(Util.message(context,"propertyWriteError",base.getClass().getName(),property.toString()),cause);
  }
catch (  Exception e) {
    throw new ELException(e);
  }
}

ID 7016=========================================================================type: 1
Method:javax.el.BeanELResolver#setValue(javax.el.ELContext, java.lang.Object, java.lang.Object, java.lang.Object)
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
@Override public void setValue(ELContext context,Object base,Object property,Object value) throws NullPointerException, PropertyNotFoundException, PropertyNotWritableException, ELException {
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null || property == null) {
    return;
  }
  context.setPropertyResolved(true);
  if (this.readOnly) {
    throw new PropertyNotWritableException(Util.message(context,"resolverNotWriteable",base.getClass().getName()));
  }
  Method m=this.property(context,base,property).write(context);
  try {
    m.invoke(base,value);
  }
 catch (  IllegalAccessException e) {
    throw new ELException(e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ThreadDeath) {
      throw (ThreadDeath)cause;
    }
    if (cause instanceof VirtualMachineError) {
      throw (VirtualMachineError)cause;
    }
    throw new ELException(Util.message(context,"propertyWriteError",base.getClass().getName(),property.toString()),cause);
  }
catch (  Exception e) {
    throw new ELException(e);
  }
}

ID 7018=========================================================================type: 1
Method:javax.el.BeanELResolver#invoke(javax.el.ELContext, java.lang.Object, java.lang.Object, Class<?>[], java.lang.Object[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: IllegalAccessException
exception comment: /** 
 * An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.
 * @author  unascribed
 * @see Class#newInstance()
 * @see java.lang.reflect.Field#set(Object,Object)
 * @see java.lang.reflect.Field#setBoolean(Object,boolean)
 * @see java.lang.reflect.Field#setByte(Object,byte)
 * @see java.lang.reflect.Field#setShort(Object,short)
 * @see java.lang.reflect.Field#setChar(Object,char)
 * @see java.lang.reflect.Field#setInt(Object,int)
 * @see java.lang.reflect.Field#setLong(Object,long)
 * @see java.lang.reflect.Field#setFloat(Object,float)
 * @see java.lang.reflect.Field#setDouble(Object,double)
 * @see java.lang.reflect.Field#get(Object)
 * @see java.lang.reflect.Field#getBoolean(Object)
 * @see java.lang.reflect.Field#getByte(Object)
 * @see java.lang.reflect.Field#getShort(Object)
 * @see java.lang.reflect.Field#getChar(Object)
 * @see java.lang.reflect.Field#getInt(Object)
 * @see java.lang.reflect.Field#getLong(Object)
 * @see java.lang.reflect.Field#getFloat(Object)
 * @see java.lang.reflect.Field#getDouble(Object)
 * @see java.lang.reflect.Method#invoke(Object,Object[])
 * @see java.lang.reflect.Constructor#newInstance(Object[])
 * @since   JDK1.0
 */

block: 
/** 
 * @since EL 2.2
 */
@Override public Object invoke(ELContext context,Object base,Object method,Class<?>[] paramTypes,Object[] params){
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null || method == null) {
    return null;
  }
  ExpressionFactory factory=Util.getExpressionFactory();
  String methodName=(String)factory.coerceToType(method,String.class);
  Method matchingMethod=Util.findMethod(base.getClass(),methodName,paramTypes,params);
  Object[] parameters=Util.buildParameters(matchingMethod.getParameterTypes(),matchingMethod.isVarArgs(),params);
  Object result=null;
  try {
    result=matchingMethod.invoke(base,parameters);
  }
 catch (  IllegalArgumentException e) {
    throw new ELException(e);
  }
catch (  IllegalAccessException e) {
    throw new ELException(e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    Util.handleThrowable(cause);
    throw new ELException(cause);
  }
  context.setPropertyResolved(true);
  return result;
}

ID 7019=========================================================================type: 1
Method:javax.el.BeanELResolver#invoke(javax.el.ELContext, java.lang.Object, java.lang.Object, Class<?>[], java.lang.Object[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: RuntimeException 
thrown: IllegalArgumentException
exception comment: /** 
 * Thrown to indicate that a method has been passed an illegal or inappropriate argument.
 * @author  unascribed
 * @since   JDK1.0
 */

block: 
/** 
 * @since EL 2.2
 */
@Override public Object invoke(ELContext context,Object base,Object method,Class<?>[] paramTypes,Object[] params){
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null || method == null) {
    return null;
  }
  ExpressionFactory factory=Util.getExpressionFactory();
  String methodName=(String)factory.coerceToType(method,String.class);
  Method matchingMethod=Util.findMethod(base.getClass(),methodName,paramTypes,params);
  Object[] parameters=Util.buildParameters(matchingMethod.getParameterTypes(),matchingMethod.isVarArgs(),params);
  Object result=null;
  try {
    result=matchingMethod.invoke(base,parameters);
  }
 catch (  IllegalArgumentException e) {
    throw new ELException(e);
  }
catch (  IllegalAccessException e) {
    throw new ELException(e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    Util.handleThrowable(cause);
    throw new ELException(cause);
  }
  context.setPropertyResolved(true);
  return result;
}

ID 7020=========================================================================type: 1
Method:javax.el.BeanELResolver#invoke(javax.el.ELContext, java.lang.Object, java.lang.Object, Class<?>[], java.lang.Object[])
Rmethod: java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
parentException: ReflectiveOperationException 
thrown: InvocationTargetException
exception comment: /** 
 * InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor. <p>As of release 1.4, this exception has been retrofitted to conform to the general purpose exception-chaining mechanism.  The "target exception" that is provided at construction time and accessed via the {@link #getTargetException()} method is now known as the <i>cause</i>,and may be accessed via the  {@link Throwable#getCause()} method,as well as the aforementioned "legacy method."
 * @see Method
 * @see Constructor
 */

block: 
/** 
 * @since EL 2.2
 */
@Override public Object invoke(ELContext context,Object base,Object method,Class<?>[] paramTypes,Object[] params){
  if (context == null) {
    throw new NullPointerException();
  }
  if (base == null || method == null) {
    return null;
  }
  ExpressionFactory factory=Util.getExpressionFactory();
  String methodName=(String)factory.coerceToType(method,String.class);
  Method matchingMethod=Util.findMethod(base.getClass(),methodName,paramTypes,params);
  Object[] parameters=Util.buildParameters(matchingMethod.getParameterTypes(),matchingMethod.isVarArgs(),params);
  Object result=null;
  try {
    result=matchingMethod.invoke(base,parameters);
  }
 catch (  IllegalArgumentException e) {
    throw new ELException(e);
  }
catch (  IllegalAccessException e) {
    throw new ELException(e);
  }
catch (  InvocationTargetException e) {
    Throwable cause=e.getCause();
    Util.handleThrowable(cause);
    throw new ELException(cause);
  }
  context.setPropertyResolved(true);
  return result;
}

ID 7022=========================================================================type: 1
Method:javax.el.BeanProperties#BeanProperties(Class<?>)
Rmethod: java.beans.Introspector#getBeanInfo(Class<?>)
parentException: 
thrown: IntrospectionException
exception comment: /** 
 * An exception occurred during the introspection of an MBean.
 * @since 1.5
 */

block: 
public BeanProperties(Class<?> type) throws ELException {
  this.type=type;
  this.properties=new HashMap<String,BeanProperty>();
  try {
    BeanInfo info=Introspector.getBeanInfo(this.type);
    PropertyDescriptor[] pds=info.getPropertyDescriptors();
    for (    PropertyDescriptor pd : pds) {
      this.properties.put(pd.getName(),new BeanProperty(type,pd));
    }
    if (System.getSecurityManager() != null) {
      populateFromInterfaces(type);
    }
  }
 catch (  IntrospectionException ie) {
    throw new ELException(ie);
  }
}

ID 7023=========================================================================type: 1
Method:javax.el.BeanProperties#BeanProperties(Class<?>)
Rmethod: javax.el.BeanProperties#populateFromInterfaces(Class<?>)
parentException: 
thrown: IntrospectionException
exception comment: /** 
 * An exception occurred during the introspection of an MBean.
 * @since 1.5
 */

block: 
public BeanProperties(Class<?> type) throws ELException {
  this.type=type;
  this.properties=new HashMap<String,BeanProperty>();
  try {
    BeanInfo info=Introspector.getBeanInfo(this.type);
    PropertyDescriptor[] pds=info.getPropertyDescriptors();
    for (    PropertyDescriptor pd : pds) {
      this.properties.put(pd.getName(),new BeanProperty(type,pd));
    }
    if (System.getSecurityManager() != null) {
      populateFromInterfaces(type);
    }
  }
 catch (  IntrospectionException ie) {
    throw new ELException(ie);
  }
}

ID 7042=========================================================================type: 1
Method:examples.ShowSource#doEndTag()
Rmethod: javax.servlet.jsp.JspWriter#println(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  if ((jspFile.indexOf("..") >= 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/WEB-INF/") != 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/META-INF/") != 0))   throw new JspTagException("Invalid JSP file " + jspFile);
  InputStream in=pageContext.getServletContext().getResourceAsStream(jspFile);
  if (in == null)   throw new JspTagException("Unable to find JSP file: " + jspFile);
  try {
    JspWriter out=pageContext.getOut();
    out.println("<body>");
    out.println("<pre>");
    for (int ch=in.read(); ch != -1; ch=in.read())     if (ch == '<')     out.print("&lt;");
 else     out.print((char)ch);
    out.println("</pre>");
    out.println("</body>");
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString());
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException e) {
      throw new JspTagException("Can't close inputstream: ",e);
    }
  }
  return super.doEndTag();
}

ID 7043=========================================================================type: 1
Method:examples.ShowSource#doEndTag()
Rmethod: java.io.InputStream#read()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  if ((jspFile.indexOf("..") >= 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/WEB-INF/") != 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/META-INF/") != 0))   throw new JspTagException("Invalid JSP file " + jspFile);
  InputStream in=pageContext.getServletContext().getResourceAsStream(jspFile);
  if (in == null)   throw new JspTagException("Unable to find JSP file: " + jspFile);
  try {
    JspWriter out=pageContext.getOut();
    out.println("<body>");
    out.println("<pre>");
    for (int ch=in.read(); ch != -1; ch=in.read())     if (ch == '<')     out.print("&lt;");
 else     out.print((char)ch);
    out.println("</pre>");
    out.println("</body>");
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString());
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException e) {
      throw new JspTagException("Can't close inputstream: ",e);
    }
  }
  return super.doEndTag();
}

ID 7044=========================================================================type: 1
Method:examples.ShowSource#doEndTag()
Rmethod: javax.servlet.jsp.JspWriter#print(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  if ((jspFile.indexOf("..") >= 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/WEB-INF/") != 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/META-INF/") != 0))   throw new JspTagException("Invalid JSP file " + jspFile);
  InputStream in=pageContext.getServletContext().getResourceAsStream(jspFile);
  if (in == null)   throw new JspTagException("Unable to find JSP file: " + jspFile);
  try {
    JspWriter out=pageContext.getOut();
    out.println("<body>");
    out.println("<pre>");
    for (int ch=in.read(); ch != -1; ch=in.read())     if (ch == '<')     out.print("&lt;");
 else     out.print((char)ch);
    out.println("</pre>");
    out.println("</body>");
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString());
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException e) {
      throw new JspTagException("Can't close inputstream: ",e);
    }
  }
  return super.doEndTag();
}

ID 7045=========================================================================type: 1
Method:examples.ShowSource#doEndTag()
Rmethod: javax.servlet.jsp.JspWriter#print(char)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  if ((jspFile.indexOf("..") >= 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/WEB-INF/") != 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/META-INF/") != 0))   throw new JspTagException("Invalid JSP file " + jspFile);
  InputStream in=pageContext.getServletContext().getResourceAsStream(jspFile);
  if (in == null)   throw new JspTagException("Unable to find JSP file: " + jspFile);
  try {
    JspWriter out=pageContext.getOut();
    out.println("<body>");
    out.println("<pre>");
    for (int ch=in.read(); ch != -1; ch=in.read())     if (ch == '<')     out.print("&lt;");
 else     out.print((char)ch);
    out.println("</pre>");
    out.println("</body>");
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString());
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException e) {
      throw new JspTagException("Can't close inputstream: ",e);
    }
  }
  return super.doEndTag();
}

ID 7046=========================================================================type: 1
Method:examples.ShowSource#doEndTag()
Rmethod: java.io.InputStream#close()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  if ((jspFile.indexOf("..") >= 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/WEB-INF/") != 0) || (jspFile.toUpperCase(Locale.ENGLISH).indexOf("/META-INF/") != 0))   throw new JspTagException("Invalid JSP file " + jspFile);
  InputStream in=pageContext.getServletContext().getResourceAsStream(jspFile);
  if (in == null)   throw new JspTagException("Unable to find JSP file: " + jspFile);
  try {
    JspWriter out=pageContext.getOut();
    out.println("<body>");
    out.println("<pre>");
    for (int ch=in.read(); ch != -1; ch=in.read())     if (ch == '<')     out.print("&lt;");
 else     out.print((char)ch);
    out.println("</pre>");
    out.println("</body>");
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString());
  }
 finally {
    try {
      in.close();
    }
 catch (    IOException e) {
      throw new JspTagException("Can't close inputstream: ",e);
    }
  }
  return super.doEndTag();
}

ID 7047=========================================================================type: 1
Method:examples.ValuesTag#doEndTag()
Rmethod: javax.servlet.jsp.JspWriter#print(java.lang.Object)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  JspWriter out=pageContext.getOut();
  try {
    if (!"-1".equals(objectValue)) {
      out.print(objectValue);
    }
 else     if (!"-1".equals(stringValue)) {
      out.print(stringValue);
    }
 else     if (longValue != -1) {
      out.print(longValue);
    }
 else     if (doubleValue != -1) {
      out.print(doubleValue);
    }
 else {
      out.print("-1");
    }
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString(),ex);
  }
  return super.doEndTag();
}

ID 7048=========================================================================type: 1
Method:examples.ValuesTag#doEndTag()
Rmethod: javax.servlet.jsp.JspWriter#print(java.lang.String)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  JspWriter out=pageContext.getOut();
  try {
    if (!"-1".equals(objectValue)) {
      out.print(objectValue);
    }
 else     if (!"-1".equals(stringValue)) {
      out.print(stringValue);
    }
 else     if (longValue != -1) {
      out.print(longValue);
    }
 else     if (doubleValue != -1) {
      out.print(doubleValue);
    }
 else {
      out.print("-1");
    }
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString(),ex);
  }
  return super.doEndTag();
}

ID 7049=========================================================================type: 1
Method:examples.ValuesTag#doEndTag()
Rmethod: javax.servlet.jsp.JspWriter#print(long)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  JspWriter out=pageContext.getOut();
  try {
    if (!"-1".equals(objectValue)) {
      out.print(objectValue);
    }
 else     if (!"-1".equals(stringValue)) {
      out.print(stringValue);
    }
 else     if (longValue != -1) {
      out.print(longValue);
    }
 else     if (doubleValue != -1) {
      out.print(doubleValue);
    }
 else {
      out.print("-1");
    }
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString(),ex);
  }
  return super.doEndTag();
}

ID 7050=========================================================================type: 1
Method:examples.ValuesTag#doEndTag()
Rmethod: javax.servlet.jsp.JspWriter#print(double)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doEndTag() throws JspException {
  JspWriter out=pageContext.getOut();
  try {
    if (!"-1".equals(objectValue)) {
      out.print(objectValue);
    }
 else     if (!"-1".equals(stringValue)) {
      out.print(stringValue);
    }
 else     if (longValue != -1) {
      out.print(longValue);
    }
 else     if (doubleValue != -1) {
      out.print(doubleValue);
    }
 else {
      out.print("-1");
    }
  }
 catch (  IOException ex) {
    throw new JspTagException("IOException: " + ex.toString(),ex);
  }
  return super.doEndTag();
}

ID 7051=========================================================================type: 1
Method:examples.LogTag#doAfterBody()
Rmethod: javax.servlet.jsp.tagext.BodyContent#writeOut(java.io.Writer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doAfterBody() throws JspException {
  try {
    String s=bodyOut.getString();
    System.err.println(s);
    if (toBrowser)     bodyOut.writeOut(bodyOut.getEnclosingWriter());
    return SKIP_BODY;
  }
 catch (  IOException ex) {
    throw new JspTagException(ex.toString());
  }
}

ID 7052=========================================================================type: 1
Method:examples.FooTag#doAfterBody()
Rmethod: javax.servlet.jsp.tagext.BodyContent#writeOut(java.io.Writer)
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
@Override public int doAfterBody() throws JspException {
  try {
    if (i == 3) {
      bodyOut.writeOut(bodyOut.getEnclosingWriter());
      return SKIP_BODY;
    }
    pageContext.setAttribute("member",atts[i]);
    i++;
    return EVAL_BODY_BUFFERED;
  }
 catch (  IOException ex) {
    throw new JspTagException(ex.toString());
  }
}

ID 7057=========================================================================type: 1
Method:validators.DebugValidator#validate(java.lang.String, java.lang.String, javax.servlet.jsp.tagext.PageData)
Rmethod: java.io.InputStream#read()
parentException: 
thrown: IOException
exception comment: /** 
 * Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.
 * @author  unascribed
 * @see java.io.InputStream
 * @see java.io.OutputStream
 * @since   JDK1.0
 */

block: 
/** 
 * Validate a JSP page.  This will get invoked once per directive in the JSP page.  This method will return <code>null</code> if the page is valid; otherwise the method should return an array of <code>ValidationMessage</code> objects.  An array of length zero is also interpreted as no errors.
 * @param prefix The value of the prefix argument in this directive
 * @param uri The value of the URI argument in this directive
 * @param page The page data for this page
 */
@Override public ValidationMessage[] validate(String prefix,String uri,PageData page){
  System.out.println("---------- Prefix=" + prefix + " URI="+ uri+ "----------");
  InputStream is=page.getInputStream();
  while (true) {
    try {
      int ch=is.read();
      if (ch < 0)       break;
      System.out.print((char)ch);
    }
 catch (    IOException e) {
      break;
    }
  }
  System.out.println();
  System.out.println("-----------------------------------------------");
  return (null);
}


